/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/debug-viewer/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(220);
	module.exports = __webpack_require__(103);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (false) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(8);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;

/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMProperty = __webpack_require__(19);
	var ReactDOMComponentFlags = __webpack_require__(64);
	
	var invariant = __webpack_require__(1);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Check if a given node should be cached.
	 */
	function shouldPrecacheNode(node, nodeID) {
	  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
	}
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (shouldPrecacheNode(childNode, childID)) {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ?  false ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ?  false ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ?  false ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;

/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(21);


/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (false) {
	  var ReactDebugTool = require('./ReactDebugTool');
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };

/***/ },
/* 10 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(14);
	var ReactFeatureFlags = __webpack_require__(67);
	var ReactReconciler = __webpack_require__(20);
	var Transaction = __webpack_require__(32);
	
	var invariant = __webpack_require__(1);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ?  false ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ?  false ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ?  false ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ?  false ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ?  false ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ?  false ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ?  false ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(14);
	
	var emptyFunction = __webpack_require__(8);
	var warning = __webpack_require__(2);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (false) {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (false) {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.returnValue !== 'unknown') {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (false) {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (false) {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (false) {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	     false ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}

/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 14 */
[249, 3],
/* 15 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	// export const MAIN_CANVAS_MOUNTED = "MAIN_CANVAS_MOUNTED";
	var NEW_STAGE_CREATED = exports.NEW_STAGE_CREATED = "NEW_STAGE_CREATED";
	var STAGE_RESIZED = exports.STAGE_RESIZED = "STAGE_RESIZED";
	
	var NEW_SHAPE_PASTED = exports.NEW_SHAPE_PASTED = "NEW_SHAPE_PASTED";
	
	var TOGGLE_UNITS_CLICKED = exports.TOGGLE_UNITS_CLICKED = "TOGGLE_UNITS_CLICKED";
	var TOGGLE_WIDTH_MODE_CLICKED = exports.TOGGLE_WIDTH_MODE_CLICKED = "TOGGLE_WIDTH_MODE_CLICKED";
	var TOGGLE_DISPLAY_VERTICES_CLICKED = exports.TOGGLE_DISPLAY_VERTICES_CLICKED = "TOGGLE_DISPLAY_VERTICES_CLICKED";
	
	var MOUSE_MOVED_ON_STAGE = exports.MOUSE_MOVED_ON_STAGE = "MOUSE_MOVED_ON_STAGE";
	var MOUSE_DOWN_ON_STAGE = exports.MOUSE_DOWN_ON_STAGE = "MOUSE_DOWN_ON_STAGE";
	var MOUSE_UP_ON_STAGE = exports.MOUSE_UP_ON_STAGE = "MOUSE_UP_ON_STAGE";
	var MOUSE_WHEEL_MOVE_ON_STAGE = exports.MOUSE_WHEEL_MOVE_ON_STAGE = "MOUSE_WHEEL_MOVE_ON_STAGE";
	
	var MOUSE_ROLL_OVER_SHAPE = exports.MOUSE_ROLL_OVER_SHAPE = "MOUSE_ROLL_OVER_SHAPE";
	var MOUSE_ROLL_OUT_SHAPE = exports.MOUSE_ROLL_OUT_SHAPE = "MOUSE_ROLL_OUT_SHAPE";
	
	// export const HOME_BUTTON_CLICKED = "HOME_BUTTON_CLICKED";
	var PAN_TO_COORDINATE = exports.PAN_TO_COORDINATE = "PAN_TO_COORDINATE";
	var PAN_AND_ZOOM_TO_SHAPE = exports.PAN_AND_ZOOM_TO_SHAPE = "PAN_AND_ZOOM_TO_SHAPE";
	
	var LAYER_LIST_PANEL_PRESSED = exports.LAYER_LIST_PANEL_PRESSED = "LAYER_LIST_PANEL_PRESSED";
	var ADD_LAYER_PRESSED = exports.ADD_LAYER_PRESSED = "ADD_LAYER_PRESSED";
	var TOGGLE_DISPLAY_LAYER_PRESSED = exports.TOGGLE_DISPLAY_LAYER_PRESSED = "TOGGLE_DISPLAY_LAYER_PRESSED";
	var TOGGLE_AFFECTED_LAYER_PRESSED = exports.TOGGLE_AFFECTED_LAYER_PRESSED = "TOGGLE_AFFECTED_LAYER_PRESSED";
	var EDIT_LAYER_NAME_PRESSED = exports.EDIT_LAYER_NAME_PRESSED = "EDIT_LAYER_NAME_PRESSED";
	var LAYERS_LIST_ARROW_DOWN_PRESSED = exports.LAYERS_LIST_ARROW_DOWN_PRESSED = "LAYERS_LIST_ARROW_DOWN_PRESSED";
	var LAYERS_LIST_ARROW_UP_PRESSED = exports.LAYERS_LIST_ARROW_UP_PRESSED = "LAYERS_LIST_ARROW_UP_PRESSED";
	
	var TOGGLE_WATCH_EXPAND_CLICKED = exports.TOGGLE_WATCH_EXPAND_CLICKED = "TOGGLE_WATCH_EXPAND_CLICKED";
	
	var INPUT_FILE_LOADED = exports.INPUT_FILE_LOADED = "INPUT_FILE_LOADED";
	
	/** Toolbar buttons **/
	var PAN_BY_DRAG_BUTTON_CLICKED = exports.PAN_BY_DRAG_BUTTON_CLICKED = "PAN_BY_DRAG_BUTTON_CLICKED";
	var MEASURE_POINTS_BUTTON_PRESSED = exports.MEASURE_POINTS_BUTTON_PRESSED = "MEASURE_POINTS_BUTTON_PRESSED";
	var MEASURE_CONTOURS_BUTTON_PRESSED = exports.MEASURE_CONTOURS_BUTTON_PRESSED = "MEASURE_CONTOURS_BUTTON_PRESSED";

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Shape = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _easeljsNEXTCombined = __webpack_require__(91);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Line = _flattenJs2.default.Line,
	    Circle = _flattenJs2.default.Circle,
	    Arc = _flattenJs2.default.Arc,
	    Vector = _flattenJs2.default.Vector,
	    Polygon = _flattenJs2.default.Polygon;
	
	var Shape = exports.Shape = function (_createjs$Shape) {
	    _inherits(Shape, _createjs$Shape);
	
	    function Shape() {
	        var geom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	        var stage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	        var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	        var watch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
	
	        _classCallCheck(this, Shape);
	
	        var _this = _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this));
	
	        _this.geom = geom;
	        stage.addChild(_this);
	        // this.stage = stage;
	        _this.graphics = new createjs.Graphics(); // this.setGraphics(style);
	        _this.watch = watch;
	        _this.expanded = false;
	        return _this;
	    }
	
	    _createClass(Shape, [{
	        key: 'redraw',
	        value: function redraw() {
	            var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            this.alpha = style && style.alpha !== undefined ? style.alpha : 1.0;
	            this.graphics.clear();
	            this.graphics = this.setGraphics(style);
	            return this;
	        }
	    }, {
	        key: 'setGraphics',
	        value: function setGraphics(style) {
	            if (!this.geom) return;
	            if (this.geom instanceof Point) {
	                return this.setGraphicsPoint(style);
	            } else if (this.geom instanceof Segment) {
	                return this.setGraphicsSegment(style);
	            } else if (this.geom instanceof Line) {} else if (this.geom instanceof Circle) {
	                return this.setGraphicsCircle(style);
	            } else if (this.geom instanceof Arc) {
	                return this.setGraphicsArc(style);
	            } else if (this.geom instanceof Vector) {} else if (this.geom instanceof Polygon) {
	                return this.setGraphicsPolygon(style);
	            }
	        }
	    }, {
	        key: 'setGraphicsPoint',
	        value: function setGraphicsPoint(style) {
	            var pt = this.stage.W2C(this.geom);
	            var graphics = new createjs.Graphics();
	            var radius = style && style.radius ? style.radius : 3;
	            var fill = style && style.fill ? style.fill : "red";
	            return graphics.beginFill(fill).drawCircle(pt.x, pt.y, radius);
	        }
	    }, {
	        key: 'setGraphicsSegment',
	        value: function setGraphicsSegment(style) {
	            var ps = this.stage.W2C(this.geom.ps);
	            var pe = this.stage.W2C(this.geom.pe);
	            var graphics = new createjs.Graphics();
	            var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 2;
	            var stroke = style && style.stroke ? style.stroke : "black";
	            return graphics.setStrokeStyle(strokeStyle).beginStroke(stroke).moveTo(ps.x, ps.y).lineTo(pe.x, pe.y).endStroke();
	        }
	    }, {
	        key: 'setGraphicsArc',
	        value: function setGraphicsArc(style) {
	            var pc = this.stage.W2C(this.geom.pc);
	            var r = this.stage.W2C_Scalar(this.geom.r);
	            var startAngle = 2 * Math.PI - this.geom.startAngle;
	            var endAngle = 2 * Math.PI - this.geom.endAngle;
	            var graphics = new createjs.Graphics();
	            var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 2;
	            var stroke = style && style.stroke ? style.stroke : "black";
	            return graphics.setStrokeStyle(strokeStyle).beginStroke(stroke).arc(pc.x, pc.y, r, startAngle, endAngle, this.geom.counterClockwise).endStroke();
	        }
	    }, {
	        key: 'setGraphicsCircle',
	        value: function setGraphicsCircle(style) {
	            var pc = this.stage.W2C(this.geom.pc);
	            var r = this.stage.W2C_Scalar(this.geom.r);
	            var graphics = new createjs.Graphics();
	            var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 2;
	            var stroke = style && style.stroke ? style.stroke : "black";
	            // graphics.setStrokeStyle(2).beginStroke("black").beginFill("red").drawCircle(pcx, pcy, r);
	            return graphics.setStrokeStyle(strokeStyle).beginStroke(stroke).drawCircle(pc.x, pc.y, r);
	        }
	    }, {
	        key: 'setGraphicsPolygon',
	        value: function setGraphicsPolygon(style) {
	            var graphics = new createjs.Graphics();
	            var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 1;
	            var stroke = style && style.stroke ? style.stroke : "#FF0303";
	            var fill = style && style.fill ? style.fill : "#FF0303";
	            graphics.setStrokeStyle(strokeStyle);
	            graphics.beginStroke(stroke);
	            graphics.beginFill(fill);
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = this.geom.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var face = _step.value;
	
	                    this.setGraphicsFace(graphics, face);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            graphics.endStroke();
	            return graphics;
	        }
	    }, {
	        key: 'setGraphicsFace',
	        value: function setGraphicsFace(graphics, face) {
	            var ps = this.stage.W2C(face.first.start);
	            graphics.moveTo(ps.x, ps.y);
	
	            var edge = face.first;
	            do {
	                this.setGraphicsEdge(graphics, edge);
	                edge = edge.next;
	            } while (edge !== face.first);
	        }
	    }, {
	        key: 'setGraphicsEdge',
	        value: function setGraphicsEdge(graphics, edge) {
	            if (edge.shape instanceof Segment) {
	                this.setGraphicsEdgeSegment(graphics, edge.shape);
	            } else if (edge.shape instanceof Arc) {
	                this.setGraphicsEdgeArc(graphics, edge.shape);
	            }
	        }
	    }, {
	        key: 'setGraphicsEdgeSegment',
	        value: function setGraphicsEdgeSegment(graphics, segment) {
	            var pe = this.stage.W2C(segment.pe);
	            graphics.lineTo(pe.x, pe.y);
	        }
	    }, {
	        key: 'setGraphicsEdgeArc',
	        value: function setGraphicsEdgeArc(graphics, arc) {
	            var pc = this.stage.W2C(arc.pc);
	            var r = this.stage.W2C_Scalar(arc.r);
	            var startAngle = 2 * Math.PI - arc.startAngle;
	            var endAngle = 2 * Math.PI - arc.endAngle;
	            graphics.arc(pc.x, pc.y, r, startAngle, endAngle, arc.counterClockwise);
	        }
	    }, {
	        key: 'box',
	        get: function get() {
	            return this.geom.box;
	        }
	    }, {
	        key: 'center',
	        get: function get() {
	            var box = this.box;
	            return new Point((box.xmin + box.xmax) / 2, (box.ymin + box.ymax) / 2);
	        }
	    }]);
	
	    return Shape;
	}(createjs.Shape);

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	'use strict';
	// require("babel-polyfill");
	
	let Utils = __webpack_require__(142);
	let Errors = __webpack_require__(141);
	
	/**
	 * FlattenJS - library for 2d geometry
	 * @type {Flatten}
	 */
	let Flatten = class Flatten {
	    constructor() {
	        this.version = "0.0.1";
	        this.DP_TOL = Utils.DP_TOL;
	        this.CCW = true;
	        this.CW = false;
	        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};
	        this.PIx2 = 2 * Math.PI;
	        this.PI_2 = 0.5 * Math.PI;
	        this.Utils = Utils;
	        this.Errors = Errors;
	    }
	};
	
	let f = new Flatten();
	
	__webpack_require__(140)(f);
	__webpack_require__(136)(f);
	__webpack_require__(139)(f);
	__webpack_require__(135)(f);
	__webpack_require__(132)(f);
	__webpack_require__(138)(f);
	__webpack_require__(130)(f);
	__webpack_require__(131)(f);
	__webpack_require__(133)(f);
	__webpack_require__(134)(f);
	__webpack_require__(137)(f);
	
	module.exports = f;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(37);
	var setInnerHTML = __webpack_require__(34);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(45);
	var setTextContent = __webpack_require__(80);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ?  false ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ?  false ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (false) {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (false) {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName:  false ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(193);
	var ReactInstrumentation = __webpack_require__(9);
	
	var warning = __webpack_require__(2);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
	  {
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	       false ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (false) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactBaseClasses = __webpack_require__(82);
	var ReactChildren = __webpack_require__(224);
	var ReactDOMFactories = __webpack_require__(225);
	var ReactElement = __webpack_require__(22);
	var ReactPropTypes = __webpack_require__(226);
	var ReactVersion = __webpack_require__(227);
	
	var createReactClass = __webpack_require__(228);
	var onlyChild = __webpack_require__(232);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (false) {
	  var lowPriorityWarning = require('./lowPriorityWarning');
	  var canDefineProperty = require('./canDefineProperty');
	  var ReactElementValidator = require('./ReactElementValidator');
	  var didWarnPropTypesDeprecated = false;
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	var createMixin = function (mixin) {
	  return mixin;
	};
	
	if (false) {
	  var warnedForSpread = false;
	  var warnedForCreateMixin = false;
	  __spread = function () {
	    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
	    warnedForSpread = true;
	    return _assign.apply(null, arguments);
	  };
	
	  createMixin = function (mixin) {
	    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
	    warnedForCreateMixin = true;
	    return mixin;
	  };
	}
	
	var React = {
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactBaseClasses.Component,
	  PureComponent: ReactBaseClasses.PureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: createReactClass,
	  createFactory: createFactory,
	  createMixin: createMixin,
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	if (false) {
	  var warnedForCreateClass = false;
	  if (canDefineProperty) {
	    Object.defineProperty(React, 'PropTypes', {
	      get: function () {
	        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
	        didWarnPropTypesDeprecated = true;
	        return ReactPropTypes;
	      }
	    });
	
	    Object.defineProperty(React, 'createClass', {
	      get: function () {
	        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
	        warnedForCreateClass = true;
	        return createReactClass;
	      }
	    });
	  }
	
	  // React.DOM factories are deprecated. Wrap these methods so that
	  // invocations of the React.DOM namespace and alert users to switch
	  // to the `react-dom-factories` package.
	  React.DOM = {};
	  var warnedForFactories = false;
	  Object.keys(ReactDOMFactories).forEach(function (factory) {
	    React.DOM[factory] = function () {
	      if (!warnedForFactories) {
	        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
	        warnedForFactories = true;
	      }
	      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
	    };
	  });
	}
	
	module.exports = React;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(13);
	
	var warning = __webpack_require__(2);
	var canDefineProperty = __webpack_require__(86);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var REACT_ELEMENT_TYPE = __webpack_require__(84);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (false) {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (false) {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	       false ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	       false ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (false) {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (false) {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (false) {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Layers = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 20/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _layer = __webpack_require__(105);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var colors = ["#FF0303", "#4AA403", "#540080", "#FFFF40", "#FF0080", "#AED424", "#545400", "#FFA980", "#A95480", "#A9A9FF", "#00FF00", "#FFEE76", "#A40576", "#4385C8", "#1CC826", "#BDBD00", "#48316E", "#14616E", "#8040BD", "#DC7676", "#924845", "#A90000", "#FFA900"];
	
	var Layers = exports.Layers = function () {
	    function Layers() {
	        _classCallCheck(this, Layers);
	    }
	
	    _createClass(Layers, null, [{
	        key: "newLayer",
	        value: function newLayer(stage, layers) {
	            var layer = new _layer.Layer(stage);
	            layer.name = Layers.getNewName(layers);
	            if (layers.length === 0) {
	                // first layer
	                layer.color = Layers.getNextColor(layers);
	                layer.displayed = true;
	                layer.affected = true;
	            }
	            return layer;
	        }
	    }, {
	        key: "getNewName",
	        value: function getNewName(layers) {
	            var name = Layers.defaultName;
	            var inc = 1;
	            var comparator = function comparator(layer) {
	                return layer.name === name;
	            };
	            while (layers.find(comparator)) {
	                name = Layers.defaultName + inc;
	                inc++;
	            }
	            return name;
	        }
	    }, {
	        key: "getAffected",
	        value: function getAffected(layers) {
	            return layers.find(function (lay) {
	                return lay.affected;
	            });
	        }
	    }, {
	        key: "getNextColor",
	        value: function getNextColor(layers) {
	            var color = "";
	
	            var _loop = function _loop(col) {
	                if (!layers.find(function (layer) {
	                    return layer.displayed && layer.color === col;
	                })) {
	                    color = col;
	                    return "break";
	                }
	            };
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var col = _step.value;
	
	                    var _ret = _loop(col);
	
	                    if (_ret === "break") break;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return color;
	        }
	    }, {
	        key: "defaultName",
	        get: function get() {
	            return "layer";
	        }
	    }]);

	    return Layers;
	}();

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var EventPluginRegistry = __webpack_require__(38);
	var EventPluginUtils = __webpack_require__(39);
	var ReactErrorUtils = __webpack_require__(43);
	
	var accumulateInto = __webpack_require__(73);
	var forEachAccumulated = __webpack_require__(74);
	var invariant = __webpack_require__(1);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ?  false ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ?  false ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	};
	
	module.exports = EventPluginHub;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	var EventPluginUtils = __webpack_require__(39);
	
	var accumulateInto = __webpack_require__(73);
	var forEachAccumulated = __webpack_require__(74);
	var warning = __webpack_require__(2);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;

/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	var getEventTarget = __webpack_require__(48);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 28 */
3,
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (false) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(38);
	var ReactEventEmitterMixin = __webpack_require__(185);
	var ViewportMetrics = __webpack_require__(72);
	
	var getVendorPrefixedEventName = __webpack_require__(217);
	var isEventSupported = __webpack_require__(49);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	var ViewportMetrics = __webpack_require__(72);
	
	var getEventModifierState = __webpack_require__(47);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /* eslint-disable space-before-function-paren */
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    /* eslint-enable space-before-function-paren */
	    !!this.isInTransaction() ?  false ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ?  false ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	var DOMNamespaces = __webpack_require__(37);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(45);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xfeff) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(18);
	var Danger = __webpack_require__(162);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstrumentation = __webpack_require__(9);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(45);
	var setInnerHTML = __webpack_require__(34);
	var setTextContent = __webpack_require__(80);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (false) {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (false) {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (false) {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: {
	                toIndex: update.toIndex,
	                content: update.content.toString()
	              }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	};
	
	module.exports = DOMChildrenOperations;

/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ?  false ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ?  false ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (false) {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames:  false ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (false) {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	};
	
	module.exports = EventPluginRegistry;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactErrorUtils = __webpack_require__(43);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (false) {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (false) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ?  false ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;

/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactPropTypesSecret = __webpack_require__(191);
	var propTypesFactory = __webpack_require__(60);
	
	var React = __webpack_require__(21);
	var PropTypes = propTypesFactory(React.isValidElement);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	var hasReadOnlyValue = {
	  button: true,
	  checkbox: true,
	  image: true,
	  hidden: true,
	  radio: true,
	  reset: true,
	  submit: true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	         false ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ?  false ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	};
	
	module.exports = ReactComponentEnvironment;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (false) {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(13);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactUpdates = __webpack_require__(11);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (false) {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (false) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState, callback) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    // Future-proof 15.5
	    if (callback !== undefined && callback !== null) {
	      ReactUpdateQueue.validateCallback(callback, 'replaceState');
	      if (internalInstance._pendingCallbacks) {
	        internalInstance._pendingCallbacks.push(callback);
	      } else {
	        internalInstance._pendingCallbacks = [callback];
	      }
	    }
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (false) {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ?  false ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	};
	
	module.exports = ReactUpdateQueue;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  Alt: 'altKey',
	  Control: 'ctrlKey',
	  Meta: 'metaKey',
	  Shift: 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var emptyFunction = __webpack_require__(8);
	var warning = __webpack_require__(2);
	
	var validateDOMNesting = emptyFunction;
	
	if (false) {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	      case 'pre':
	      case 'listing':
	      case 'table':
	      case 'hr':
	      case 'xmp':
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(8);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (false) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;

/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 54 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/28/2017.
	 */
	
	'use strict';
	
	module.exports = {
	    RB_TREE_COLOR_RED: 0,
	    RB_TREE_COLOR_BLACK: 1
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(149);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(143),
	    getPrototype = __webpack_require__(145),
	    isObjectLike = __webpack_require__(150);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;


/***/ },
/* 58 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var asap = __webpack_require__(92);
	
	function noop() {}
	
	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable
	
	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.
	
	
	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	module.exports = Promise;
	
	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;
	
	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};
	
	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}
	
	function handleResolved(self, deferred) {
	  asap(function() {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}
	
	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}
	
	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}
	
	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	// React 15.5 references this module, and assumes PropTypes are still callable in production.
	// Therefore we re-export development-only version with all the PropTypes checks here.
	// However if one is migrating to the `prop-types` npm library, they will go through the
	// `index.js` entry point, and it will branch depending on the environment.
	var factory = __webpack_require__(154);
	module.exports = function(isValidElement) {
	  // It is still allowed in 15.5.
	  var throwOnDirectAccess = false;
	  return factory(isValidElement, throwOnDirectAccess);
	};


/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridRowEnd: true,
	  gridRowSpan: true,
	  gridRowStart: true,
	  gridColumn: true,
	  gridColumnEnd: true,
	  gridColumnSpan: true,
	  gridColumnStart: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PooledClass = __webpack_require__(14);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ?  false ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(19);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstrumentation = __webpack_require__(9);
	
	var quoteAttributeValueForBrowser = __webpack_require__(218);
	var warning = __webpack_require__(2);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	   false ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (false) {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (false) {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (false) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (false) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	};
	
	module.exports = DOMPropertyOperations;

/***/ },
/* 64 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var LinkedValueUtils = __webpack_require__(41);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(11);
	
	var warning = __webpack_require__(2);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	     false ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	       false ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	       false ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	       false ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	var genericComponentClass = null;
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ?  false ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(178);
	
	var containsNode = __webpack_require__(117);
	var focusNode = __webpack_require__(53);
	var getActiveElement = __webpack_require__(54);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMLazyTree = __webpack_require__(18);
	var DOMProperty = __webpack_require__(19);
	var React = __webpack_require__(21);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactCurrentOwner = __webpack_require__(13);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMContainerInfo = __webpack_require__(172);
	var ReactDOMFeatureFlags = __webpack_require__(174);
	var ReactFeatureFlags = __webpack_require__(67);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactMarkupChecksum = __webpack_require__(188);
	var ReactReconciler = __webpack_require__(20);
	var ReactUpdateQueue = __webpack_require__(44);
	var ReactUpdates = __webpack_require__(11);
	
	var emptyObject = __webpack_require__(29);
	var instantiateReactComponent = __webpack_require__(78);
	var invariant = __webpack_require__(1);
	var setInnerHTML = __webpack_require__(34);
	var shouldUpdateReactComponent = __webpack_require__(50);
	var warning = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (false) {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (false) {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (false) {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	     false ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ?  false ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ?  false ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ?  false ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	     false ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, {
	      child: nextElement
	    });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	     false ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ?  false ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ?  false ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (false) {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (false) {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var React = __webpack_require__(21);
	
	var invariant = __webpack_require__(1);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ?  false ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ?  false ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(71);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(5);
	
	function isCheckable(elem) {
	  var type = elem.type;
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
	}
	
	function getTracker(inst) {
	  return inst._wrapperState.valueTracker;
	}
	
	function attachTracker(inst, tracker) {
	  inst._wrapperState.valueTracker = tracker;
	}
	
	function detachTracker(inst) {
	  delete inst._wrapperState.valueTracker;
	}
	
	function getValueFromNode(node) {
	  var value;
	  if (node) {
	    value = isCheckable(node) ? '' + node.checked : node.value;
	  }
	  return value;
	}
	
	var inputValueTracking = {
	  // exposed for testing
	  _getTrackerFromNode: function (node) {
	    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
	  },
	
	
	  track: function (inst) {
	    if (getTracker(inst)) {
	      return;
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var valueField = isCheckable(node) ? 'checked' : 'value';
	    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
	
	    var currentValue = '' + node[valueField];
	
	    // if someone has already defined a value or Safari, then bail
	    // and don't track value will cause over reporting of changes,
	    // but it's better then a hard failure
	    // (needed for certain tests that spyOn input values and Safari)
	    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
	      return;
	    }
	
	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable,
	      configurable: true,
	      get: function () {
	        return descriptor.get.call(this);
	      },
	      set: function (value) {
	        currentValue = '' + value;
	        descriptor.set.call(this, value);
	      }
	    });
	
	    attachTracker(inst, {
	      getValue: function () {
	        return currentValue;
	      },
	      setValue: function (value) {
	        currentValue = '' + value;
	      },
	      stopTracking: function () {
	        detachTracker(inst);
	        delete node[valueField];
	      }
	    });
	  },
	
	  updateValueIfChanged: function (inst) {
	    if (!inst) {
	      return false;
	    }
	    var tracker = getTracker(inst);
	
	    if (!tracker) {
	      inputValueTracking.track(inst);
	      return true;
	    }
	
	    var lastValue = tracker.getValue();
	    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));
	
	    if (nextValue !== lastValue) {
	      tracker.setValue(nextValue);
	      return true;
	    }
	
	    return false;
	  },
	  stopTracking: function (inst) {
	    var tracker = getTracker(inst);
	    if (tracker) {
	      tracker.stopTracking();
	    }
	  }
	};
	
	module.exports = inputValueTracking;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var ReactCompositeComponent = __webpack_require__(169);
	var ReactEmptyComponent = __webpack_require__(66);
	var ReactHostComponent = __webpack_require__(68);
	
	var getNextDebugID = __webpack_require__(230);
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    var type = element.type;
	    if (typeof type !== 'function' && typeof type !== 'string') {
	      var info = '';
	      if (false) {
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }
	      }
	      info += getDeclarationErrorAddendum(element._owner);
	       true ?  false ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
	    }
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ?  false ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (false) {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (false) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	module.exports = instantiateReactComponent;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  'datetime-local': true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	var escapeTextContentForBrowser = __webpack_require__(33);
	var setInnerHTML = __webpack_require__(34);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(13);
	var REACT_ELEMENT_TYPE = __webpack_require__(184);
	
	var getIteratorFn = __webpack_require__(215);
	var invariant = __webpack_require__(1);
	var KeyEscapeUtils = __webpack_require__(40);
	var warning = __webpack_require__(2);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (false) {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (false) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  false ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(28),
	    _assign = __webpack_require__(4);
	
	var ReactNoopUpdateQueue = __webpack_require__(85);
	
	var canDefineProperty = __webpack_require__(86);
	var emptyObject = __webpack_require__(29);
	var invariant = __webpack_require__(1);
	var lowPriorityWarning = __webpack_require__(231);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ?  false ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (false) {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = {
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(28);
	
	var ReactCurrentOwner = __webpack_require__(13);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty
	  // Strip regex characters so we can use it for regex
	  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
	  // Remove hasOwnProperty from the template to make it generic
	  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var setItem;
	var getItem;
	var removeItem;
	var getItemIDs;
	var addRoot;
	var removeRoot;
	var getRootIDs;
	
	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();
	
	  setItem = function (id, item) {
	    itemMap.set(id, item);
	  };
	  getItem = function (id) {
	    return itemMap.get(id);
	  };
	  removeItem = function (id) {
	    itemMap['delete'](id);
	  };
	  getItemIDs = function () {
	    return Array.from(itemMap.keys());
	  };
	
	  addRoot = function (id) {
	    rootIDSet.add(id);
	  };
	  removeRoot = function (id) {
	    rootIDSet['delete'](id);
	  };
	  getRootIDs = function () {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};
	
	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function (id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function (key) {
	    return parseInt(key.substr(1), 10);
	  };
	
	  setItem = function (id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  getItem = function (id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  removeItem = function (id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  getItemIDs = function () {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };
	
	  addRoot = function (id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  removeRoot = function (id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  getRootIDs = function () {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}
	
	var unmountedIDs = [];
	
	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	   false ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = getItem(id);
	    !item ?  false ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ?  false ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ?  false ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ?  false ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ?  false ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = getItem(id);
	    !item ?  false ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var name = getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs,
	
	  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
	    if (typeof console.reactStack !== 'function') {
	      return;
	    }
	
	    var stack = [];
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    try {
	      if (isCreatingElement) {
	        stack.push({
	          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
	          fileName: currentSource ? currentSource.fileName : null,
	          lineNumber: currentSource ? currentSource.lineNumber : null
	        });
	      }
	
	      while (id) {
	        var element = ReactComponentTreeHook.getElement(id);
	        var parentID = ReactComponentTreeHook.getParentID(id);
	        var ownerID = ReactComponentTreeHook.getOwnerID(id);
	        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
	        var source = element && element._source;
	        stack.push({
	          name: ownerName,
	          fileName: source ? source.fileName : null,
	          lineNumber: source ? source.lineNumber : null
	        });
	        id = parentID;
	      }
	    } catch (err) {
	      // Internal state is messed up.
	      // Stop building the stack (it's just a nice to have).
	    }
	
	    console.reactStack(stack);
	  },
	  popNonStandardWarningStack: function () {
	    if (typeof console.reactStackEnd !== 'function') {
	      return;
	    }
	    console.reactStackEnd();
	  }
	};
	
	module.exports = ReactComponentTreeHook;

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var warning = __webpack_require__(2);
	
	function warnNoop(publicInstance, callerName) {
	  if (false) {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (false) {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;

/***/ },
/* 87 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	
	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(undefined, arguments));
	    };
	  });
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;
	
	var _isPlainObject = __webpack_require__(57);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(237);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	
	  /**
	   * Creates a Redux store that holds the state tree.
	   * The only way to change the data in the store is to call `dispatch()` on it.
	   *
	   * There should only be a single store in your app. To specify how different
	   * parts of the state tree respond to actions, you may combine several reducers
	   * into a single reducer function by using `combineReducers`.
	   *
	   * @param {Function} reducer A function that returns the next state tree, given
	   * the current state tree and the action to handle.
	   *
	   * @param {any} [preloadedState] The initial state. You may optionally specify it
	   * to hydrate the state from the server in universal apps, or to restore a
	   * previously serialized user session.
	   * If you use `combineReducers` to produce the root reducer function, this must be
	   * an object with the same shape as `combineReducers` keys.
	   *
	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	   * to enhance the store with third-party capabilities such as middleware,
	   * time travel, persistence, etc. The only store enhancer that ships with Redux
	   * is `applyMiddleware()`.
	   *
	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
	   * and subscribe to changes.
	   */
	};function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(88);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(236);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(235);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(234);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(87);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(90);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (false) {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];

/***/ },
/* 90 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 91 */
/***/ function(module, exports) {

	/*!
	* EaselJS
	* Visit http://createjs.com/ for documentation, updates and examples.
	*
	* Copyright (c) 2010 gskinner.com, inc.
	*
	* Permission is hereby granted, free of charge, to any person
	* obtaining a copy of this software and associated documentation
	* files (the "Software"), to deal in the Software without
	* restriction, including without limitation the rights to use,
	* copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the
	* Software is furnished to do so, subject to the following
	* conditions:
	*
	* The above copyright notice and this permission notice shall be
	* included in all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	* OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	
	//##############################################################################
	// extend.js
	//##############################################################################
	let createjs = {};
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Sets up the prototype chain and constructor property for a new class.
	 *
	 * This should be called right after creating the class constructor.
	 *
	 * 	function MySubClass() {}
	 * 	createjs.extend(MySubClass, MySuperClass);
	 * 	MySubClass.prototype.doSomething = function() { }
	 *
	 * 	var foo = new MySubClass();
	 * 	console.log(foo instanceof MySuperClass); // true
	 * 	console.log(foo.prototype.constructor === MySubClass); // true
	 *
	 * @method extend
	 * @param {Function} subclass The subclass.
	 * @param {Function} superclass The superclass to extend.
	 * @return {Function} Returns the subclass's new prototype.
	 */
	createjs.extend = function(subclass, superclass) {
		"use strict";
	
		function o() { this.constructor = subclass; }
		o.prototype = superclass.prototype;
		return (subclass.prototype = new o());
	};
	
	//##############################################################################
	// promote.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
	 * It is recommended to use the super class's name as the prefix.
	 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
	 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
	 *
	 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
	 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
	 * prototype of `MySubClass` as `MySuperClass_draw`.
	 *
	 * This should be called after the class's prototype is fully defined.
	 *
	 * 	function ClassA(name) {
	 * 		this.name = name;
	 * 	}
	 * 	ClassA.prototype.greet = function() {
	 * 		return "Hello "+this.name;
	 * 	}
	 *
	 * 	function ClassB(name, punctuation) {
	 * 		this.ClassA_constructor(name);
	 * 		this.punctuation = punctuation;
	 * 	}
	 * 	createjs.extend(ClassB, ClassA);
	 * 	ClassB.prototype.greet = function() {
	 * 		return this.ClassA_greet()+this.punctuation;
	 * 	}
	 * 	createjs.promote(ClassB, "ClassA");
	 *
	 * 	var foo = new ClassB("World", "!?!");
	 * 	console.log(foo.greet()); // Hello World!?!
	 *
	 * @method promote
	 * @param {Function} subclass The class to promote super class methods on.
	 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
	 * @return {Function} Returns the subclass.
	 */
	createjs.promote = function(subclass, prefix) {
		"use strict";
	
		var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
		if (supP) {
			subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
			for (var n in supP) {
				if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
			}
		}
		return subclass;
	};
	
	//##############################################################################
	// indexOf.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
	 * that value.  Returns -1 if value is not found.
	 *
	 *      var i = createjs.indexOf(myArray, myElementToFind);
	 *
	 * @method indexOf
	 * @param {Array} array Array to search for searchElement
	 * @param searchElement Element to find in array.
	 * @return {Number} The first index of searchElement in array.
	 */
	createjs.indexOf = function (array, searchElement){
		"use strict";
	
		for (var i = 0,l=array.length; i < l; i++) {
			if (searchElement === array[i]) {
				return i;
			}
		}
		return -1;
	};
	
	//##############################################################################
	// UID.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)
		 * and should not be instantiated.
		 * @class UID
		 * @static
		 **/
		function UID() {
			throw "UID cannot be instantiated";
		}
	
	
	// private static properties:
		/**
		 * @property _nextID
		 * @type Number
		 * @protected
		 **/
		UID._nextID = 0;
	
	
	// public static methods:
		/**
		 * Returns the next unique id.
		 * @method get
		 * @return {Number} The next unique id
		 * @static
		 **/
		UID.get = function() {
			return UID._nextID++;
		};
	
	
		createjs.UID = UID;
	}());
	
	//##############################################################################
	// deprecate.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Wraps deprecated methods so they still be used, but throw warnings to developers.
	 *
	 *	obj.deprecatedMethod = createjs.deprecate("Old Method Name", obj._fallbackMethod);
	 *
	 * The recommended approach for deprecated properties is:
	 *
	 *	try {
	 *		Obj	ect.defineProperties(object, {
	 *			readyOnlyProp: { get: createjs.deprecate("readOnlyProp", function() { return this.alternateProp; }) },
	 *			readWriteProp: {
	 *				get: createjs.deprecate("readOnlyProp", function() { return this.alternateProp; }),
	 *				set: createjs.deprecate("readOnlyProp", function(val) { this.alternateProp = val; })
	 *		});
	 *	} catch (e) {}
	 *
	 * @method deprecate
	 * @param {Function} [fallbackMethod=null] A method to call when the deprecated method is used. See the example for how
	 * @param {String} [name=null] The name of the method or property to display in the console warning.
	 * to deprecate properties.
	 * @return {Function} If a fallbackMethod is supplied, returns a closure that will call the fallback method after
	 * logging the warning in the console.
	 */
	createjs.deprecate = function(fallbackMethod, name) {
		"use strict";
		return function() {
			var msg = "Deprecated property or method '"+name+"'. See docs for info.";
			console && (console.warn ? console.warn(msg) : console.log(msg));
			return fallbackMethod && fallbackMethod.apply(this, arguments);
		}
	};
	
	//##############################################################################
	// Event.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	// constructor:
		/**
		 * Contains properties and methods shared by all events for use with
		 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
		 * 
		 * Note that Event objects are often reused, so you should never
		 * rely on an event object's state outside of the call stack it was received in.
		 * @class Event
		 * @param {String} type The event type.
		 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
		 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
		 * @constructor
		 **/
		function Event(type, bubbles, cancelable) {
			
		
		// public properties:
			/**
			 * The type of event.
			 * @property type
			 * @type String
			 **/
			this.type = type;
		
			/**
			 * The object that generated an event.
			 * @property target
			 * @type Object
			 * @default null
			 * @readonly
			*/
			this.target = null;
		
			/**
			 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
			 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
			 * is generated from childObj, then a listener on parentObj would receive the event with
			 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
			 * @property currentTarget
			 * @type Object
			 * @default null
			 * @readonly
			*/
			this.currentTarget = null;
		
			/**
			 * For bubbling events, this indicates the current event phase:<OL>
			 * 	<LI> capture phase: starting from the top parent to the target</LI>
			 * 	<LI> at target phase: currently being dispatched from the target</LI>
			 * 	<LI> bubbling phase: from the target to the top parent</LI>
			 * </OL>
			 * @property eventPhase
			 * @type Number
			 * @default 0
			 * @readonly
			*/
			this.eventPhase = 0;
		
			/**
			 * Indicates whether the event will bubble through the display list.
			 * @property bubbles
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.bubbles = !!bubbles;
		
			/**
			 * Indicates whether the default behaviour of this event can be cancelled via
			 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
			 * @property cancelable
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.cancelable = !!cancelable;
		
			/**
			 * The epoch time at which this event was created.
			 * @property timeStamp
			 * @type Number
			 * @default 0
			 * @readonly
			*/
			this.timeStamp = (new Date()).getTime();
		
			/**
			 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
			 * on this event.
			 * @property defaultPrevented
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.defaultPrevented = false;
		
			/**
			 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
			 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
			 * @property propagationStopped
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.propagationStopped = false;
		
			/**
			 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
			 * on this event.
			 * @property immediatePropagationStopped
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.immediatePropagationStopped = false;
			
			/**
			 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
			 * @property removed
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.removed = false;
		}
		var p = Event.prototype;
	
	// public methods:
		/**
		 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
		 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
		 * cancel the default behaviour associated with the event.
		 * @method preventDefault
		 **/
		p.preventDefault = function() {
			this.defaultPrevented = this.cancelable&&true;
		};
	
		/**
		 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
		 * Mirrors the DOM event standard.
		 * @method stopPropagation
		 **/
		p.stopPropagation = function() {
			this.propagationStopped = true;
		};
	
		/**
		 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
		 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
		 * Mirrors the DOM event standard.
		 * @method stopImmediatePropagation
		 **/
		p.stopImmediatePropagation = function() {
			this.immediatePropagationStopped = this.propagationStopped = true;
		};
		
		/**
		 * Causes the active listener to be removed via removeEventListener();
		 * 
		 * 		myBtn.addEventListener("click", function(evt) {
		 * 			// do stuff...
		 * 			evt.remove(); // removes this listener.
		 * 		});
		 * 
		 * @method remove
		 **/
		p.remove = function() {
			this.removed = true;
		};
		
		/**
		 * Returns a clone of the Event instance.
		 * @method clone
		 * @return {Event} a clone of the Event instance.
		 **/
		p.clone = function() {
			return new Event(this.type, this.bubbles, this.cancelable);
		};
		
		/**
		 * Provides a chainable shortcut method for setting a number of properties on the instance.
		 *
		 * @method set
		 * @param {Object} props A generic object containing properties to copy to the instance.
		 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
		 * @chainable
		*/
		p.set = function(props) {
			for (var n in props) { this[n] = props[n]; }
			return this;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Event (type="+this.type+")]";
		};
	
		createjs.Event = Event;
	}());
	
	//##############################################################################
	// EventDispatcher.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
		 *
		 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
		 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
		 * 
		 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
		 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
		 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
		 * 
		 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
		 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
		 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
		 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
		 * 
		 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
		 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
		 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
		 *
		 * <h4>Example</h4>
		 * Add EventDispatcher capabilities to the "MyClass" class.
		 *
		 *      EventDispatcher.initialize(MyClass.prototype);
		 *
		 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
		 *
		 *      instance.addEventListener("eventName", handlerMethod);
		 *      function handlerMethod(event) {
		 *          console.log(event.target + " Was Clicked");
		 *      }
		 *
		 * <b>Maintaining proper scope</b><br />
		 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
		 * method to subscribe to events simplifies this.
		 *
		 *      instance.addEventListener("click", function(event) {
		 *          console.log(instance == this); // false, scope is ambiguous.
		 *      });
		 *      
		 *      instance.on("click", function(event) {
		 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
		 *      });
		 * 
		 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage
		 * scope.
		 *
		 * <b>Browser support</b>
		 * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model
		 * requires modern browsers (IE9+).
		 *      
		 *
		 * @class EventDispatcher
		 * @constructor
		 **/
		function EventDispatcher() {
		
		
		// private properties:
			/**
			 * @protected
			 * @property _listeners
			 * @type Object
			 **/
			this._listeners = null;
			
			/**
			 * @protected
			 * @property _captureListeners
			 * @type Object
			 **/
			this._captureListeners = null;
		}
		var p = EventDispatcher.prototype;
	
	// static public methods:
		/**
		 * Static initializer to mix EventDispatcher methods into a target object or prototype.
		 * 
		 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
		 * 		EventDispatcher.initialize(myObject); // add to a specific instance
		 * 
		 * @method initialize
		 * @static
		 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
		 * prototype.
		 **/
		EventDispatcher.initialize = function(target) {
			target.addEventListener = p.addEventListener;
			target.on = p.on;
			target.removeEventListener = target.off =  p.removeEventListener;
			target.removeAllEventListeners = p.removeAllEventListeners;
			target.hasEventListener = p.hasEventListener;
			target.dispatchEvent = p.dispatchEvent;
			target._dispatchEvent = p._dispatchEvent;
			target.willTrigger = p.willTrigger;
		};
		
	
	// public methods:
		/**
		 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
		 * multiple callbacks getting fired.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.addEventListener("click", handleClick);
		 *      function handleClick(event) {
		 *         // Click happened.
		 *      }
		 *
		 * @method addEventListener
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
		 * the event is dispatched.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 * @return {Function | Object} Returns the listener for chaining or assignment.
		 **/
		p.addEventListener = function(type, listener, useCapture) {
			var listeners;
			if (useCapture) {
				listeners = this._captureListeners = this._captureListeners||{};
			} else {
				listeners = this._listeners = this._listeners||{};
			}
			var arr = listeners[type];
			if (arr) { this.removeEventListener(type, listener, useCapture); }
			arr = listeners[type]; // remove may have deleted the array
			if (!arr) { listeners[type] = [listener];  }
			else { arr.push(listener); }
			return listener;
		};
		
		/**
		 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
		 * only run once, associate arbitrary data with the listener, and remove the listener.
		 * 
		 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
		 * The wrapper function is returned for use with `removeEventListener` (or `off`).
		 * 
		 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
		 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
		 * to `on` with the same params will create multiple listeners.
		 * 
		 * <h4>Example</h4>
		 * 
		 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
		 * 		function handleClick(evt, data) {
		 * 			data.count -= 1;
		 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
		 * 			if (data.count == 0) {
		 * 				alert("clicked 3 times!");
		 * 				myBtn.off("click", listener);
		 * 				// alternately: evt.remove();
		 * 			}
		 * 		}
		 * 
		 * @method on
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
		 * the event is dispatched.
		 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
		 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
		 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
		 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
		 **/
		p.on = function(type, listener, scope, once, data, useCapture) {
			if (listener.handleEvent) {
				scope = scope||listener;
				listener = listener.handleEvent;
			}
			scope = scope||this;
			return this.addEventListener(type, function(evt) {
					listener.call(scope, evt, data);
					once&&evt.remove();
				}, useCapture);
		};
	
		/**
		 * Removes the specified event listener.
		 *
		 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
		 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
		 * closure will not work.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.removeEventListener("click", handleClick);
		 *
		 * @method removeEventListener
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener The listener function or object.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 **/
		p.removeEventListener = function(type, listener, useCapture) {
			var listeners = useCapture ? this._captureListeners : this._listeners;
			if (!listeners) { return; }
			var arr = listeners[type];
			if (!arr) { return; }
			for (var i=0,l=arr.length; i<l; i++) {
				if (arr[i] == listener) {
					if (l==1) { delete(listeners[type]); } // allows for faster checks.
					else { arr.splice(i,1); }
					break;
				}
			}
		};
		
		/**
		 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
		 * .on method.
		 * 
		 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
		 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
		 *
		 * @method off
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener The listener function or object.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 **/
		p.off = p.removeEventListener;
	
		/**
		 * Removes all listeners for the specified type, or all listeners of all types.
		 *
		 * <h4>Example</h4>
		 *
		 *      // Remove all listeners
		 *      displayObject.removeAllEventListeners();
		 *
		 *      // Remove all click listeners
		 *      displayObject.removeAllEventListeners("click");
		 *
		 * @method removeAllEventListeners
		 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
		 **/
		p.removeAllEventListeners = function(type) {
			if (!type) { this._listeners = this._captureListeners = null; }
			else {
				if (this._listeners) { delete(this._listeners[type]); }
				if (this._captureListeners) { delete(this._captureListeners[type]); }
			}
		};
	
		/**
		 * Dispatches the specified event to all listeners.
		 *
		 * <h4>Example</h4>
		 *
		 *      // Use a string event
		 *      this.dispatchEvent("complete");
		 *
		 *      // Use an Event instance
		 *      var event = new createjs.Event("progress");
		 *      this.dispatchEvent(event);
		 *
		 * @method dispatchEvent
		 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
		 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
		 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
		 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
		 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
		 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
		 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
		 **/
		p.dispatchEvent = function(eventObj, bubbles, cancelable) {
			if (typeof eventObj == "string") {
				// skip everything if there's no listeners and it doesn't bubble:
				var listeners = this._listeners;
				if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
				eventObj = new createjs.Event(eventObj, bubbles, cancelable);
			} else if (eventObj.target && eventObj.clone) {
				// redispatching an active event object, so clone it:
				eventObj = eventObj.clone();
			}
			
			// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
			try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events
	
			if (!eventObj.bubbles || !this.parent) {
				this._dispatchEvent(eventObj, 2);
			} else {
				var top=this, list=[top];
				while (top.parent) { list.push(top = top.parent); }
				var i, l=list.length;
	
				// capture & atTarget
				for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
					list[i]._dispatchEvent(eventObj, 1+(i==0));
				}
				// bubbling
				for (i=1; i<l && !eventObj.propagationStopped; i++) {
					list[i]._dispatchEvent(eventObj, 3);
				}
			}
			return !eventObj.defaultPrevented;
		};
	
		/**
		 * Indicates whether there is at least one listener for the specified event type.
		 * @method hasEventListener
		 * @param {String} type The string type of the event.
		 * @return {Boolean} Returns true if there is at least one listener for the specified event.
		 **/
		p.hasEventListener = function(type) {
			var listeners = this._listeners, captureListeners = this._captureListeners;
			return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
		};
		
		/**
		 * Indicates whether there is at least one listener for the specified event type on this object or any of its
		 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
		 * specified type is dispatched from this object, it will trigger at least one listener.
		 * 
		 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
		 * event flow for a listener, not just this object.
		 * @method willTrigger
		 * @param {String} type The string type of the event.
		 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
		 **/
		p.willTrigger = function(type) {
			var o = this;
			while (o) {
				if (o.hasEventListener(type)) { return true; }
				o = o.parent;
			}
			return false;
		};
	
		/**
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[EventDispatcher]";
		};
	
	
	// private methods:
		/**
		 * @method _dispatchEvent
		 * @param {Object | Event} eventObj
		 * @param {Object} eventPhase
		 * @protected
		 **/
		p._dispatchEvent = function(eventObj, eventPhase) {
			var l, arr, listeners = (eventPhase <= 2) ? this._captureListeners : this._listeners;
			if (eventObj && listeners && (arr = listeners[eventObj.type]) && (l=arr.length)) {
				try { eventObj.currentTarget = this; } catch (e) {}
				try { eventObj.eventPhase = eventPhase|0; } catch (e) {}
				eventObj.removed = false;
				
				arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
				for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
					var o = arr[i];
					if (o.handleEvent) { o.handleEvent(eventObj); }
					else { o(eventObj); }
					if (eventObj.removed) {
						this.off(eventObj.type, o, eventPhase==1);
						eventObj.removed = false;
					}
				}
			}
			if (eventPhase === 2) { this._dispatchEvent(eventObj, 2.1); }
		};
	
	
		createjs.EventDispatcher = EventDispatcher;
	}());
	
	//##############################################################################
	// Ticker.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
		 * event to be notified when a set time interval has elapsed.
		 *
		 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
		 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
		 * can not be instantiated.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          // Actions carried out each tick (aka frame)
		 *          if (!event.paused) {
		 *              // Actions carried out when the Ticker is not paused.
		 *          }
		 *      }
		 *
		 * @class Ticker
		 * @uses EventDispatcher
		 * @static
		 **/
		function Ticker() {
			throw "Ticker cannot be instantiated.";
		}
	
	
	// constants:
		/**
		 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
		 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
		 * dispatches the tick when the time is within a certain threshold.
		 *
		 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
		 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
		 * gaining the benefits of that API (screen synch, background throttling).
		 *
		 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
		 * framerates of 10, 12, 15, 20, and 30 work well.
		 *
		 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
		 * supported.
		 * @property RAF_SYNCHED
		 * @static
		 * @type {String}
		 * @default "synched"
		 * @readonly
		 **/
		Ticker.RAF_SYNCHED = "synched";
	
		/**
		 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
		 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
		 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event object's "delta" properties to make this easier.
		 *
		 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
		 * supported.
		 * @property RAF
		 * @static
		 * @type {String}
		 * @default "raf"
		 * @readonly
		 **/
		Ticker.RAF = "raf";
	
		/**
		 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
		 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
		 * @property TIMEOUT
		 * @static
		 * @type {String}
		 * @default "timeout"
		 * @readonly
		 **/
		Ticker.TIMEOUT = "timeout";
	
	
	// static events:
		/**
		 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
		 * {{#crossLink "Ticker/paused:property"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          console.log("Paused:", event.paused, event.delta);
		 *      }
		 *
		 * @event tick
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Boolean} paused Indicates whether the ticker is currently paused.
		 * @param {Number} delta The time elapsed in ms since the last tick.
		 * @param {Number} time The total time in ms since Ticker was initialized.
		 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
		 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
		 * @since 0.6.0
		 */
	
	
	// public static properties:
		/**
		 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
		 * {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}}, {{#crossLink "Ticker/RAF:property"}}{{/crossLink}}, and
		 * {{#crossLink "Ticker/RAF_SYNCHED:property"}}{{/crossLink}} for mode details.
		 * @property timingMode
		 * @static
		 * @type {String}
		 * @default Ticker.TIMEOUT
		 **/
		Ticker.timingMode = null;
	
		/**
		 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
		 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
		 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
		 * (ex. maxDelta=50 when running at 40fps).
		 * 
		 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
		 * when using both delta and other values.
		 * 
		 * If 0, there is no maximum.
		 * @property maxDelta
		 * @static
		 * @type {number}
		 * @default 0
		 */
		Ticker.maxDelta = 0;
		
		/**
		 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
		 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
		 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
		 * info.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      createjs.Ticker.paused = true;
		 *      function handleTick(event) {
		 *          console.log(event.paused,
		 *          	createjs.Ticker.getTime(false),
		 *          	createjs.Ticker.getTime(true));
		 *      }
		 *
		 * @property paused
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		Ticker.paused = false;
	
	
	// mix-ins:
		// EventDispatcher methods:
		Ticker.removeEventListener = null;
		Ticker.removeAllEventListeners = null;
		Ticker.dispatchEvent = null;
		Ticker.hasEventListener = null;
		Ticker._listeners = null;
		createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
		Ticker._addEventListener = Ticker.addEventListener;
		Ticker.addEventListener = function() {
			!Ticker._inited&&Ticker.init();
			return Ticker._addEventListener.apply(Ticker, arguments);
		};
	
	
	// private static properties:
		/**
		 * @property _inited
		 * @static
		 * @type {Boolean}
		 * @private
		 **/
		Ticker._inited = false;
	
		/**
		 * @property _startTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._startTime = 0;
	
		/**
		 * @property _pausedTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._pausedTime=0;
	
		/**
		 * The number of ticks that have passed
		 * @property _ticks
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._ticks = 0;
	
		/**
		 * The number of ticks that have passed while Ticker has been paused
		 * @property _pausedTicks
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._pausedTicks = 0;
	
		/**
		 * @property _interval
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._interval = 50;
	
		/**
		 * @property _lastTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._lastTime = 0;
	
		/**
		 * @property _times
		 * @static
		 * @type {Array}
		 * @private
		 **/
		Ticker._times = null;
	
		/**
		 * @property _tickTimes
		 * @static
		 * @type {Array}
		 * @private
		 **/
		Ticker._tickTimes = null;
	
		/**
		 * Stores the timeout or requestAnimationFrame id.
		 * @property _timerId
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._timerId = null;
		
		/**
		 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
		 * if that property changed and a tick hasn't fired.
		 * @property _raf
		 * @static
		 * @type {Boolean}
		 * @private
		 **/
		Ticker._raf = true;
		
	
	// static getter / setters:
		/**
		 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
		 * @method _setInterval
		 * @private
		 * @static
		 * @param {Number} interval
		 **/
		Ticker._setInterval = function(interval) {
			Ticker._interval = interval;
			if (!Ticker._inited) { return; }
			Ticker._setupTick();
		};
		// Ticker.setInterval is @deprecated. Remove for 1.1+
		Ticker.setInterval = createjs.deprecate(Ticker._setInterval, "Ticker.setInterval");
	
		/**
		 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
		 * @method _getInterval
		 * @private
		 * @static
		 * @return {Number}
		 **/
		Ticker._getInterval = function() {
			return Ticker._interval;
		};
		// Ticker.getInterval is @deprecated. Remove for 1.1+
		Ticker.getInterval = createjs.deprecate(Ticker._getInterval, "Ticker.getInterval");
	
		/**
		 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
		 * @method _setFPS
		 * @private
		 * @static
		 * @param {Number} value
		 **/
		Ticker._setFPS = function(value) {
			Ticker._setInterval(1000/value);
		};
		// Ticker.setFPS is @deprecated. Remove for 1.1+
		Ticker.setFPS = createjs.deprecate(Ticker._setFPS, "Ticker.setFPS");
	
		/**
		 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
		 * @method _getFPS
		 * @static
		 * @private
		 * @return {Number}
		 **/
		Ticker._getFPS = function() {
			return 1000/Ticker._interval;
		};
		// Ticker.getFPS is @deprecated. Remove for 1.1+
		Ticker.getFPS = createjs.deprecate(Ticker._getFPS, "Ticker.getFPS");
	
		/**
		 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
		 * Note that actual time between ticks may be more than specified depending on CPU load.
		 * This property is ignored if the ticker is using the `RAF` timing mode.
		 * @property interval
		 * @static
		 * @type {Number}
		 **/
		 
		/**
		 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
		 * `framerate == 1000/interval`.
		 * @property framerate
		 * @static
		 * @type {Number}
		 **/
		try {
			Object.defineProperties(Ticker, {
				interval: { get: Ticker._getInterval, set: Ticker._setInterval },
				framerate: { get: Ticker._getFPS, set: Ticker._setFPS }
			});
		} catch (e) { console.log(e); }
	
	
	// public static methods:
		/**
		 * Starts the tick. This is called automatically when the first listener is added.
		 * @method init
		 * @static
		 **/
		Ticker.init = function() {
			if (Ticker._inited) { return; }
			Ticker._inited = true;
			Ticker._times = [];
			Ticker._tickTimes = [];
			Ticker._startTime = Ticker._getTime();
			Ticker._times.push(Ticker._lastTime = 0);
			Ticker.interval = Ticker._interval;
		};
		
		/**
		 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
		 * @method reset
		 * @static
		 **/
		Ticker.reset = function() {
			if (Ticker._raf) {
				var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
				f&&f(Ticker._timerId);
			} else {
				clearTimeout(Ticker._timerId);
			}
			Ticker.removeAllEventListeners("tick");
			Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
			Ticker._startTime = Ticker._lastTime = Ticker._ticks = Ticker._pausedTime = 0;
			Ticker._inited = false;
		};
	
		/**
		 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
		 * because it only measures the time spent within the tick execution stack. 
		 * 
		 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
		 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
		 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
		 *
		 * Example 2: With a target FPS of 30, {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} returns 10fps, which
		 * indicates an average of 100ms between the end of one tick and the end of the next. However, {{#crossLink "Ticker/getMeasuredTickTime"}}{{/crossLink}}
		 * returns 20ms. This would indicate that something other than the tick is using ~80ms (another script, DOM
		 * rendering, etc).
		 * @method getMeasuredTickTime
		 * @static
		 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
		 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
		 * @return {Number} The average time spent in a tick in milliseconds.
		 **/
		Ticker.getMeasuredTickTime = function(ticks) {
			var ttl=0, times=Ticker._tickTimes;
			if (!times || times.length < 1) { return -1; }
	
			// by default, calculate average for the past ~1 second:
			ticks = Math.min(times.length, ticks||(Ticker._getFPS()|0));
			for (var i=0; i<ticks; i++) { ttl += times[i]; }
			return ttl/ticks;
		};
	
		/**
		 * Returns the actual frames / ticks per second.
		 * @method getMeasuredFPS
		 * @static
		 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
		 * Defaults to the number of ticks per second.
		 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
		 * from the target frames per second.
		 **/
		Ticker.getMeasuredFPS = function(ticks) {
			var times = Ticker._times;
			if (!times || times.length < 2) { return -1; }
	
			// by default, calculate fps for the past ~1 second:
			ticks = Math.min(times.length-1, ticks||(Ticker._getFPS()|0));
			return 1000/((times[0]-times[ticks])/ticks);
		};
	
		/**
		 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
		 * Returns -1 if Ticker has not been initialized. For example, you could use
		 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
		 * @method getTime
		 * @static
		 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
		 * If false, the value returned will be total time elapsed since the first tick event listener was added.
		 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
		 **/
		Ticker.getTime = function(runTime) {
			return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
		};
	
		/**
		 * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event object.
		 * @method getEventTime
		 * @static
		 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
		 * @returns {number} The time or runTime property from the most recent tick event or -1.
		 */
		Ticker.getEventTime = function(runTime) {
			return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
		};
		
		/**
		 * Returns the number of ticks that have been broadcast by Ticker.
		 * @method getTicks
		 * @static
		 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
		 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
		 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
		 * value. The default value is false.
		 * @return {Number} of ticks that have been broadcast.
		 **/
		Ticker.getTicks = function(pauseable) {
			return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
		};
	
	
	// private static methods:
		/**
		 * @method _handleSynch
		 * @static
		 * @private
		 **/
		Ticker._handleSynch = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
	
			// run if enough time has elapsed, with a little bit of flexibility to be early:
			if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
				Ticker._tick();
			}
		};
	
		/**
		 * @method _handleRAF
		 * @static
		 * @private
		 **/
		Ticker._handleRAF = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
			Ticker._tick();
		};
	
		/**
		 * @method _handleTimeout
		 * @static
		 * @private
		 **/
		Ticker._handleTimeout = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
			Ticker._tick();
		};
	
		/**
		 * @method _setupTick
		 * @static
		 * @private
		 **/
		Ticker._setupTick = function() {
			if (Ticker._timerId != null) { return; } // avoid duplicates
	
			var mode = Ticker.timingMode;
			if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
				var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
				if (f) {
					Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
					Ticker._raf = true;
					return;
				}
			}
			Ticker._raf = false;
			Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
		};
	
		/**
		 * @method _tick
		 * @static
		 * @private
		 **/
		Ticker._tick = function() {
			var paused = Ticker.paused;
			var time = Ticker._getTime();
			var elapsedTime = time-Ticker._lastTime;
			Ticker._lastTime = time;
			Ticker._ticks++;
			
			if (paused) {
				Ticker._pausedTicks++;
				Ticker._pausedTime += elapsedTime;
			}
			
			if (Ticker.hasEventListener("tick")) {
				var event = new createjs.Event("tick");
				var maxDelta = Ticker.maxDelta;
				event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
				event.paused = paused;
				event.time = time;
				event.runTime = time-Ticker._pausedTime;
				Ticker.dispatchEvent(event);
			}
			
			Ticker._tickTimes.unshift(Ticker._getTime()-time);
			while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }
	
			Ticker._times.unshift(time);
			while (Ticker._times.length > 100) { Ticker._times.pop(); }
		};
	
		/**
		 * @method _getTime
		 * @static
		 * @private
		 **/
		var w=window, now=w.performance.now || w.performance.mozNow || w.performance.msNow || w.performance.oNow || w.performance.webkitNow;
		Ticker._getTime = function() {
			return ((now&&now.call(w.performance))||(new Date().getTime())) - Ticker._startTime;
		};
	
	
		createjs.Ticker = Ticker;
	}());
	
	//##############################################################################
	// VideoBuffer.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * When an HTML video seeks, including when looping, there is an indeterminate period before a new frame is available.
		 * This can result in the video blinking or flashing when it is drawn to a canvas. The VideoBuffer class resolves
		 * this issue by drawing each frame to an off-screen canvas and preserving the prior frame during a seek.
		 * 
		 * 	var myBuffer = new createjs.VideoBuffer(myVideo);
		 * 	var myBitmap = new Bitmap(myBuffer);
		 * 
		 * @class VideoBuffer
		 * @param {HTMLVideoElement} video The HTML video element to buffer.
		 * @constructor
		 **/
		function VideoBuffer(video) {
			
		// private properties:
			/**
			 * Used by Bitmap to determine when the video buffer is ready to be drawn. Not intended for general use.
			 * @property readyState
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.readyState = video.readyState;
			
			/**
			 * @property _video
			 * @protected
			 * @type {HTMLVideoElement}
			 * @default 0
			 **/
			this._video = video;
			
			/**
			 * @property _canvas
			 * @protected
			 * @type {HTMLCanvasElement}
			 * @default 0
			 **/
			this._canvas = null;
			
			/**
			 * @property _lastTime
			 * @protected
			 * @type {Number}
			 * @default -1
			 **/
			this._lastTime = -1;
			
			if (this.readyState < 2) { video.addEventListener("canplaythrough", this._videoReady.bind(this)); } //once:true isn't supported everywhere, but its a non-critical optimization here.
		}
		var p = VideoBuffer.prototype;
		
		
	// public methods:
		/**
		 * Gets an HTML canvas element showing the current video frame, or the previous frame if in a seek / loop.
		 * Primarily for use by {{#crossLink "Bitmap"}}{{/crossLink}}.
		 * @method getImage
		 **/
		p.getImage = function() {
			if (this.readyState < 2) { return; }
			var canvas=this._canvas, video = this._video;
			if (!canvas) {
				canvas = this._canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
			}
			if (video.readyState >= 2 && video.currentTime !== this._lastTime) {
				var ctx = canvas.getContext("2d");
				ctx.clearRect(0,0,canvas.width,canvas.height);
				ctx.drawImage(video,0,0,canvas.width,canvas.height);
				this._lastTime = video.currentTime;
			}
			return canvas;
		};
		
	// private methods:
		/**
		 * @method _videoReady
		 * @protected
		 **/
		p._videoReady = function() {
			this.readyState = 2;
		};
	
	
		createjs.VideoBuffer = VideoBuffer;
	}());
	
	//##############################################################################
	// MouseEvent.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
		 * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.
		 * @class MouseEvent
		 * @param {String} type The event type.
		 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
		 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
		 * @param {Number} stageX The normalized x position relative to the stage.
		 * @param {Number} stageY The normalized y position relative to the stage.
		 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
		 * @param {Number} pointerID The unique id for the pointer.
		 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
		 * @param {Number} rawX The raw x position relative to the stage.
		 * @param {Number} rawY The raw y position relative to the stage.
		 * @param {DisplayObject} relatedTarget The secondary target for the event.
		 * @extends Event
		 * @constructor
		 **/
		function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
			this.Event_constructor(type, bubbles, cancelable);
			
			
		// public properties:
			/**
			 * The normalized x position on the stage. This will always be within the range 0 to stage width.
			 * @property stageX
			 * @type Number
			*/
			this.stageX = stageX;
		
			/**
			 * The normalized y position on the stage. This will always be within the range 0 to stage height.
			 * @property stageY
			 * @type Number
			 **/
			this.stageY = stageY;
		
			/**
			 * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
			 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
			 * @property rawX
			 * @type Number
			*/
			this.rawX = (rawX==null)?stageX:rawX;
		
			/**
			 * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
			 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
			 * @property rawY
			 * @type Number
			*/
			this.rawY = (rawY==null)?stageY:rawY;
		
			/**
			 * The native MouseEvent generated by the browser. The properties and API for this
			 * event may differ between browsers. This property will be null if the
			 * EaselJS property was not directly generated from a native MouseEvent.
			 * @property nativeEvent
			 * @type HtmlMouseEvent
			 * @default null
			 **/
			this.nativeEvent = nativeEvent;
		
			/**
			 * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
			 * supplied id value.
			 * @property pointerID
			 * @type {Number}
			 */
			this.pointerID = pointerID;
		
			/**
			 * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
			 * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
			 * @property primary
			 * @type {Boolean}
			 */
			this.primary = !!primary;
			
			/**
			 * The secondary target for the event, if applicable. This is used for mouseout/rollout
			 * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
			 * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
			 * 
			 * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
			 * @property relatedTarget
			 * @type {DisplayObject}
			 */
			this.relatedTarget = relatedTarget;
		}
		var p = createjs.extend(MouseEvent, createjs.Event);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
		
		
	// getter / setters:
		/**
		 * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
		 * @property localX
		 * @type {Number}
		 * @readonly
		 */
		p._get_localX = function() {
			return this.currentTarget.globalToLocal(this.rawX, this.rawY).x;
		};
		
		/**
		 * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
		 * @property localY
		 * @type {Number}
		 * @readonly
		 */
		p._get_localY = function() {
			return this.currentTarget.globalToLocal(this.rawX, this.rawY).y;
		};
		
		/**
		 * Indicates whether the event was generated by a touch input (versus a mouse input).
		 * @property isTouch
		 * @type {Boolean}
		 * @readonly
		 */
		p._get_isTouch = function() {
			return this.pointerID !== -1;
		};
		
		
		try {
			Object.defineProperties(p, {
				localX: { get: p._get_localX },
				localY: { get: p._get_localY },
				isTouch: { get: p._get_isTouch }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Returns a clone of the MouseEvent instance.
		 * @method clone
		 * @return {MouseEvent} a clone of the MouseEvent instance.
		 **/
		p.clone = function() {
			return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";
		};
	
	
		createjs.MouseEvent = createjs.promote(MouseEvent, "Event");
	}());
	
	//##############################################################################
	// Matrix2D.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
		 *
		 * This matrix can be visualized as:
		 *
		 * 	[ a  c  tx
		 * 	  b  d  ty
		 * 	  0  0  1  ]
		 *
		 * Note the locations of b and c.
		 *
		 * @class Matrix2D
		 * @param {Number} [a=1] Specifies the a property for the new matrix.
		 * @param {Number} [b=0] Specifies the b property for the new matrix.
		 * @param {Number} [c=0] Specifies the c property for the new matrix.
		 * @param {Number} [d=1] Specifies the d property for the new matrix.
		 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
		 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
		 * @constructor
		 **/
		function Matrix2D(a, b, c, d, tx, ty) {
			this.setValues(a,b,c,d,tx,ty);
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * Position (0, 0) in a 3x3 affine transformation matrix.
			 * @property a
			 * @type Number
			 **/
		
			/**
			 * Position (0, 1) in a 3x3 affine transformation matrix.
			 * @property b
			 * @type Number
			 **/
		
			/**
			 * Position (1, 0) in a 3x3 affine transformation matrix.
			 * @property c
			 * @type Number
			 **/
		
			/**
			 * Position (1, 1) in a 3x3 affine transformation matrix.
			 * @property d
			 * @type Number
			 **/
		
			/**
			 * Position (2, 0) in a 3x3 affine transformation matrix.
			 * @property tx
			 * @type Number
			 **/
		
			/**
			 * Position (2, 1) in a 3x3 affine transformation matrix.
			 * @property ty
			 * @type Number
			 **/
		}
		var p = Matrix2D.prototype;
	
	// constants:
		/**
		 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
		 * @property DEG_TO_RAD
		 * @static
		 * @final
		 * @type Number
		 * @readonly
		 **/
		Matrix2D.DEG_TO_RAD = Math.PI/180;
	
	
	// static public properties:
		/**
		 * An identity matrix, representing a null transformation.
		 * @property identity
		 * @static
		 * @type Matrix2D
		 * @readonly
		 **/
		Matrix2D.identity = null; // set at bottom of class definition.
		
	
	// public methods:
		/**
		 * Sets the specified values on this instance. 
		 * @method setValues
		 * @param {Number} [a=1] Specifies the a property for the new matrix.
		 * @param {Number} [b=0] Specifies the b property for the new matrix.
		 * @param {Number} [c=0] Specifies the c property for the new matrix.
		 * @param {Number} [d=1] Specifies the d property for the new matrix.
		 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
		 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
		 * @return {Matrix2D} This instance. Useful for chaining method calls.
		*/
		p.setValues = function(a, b, c, d, tx, ty) {
			// don't forget to update docs in the constructor if these change:
			this.a = (a == null) ? 1 : a;
			this.b = b || 0;
			this.c = c || 0;
			this.d = (d == null) ? 1 : d;
			this.tx = tx || 0;
			this.ty = ty || 0;
			return this;
		};
	
		/**
		 * Appends the specified matrix properties to this matrix. All parameters are required.
		 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
		 * @method append
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.append = function(a, b, c, d, tx, ty) {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			if (a != 1 || b != 0 || c != 0 || d != 1) {
				this.a  = a1*a+c1*b;
				this.b  = b1*a+d1*b;
				this.c  = a1*c+c1*d;
				this.d  = b1*c+d1*d;
			}
			this.tx = a1*tx+c1*ty+this.tx;
			this.ty = b1*tx+d1*ty+this.ty;
			return this;
		};
	
		/**
		 * Prepends the specified matrix properties to this matrix.
		 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
		 * All parameters are required.
		 * @method prepend
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prepend = function(a, b, c, d, tx, ty) {
			var a1 = this.a;
			var c1 = this.c;
			var tx1 = this.tx;
	
			this.a  = a*a1+c*this.b;
			this.b  = b*a1+d*this.b;
			this.c  = a*c1+c*this.d;
			this.d  = b*c1+d*this.d;
			this.tx = a*tx1+c*this.ty+tx;
			this.ty = b*tx1+d*this.ty+ty;
			return this;
		};
	
		/**
		 * Appends the specified matrix to this matrix.
		 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
		 * @method appendMatrix
		 * @param {Matrix2D} matrix
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.appendMatrix = function(matrix) {
			return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Prepends the specified matrix to this matrix.
		 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
		 * For example, you could calculate the combined transformation for a child object using:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var mtx = o.getMatrix();
		 * 	while (o = o.parent) {
		 * 		// prepend each parent's transformation in turn:
		 * 		o.prependMatrix(o.getMatrix());
		 * 	}
		 * @method prependMatrix
		 * @param {Matrix2D} matrix
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prependMatrix = function(matrix) {
			return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
		 * For example, you can use this to generate a matrix representing the transformations of a display object:
		 * 
		 * 	var mtx = new createjs.Matrix2D();
		 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}
	
			if (skewX || skewY) {
				// TODO: can this be combined into a single append operation?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			
			if (regX || regY) {
				// append the registration offset:
				this.tx -= regX*this.a+regY*this.c; 
				this.ty -= regX*this.b+regY*this.d;
			}
			return this;
		};
	
		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
		 * For example, you could calculate the combined transformation for a child object using:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var mtx = new createjs.Matrix2D();
		 * 	do  {
		 * 		// prepend each parent's transformation in turn:
		 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
		 * 	} while (o = o.parent);
		 * 	
		 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
		 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}
	
			if (regX || regY) {
				// prepend the registration offset:
				this.tx -= regX; this.ty -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			return this;
		};
	
		/**
		 * Applies a clockwise rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.rotate = function(angle) {
			angle = angle*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
	
			var a1 = this.a;
			var b1 = this.b;
	
			this.a = a1*cos+this.c*sin;
			this.b = b1*cos+this.d*sin;
			this.c = -a1*sin+this.c*cos;
			this.d = -b1*sin+this.d*cos;
			return this;
		};
	
		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		*/
		p.skew = function(skewX, skewY) {
			skewX = skewX*Matrix2D.DEG_TO_RAD;
			skewY = skewY*Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
			return this;
		};
	
		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
		 * @param {Number} y The amount to scale vertically.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.scale = function(x, y) {
			this.a *= x;
			this.b *= x;
			this.c *= y;
			this.d *= y;
			//this.tx *= x;
			//this.ty *= y;
			return this;
		};
	
		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.translate = function(x, y) {
			this.tx += this.a*x + this.c*y;
			this.ty += this.b*x + this.d*y;
			return this;
		};
	
		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.identity = function() {
			this.a = this.d = 1;
			this.b = this.c = this.tx = this.ty = 0;
			return this;
		};
	
		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.invert = function() {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var n = a1*d1-b1*c1;
	
			this.a = d1/n;
			this.b = -b1/n;
			this.c = -c1/n;
			this.d = a1/n;
			this.tx = (c1*this.ty-d1*tx1)/n;
			this.ty = -(a1*this.ty-b1*tx1)/n;
			return this;
		};
	
		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @return {Boolean}
		 **/
		p.isIdentity = function() {
			return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
		};
		
		/**
		 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
		 * @method equals
		 * @param {Matrix2D} matrix The matrix to compare.
		 * @return {Boolean}
		 **/
		p.equals = function(matrix) {
			return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
		};
	
		/**
		 * Transforms a point according to this matrix.
		 * @method transformPoint
		 * @param {Number} x The x component of the point to transform.
		 * @param {Number} y The y component of the point to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
		 * @return {Point} This matrix. Useful for chaining method calls.
		 **/
		p.transformPoint = function(x, y, pt) {
			pt = pt||{};
			pt.x = x*this.a+y*this.c+this.tx;
			pt.y = x*this.b+y*this.d+this.ty;
			return pt;
		};
	
		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 * @return {Object} The target, or a new generic object with the transform properties applied.
		*/
		p.decompose = function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.tx;
			target.y = this.ty;
			target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
			target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
	
			var skewX = Math.atan2(-this.c, this.d);
			var skewY = Math.atan2(this.b, this.a);
	
			var delta = Math.abs(1-skewX/skewY);
			if (delta < 0.00001) { // effectively identical, can use rotation:
				target.rotation = skewY/Matrix2D.DEG_TO_RAD;
				if (this.a < 0 && this.d >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/Matrix2D.DEG_TO_RAD;
				target.skewY = skewY/Matrix2D.DEG_TO_RAD;
			}
			return target;
		};
		
		/**
		 * Copies all properties from the specified matrix to this matrix.
		 * @method copy
		 * @param {Matrix2D} matrix The matrix to copy properties from.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		*/
		p.copy = function(matrix) {
			return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Returns a clone of the Matrix2D instance.
		 * @method clone
		 * @return {Matrix2D} a clone of the Matrix2D instance.
		 **/
		p.clone = function() {
			return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
		};
	
		// this has to be populated after the class is defined:
		Matrix2D.identity = new Matrix2D();
	
	
		createjs.Matrix2D = Matrix2D;
	}());
	
	//##############################################################################
	// DisplayProps.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
		/**
		 * Used for calculating and encapsulating display related properties.
		 * @class DisplayProps
		 * @param {Number} [visible=true] Visible value.
		 * @param {Number} [alpha=1] Alpha value.
		 * @param {Number} [shadow=null] A Shadow instance or null.
		 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
		 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
		 * @constructor
		 **/
		function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
			this.setValues(visible, alpha, shadow, compositeOperation, matrix);
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * Property representing the alpha that will be applied to a display object.
			 * @property alpha
			 * @type Number
			 **/
		
			/**
			 * Property representing the shadow that will be applied to a display object.
			 * @property shadow
			 * @type Shadow
			 **/
		
			/**
			 * Property representing the compositeOperation that will be applied to a display object.
			 * You can find a list of valid composite operations at:
			 * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing</a>
			 * @property compositeOperation
			 * @type String
			 **/
			
			/**
			 * Property representing the value for visible that will be applied to a display object.
			 * @property visible
			 * @type Boolean
			 **/
			
			/**
			 * The transformation matrix that will be applied to a display object.
			 * @property matrix
			 * @type Matrix2D
			 **/
		}
		var p = DisplayProps.prototype;
	
	// initialization:
		/**
		 * Reinitializes the instance with the specified values.
		 * @method setValues
		 * @param {Number} [visible=true] Visible value.
		 * @param {Number} [alpha=1] Alpha value.
		 * @param {Number} [shadow=null] A Shadow instance or null.
		 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
		 * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
			this.visible = visible == null ? true : !!visible;
			this.alpha = alpha == null ? 1 : alpha;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			this.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();
			return this;
		};
	
	// public methods:
		/**
		 * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
		 * @method append
		 * @param {Boolean} visible desired visible value
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @param {Matrix2D} [matrix] a Matrix2D instance
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.append = function(visible, alpha, shadow, compositeOperation, matrix) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
			this.visible = this.visible && visible;
			matrix&&this.matrix.appendMatrix(matrix);
			return this;
		};
		
		/**
		 * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
		 * For example, to get the combined display properties that would be applied to a child, you could use:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var props = new createjs.DisplayProps();
		 * 	do {
		 * 		// prepend each parent's props in turn:
		 * 		props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
		 * 	} while (o = o.parent);
		 * 	
		 * @method prepend
		 * @param {Boolean} visible desired visible value
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @param {Matrix2D} [matrix] a Matrix2D instance
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
			this.visible = this.visible && visible;
			matrix&&this.matrix.prependMatrix(matrix);
			return this;
		};
		
		/**
		 * Resets this instance and its matrix to default values.
		 * @method identity
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.identity = function() {
			this.visible = true;
			this.alpha = 1;
			this.shadow = this.compositeOperation = null;
			this.matrix.identity();
			return this;
		};
		
		/**
		 * Returns a clone of the DisplayProps instance. Clones the associated matrix.
		 * @method clone
		 * @return {DisplayProps} a clone of the DisplayProps instance.
		 **/
		p.clone = function() {
			return new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());
		};
	
	// private methods:
	
		createjs.DisplayProps = DisplayProps;
	})();
	
	//##############################################################################
	// Point.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents a point on a 2 dimensional x / y coordinate system.
		 *
		 * <h4>Example</h4>
		 * 
		 *      var point = new createjs.Point(0, 100);
		 * 
		 * @class Point
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @constructor
		 **/
		function Point(x, y) {
		 	this.setValues(x, y);
		 	
		 	
		// public properties:
			// assigned in the setValues method.
			/**
			 * X position.
			 * @property x
			 * @type Number
			 **/
		
			/**
			 * Y position.
			 * @property y
			 * @type Number
			 **/
		}
		var p = Point.prototype;
		
	// public methods:
		/** 
		 * Sets the specified values on this instance.
		 * @method setValues
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @return {Point} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function(x, y) {
			this.x = x||0;
			this.y = y||0;
			return this;
		};
		
		/**
		 * Copies all properties from the specified point to this point.
		 * @method copy
		 * @param {Point} point The point to copy properties from.
		 * @return {Point} This point. Useful for chaining method calls.
		 * @chainable
		*/
		p.copy = function(point) {
			this.x = point.x;
			this.y = point.y;
			return this;
		};
		
		/**
		 * Returns a clone of the Point instance.
		 * @method clone
		 * @return {Point} a clone of the Point instance.
		 **/
		p.clone = function() {
			return new Point(this.x, this.y);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Point (x="+this.x+" y="+this.y+")]";
		};
		
		
		createjs.Point = Point;
	}());
	
	//##############################################################################
	// Rectangle.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).
		 *
		 * <h4>Example</h4>
		 *
		 *      var rect = new createjs.Rectangle(0, 0, 100, 100);
		 *
		 * @class Rectangle
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @param {Number} [width=0] The width of the Rectangle.
		 * @param {Number} [height=0] The height of the Rectangle.
		 * @constructor
		 **/
		function Rectangle(x, y, width, height) {
			this.setValues(x, y, width, height);
			
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * X position.
			 * @property x
			 * @type Number
			 **/
		
			/**
			 * Y position.
			 * @property y
			 * @type Number
			 **/
		
			/**
			 * Width.
			 * @property width
			 * @type Number
			 **/
		
			/**
			 * Height.
			 * @property height
			 * @type Number
			 **/
		}
		var p = Rectangle.prototype;
	
	// public methods:
		/** 
		 * Sets the specified values on this instance.
		 * @method setValues
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @param {Number} [width=0] The width of the Rectangle.
		 * @param {Number} [height=0] The height of the Rectangle.
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function(x, y, width, height) {
			// don't forget to update docs in the constructor if these change:
			this.x = x||0;
			this.y = y||0;
			this.width = width||0;
			this.height = height||0;
			return this;
		};
		
		/** 
		 * Extends the rectangle's bounds to include the described point or rectangle.
		 * @method extend
		 * @param {Number} x X position of the point or rectangle.
		 * @param {Number} y Y position of the point or rectangle.
		 * @param {Number} [width=0] The width of the rectangle.
		 * @param {Number} [height=0] The height of the rectangle.
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.extend = function(x, y, width, height) {
			width = width||0;
			height = height||0;
			if (x+width > this.x+this.width) { this.width = x+width-this.x; }
			if (y+height > this.y+this.height) { this.height = y+height-this.y; }
			if (x < this.x) { this.width += this.x-x; this.x = x; }
			if (y < this.y) { this.height += this.y-y; this.y = y; }
			return this;
		};
		
		/** 
		 * Adds the specified padding to the rectangle's bounds.
		 * @method pad
		 * @param {Number} top
		 * @param {Number} left
		 * @param {Number} bottom
		 * @param {Number} right
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.pad = function(top, left, bottom, right) {
			this.x -= left;
			this.y -= top;
			this.width += left+right;
			this.height += top+bottom;
			return this;
		};
		
		/**
		 * Copies all properties from the specified rectangle to this rectangle.
		 * @method copy
		 * @param {Rectangle} rectangle The rectangle to copy properties from.
		 * @return {Rectangle} This rectangle. Useful for chaining method calls.
		 * @chainable
		*/
		p.copy = function(rectangle) {
			return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
		};
		
		/** 
		 * Returns true if this rectangle fully encloses the described point or rectangle.
		 * @method contains
		 * @param {Number} x X position of the point or rectangle.
		 * @param {Number} y Y position of the point or rectangle.
		 * @param {Number} [width=0] The width of the rectangle.
		 * @param {Number} [height=0] The height of the rectangle.
		 * @return {Boolean} True if the described point or rectangle is contained within this rectangle.
		*/
		p.contains = function(x, y, width, height) {
			width = width||0;
			height = height||0;
			return (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);
		};
		
		/** 
		 * Returns a new rectangle which contains this rectangle and the specified rectangle.
		 * @method union
		 * @param {Rectangle} rect The rectangle to calculate a union with.
		 * @return {Rectangle} A new rectangle describing the union.
		*/
		p.union = function(rect) {
			return this.clone().extend(rect.x, rect.y, rect.width, rect.height);
		};
		
		/** 
		 * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,
		 * or null if they do not intersect.
		 * @method intersection
		 * @param {Rectangle} rect The rectangle to calculate an intersection with.
		 * @return {Rectangle} A new rectangle describing the intersection or null.
		*/
		p.intersection = function(rect) {
			var x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;
			if (this.x > x1) { x1 = this.x; }
			if (this.y > y1) { y1 = this.y; }
			if (this.x + this.width < x2) { x2 = this.x + this.width; }
			if (this.y + this.height < y2) { y2 = this.y + this.height; }
			return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);
		};
		
		/** 
		 * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.
		 * @method intersects
		 * @param {Rectangle} rect The rectangle to compare.
		 * @return {Boolean} True if the rectangles intersect.
		*/
		p.intersects = function(rect) {
			return (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);
		};
		
		/** 
		 * Returns true if the width or height are equal or less than 0.
		 * @method isEmpty
		 * @return {Boolean} True if the rectangle is empty.
		*/
		p.isEmpty = function() {
			return this.width <= 0 || this.height <= 0;
		};
		
		/**
		 * Returns a clone of the Rectangle instance.
		 * @method clone
		 * @return {Rectangle} a clone of the Rectangle instance.
		 **/
		p.clone = function() {
			return new Rectangle(this.x, this.y, this.width, this.height);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";
		};
		
		
		createjs.Rectangle = Rectangle;
	}());
	
	//##############################################################################
	// ButtonHelper.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or
		 * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and
		 * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},
		 * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.
		 *
		 * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent
		 * garbage collection.
		 * 
		 * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 *
		 *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");
		 *      myInstance.addEventListener("click", handleClick);
		 *      function handleClick(event) {
		 *          // Click Happened.
		 *      }
		 *
		 * @class ButtonHelper
		 * @param {Sprite|MovieClip} target The instance to manage.
		 * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.
		 * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.
		 * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.
		 * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing
		 * states.
		 * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,
		 * then the button's visible states will be used instead. Note that the same instance as the "target" argument can be
		 * used for the hitState.
		 * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is
		 * null, then the default state of the hitArea will be used. *
		 * @constructor
		 */
		function ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {
			if (!target.addEventListener) { return; }
		
		
		// public properties:
			/**
			 * The target for this button helper.
			 * @property target
			 * @type MovieClip | Sprite
			 * @readonly
			 **/
			this.target = target;
		
			/**
			 * The label name or frame number to display when the user mouses out of the target. Defaults to "over".
			 * @property overLabel
			 * @type String | Number
			 **/
			this.overLabel = overLabel == null ? "over" : overLabel;
		
			/**
			 * The label name or frame number to display when the user mouses over the target. Defaults to "out".
			 * @property outLabel
			 * @type String | Number
			 **/
			this.outLabel = outLabel == null ? "out" : outLabel;
		
			/**
			 * The label name or frame number to display when the user presses on the target. Defaults to "down".
			 * @property downLabel
			 * @type String | Number
			 **/
			this.downLabel = downLabel == null ? "down" : downLabel;
		
			/**
			 * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.
			 * @property play
			 * @default false
			 * @type Boolean
			 **/
			this.play = play;
			
			
		//  private properties
			/**
			 * @property _isPressed
			 * @type Boolean
			 * @protected
			 **/
			this._isPressed = false;
		
			/**
			 * @property _isOver
			 * @type Boolean
			 * @protected
			 **/
			this._isOver = false;
		
			/**
			 * @property _enabled
			 * @type Boolean
			 * @protected
			 **/
			this._enabled = false;
			
		// setup:
			target.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.
			this.enabled = true;
			this.handleEvent({});
			if (hitArea) {
				if (hitLabel) {
					hitArea.actionsEnabled = false;
					hitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);
				}
				target.hitArea = hitArea;
			}
		}
		var p = ButtonHelper.prototype;
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
		 * @method setEnabled
		 * @param {Boolean} value The enabled property to set the instance to.
		 * @[rptected
		 * @protected
		 **/
		p._setEnabled = function(value) {
			if (value == this._enabled) { return; }
			var o = this.target;
			this._enabled = value;
			if (value) {
				o.cursor = "pointer";
				o.addEventListener("rollover", this);
				o.addEventListener("rollout", this);
				o.addEventListener("mousedown", this);
				o.addEventListener("pressup", this);
				if (o._reset) { o.__reset = o._reset; o._reset = this._reset;}
			} else {
				o.cursor = null;
				o.removeEventListener("rollover", this);
				o.removeEventListener("rollout", this);
				o.removeEventListener("mousedown", this);
				o.removeEventListener("pressup", this);
				if (o.__reset) { o._reset = o.__reset; delete(o.__reset); }
			}
		};
		// ButtonHelper.setEnabled is @deprecated. Remove for 1.1+
		p.setEnabled = createjs.deprecate(p._setEnabled, "ButtonHelper.setEnabled");
	
		/**
		 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
		 * @method getEnabled
		 * @protected
		 * @return {Boolean}
		 **/
		p._getEnabled = function() {
			return this._enabled;
		};
		// ButtonHelper.getEnabled is @deprecated. Remove for 1.1+
		p.getEnabled = createjs.deprecate(p._getEnabled, "ButtonHelper.getEnabled");
	
		/**
		 * Enables or disables the button functionality on the target.
		 * @property enabled
		 * @type {Boolean}
		 **/
		try {
			Object.defineProperties(p, {
				enabled: { get: p._getEnabled, set: p._setEnabled }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[ButtonHelper]";
		};
	
	
	// private methods:
		/**
		 * @method handleEvent
		 * @param {Object} evt The mouse event to handle.
		 * @protected
		 **/
		p.handleEvent = function(evt) {
			var label, t = this.target, type = evt.type;
			if (type == "mousedown") {
				this._isPressed = true;
				label = this.downLabel;
			} else if (type == "pressup") {
				this._isPressed = false;
				label = this._isOver ? this.overLabel : this.outLabel;
			} else if (type == "rollover") {
				this._isOver = true;
				label = this._isPressed ? this.downLabel : this.overLabel;
			} else { // rollout and default
				this._isOver = false;
				label = this._isPressed ? this.overLabel : this.outLabel;
			}
			if (this.play) {
				t.gotoAndPlay&&t.gotoAndPlay(label);
			} else {
				t.gotoAndStop&&t.gotoAndStop(label);
			}
		};
		
		/**
		 * Injected into target. Preserves the paused state through a reset.
		 * @method _reset
		 * @protected
		 **/
		p._reset = function() {
			// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.
			var p = this.paused;
			this.__reset();
			this.paused = p;
		};
	
	
		createjs.ButtonHelper = ButtonHelper;
	}());
	
	//##############################################################################
	// Shadow.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}
		 * via its <code>shadow</code> property.
		 *
		 * <h4>Example</h4>
		 *
		 *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
		 *
		 * @class Shadow
		 * @constructor
		 * @param {String} color The color of the shadow. This can be any valid CSS color value.
		 * @param {Number} offsetX The x offset of the shadow in pixels.
		 * @param {Number} offsetY The y offset of the shadow in pixels.
		 * @param {Number} blur The size of the blurring effect.
		 **/
		function Shadow(color, offsetX, offsetY, blur) {
			
			
		// public properties:
			/** 
			 * The color of the shadow. This can be any valid CSS color value.
			 * @property color
			 * @type String
			 * @default null
			 */
			this.color = color||"black";
		
			/** The x offset of the shadow.
			 * @property offsetX
			 * @type Number
			 * @default 0
			 */
			this.offsetX = offsetX||0;
		
			/** The y offset of the shadow.
			 * @property offsetY
			 * @type Number
			 * @default 0
			 */
			this.offsetY = offsetY||0;
		
			/** The blur of the shadow.
			 * @property blur
			 * @type Number
			 * @default 0
			 */
			this.blur = blur||0;
		}
		var p = Shadow.prototype;
	
	// static public properties:
		/**
		 * An identity shadow object (all properties are set to 0).
		 * @property identity
		 * @type Shadow
		 * @static
		 * @final
		 * @readonly
		 **/
		Shadow.identity = new Shadow("transparent", 0, 0, 0);
	
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Shadow]";
		};
	
		/**
		 * Returns a clone of this Shadow instance.
		 * @method clone
		 * @return {Shadow} A clone of the current Shadow instance.
		 **/
		p.clone = function() {
			return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
		};
		
	
		createjs.Shadow = Shadow;
	}());
	
	//##############################################################################
	// SpriteSheet.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually
		 * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100
		 * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).
		 *
		 * The data passed to the SpriteSheet constructor defines:
		 * <ol>
		 * 	<li> The source image or images to use.</li>
		 * 	<li> The positions of individual image frames.</li>
		 * 	<li> Sequences of frames that form named animations. Optional.</li>
		 * 	<li> The target playback framerate. Optional.</li>
		 * </ol>
		 * <h3>SpriteSheet Format</h3>
		 * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties
		 * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.
		 *
		 * <h4>images</h4>
		 * An array of source images. Images can be either an HTMlimage
		 * instance, or a uri to an image. The former is recommended to control preloading.
		 *
		 * 	images: [image1, "path/to/image2.png"],
		 *
		 * <h4>frames</h4>
		 * Defines the individual frames. There are two supported formats for frame data:
		 * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,
		 * and `count` properties.
		 *
		 * <ul>
		 *  <li>`width` & `height` are required and specify the dimensions of the frames</li>
		 *  <li>`regX` & `regY` indicate the registration point or "origin" of the frames</li>
		 *  <li>`spacing` indicate the spacing between frames</li>
		 *  <li>`margin` specify the margin around the image(s)</li>
		 *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will
		 *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned
		 *  indexes based on their position in the source images (left to right, top to bottom).</li>
		 * </ul>
		 *
		 *  	frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
		 *
		 * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array
		 * with 4 required and 3 optional entries, in the order:
		 *
		 * <ul>
		 *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>
		 *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>
		 *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>
		 * </ul>
		 *
		 * 	frames: [
		 * 		// x, y, width, height, imageIndex*, regX*, regY*
		 * 		[64, 0, 96, 64],
		 * 		[0, 0, 64, 64, 1, 32, 32]
		 * 		// etc.
		 * 	]
		 *
		 * <h4>animations</h4>
		 * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an
		 * animation of the same name. Each animation must specify the frames to play, and may
		 * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and
		 * the name of the `next` animation to sequence to after it completes.
		 *
		 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:
		 * <ol>
		 * 	<li>for a single frame animation, you can simply specify the frame index
		 *
		 * 		animations: {
		 * 			sit: 7
		 * 		}
		 *
		 * </li>
		 * <li>
		 *      for an animation of consecutive frames, you can use an array with two required, and two optional entries
		 * 		in the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.
		 *
		 * 		animations: {
		 * 			// start, end, next*, speed*
		 * 			run: [0, 8],
		 * 			jump: [9, 12, "run", 2]
		 * 		}
		 *
		 *  </li>
		 *  <li>
		 *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame
		 *     indexes to play in order. The object can also specify `next` and `speed` properties.
		 *
		 * 		animations: {
		 * 			walk: {
		 * 				frames: [1,2,3,3,2,1]
		 * 			},
		 * 			shoot: {
		 * 				frames: [1,4,5,6],
		 * 				next: "walk",
		 * 				speed: 0.5
		 * 			}
		 * 		}
		 *
		 *  </li>
		 * </ol>
		 * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`
		 * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in
		 * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.
		 *
		 * <h4>framerate</h4>
		 * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See
		 * {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.
		 *
		 * 		framerate: 20
		 *
		 * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event generated by the {{#crossLink "Ticker"}}{{/crossLink}}.
		 *
		 * 		createjs.Ticker.on("tick", handleTick);
		 * 		function handleTick(event) {
		 *			stage.update(event);
		 *		}
		 *
		 * <h3>Example</h3>
		 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three
		 * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing frame 6-8 and
		 * sequencing back to run.
		 *
		 * 		var data = {
		 * 			images: ["sprites.jpg"],
		 * 			frames: {width:50, height:50},
		 * 			animations: {
		 * 				stand:0,
		 * 				run:[1,5],
		 * 				jump:[6,8,"run"]
		 * 			}
		 * 		};
		 * 		var spriteSheet = new createjs.SpriteSheet(data);
		 * 		var animation = new createjs.Sprite(spriteSheet, "run");
		 *
		 * <h3>Generating SpriteSheet Images</h3>
		 * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or
		 * coordinates manually, however there are a number of tools that facilitate this.
		 * <ul>
		 *     <li>Exporting SpriteSheets or HTML5 content from Adobe Flash/Animate supports the EaselJS SpriteSheet format.</li>
		 *     <li>The popular <a href="https://www.codeandweb.com/texturepacker/easeljs" target="_blank">Texture Packer</a> has
		 *     EaselJS support.
		 *     <li>SWF animations in Adobe Flash/Animate can be exported to SpriteSheets using <a href="http://createjs.com/zoe" target="_blank">Zo&euml;</a></li>
		 * </ul>
		 *
		 * <h3>Cross Origin Issues</h3>
		 * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with
		 * using:
		 * <ul>
		 *     <li>a mouse</li>
		 *     <li>methods such as {{#crossLink "Container/getObjectUnderPoint"}}{{/crossLink}}</li>
		 *     <li>Filters (see {{#crossLink "Filter"}}{{/crossLink}})</li>
		 *     <li>caching (see {{#crossLink "DisplayObject/cache"}}{{/crossLink}})</li>
		 * </ul>
		 * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or
		 * setting the `crossOrigin` property on PreloadJS' LoadQueue or LoadItems.
		 *
		 * 		var image = new Image();
		 * 		img.crossOrigin="Anonymous";
		 * 		img.src = "http://server-with-CORS-support.com/path/to/image.jpg";
		 *
		 * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must
		 * support cross-origin requests, or this will not work. For more information, check out
		 * <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">CORS overview on MDN</a>.
		 *
		 * @class SpriteSheet
		 * @constructor
		 * @param {Object} data An object describing the SpriteSheet data.
		 * @extends EventDispatcher
		 **/
		function SpriteSheet(data) {
			this.EventDispatcher_constructor();
	
	
			// public properties:
			/**
			 * Indicates whether all images are finished loading.
			 * @property complete
			 * @type Boolean
			 * @readonly
			 **/
			this.complete = true;
	
			/**
			 * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class
			 * {{#crossLink "Sprite/framerate:property"}}{{/crossLink}} for more information.
			 * @property framerate
			 * @type Number
			 **/
			this.framerate = 0;
	
	
			// private properties:
			/**
			 * @property _animations
			 * @protected
			 * @type Array
			 **/
			this._animations = null;
	
			/**
			 * @property _frames
			 * @protected
			 * @type Array
			 **/
			this._frames = null;
	
			/**
			 * @property _images
			 * @protected
			 * @type Array
			 **/
			this._images = null;
	
			/**
			 * @property _data
			 * @protected
			 * @type Object
			 **/
			this._data = null;
	
			/**
			 * @property _loadCount
			 * @protected
			 * @type Number
			 **/
			this._loadCount = 0;
	
			// only used for simple frame defs:
			/**
			 * @property _frameHeight
			 * @protected
			 * @type Number
			 **/
			this._frameHeight = 0;
	
			/**
			 * @property _frameWidth
			 * @protected
			 * @type Number
			 **/
			this._frameWidth = 0;
	
			/**
			 * @property _numFrames
			 * @protected
			 * @type Number
			 **/
			this._numFrames = 0;
	
			/**
			 * @property _regX
			 * @protected
			 * @type Number
			 **/
			this._regX = 0;
	
			/**
			 * @property _regY
			 * @protected
			 * @type Number
			 **/
			this._regY = 0;
	
			/**
			 * @property _spacing
			 * @protected
			 * @type Number
			 **/
			this._spacing = 0;
	
			/**
			 * @property _margin
			 * @protected
			 * @type Number
			 **/
			this._margin = 0;
	
			// setup:
			this._parseData(data);
		}
		var p = createjs.extend(SpriteSheet, createjs.EventDispatcher);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// events:
		/**
		 * Dispatched when all images are loaded.  Note that this only fires if the images
		 * were not fully loaded when the sprite sheet was initialized. You should check the complete property
		 * to prior to adding a listener. Ex.
		 *
		 * 	var sheet = new createjs.SpriteSheet(data);
		 * 	if (!sheet.complete) {
		 * 		// not preloaded, listen for the complete event:
		 * 		sheet.addEventListener("complete", handler);
		 * 	}
		 *
		 * @event complete
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}
		 * when doing on-demand rendering.
		 * @event getframe
		 * @param {Number} index The frame index.
		 * @param {Object} frame The frame object that getFrame will return.
		 */
	
		/**
		 * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that
		 * encounters an error, and will still dispatch a {{#crossLink "SpriteSheet/complete:event"}}{{/crossLink}}
		 * event once all images are finished processing, even if an error is encountered.
		 * @event error
		 * @param {String} src The source of the image that failed to load.
		 * @since 0.8.2
		 */
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.
		 * @method _getAnimations
		 * @protected
		 * @return {Array}
		 **/
		p._getAnimations = function() {
			return this._animations.slice();
		};
		// SpriteSheet.getAnimations is @deprecated. Remove for 1.1+
		p.getAnimations = createjs.deprecate(p._getAnimations, "SpriteSheet.getAnimations");
	
		/**
		 * Returns an array of all available animation names available on this sprite sheet as strings.
		 * @property animations
		 * @type {Array}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				animations: { get: p._getAnimations }
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns the total number of frames in the specified animation, or in the whole sprite
		 * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and
		 * the images have not been fully loaded.
		 * @method getNumFrames
		 * @param {String} animation The name of the animation to get a frame count for.
		 * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.
		 */
		p.getNumFrames = function(animation) {
			if (animation == null) {
				return this._frames ? this._frames.length : this._numFrames || 0;
			} else {
				var data = this._data[animation];
				if (data == null) { return 0; }
				else { return data.frames.length; }
			}
		};
	
		/**
		 * Returns an object defining the specified animation. The returned object contains:<UL>
		 * 	<li>frames: an array of the frame ids in the animation</li>
		 * 	<li>speed: the playback speed for this animation</li>
		 * 	<li>name: the name of the animation</li>
		 * 	<li>next: the default animation to play next. If the animation loops, the name and next property will be the
		 * 	same.</li>
		 * </UL>
		 * @method getAnimation
		 * @param {String} name The name of the animation to get.
		 * @return {Object} a generic object with frames, speed, name, and next properties.
		 **/
		p.getAnimation = function(name) {
			return this._data[name];
		};
	
		/**
		 * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>
		 * 	<li>an image property holding a reference to the image object in which the frame is found</li>
		 * 	<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that
		 * 	image.</li>
		 * 	<li> A regX and regY property corresponding to the regX/Y values for the frame.
		 * </UL>
		 * @method getFrame
		 * @param {Number} frameIndex The index of the frame.
		 * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.
		 **/
		p.getFrame = function(frameIndex) {
			var frame;
			if (this._frames && (frame=this._frames[frameIndex])) { return frame; }
			return null;
		};
	
		/**
		 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative
		 * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:
		 *
		 * 	[x=-50, y=-40, width=90, height=70]
		 *
		 * @method getFrameBounds
		 * @param {Number} frameIndex The index of the frame.
		 * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.
		 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.
		 **/
		p.getFrameBounds = function(frameIndex, rectangle) {
			var frame = this.getFrame(frameIndex);
			return frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[SpriteSheet]";
		};
	
		/**
		 * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.
		 * @method clone
		 **/
		p.clone = function() {
			throw("SpriteSheet cannot be cloned.")
		};
	
	// private methods:
		/**
		 * @method _parseData
		 * @param {Object} data An object describing the SpriteSheet data.
		 * @protected
		 **/
		p._parseData = function(data) {
			var i,l,o,a;
			if (data == null) { return; }
	
			this.framerate = data.framerate||0;
	
			// parse images:
			if (data.images && (l=data.images.length) > 0) {
				a = this._images = [];
				for (i=0; i<l; i++) {
					var img = data.images[i];
					if (typeof img == "string") {
						var src = img;
						img = document.createElement("img");
						img.src = src;
					}
					a.push(img);
					if (!img.getContext && !img.naturalWidth) {
						this._loadCount++;
						this.complete = false;
						(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);
						(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);
					}
				}
			}
	
			// parse frames:
			if (data.frames == null) { // nothing
			} else if (Array.isArray(data.frames)) {
				this._frames = [];
				a = data.frames;
				for (i=0,l=a.length;i<l;i++) {
					var arr = a[i];
					this._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });
				}
			} else {
				o = data.frames;
				this._frameWidth = o.width;
				this._frameHeight = o.height;
				this._regX = o.regX||0;
				this._regY = o.regY||0;
				this._spacing = o.spacing||0;
				this._margin = o.margin||0;
				this._numFrames = o.count;
				if (this._loadCount == 0) { this._calculateFrames(); }
			}
	
			// parse animations:
			this._animations = [];
			if ((o=data.animations) != null) {
				this._data = {};
				var name;
				for (name in o) {
					var anim = {name:name};
					var obj = o[name];
					if (typeof obj == "number") { // single frame
						a = anim.frames = [obj];
					} else if (Array.isArray(obj)) { // simple
						if (obj.length == 1) { anim.frames = [obj[0]]; }
						else {
							anim.speed = obj[3];
							anim.next = obj[2];
							a = anim.frames = [];
							for (i=obj[0];i<=obj[1];i++) {
								a.push(i);
							}
						}
					} else { // complex
						anim.speed = obj.speed;
						anim.next = obj.next;
						var frames = obj.frames;
						a = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);
					}
					if (anim.next === true || anim.next === undefined) { anim.next = name; } // loop
					if (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop
					if (!anim.speed) { anim.speed = 1; }
					this._animations.push(name);
					this._data[name] = anim;
				}
			}
		};
	
		/**
		 * @method _handleImageLoad
		 * @protected
		 **/
		p._handleImageLoad = function(src) {
			if (--this._loadCount == 0) {
				this._calculateFrames();
				this.complete = true;
				this.dispatchEvent("complete");
			}
		};
	
		/**
		 * @method _handleImageError
		 * @protected
		 */
		p._handleImageError = function (src) {
			var errorEvent = new createjs.Event("error");
			errorEvent.src = src;
			this.dispatchEvent(errorEvent);
	
			// Complete is still dispatched.
			if (--this._loadCount == 0) {
				this.dispatchEvent("complete");
			}
		};
	
		/**
		 * @method _calculateFrames
		 * @protected
		 **/
		p._calculateFrames = function() {
			if (this._frames || this._frameWidth == 0) { return; }
	
			this._frames = [];
	
			var maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.
			var frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;
			var spacing = this._spacing, margin = this._margin;
			
			imgLoop:
			for (var i=0, imgs=this._images; i<imgs.length; i++) {
				var img = imgs[i], imgW = (img.width||img.naturalWidth), imgH = (img.height||img.naturalHeight);
	
				var y = margin;
				while (y <= imgH-margin-frameHeight) {
					var x = margin;
					while (x <= imgW-margin-frameWidth) {
						if (frameCount >= maxFrames) { break imgLoop; }
						frameCount++;
						this._frames.push({
								image: img,
								rect: new createjs.Rectangle(x, y, frameWidth, frameHeight),
								regX: this._regX,
								regY: this._regY
							});
						x += frameWidth+spacing;
					}
					y += frameHeight+spacing;
				}
			}
			this._numFrames = frameCount;
		};
	
	
		createjs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");
	}());
	
	//##############################################################################
	// Graphics.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
		 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}
		 * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the
		 * context of an EaselJS display list.
		 *
		 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
		 * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.
		 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
		 *
		 *      var g = new createjs.Graphics();
		 *      g.setStrokeStyle(1);
		 *      g.beginStroke("#000000");
		 *      g.beginFill("red");
		 *      g.drawCircle(0,0,30);
		 *
		 * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,
		 * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:
		 *
		 *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
		 *
		 * Each graphics API call generates a command object (see below). The last command to be created can be accessed via
		 * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:
		 *
		 *      var fillCommand = myGraphics.beginFill("red").command;
		 *      // ... later, update the fill style/color:
		 *      fillCommand.style = "blue";
		 *      // or change it to a bitmap fill:
		 *      fillCommand.bitmap(myImage);
		 *
		 * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you
		 * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
		 *
		 *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
		 *      myGraphics.append(createjs.Graphics.beginCmd);
		 *      // we need to define the path before applying the fill:
		 *      var circle = new createjs.Graphics.Circle(0,0,30);
		 *      myGraphics.append(circle);
		 *      // fill the path we just defined:
		 *      var fill = new createjs.Graphics.Fill("red");
		 *      myGraphics.append(fill);
		 *
		 * These approaches can be used together, for example to insert a custom command:
		 *
		 *      myGraphics.beginFill("red");
		 *      var customCommand = new CustomSpiralCommand(etc);
		 *      myGraphics.append(customCommand);
		 *      myGraphics.beginFill("blue");
		 *      myGraphics.drawCircle(0, 0, 30);
		 *
		 * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.
		 *
		 * <h4>Tiny API</h4>
		 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
		 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
		 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
		 * descriptions in the docs.
		 *
		 * <table>
		 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
		 *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>
		 *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>
		 *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>
		 *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>
		 *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>
		 *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>
		 *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>
		 *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>
		 *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>
		 *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>
		 *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>
		 *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>
		 *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>
		 *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>
		 *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>
		 *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>
		 *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>
		 *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>
		 *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>
		 *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>
		 *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>
		 *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>
		 *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>
		 * </table>
		 *
		 * Here is the above example, using the tiny API instead.
		 *
		 *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);
		 *
		 * @class Graphics
		 * @constructor
		 **/
		function Graphics() {
	
	
		// public properties
			/**
			 * Holds a reference to the last command that was created or appended. For example, you could retain a reference
			 * to a Fill command in order to dynamically update the color later by using:
			 *
			 * 		var myFill = myGraphics.beginFill("red").command;
			 * 		// update color later:
			 * 		myFill.style = "yellow";
			 *
			 * @property command
			 * @type Object
			 **/
			this.command = null;
	
	
		// private properties
			/**
			 * @property _stroke
			 * @protected
			 * @type {Stroke}
			 **/
			this._stroke = null;
	
			/**
			 * @property _strokeStyle
			 * @protected
			 * @type {StrokeStyle}
			 **/
			this._strokeStyle = null;
			
			/**
			 * @property _oldStrokeStyle
			 * @protected
			 * @type {StrokeStyle}
			 **/
			this._oldStrokeStyle = null;
			
			/**
			 * @property _strokeDash
			 * @protected
			 * @type {StrokeDash}
			 **/
			this._strokeDash = null;
			
			/**
			 * @property _oldStrokeDash
			 * @protected
			 * @type {StrokeDash}
			 **/
			this._oldStrokeDash = null;
	
			/**
			 * @property _strokeIgnoreScale
			 * @protected
			 * @type Boolean
			 **/
			this._strokeIgnoreScale = false;
	
			/**
			 * @property _fill
			 * @protected
			 * @type {Fill}
			 **/
			this._fill = null;
	
			/**
			 * @property _instructions
			 * @protected
			 * @type {Array}
			 **/
			this._instructions = [];
	
			/**
			 * Indicates the last instruction index that was committed.
			 * @property _commitIndex
			 * @protected
			 * @type {Number}
			 **/
			this._commitIndex = 0;
	
			/**
			 * Uncommitted instructions.
			 * @property _activeInstructions
			 * @protected
			 * @type {Array}
			 **/
			this._activeInstructions = [];
	
			/**
			 * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
			 * @property _dirty
			 * @protected
			 * @type {Boolean}
			 * @default false
			 **/
			this._dirty = false;
	
			/**
			 * Index to draw from if a store operation has happened.
			 * @property _storeIndex
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._storeIndex = 0;
	
		// setup:
			this.clear();
		}
		var p = Graphics.prototype;
		var G = Graphics; // shortcut
	
	// static public methods:
		/**
		 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
		 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,
		 *
		 *      createjs.Graphics.getRGB(50, 100, 150, 0.5);
		 *      // Returns "rgba(50,100,150,0.5)"
		 *
		 * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
		 * param. For example,
		 *
		 *      createjs.Graphics.getRGB(0xFF00FF, 0.2);
		 *      // Returns "rgba(255,0,255,0.2)"
		 *
		 * @method getRGB
		 * @static
		 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
		 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
		 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
		 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
		 * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
		 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
		 **/
		Graphics.getRGB = function(r, g, b, alpha) {
			if (r != null && b == null) {
				alpha = g;
				b = r&0xFF;
				g = r>>8&0xFF;
				r = r>>16&0xFF;
			}
			if (alpha == null) {
				return "rgb("+r+","+g+","+b+")";
			} else {
				return "rgba("+r+","+g+","+b+","+alpha+")";
			}
		};
	
		/**
		 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
		 * or if alpha is null then in the format "hsl(360,100,100)".
		 *
		 *      createjs.Graphics.getHSL(150, 100, 70);
		 *      // Returns "hsl(150,100,70)"
		 *
		 * @method getHSL
		 * @static
		 * @param {Number} hue The hue component for the color, between 0 and 360.
		 * @param {Number} saturation The saturation component for the color, between 0 and 100.
		 * @param {Number} lightness The lightness component for the color, between 0 and 100.
		 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
		 * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
		 * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
		 **/
		Graphics.getHSL = function(hue, saturation, lightness, alpha) {
			if (alpha == null) {
				return "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";
			} else {
				return "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";
			}
		};
	
	
	// static properties:
		/**
		 * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid
		 * unnecessary instantiation.
		 * @property beginCmd
		 * @type {Graphics.BeginPath}
		 * @static
		 **/
		 // defined at the bottom of this file.
	
		/**
		 * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.
		 * @property BASE_64
		 * @static
		 * @final
		 * @readonly
		 * @type {Object}
		 **/
		Graphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};
	
		/**
		 * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
		 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
		 * "butt", 1 to "round", and 2 to "square".
		 * For example, to set the line caps to "square":
		 *
		 *      myGraphics.ss(16, 2);
		 *
		 * @property STROKE_CAPS_MAP
		 * @static
		 * @final
		 * @readonly
		 * @type {Array}
		 **/
		Graphics.STROKE_CAPS_MAP = ["butt", "round", "square"];
	
		/**
		 * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
		 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
		 * "miter", 1 to "round", and 2 to "bevel".
		 * For example, to set the line joints to "bevel":
		 *
		 *      myGraphics.ss(16, 0, 2);
		 *
		 * @property STROKE_JOINTS_MAP
		 * @static
		 * @final
		 * @readonly
		 * @type {Array}
		 **/
		Graphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];
	
		/**
		 * @property _ctx
		 * @static
		 * @protected
		 * @type {CanvasRenderingContext2D}
		 **/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) {
			Graphics._ctx = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.
		 * @method _getInstructions
		 * @protected
		 * @return {Array} The instructions array, useful for chaining
		 **/
		p._getInstructions = function() {
			this._updateInstructions();
			return this._instructions;
		};
		// Graphics.getInstructions is @deprecated. Remove for 1.1+
		p.getInstructions = createjs.deprecate(p._getInstructions, "Graphics.getInstructions");
	
		/**
		 * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
		 * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
		 *
		 * This property is mainly intended for introspection of the instructions (ex. for graphics export).
		 * @property instructions
		 * @type {Array}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				instructions: { get: p._getInstructions }
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns true if this Graphics instance has no drawing commands.
		 * @method isEmpty
		 * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
		 **/
		p.isEmpty = function() {
			return !(this._instructions.length || this._activeInstructions.length);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
		 **/
		p.draw = function(ctx, data) {
			this._updateInstructions();
			var instr = this._instructions;
			for (var i=this._storeIndex, l=instr.length; i<l; i++) {
				instr[i].exec(ctx, data);
			}
		};
	
		/**
		 * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
		 * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method drawAsPath
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 **/
		p.drawAsPath = function(ctx) {
			this._updateInstructions();
			var instr, instrs = this._instructions;
			for (var i=this._storeIndex, l=instrs.length; i<l; i++) {
				// the first command is always a beginPath command.
				if ((instr = instrs[i]).path !== false) { instr.exec(ctx); }
			}
		};
	
	
	// public methods that map directly to context 2D calls:
		/**
		 * Moves the drawing point to the specified position. A tiny API method "mt" also exists.
		 * @method moveTo
		 * @param {Number} x The x coordinate the drawing point should move to.
		 * @param {Number} y The y coordinate the drawing point should move to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
		 * @chainable
		 **/
		p.moveTo = function(x, y) {
			return this.append(new G.MoveTo(x,y), true);
		};
	
		/**
		 * Draws a line from the current drawing point to the specified position, which become the new current drawing
		 * point. Note that you *must* call {{#crossLink "Graphics/moveTo"}}{{/crossLink}} before the first `lineTo()`.
		 * A tiny API method "lt" also exists.
		 *
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">
		 * whatwg spec</a>.
		 * @method lineTo
		 * @param {Number} x The x coordinate the drawing point should draw to.
		 * @param {Number} y The y coordinate the drawing point should draw to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.lineTo = function(x, y) {
			return this.append(new G.LineTo(x,y));
		};
	
		/**
		 * Draws an arc with the specified control points and radius.  For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">
		 * whatwg spec</a>. A tiny API method "at" also exists.
		 * @method arcTo
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.arcTo = function(x1, y1, x2, y2, radius) {
			return this.append(new G.ArcTo(x1, y1, x2, y2, radius));
		};
	
		/**
		 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For
		 * example, to draw a full circle with a radius of 20 centered at (100, 100):
		 *
		 *      arc(100, 100, 20, 0, Math.PI*2);
		 *
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.
		 * A tiny API method "a" also exists.
		 * @method arc
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle Measured in radians.
		 * @param {Number} endAngle Measured in radians.
		 * @param {Boolean} anticlockwise
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
			return this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));
		};
	
		/**
		 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed
		 * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">
		 * whatwg spec</a>. A tiny API method "qt" also exists.
		 * @method quadraticCurveTo
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.quadraticCurveTo = function(cpx, cpy, x, y) {
			return this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));
		};
	
		/**
		 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,
		 * cp2y). For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">
		 * whatwg spec</a>. A tiny API method "bt" also exists.
		 * @method bezierCurveTo
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
			return this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
		};
	
		/**
		 * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">
		 * whatwg spec</a>. A tiny API method "r" also exists.
		 * @method rect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.rect = function(x, y, w, h) {
			return this.append(new G.Rect(x, y, w, h));
		};
	
		/**
		 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
		 * since the fill or stroke was last set. A tiny API method "cp" also exists.
		 * @method closePath
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.closePath = function() {
			return this._activeInstructions.length ? this.append(new G.ClosePath()) : this;
		};
	
	
	// public methods that roughly map to Adobe Flash/Animate graphics APIs:
		/**
		 * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
		 * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.
		 * @method clear
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.clear = function() {
			this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
			this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
			this._dirty = this._strokeIgnoreScale = false;
			return this;
		};
	
		/**
		 * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.
		 * @method beginFill
		 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no fill.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginFill = function(color) {
			return this._setFill(color ? new G.Fill(color) : null);
		};
	
		/**
		 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
		 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
		 * square to display it:
		 *
		 *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
		 *
		 * A tiny API method "lf" also exists.
		 * @method beginLinearGradientFill
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
		 * drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
		 * the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
			return this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
		};
	
		/**
		 * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to
		 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:
		 *
		 *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
		 *
		 * A tiny API method "rf" also exists.
		 * @method beginRadialGradientFill
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			return this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
		};
	
		/**
		 * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also
		 * exists.
		 * @method beginBitmapFill
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
		 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
		 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
		 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
		 * will be applied relative to the parent transform.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginBitmapFill = function(image, repetition, matrix) {
			return this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));
		};
	
		/**
		 * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.
		 * A tiny API method "ef" also exists.
		 * @method endFill
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.endFill = function() {
			return this.beginFill();
		};
	
		/**
		 * Sets the stroke style. Like all drawing methods, this can be chained, so you can define
		 * the stroke style and color in a single line of code like so:
		 *
		 * 	myGraphics.setStrokeStyle(8,"round").beginStroke("#F00");
		 *
		 * A tiny API method "ss" also exists.
		 * @method setStrokeStyle
		 * @param {Number} thickness The width of the stroke.
		 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
		 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
		 * the tiny API.
		 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
		 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
		 * for use with the tiny API.
		 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
		 * controls at what point a mitered joint will be clipped.
		 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
		 * of active transformations.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {
			this._updateInstructions(true);
			this._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);
	
			// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
			if (this._stroke) { this._stroke.ignoreScale = ignoreScale; }
			this._strokeIgnoreScale = ignoreScale;
			return this;
		};
		
		/**
		 * Sets or clears the stroke dash pattern.
		 *
		 * 	myGraphics.setStrokeDash([20, 10], 0);
		 *
		 * A tiny API method `sd` also exists.
		 * @method setStrokeDash
		 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
		 * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
		 * Passing null or an empty array will clear the existing stroke dash.
		 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.setStrokeDash = function(segments, offset) {
			this._updateInstructions(true);
			this._strokeDash = this.command = new G.StrokeDash(segments, offset);
			return this;
		};
	
		/**
		 * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.
		 * @method beginStroke
		 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no stroke.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginStroke = function(color) {
			return this._setStroke(color ? new G.Stroke(color) : null);
		};
	
		/**
		 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
		 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
		 * square to display it:
		 *
		 *      myGraphics.setStrokeStyle(10).
		 *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
		 *
		 * A tiny API method "ls" also exists.
		 * @method beginLinearGradientStroke
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
			return this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
		};
	
		/**
		 * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to
		 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:
		 *
		 *      myGraphics.setStrokeStyle(10)
		 *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
		 *          .drawRect(50, 90, 150, 110);
		 *
		 * A tiny API method "rs" also exists.
		 * @method beginRadialGradientStroke
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
		 * to 100%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			return this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
		};
	
		/**
		 * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
		 * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"
		 * also exists.
		 * @method beginBitmapStroke
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
		 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginBitmapStroke = function(image, repetition) {
			// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
			return this._setStroke(new G.Stroke().bitmap(image, repetition));
		};
	
		/**
		 * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.
		 * A tiny API method "es" also exists.
		 * @method endStroke
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.endStroke = function() {
			return this.beginStroke();
		};
	
		/**
		 * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}
		 * method.
		 * @method curveTo
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.curveTo = p.quadraticCurveTo;
	
		/**
		 *
		 * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}
		 * method.
		 * @method drawRect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRect = p.rect;
	
		/**
		 * Draws a rounded rectangle with all corners with the specified radius.
		 * @method drawRoundRect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radius Corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRoundRect = function(x, y, w, h, radius) {
			return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
		};
	
		/**
		 * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API
		 * method "rc" also exists.
		 * @method drawRoundRectComplex
		 * @param {Number} x The horizontal coordinate to draw the round rect.
		 * @param {Number} y The vertical coordinate to draw the round rect.
		 * @param {Number} w The width of the round rect.
		 * @param {Number} h The height of the round rect.
		 * @param {Number} radiusTL Top left corner radius.
		 * @param {Number} radiusTR Top right corner radius.
		 * @param {Number} radiusBR Bottom right corner radius.
		 * @param {Number} radiusBL Bottom left corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
			return this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
		};
	
		/**
		 * Draws a circle with the specified radius at (x, y).
		 *
		 *      var g = new createjs.Graphics();
		 *	    g.setStrokeStyle(1);
		 *	    g.beginStroke(createjs.Graphics.getRGB(0,0,0));
		 *	    g.beginFill(createjs.Graphics.getRGB(255,0,0));
		 *	    g.drawCircle(0,0,3);
		 *
		 *	    var s = new createjs.Shape(g);
		 *		s.x = 100;
		 *		s.y = 100;
		 *
		 *	    stage.addChild(s);
		 *	    stage.update();
		 *
		 * A tiny API method "dc" also exists.
		 * @method drawCircle
		 * @param {Number} x x coordinate center point of circle.
		 * @param {Number} y y coordinate center point of circle.
		 * @param {Number} radius Radius of circle.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawCircle = function(x, y, radius) {
			return this.append(new G.Circle(x, y, radius));
		};
	
		/**
		 * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},
		 * except the width and height can be different. A tiny API method "de" also exists.
		 * @method drawEllipse
		 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from center.
		 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from the center.
		 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
		 * number.
		 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawEllipse = function(x, y, w, h) {
			return this.append(new G.Ellipse(x, y, w, h));
		};
	
		/**
		 * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of
		 * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a
		 * radius of 50:
		 *
		 *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
		 *      // Note: -90 makes the first point vertical
		 *
		 * A tiny API method "dp" also exists.
		 *
		 * @method drawPolyStar
		 * @param {Number} x Position of the center of the shape.
		 * @param {Number} y Position of the center of the shape.
		 * @param {Number} radius The outer radius of the shape.
		 * @param {Number} sides The number of points on the star or sides on the polygon.
		 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
		 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
		 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
		 * directly to the right of the center.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
			return this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));
		};
	
		/**
		 * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
		 * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
		 * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.
		 *
		 * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
		 * built-in or custom graphics commands. For example:
		 *
		 * 		// attach data to our shape, so we can access it during the draw:
		 * 		myShape.color = "red";
		 *
		 * 		// append a Circle command object:
		 * 		myShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));
		 *
		 * 		// append a custom command object with an exec method that sets the fill style
		 * 		// based on the shape's data, and then fills the circle.
		 * 		myShape.graphics.append({exec:function(ctx, shape) {
		 * 			ctx.fillStyle = shape.color;
		 * 			ctx.fill();
		 * 		}});
		 *
		 * @method append
		 * @param {Object} command A graphics command object exposing an "exec" method.
		 * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.append = function(command, clean) {
			this._activeInstructions.push(command);
			this.command = command;
			if (!clean) { this._dirty = true; }
			return this;
		};
	
		/**
		 * Decodes a compact encoded path string into a series of draw instructions.
		 * This format is not intended to be human readable, and is meant for use by authoring tools.
		 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
		 * commands.
		 *
		 * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
		 * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
		 * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
		 * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
		 * latter. Bits 5 and 6 are currently unused.
		 *
		 * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
		 * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
		 * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
		 * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
		 * case of move operations which are absolute, this value is a delta from the previous x or y position (as
		 * appropriate).
		 *
		 * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
		 * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
		 * parameter.
		 * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
		 * indicate 1500 tenths of a pixel.
		 * <br />AA - 000000000000. Absolute y position of 0.
		 * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
		 * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
		 * provide an absolute position of +150.0px.
		 * <br />AAA - 000000000000000000. A y delta value of 0.
		 *
		 * A tiny API method "p" also exists.
		 * @method decodePath
		 * @param {String} str The path string to decode.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.decodePath = function(str) {
			var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
			var paramCount = [2, 2, 4, 6, 0];
			var i=0, l=str.length;
			var params = [];
			var x=0, y=0;
			var base64 = Graphics.BASE_64;
	
			while (i<l) {
				var c = str.charAt(i);
				var n = base64[c];
				var fi = n>>3; // highest order bits 1-3 code for operation.
				var f = instructions[fi];
				// check that we have a valid instruction & that the unused bits are empty:
				if (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }
				var pl = paramCount[fi];
				if (!fi) { x=y=0; } // move operations reset the position.
				params.length = 0;
				i++;
				var charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.
				for (var p=0; p<pl; p++) {
					var num = base64[str.charAt(i)];
					var sign = (num>>5) ? -1 : 1;
					num = ((num&31)<<6)|(base64[str.charAt(i+1)]);
					if (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }
					num = sign*num/10;
					if (p%2) { x = (num += x); }
					else { y = (num += y); }
					params[p] = num;
					i += charCount;
				}
				f.apply(this,params);
			}
			return this;
		};
	
		/**
		 * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
		 * the existing store. This also affects `drawAsPath()`.
		 *
		 * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
		 * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
		 * of the vector instructions for later use (ex. scaling, modifying, or exporting).
		 *
		 * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
		 * the fill or stroke.
		 *
		 * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
		 * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},
		 * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.
		 *
		 * 	// set up cache:
		 * 	myShape.cache(0,0,500,500,scale);
		 *
		 * 	// when the user drags, draw a new line:
		 * 	myShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
		 * 	// then draw it into the existing cache:
		 * 	myShape.updateCache("source-over");
		 * 	// store the new line, so it isn't redrawn next time:
		 * 	myShape.store();
		 *
		 * 	// then, when the window resizes, we can re-render at a different scale:
		 * 	// first, unstore all our lines:
		 * 	myShape.unstore();
		 * 	// then cache using the new scale:
		 * 	myShape.cache(0,0,500,500,newScale);
		 * 	// finally, store the existing commands again:
		 * 	myShape.store();
		 *
		 * @method store
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.store = function() {
			this._updateInstructions(true);
			this._storeIndex = this._instructions.length;
			return this;
		};
	
		/**
		 * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}
		 * so that they will be executed in subsequent draw calls.
		 *
		 * @method unstore
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.unstore = function() {
			this._storeIndex = 0;
			return this;
		};
	
		/**
		 * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
		 * @method clone
		 * @return {Graphics} A clone of the current Graphics instance.
		 **/
		p.clone = function() {
			var o = new Graphics();
			o.command = this.command;
			o._stroke = this._stroke;
			o._strokeStyle = this._strokeStyle;
			o._strokeDash = this._strokeDash;
			o._strokeIgnoreScale = this._strokeIgnoreScale;
			o._fill = this._fill;
			o._instructions = this._instructions.slice();
			o._commitIndex = this._commitIndex;
			o._activeInstructions = this._activeInstructions.slice();
			o._dirty = this._dirty;
			o._storeIndex = this._storeIndex;
			return o;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Graphics]";
		};
	
	
	// tiny API:
		/**
		 * Shortcut to moveTo.
		 * @method mt
		 * @param {Number} x The x coordinate the drawing point should move to.
		 * @param {Number} y The y coordinate the drawing point should move to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
		 * @chainable
		 * @protected
		 **/
		p.mt = p.moveTo;
	
		/**
		 * Shortcut to lineTo.
		 * @method lt
		 * @param {Number} x The x coordinate the drawing point should draw to.
		 * @param {Number} y The y coordinate the drawing point should draw to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.lt = p.lineTo;
	
		/**
		 * Shortcut to arcTo.
		 * @method at
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.at = p.arcTo;
	
		/**
		 * Shortcut to bezierCurveTo.
		 * @method bt
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bt = p.bezierCurveTo;
	
		/**
		 * Shortcut to quadraticCurveTo / curveTo.
		 * @method qt
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 * @chainable
		 **/
		p.qt = p.quadraticCurveTo;
	
		/**
		 * Shortcut to arc.
		 * @method a
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle Measured in radians.
		 * @param {Number} endAngle Measured in radians.
		 * @param {Boolean} anticlockwise
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @protected
		 * @chainable
		 **/
		p.a = p.arc;
	
		/**
		 * Shortcut to rect.
		 * @method r
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.r = p.rect;
	
		/**
		 * Shortcut to closePath.
		 * @method cp
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.cp = p.closePath;
	
		/**
		 * Shortcut to clear.
		 * @method c
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.c = p.clear;
	
		/**
		 * Shortcut to beginFill.
		 * @method f
		 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no fill.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.f = p.beginFill;
	
		/**
		 * Shortcut to beginLinearGradientFill.
		 * @method lf
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
		 * drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
		 * the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.lf = p.beginLinearGradientFill;
	
		/**
		 * Shortcut to beginRadialGradientFill.
		 * @method rf
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rf = p.beginRadialGradientFill;
	
		/**
		 * Shortcut to beginBitmapFill.
		 * @method bf
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern.
		 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
		 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
		 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
		 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
		 * will be applied relative to the parent transform.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bf = p.beginBitmapFill;
	
		/**
		 * Shortcut to endFill.
		 * @method ef
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ef = p.endFill;
	
		/**
		 * Shortcut to setStrokeStyle.
		 * @method ss
		 * @param {Number} thickness The width of the stroke.
		 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
		 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
		 * the tiny API.
		 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
		 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
		 * for use with the tiny API.
		 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
		 * controls at what point a mitered joint will be clipped.
		 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
		 * of active transformations.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ss = p.setStrokeStyle;
		
		/**
		 * Shortcut to setStrokeDash.
		 * @method sd
		 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
		 * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.
		 * Passing null or an empty array will clear any existing dash.
		 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.sd = p.setStrokeDash;
	
		/**
		 * Shortcut to beginStroke.
		 * @method s
		 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no stroke.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.s = p.beginStroke;
	
		/**
		 * Shortcut to beginLinearGradientStroke.
		 * @method ls
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ls = p.beginLinearGradientStroke;
	
		/**
		 * Shortcut to beginRadialGradientStroke.
		 * @method rs
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
		 * to 100%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rs = p.beginRadialGradientStroke;
	
		/**
		 * Shortcut to beginBitmapStroke.
		 * @method bs
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern.
		 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
		 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bs = p.beginBitmapStroke;
	
		/**
		 * Shortcut to endStroke.
		 * @method es
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.es = p.endStroke;
	
		/**
		 * Shortcut to drawRect.
		 * @method dr
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dr = p.drawRect;
	
		/**
		 * Shortcut to drawRoundRect.
		 * @method rr
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radius Corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rr = p.drawRoundRect;
	
		/**
		 * Shortcut to drawRoundRectComplex.
		 * @method rc
		 * @param {Number} x The horizontal coordinate to draw the round rect.
		 * @param {Number} y The vertical coordinate to draw the round rect.
		 * @param {Number} w The width of the round rect.
		 * @param {Number} h The height of the round rect.
		 * @param {Number} radiusTL Top left corner radius.
		 * @param {Number} radiusTR Top right corner radius.
		 * @param {Number} radiusBR Bottom right corner radius.
		 * @param {Number} radiusBL Bottom left corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rc = p.drawRoundRectComplex;
	
		/**
		 * Shortcut to drawCircle.
		 * @method dc
		 * @param {Number} x x coordinate center point of circle.
		 * @param {Number} y y coordinate center point of circle.
		 * @param {Number} radius Radius of circle.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dc = p.drawCircle;
	
		/**
		 * Shortcut to drawEllipse.
		 * @method de
		 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from center.
		 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from the center.
		 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
		 * number.
		 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.de = p.drawEllipse;
	
		/**
		 * Shortcut to drawPolyStar.
		 * @method dp
		 * @param {Number} x Position of the center of the shape.
		 * @param {Number} y Position of the center of the shape.
		 * @param {Number} radius The outer radius of the shape.
		 * @param {Number} sides The number of points on the star or sides on the polygon.
		 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
		 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
		 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
		 * directly to the right of the center.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dp = p.drawPolyStar;
	
		/**
		 * Shortcut to decodePath.
		 * @method p
		 * @param {String} str The path string to decode.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.p = p.decodePath;
	
	
	// private methods:
		/**
		 * @method _updateInstructions
		 * @param commit
		 * @protected
		 **/
		p._updateInstructions = function(commit) {
			var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;
	
			if (this._dirty && active.length) {
				instr.length = commitIndex; // remove old, uncommitted commands
				instr.push(Graphics.beginCmd);
	
				var l = active.length, ll = instr.length;
				instr.length = ll+l;
				for (var i=0; i<l; i++) { instr[i+ll] = active[i]; }
	
				if (this._fill) { instr.push(this._fill); }
				if (this._stroke) {
					// doesn't need to be re-applied if it hasn't changed.
					if (this._strokeDash !== this._oldStrokeDash) {
						instr.push(this._strokeDash);
					}
					if (this._strokeStyle !== this._oldStrokeStyle) {
						instr.push(this._strokeStyle);
					}
					if (commit) {
						this._oldStrokeStyle = this._strokeStyle;
						this._oldStrokeDash = this._strokeDash;
					}
					instr.push(this._stroke);
				}
	
				this._dirty = false;
			}
	
			if (commit) {
				active.length = 0;
				this._commitIndex = instr.length;
			}
		};
	
		/**
		 * @method _setFill
		 * @param fill
		 * @protected
		 **/
		p._setFill = function(fill) {
			this._updateInstructions(true);
			this.command = this._fill = fill;
			return this;
		};
	
		/**
		 * @method _setStroke
		 * @param stroke
		 * @protected
		 **/
		p._setStroke = function(stroke) {
			this._updateInstructions(true);
			if (this.command = this._stroke = stroke) {
				stroke.ignoreScale = this._strokeIgnoreScale;
			}
			return this;
		};
	
	// Command Objects:
		/**
		 * @namespace Graphics
		 */
		/**
		 * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class LineTo
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.LineTo = function(x, y) {
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class MoveTo
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx
		 */
		(G.MoveTo = function(x, y) {
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };
	
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class ArcTo
		 * @constructor
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 **/
		/**
		 * @property x1
		 * @type Number
		 */
		/**
		 * @property y1
		 * @type Number
		 */
		/**
		 * @property x2
		 * @type Number
		 */
		/**
		 * @property y2
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.ArcTo = function(x1, y1, x2, y2, radius) {
			this.x1 = x1; this.y1 = y1;
			this.x2 = x2; this.y2 = y2;
			this.radius = radius;
		}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Arc
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle
		 * @param {Number} endAngle
		 * @param {Number} anticlockwise
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * @property startAngle
		 * @type Number
		 */
		/**
		 * @property endAngle
		 * @type Number
		 */
		/**
		 * @property anticlockwise
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
			this.x = x; this.y = y;
			this.radius = radius;
			this.startAngle = startAngle; this.endAngle = endAngle;
			this.anticlockwise = !!anticlockwise;
		}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class QuadraticCurveTo
		 * @constructor
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property cpx
		 * @type Number
		 */
		/**
		 * @property cpy
		 * @type Number
		 */
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.QuadraticCurveTo = function(cpx, cpy, x, y) {
			this.cpx = cpx; this.cpy = cpy;
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class BezierCurveTo
		 * @constructor
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property cp1x
		 * @type Number
		 */
		/**
		 * @property cp1y
		 * @type Number
		 */
		/**
		 * @property cp2x
		 * @type Number
		 */
		/**
		 * @property cp2y
		 * @type Number
		 */
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
			this.cp1x = cp1x; this.cp1y = cp1y;
			this.cp2x = cp2x; this.cp2y = cp2y;
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Rect
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Rect = function(x, y, w, h) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
		}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class ClosePath
		 * @constructor
		 **/
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.ClosePath = function() {
		}).prototype.exec = function(ctx) { ctx.closePath(); };
	
		/**
		 * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class BeginPath
		 * @constructor
		 **/
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.BeginPath = function() {
		}).prototype.exec = function(ctx) { ctx.beginPath(); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Fill
		 * @constructor
		 * @param {Object} style A valid Context2D fillStyle.
		 * @param {Matrix2D} matrix
		 **/
		/**
		 * A valid Context2D fillStyle.
		 * @property style
		 * @type Object
		 */
		/**
		 * @property matrix
		 * @type Matrix2D
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.Fill = function(style, matrix) {
			this.style = style;
			this.matrix = matrix;
		}).prototype;
		p.exec = function(ctx) {
			if (!this.style) { return; }
			ctx.fillStyle = this.style;
			var mtx = this.matrix;
			if (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }
			ctx.fill();
			if (mtx) { ctx.restore(); }
		};
		/**
		 * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.
		 * @method linearGradient
		 * @param {Array} colors
		 *
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.linearGradient = function(colors, ratios, x0, y0, x1, y1) {
			var o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
			for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
			o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};
			return this;
		};
		/**
		 * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.
		 * @method radialGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} r0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} r1
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			var o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
			for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
			o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};
			return this;
		};
		/**
		 * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.
		 * @method bitmap
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.bitmap = function(image, repetition) {
			if (image.naturalWidth || image.getContext || image.readyState >= 2) {
				var o = this.style = Graphics._ctx.createPattern(image, repetition || "");
				o.props = {image: image, repetition: repetition, type: "bitmap"};
			}
			return this;
		};
		p.path = false;
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Stroke
		 * @constructor
		 * @param {Object} style A valid Context2D fillStyle.
		 * @param {Boolean} ignoreScale
		 **/
		/**
		 * A valid Context2D strokeStyle.
		 * @property style
		 * @type Object
		 */
		/**
		 * @property ignoreScale
		 * @type Boolean
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.Stroke = function(style, ignoreScale) {
			this.style = style;
			this.ignoreScale = ignoreScale;
		}).prototype;
		p.exec = function(ctx) {
			if (!this.style) { return; }
			ctx.strokeStyle = this.style;
			if (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }
			ctx.stroke();
			if (this.ignoreScale) { ctx.restore(); }
		};
		/**
		 * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.
		 * @method linearGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.linearGradient = G.Fill.prototype.linearGradient;
		/**
		 * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.
		 * @method radialGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} r0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} r1
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.radialGradient = G.Fill.prototype.radialGradient;
		/**
		 * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.
		 * @method bitmap
		 * @param {HTMLImageElement} image
		 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.bitmap = G.Fill.prototype.bitmap;
		p.path = false;
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class StrokeStyle
		 * @constructor
		 * @param {Number} width
		 * @param {String} [caps=butt]
		 * @param {String} [joints=miter]
		 * @param {Number} [miterLimit=10]
		 * @param {Boolean} [ignoreScale=false]
		 **/
		/**
		 * @property width
		 * @type Number
		 */
		/**
		 * One of: butt, round, square
		 * @property caps
		 * @type String
		 */
		/**
		 * One of: round, bevel, miter
		 * @property joints
		 * @type String
		 */
		/**
		 * @property miterLimit
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {
			this.width = width;
			this.caps = caps;
			this.joints = joints;
			this.miterLimit = miterLimit;
			this.ignoreScale = ignoreScale;
		}).prototype;
		p.exec = function(ctx) {
			ctx.lineWidth = (this.width == null ? "1" : this.width);
			ctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));
			ctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));
			ctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);
			ctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);
		};
		p.path = false;
		
		/**
		 * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class StrokeDash
		 * @constructor
		 * @param {Array} [segments]
		 * @param {Number} [offset=0]
		 **/
		/**
		 * @property segments
		 * @type Array
		 */
		/**
		 * @property offset
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.StrokeDash = function(segments, offset) {
			this.segments = segments;
			this.offset = offset||0;
		}).prototype.exec = function(ctx) {
			if (ctx.setLineDash) { // feature detection.
				ctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.
				ctx.lineDashOffset = this.offset||0;
			}
		};
		/**
		 * The default value for segments (ie. no dash).
		 * @property EMPTY_SEGMENTS
		 * @static
		 * @final
		 * @readonly
		 * @protected
		 * @type {Array}
		 **/
		G.StrokeDash.EMPTY_SEGMENTS = [];
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class RoundRect
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radiusTL
		 * @param {Number} radiusTR
		 * @param {Number} radiusBR
		 * @param {Number} radiusBL
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * @property radiusTL
		 * @type Number
		 */
		/**
		 * @property radiusTR
		 * @type Number
		 */
		/**
		 * @property radiusBR
		 * @type Number
		 */
		/**
		 * @property radiusBL
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
			this.radiusTL = radiusTL; this.radiusTR = radiusTR;
			this.radiusBR = radiusBR; this.radiusBL = radiusBL;
		}).prototype.exec = function(ctx) {
			var max = (w<h?w:h)/2;
			var mTL=0, mTR=0, mBR=0, mBL=0;
			var x = this.x, y = this.y, w = this.w, h = this.h;
			var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;
	
			if (rTL < 0) { rTL *= (mTL=-1); }
			if (rTL > max) { rTL = max; }
			if (rTR < 0) { rTR *= (mTR=-1); }
			if (rTR > max) { rTR = max; }
			if (rBR < 0) { rBR *= (mBR=-1); }
			if (rBR > max) { rBR = max; }
			if (rBL < 0) { rBL *= (mBL=-1); }
			if (rBL > max) { rBL = max; }
	
			ctx.moveTo(x+w-rTR, y);
			ctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);
			ctx.lineTo(x+w, y+h-rBR);
			ctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);
			ctx.lineTo(x+rBL, y+h);
			ctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);
			ctx.lineTo(x, y+rTL);
			ctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);
			ctx.closePath();
		};
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Circle
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Circle = function(x, y, radius) {
			this.x = x; this.y = y;
			this.radius = radius;
		}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Ellipse
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Ellipse = function(x, y, w, h) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
		}).prototype.exec = function(ctx) {
			var x = this.x, y = this.y;
			var w = this.w, h = this.h;
	
			var k = 0.5522848;
			var ox = (w / 2) * k;
			var oy = (h / 2) * k;
			var xe = x + w;
			var ye = y + h;
			var xm = x + w / 2;
			var ym = y + h / 2;
	
			ctx.moveTo(x, ym);
			ctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);
			ctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);
			ctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);
			ctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);
		};
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class PolyStar
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} sides
		 * @param {Number} pointSize
		 * @param {Number} angle
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * @property sides
		 * @type Number
		 */
		/**
		 * @property pointSize
		 * @type Number
		 */
		/**
		 * @property angle
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {
			this.x = x; this.y = y;
			this.radius = radius;
			this.sides = sides;
			this.pointSize = pointSize;
			this.angle = angle;
		}).prototype.exec = function(ctx) {
			var x = this.x, y = this.y;
			var radius = this.radius;
			var angle = (this.angle||0)/180*Math.PI;
			var sides = this.sides;
			var ps = 1-(this.pointSize||0);
			var a = Math.PI/sides;
	
			ctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
			for (var i=0; i<sides; i++) {
				angle += a;
				if (ps != 1) {
					ctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);
				}
				angle += a;
				ctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
			}
			ctx.closePath();
		};
	
		// docced above.
		Graphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.
	
	
		createjs.Graphics = Graphics;
	}());
	
	//##############################################################################
	// DisplayObject.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as
		 * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.
		 * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and
		 * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),
		 * caching, and mouse handlers.
		 * @class DisplayObject
		 * @extends EventDispatcher
		 * @constructor
		 **/
		function DisplayObject() {
			this.EventDispatcher_constructor();
	
	
		// public properties:
			/**
			 * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
			 * @property alpha
			 * @type {Number}
			 * @default 1
			 **/
			this.alpha = 1;
	
			/**
			 * If a cache is active, this returns the canvas that holds the image of this display object. See {{#crossLink "DisplayObject/cache:method"}}{{/crossLink}}
			 * for more information. Use this to display the result of a cache. This will be a HTMLCanvasElement unless special cache rules have been deliberately enabled for this cache.
			 * @property cacheCanvas
			 * @type {HTMLCanvasElement | Object}
			 * @default null
			 * @readonly
			 **/
			this.cacheCanvas = null;
	
			/**
			 * If a cache has been made, this returns the class that is managing the cacheCanvas and its properties. See {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * for more information. Use this to control, inspect, and change the cache. In special circumstances this may be a modified or subclassed BitmapCache.
			 * @property bitmapCache
			 * @type {BitmapCache}
			 * @default null
			 * @readonly
			 **/
			this.bitmapCache = null;
	
			/**
			 * Unique ID for this display object. Makes display objects easier for some uses.
			 * @property id
			 * @type {Number}
			 * @default -1
			 **/
			this.id = createjs.UID.get();
	
			/**
			 * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
			 * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is
			 * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}
			 * method from returning the child.
			 *
			 * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please
			 * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be
			 * provided in the next release of EaselJS.
			 * @property mouseEnabled
			 * @type {Boolean}
			 * @default true
			 **/
			this.mouseEnabled = true;
	
			/**
			 * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
			 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
			 * on some display objects (ex. Sprite & MovieClip frame advancing, and DOMElement display properties).
			 * @property tickEnabled
			 * @type Boolean
			 * @default true
			 **/
			this.tickEnabled = true;
	
			/**
			 * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for
			 * debugging.
			 * @property name
			 * @type {String}
			 * @default null
			 **/
			this.name = null;
	
			/**
			 * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that
			 * contains this display object, or null if it has not been added
			 * to one.
			 * @property parent
			 * @final
			 * @type {Container}
			 * @default null
			 * @readonly
			 **/
			this.parent = null;
	
			/**
			 * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
			 * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.
			 * Cached object's registration points should be set based on pre-cache conditions, not cached size.
			 * @property regX
			 * @type {Number}
			 * @default 0
			 **/
			this.regX = 0;
	
			/**
			 * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
			 * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.
			 * Cached object's registration points should be set based on pre-cache conditions, not cached size.
			 * @property regY
			 * @type {Number}
			 * @default 0
			 **/
			this.regY = 0;
	
			/**
			 * The rotation in degrees for this display object.
			 * @property rotation
			 * @type {Number}
			 * @default 0
			 **/
			this.rotation = 0;
	
			/**
			 * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
			 * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
			 * @property scaleX
			 * @type {Number}
			 * @default 1
			 **/
			this.scaleX = 1;
	
			/**
			 * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
			 * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
			 * @property scaleY
			 * @type {Number}
			 * @default 1
			 **/
			this.scaleY = 1;
	
			/**
			 * The factor to skew this display object horizontally.
			 * @property skewX
			 * @type {Number}
			 * @default 0
			 **/
			this.skewX = 0;
	
			/**
			 * The factor to skew this display object vertically.
			 * @property skewY
			 * @type {Number}
			 * @default 0
			 **/
			this.skewY = 0;
	
			/**
			 * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
			 * null, this property is inherited from the parent container.
			 * @property shadow
			 * @type {Shadow}
			 * @default null
			 **/
			this.shadow = null;
	
			/**
			 * Indicates whether this display object should be rendered to the canvas and included when running the Stage
			 * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.
			 * @property visible
			 * @type {Boolean}
			 * @default true
			 **/
			this.visible = true;
	
			/**
			 * The x (horizontal) position of the display object, relative to its parent.
			 * @property x
			 * @type {Number}
			 * @default 0
			 **/
			this.x = 0;
	
			/** The y (vertical) position of the display object, relative to its parent.
			 * @property y
			 * @type {Number}
			 * @default 0
			 **/
			this.y = 0;
	
			/**
			 * If set, defines the transformation for this display object, overriding all other transformation properties
			 * (x, y, rotation, scale, skew).
			 * @property transformMatrix
			 * @type {Matrix2D}
			 * @default null
			 **/
			this.transformMatrix = null;
	
			/**
			 * The composite operation indicates how the pixels of this display object will be composited with the elements
			 * behind it. If `null`, this property is inherited from the parent container. For more information, read the
			 * <a href="https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation">
			 * whatwg spec on compositing</a>. For a list of supported compositeOperation value, visit
			 * <a href="https://drafts.fxtf.org/compositing/">the W3C draft on Compositing and Blending</a>.
			 * @property compositeOperation
			 * @type {String}
			 * @default null
			 **/
			this.compositeOperation = null;
	
			/**
			 * Indicates whether the display object should be drawn to a whole pixel when
			 * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole
			 * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).
			 * @property snapToPixel
			 * @type {Boolean}
			 * @default true
			 **/
			this.snapToPixel = true;
	
			/**
			 * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}
			 * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is
			 * cached.
			 * @property filters
			 * @type {Array}
			 * @default null
			 **/
			this.filters = null;
	
			/**
			 * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation
			 * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
			 * @property mask
			 * @type {Shape}
			 * @default null
			 */
			this.mask = null;
	
			/**
			 * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.
			 * The hit area will have its transformation applied relative to this display object's coordinate space (as though
			 * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
			 * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
			 * ancestors (parents).
			 * 
			 * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.
			 * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.
			 *
			 * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.
			 * @property hitArea
			 * @type {DisplayObject}
			 * @default null
			 */
			this.hitArea = null;
	
			/**
			 * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
			 * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to
			 * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
			 * @property cursor
			 * @type {String}
			 * @default null
			 */
			this.cursor = null;
	
	
		// private properties:
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheScale
			 * @protected
			 * @type {Number}
			 * @default 1
			 * @deprecated
			 **/
	
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheDataURLID
			 * @protected
			 * @type {Number}
			 * @default 0
			 * @deprecated
			 */
	
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheDataURL
			 * @protected
			 * @type {String}
			 * @default null
			 * @deprecated
			 */
	
			/**
			 * @property _props
			 * @protected
			 * @type {DisplayObject}
			 * @default null
			 **/
			this._props = new createjs.DisplayProps();
	
			/**
			 * @property _rectangle
			 * @protected
			 * @type {Rectangle}
			 * @default null
			 **/
			this._rectangle = new createjs.Rectangle();
	
			/**
			 * @property _bounds
			 * @protected
			 * @type {Rectangle}
			 * @default null
			 **/
			this._bounds = null;
	
			/**
			 * Where StageGL should look for required display properties, matters only for leaf display objects. Containers
			 * or cached objects won't use this property, it's for native display of terminal elements.
			 * @property _webGLRenderStyle
			 * @protected
			 * @type {number}
			 * @default 0
			 */
			this._webGLRenderStyle = DisplayObject._StageGL_NONE;
		}
		var p = createjs.extend(DisplayObject, createjs.EventDispatcher);
	
	// static properties:
		/**
		 * Listing of mouse event names. Used in _hasMouseEventListener.
		 * @property _MOUSE_EVENTS
		 * @protected
		 * @static
		 * @type {Array}
		 **/
		DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];
	
		/**
		 * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}
		 * with cross domain content.
		 * @property suppressCrossDomainErrors
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		DisplayObject.suppressCrossDomainErrors = false;
	
		/**
		 * @property _snapToPixelEnabled
		 * @protected
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		DisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_NONE
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_NONE = 0;
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_SPRITE
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_SPRITE = 1;
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_BITMAP
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_BITMAP = 2;
	
		/**
		 * @property _hitTestCanvas
		 * @type {HTMLCanvasElement | Object}
		 * @static
		 * @protected
		 **/
		/**
		 * @property _hitTestContext
		 * @type {CanvasRenderingContext2D}
		 * @static
		 * @protected
		 **/
		var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.
		if (canvas.getContext) {
			DisplayObject._hitTestCanvas = canvas;
			DisplayObject._hitTestContext = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	// events:
		/**
		 * Dispatched when the user presses their left mouse button over the display object. See the 
		 * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mousedown
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user presses their left mouse button and then releases it while over the display object.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event click
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user double clicks their left mouse button over this display object.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event dblclick
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user's mouse enters this display object. This event must be enabled using 
		 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mouseover
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user's mouse leaves this display object. This event must be enabled using 
		 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mouseout
		 * @since 0.6.0
		 */
	
		/**
		 * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following
		 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
		 * aggregate of their content.
		 * 
		 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
		 * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on
		 * myContainer, two events would be received, each targeting a child element:<OL>
		 * <LI>when the mouse enters shapeA (target=shapeA)</LI>
		 * <LI>when the mouse enters shapeB (target=shapeB)</LI>
		 * </OL>
		 * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
		 * the aggregate myContainer content (target=myContainer).
		 * 
		 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event rollover
		 * @since 0.7.0
		 */
	
		/**
		 * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following
		 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
		 * aggregate of their content.
		 * 
		 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
		 * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}
		 * on myContainer, two events would be received, each targeting a child element:<OL>
		 * <LI>when the mouse leaves shapeA (target=shapeA)</LI>
		 * <LI>when the mouse leaves shapeB (target=shapeB)</LI>
		 * </OL>
		 * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
		 * the aggregate myContainer content (target=myContainer).
		 * 
		 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event rollout
		 * @since 0.7.0
		 */
	
		/**
		 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove
		 * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
		 * useful for dragging and similar operations.
		 *
		 * **Please note** that if the initial mouse target from a `mousedown` event is removed from the stage after being pressed
		 * (e.g. during a `pressmove` event), a `pressmove` event is still generated. However since it is no longer in the
		 * display list, the event can not bubble. This means that previous ancestors (parent containers) will not receive
		 * the event, and therefore can not re-dispatch it. If you intend to listen for `{{#crossLink "DisplayObject/pressup:event"}}{{/crossLink}}`
		 * or `pressmove` on a dynamic object (such as a {{#crossLink "MovieClip"}}{{/crossLink}} or {{#crossLink "Container"}}{{/crossLink}}),
		 * then ensure you set {{#crossLink "Container/mouseChildren:property"}}{{/crossLink}} to `false`.
		 * @event pressmove
		 * @since 0.7.0
		 */
	
		/**
		 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event
		 * will be generated on that object when that mouse press is released. This can be useful for dragging and similar
		 * operations.
		 *
		 * **Please note** that if the initial mouse target from a `mousedown` event is removed from the stage after being pressed
		 * (e.g. during a `pressmove` event), a `pressup` event is still generated. However since it is no longer in the
		 * display list, the event can not bubble. This means that previous ancestors (parent containers) will not receive
		 * the event, and therefore can not re-dispatch it. If you intend to listen for `{{#crossLink "DisplayObject/pressmove:event"}}{{/crossLink}}`
		 * or `pressup` on a dynamic object (such as a {{#crossLink "MovieClip"}}{{/crossLink}} or {{#crossLink "Container"}}{{/crossLink}}),
		 * then ensure you set {{#crossLink "Container/mouseChildren:property"}}{{/crossLink}} to `false`.
		 * @event pressup
		 * @since 0.7.0
		 */
	
		/**
		 * Dispatched when the display object is added to a parent container.
		 * @event added
		 */
	
		/**
		 * Dispatched when the display object is removed from its parent container.
		 * @event removed
		 */
	
		/**
		 * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
		 * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on
		 * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
		 * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being
		 * dispatched on their parent.
		 * @event tick
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For
		 *      example if you called stage.update("hello"), then the params would be ["hello"].
		 * @since 0.6.0
		 */
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.
		 * @method _getStage
		 * @protected
		 * @return {Stage}
		 **/
		p._getStage = function() {
			// uses dynamic access to avoid circular dependencies;
			var o = this, _Stage = createjs["Stage"];
			while (o.parent) { o = o.parent; }
			if (o instanceof _Stage) { return o; }
			return null;
		};
		// DisplayObject.getStage is @deprecated. Remove for 1.1+
		p.getStage = createjs.deprecate(p._getStage, "DisplayObject.getStage");
	
		/**
		 * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.
		 * @property stage
		 * @type {Stage}
		 * @readonly
		 **/
	
		/**
		 * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to
		 * determine if the cache has changed since a previous check.
		 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
		 * @property cacheID
		 * @deprecated
		 * @type {Number}
		 * @default 0
		 */
	
		/**
		 * Set both the {{#crossLink "DisplayObject/scaleX:property"}}{{/crossLink}} and the {{#crossLink "DisplayObject/scaleY"}}{{/crossLink}}
		 * property to the same value. Note that when you get the value, if the `scaleX` and `scaleY` are different values,
		 * it will return only the `scaleX`.
		 * @property scaleX
		 * @type {Number}
		 * @default 1
		 */
		try {
			Object.defineProperties(p, {
				stage: { get: p._getStage },
				cacheID: {
					get: function(){ return this.bitmapCache && this.bitmapCache.cacheID },
					set: function(a){ this.bitmapCache && (this.bitmapCache.cacheID = a) }
				},
				scale: {
					get: function() { return this.scaleX; },
					set: function(scale) { this.scaleX = this.scaleY = scale; },
				}
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns <code>true</code> if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
		 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			var cache = this.bitmapCache;
			if(cache && !ignoreCache) {
				return cache.draw(ctx);
			}
			return false;
		};
	
		/**
		 * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow
		 * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.
		 * @method updateContext
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
		 **/
		p.updateContext = function(ctx) {
			var o=this, mask=o.mask, mtx= o._props.matrix;
			
			if (mask && mask.graphics && !mask.graphics.isEmpty()) {
				mask.getMatrix(mtx);
				ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
				
				mask.graphics.drawAsPath(ctx);
				ctx.clip();
				
				mtx.invert();
				ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
			}
			
			this.getMatrix(mtx);
			var tx = mtx.tx, ty = mtx.ty;
			if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
				tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
				ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
			}
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);
			ctx.globalAlpha *= o.alpha;
			if (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }
			if (o.shadow) { this._applyShadow(ctx, o.shadow); }
		};
	
		/**
		 * Draws the display object into a new element, which is then used for subsequent draws. Intended for complex content
		 * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
		 * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
		 * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually
		 * update the cache by calling <code>updateCache()</code> again. You must specify the cached area via the x, y, w,
		 * and h parameters. This defines the rectangle that will be rendered and cached using this display object's coordinates.
		 *
		 * <h4>Example</h4>
		 * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:
		 *
		 *      var shape = new createjs.Shape();
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
		 *      shape.cache(-25, -25, 50, 50);
		 *
		 * Note that filters need to be defined <em>before</em> the cache is applied or you will have to call updateCache after
		 * application. Check out the {{#crossLink "Filter"}}{{/crossLink}} class for more information. Some filters
		 * (ex. BlurFilter) may not work as expected in conjunction with the scale param.
		 * 
		 * Usually, the resulting cacheCanvas will have the dimensions width * scale, height * scale, however some filters (ex. BlurFilter)
		 * will add padding to the canvas dimensions.
		 *
		 * In previous versions caching was handled on DisplayObject but has since been moved to {{#crossLink "BitmapCache"}}{{/crossLink}}.
		 * This allows for easier interaction and alternate cache methods like WebGL with {{#crossLink "StageGL"}}{{/crossLink}}.
		 * For more information on the options object, see the BitmapCache {{#crossLink "BitmapCache/define"}}{{/crossLink}}.
		 *
		 * @method cache
		 * @param {Number} x The x coordinate origin for the cache region.
		 * @param {Number} y The y coordinate origin for the cache region.
		 * @param {Number} width The width of the cache region.
		 * @param {Number} height The height of the cache region.
		 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
		 * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
		 * 	cached elements with greater fidelity. Default is 1.
		 * @param {Object} [options=undefined] Specify additional parameters for the cache logic
		 **/
		p.cache = function(x, y, width, height, scale, options) {
			if(!this.bitmapCache){
				this.bitmapCache = new createjs.BitmapCache();
			}
			this.bitmapCache.define(this, x, y, width, height, scale, options);
		};
	
		/**
		 * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
		 * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object
		 * will be drawn over the existing cache using the specified compositeOperation.
		 *
		 * <h4>Example</h4>
		 * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line
		 * will be drawn on top of the old one.
		 *
		 *      // Not shown: Creating the shape, and caching it.
		 *      shapeInstance.clear();
		 *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
		 *      shapeInstance.updateCache();
		 *
		 * In previous versions caching was handled on DisplayObject but has since been moved to {{#crossLink "BitmapCache"}}{{/crossLink}}.
		 * This allows for easier interaction and alternate cache methods like WebGL and {{#crossLink "StageGL"}}{{/crossLink}}.
		 *
		 * @method updateCache
		 * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.
		 * <a href="https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation">
		 * whatwg spec on compositing</a>.
		 **/
		p.updateCache = function(compositeOperation) {
			if(!this.bitmapCache) {
				throw "cache() must be called before updateCache()";
			}
			this.bitmapCache.update(compositeOperation);
		};
	
		/**
		 * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.
		 * @method uncache
		 **/
		p.uncache = function() {
			if(this.bitmapCache) {
				this.bitmapCache.release();
				this.bitmapCache = undefined;
			}
		};
	
		/**
		 * Returns a data URL for the cache, or null if this display object is not cached.
		 * Only generated if the cache has changed, otherwise returns last result.
		 * @method getCacheDataURL
		 * @return {String} The image data url for the cache.
		 **/
		p.getCacheDataURL = function() {
			return this.bitmapCache?this.bitmapCache.getDataURL():null;
		};
	
		/**
		 * Transforms the specified x and y position from the coordinate space of the display object
		 * to the global (stage) coordinate space. For example, this could be used to position an HTML label
		 * over a specific point on a nested display object. Returns a Point instance with x and y properties
		 * correlating to the transformed coordinates on the stage.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.x = 300;
		 *      displayObject.y = 200;
		 *      stage.addChild(displayObject);
		 *      var point = displayObject.localToGlobal(100, 100);
		 *      // Results in x=400, y=300
		 *
		 * @method localToGlobal
		 * @param {Number} x The x position in the source display object to transform.
		 * @param {Number} y The y position in the source display object to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates
		 * on the stage.
		 **/
		p.localToGlobal = function(x, y, pt) {
			return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());
		};
	
		/**
		 * Transforms the specified x and y position from the global (stage) coordinate space to the
		 * coordinate space of the display object. For example, this could be used to determine
		 * the current mouse position within the display object. Returns a Point instance with x and y properties
		 * correlating to the transformed position in the display object's coordinate space.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.x = 300;
		 *      displayObject.y = 200;
		 *      stage.addChild(displayObject);
		 *      var point = displayObject.globalToLocal(100, 100);
		 *      // Results in x=-200, y=-100
		 *
		 * @method globalToLocal
		 * @param {Number} x The x position on the stage to transform.
		 * @param {Number} y The y position on the stage to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
		 * display object's coordinate space.
		 **/
		p.globalToLocal = function(x, y, pt) {
			return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());
		};
	
		/**
		 * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
		 * space of the target display object. Returns a Point instance with x and y properties correlating to the
		 * transformed position in the target's coordinate space. Effectively the same as using the following code with
		 * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
		 *
		 *      var pt = this.localToGlobal(x, y);
		 *      pt = target.globalToLocal(pt.x, pt.y);
		 *
		 * @method localToLocal
		 * @param {Number} x The x position in the source display object to transform.
		 * @param {Number} y The y position on the source display object to transform.
		 * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
		 * in the target's coordinate space.
		 **/
		p.localToLocal = function(x, y, target, pt) {
			pt = this.localToGlobal(x, y, pt);
			return target.globalToLocal(pt.x, pt.y, pt);
		};
	
		/**
		 * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
		 * Omitted parameters will have the default value set.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.setTransform(100, 100, 2, 2);
		 *
		 * @method setTransform
		 * @param {Number} [x=0] The horizontal translation (x position) in pixels
		 * @param {Number} [y=0] The vertical translation (y position) in pixels
		 * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
		 * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
		 * @param {Number} [rotation=0] The rotation, in degrees
		 * @param {Number} [skewX=0] The horizontal skew factor
		 * @param {Number} [skewY=0] The vertical skew factor
		 * @param {Number} [regX=0] The horizontal registration point in pixels
		 * @param {Number} [regY=0] The vertical registration point in pixels
		 * @return {DisplayObject} Returns this instance. Useful for chaining commands.
		 * @chainable
		*/
		p.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			this.x = x || 0;
			this.y = y || 0;
			this.scaleX = scaleX == null ? 1 : scaleX;
			this.scaleY = scaleY == null ? 1 : scaleY;
			this.rotation = rotation || 0;
			this.skewX = skewX || 0;
			this.skewY = skewY || 0;
			this.regX = regX || 0;
			this.regY = regY || 0;
			return this;
		};
	
		/**
		 * Returns a matrix based on this object's current transform.
		 * @method getMatrix
		 * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new
		 * Matrix object is returned.
		 * @return {Matrix2D} A matrix representing this display object's transform.
		 **/
		p.getMatrix = function(matrix) {
			var o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();
			return o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
		};
	
		/**
		 * Generates a Matrix2D object representing the combined transform of the display object and all of its
		 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can
		 * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
		 * @method getConcatenatedMatrix
		 * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.
		 * If null, a new Matrix2D object is returned.
		 * @return {Matrix2D} The combined matrix.
		 **/
		p.getConcatenatedMatrix = function(matrix) {
			var o = this, mtx = this.getMatrix(matrix);
			while (o = o.parent) {
				mtx.prependMatrix(o.getMatrix(o._props.matrix));
			}
			return mtx;
		};
	
		/**
		 * Generates a DisplayProps object representing the combined display properties of the  object and all of its
		 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).
		 * @method getConcatenatedDisplayProps
		 * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.
		 * If null, a new DisplayProps object is returned.
		 * @return {DisplayProps} The combined display properties.
		 **/
		p.getConcatenatedDisplayProps = function(props) {
			props = props ? props.identity() : new createjs.DisplayProps();
			var o = this, mtx = o.getMatrix(props.matrix); 
			do {
				props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
				
				// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
				// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
				if (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }
			} while (o = o.parent);
			return props;
		};
	
		/**
		 * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
		 * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
		 *
		 * <h4>Example</h4>
		 *
		 *      stage.addEventListener("stagemousedown", handleMouseDown);
		 *      function handleMouseDown(event) {
		 *          var hit = myShape.hitTest(event.stageX, event.stageY);
		 *      }
		 *
		 * Please note that shape-to-shape collision is not currently supported by EaselJS.
		 * @method hitTest
		 * @param {Number} x The x position to check in the display object's local coordinates.
		 * @param {Number} y The y position to check in the display object's local coordinates.
		 * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
		 * local Point.
		*/
		p.hitTest = function(x, y) {
			var ctx = DisplayObject._hitTestContext;
			ctx.setTransform(1, 0, 0, 1, -x, -y);
			this.draw(ctx);
	
			var hit = this._testHit(ctx);
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, 2, 2);
			return hit;
		};
	
		/**
		 * Provides a chainable shortcut method for setting a number of properties on the instance.
		 *
		 * <h4>Example</h4>
		 *
		 *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
		 *      var shape = stage.addChild(new Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});
		 *
		 * @method set
		 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
		 * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
		 * @chainable
		*/
		p.set = function(props) {
			for (var n in props) { this[n] = props[n]; }
			return this;
		};
	
		/**
		 * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
		 * Objects that have been cached will return the bounds of the cache.
		 * 
		 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
		 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
		 * bounds.
		 * 
		 * <table>
		 * 	<tr><td><b>All</b></td><td>
		 * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
		 * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
		 * 		the automatic calculations listed below.
		 * 	</td></tr>
		 * 	<tr><td><b>Bitmap</b></td><td>
		 * 		Returns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).
		 * 	</td></tr>
		 * 	<tr><td><b>Sprite</b></td><td>
		 * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
		 * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
		 * 	</td></tr>
		 * 	<tr><td><b>Container</b></td><td>
		 * 		Returns the aggregate (combined) bounds of all children that return a non-null value from getBounds().
		 * 	</td></tr>
		 * 	<tr><td><b>Shape</b></td><td>
		 * 		Does not currently support automatic bounds calculations. Use setBounds() to manually define bounds.
		 * 	</td></tr>
		 * 	<tr><td><b>Text</b></td><td>
		 * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are
		 * 		not, especially when using textBaseline values other than "top".
		 * 	</td></tr>
		 * 	<tr><td><b>BitmapText</b></td><td>
		 * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
		 * 		to (x=0,y=0).
		 * 	</td></tr>
		* </table>
		 * 
		 * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
		 * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
		 * bounds explicitly:
		 * 
		 * 	var bounds = obj.getBounds();
		 * 	obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
		 * 	// getBounds will now use the set values, instead of recalculating
		 * 
		 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
		 * values if you need to retain it.
		 * 
		 * 	var myBounds = obj.getBounds().clone();
		 * 	// OR:
		 * 	myRect.copy(obj.getBounds());
		 * 
		 * @method getBounds
		 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
		 * object.
		 **/
		p.getBounds = function() {
			if (this._bounds) { return this._rectangle.copy(this._bounds); }
			var cacheCanvas = this.cacheCanvas;
			if (cacheCanvas) {
				var scale = this._cacheScale;
				return this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
			}
			return null;
		};
	
		/**
		 * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
		 * Objects that have been cached will return the transformed bounds of the cache.
		 * 
		 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
		 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
		 * bounds.
		 * 
		 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
		 * values if you need to retain it.
		 * 
		 * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
		 * @method getTransformedBounds
		 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
		 **/
		p.getTransformedBounds = function() {
			return this._getBounds();
		};
	
		/**
		 * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
		 * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
		 * override calculated bounds.
		 * 
		 * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
		 * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
		 * @method setBounds
		 * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
		 * @param {Number} y The y origin of the bounds.
		 * @param {Number} width The width of the bounds.
		 * @param {Number} height The height of the bounds.
		 **/
		p.setBounds = function(x, y, width, height) {
			if (x == null) { this._bounds = x; return; }
			this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
		};
	
		/**
		 * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
		 * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
		 * are copied by reference (masks, individual filter instances, hit area)
		 * @method clone
		 * @return {DisplayObject} A clone of the current DisplayObject instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new DisplayObject());
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[DisplayObject (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * Called before the object gets drawn and is a chance to ensure the display state of the object is correct.
		 * Mostly used by {{#crossLink "MovieClip"}}{{/crossLink}} and {{#crossLink "BitmapText"}}{{/crossLink}} to
		 * correct their internal state and children prior to being drawn.
		 *
		 * Is manually called via draw in a {{#crossLink "Stage"}}{{/crossLink}} but is automatically called when
		 * present in a {{#crossLink "StageGL"}}{{/crossLink}} instance.
		 *
		 * @method _updateState
		 * @default null
		 */
		p._updateState = null;
	
		// separated so it can be used more easily in subclasses:
		/**
		 * @method _cloneProps
		 * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
		 * instance copied into.
		 * @return {DisplayObject} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			o.alpha = this.alpha;
			o.mouseEnabled = this.mouseEnabled;
			o.tickEnabled = this.tickEnabled;
			o.name = this.name;
			o.regX = this.regX;
			o.regY = this.regY;
			o.rotation = this.rotation;
			o.scaleX = this.scaleX;
			o.scaleY = this.scaleY;
			o.shadow = this.shadow;
			o.skewX = this.skewX;
			o.skewY = this.skewY;
			o.visible = this.visible;
			o.x  = this.x;
			o.y = this.y;
			o.compositeOperation = this.compositeOperation;
			o.snapToPixel = this.snapToPixel;
			o.filters = this.filters==null?null:this.filters.slice(0);
			o.mask = this.mask;
			o.hitArea = this.hitArea;
			o.cursor = this.cursor;
			o._bounds = this._bounds;
			return o;
		};
	
		/**
		 * @method _applyShadow
		 * @protected
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {Shadow} shadow
		 **/
		p._applyShadow = function(ctx, shadow) {
			shadow = shadow || Shadow.identity;
			ctx.shadowColor = shadow.color;
			ctx.shadowOffsetX = shadow.offsetX;
			ctx.shadowOffsetY = shadow.offsetY;
			ctx.shadowBlur = shadow.blur;
		};
	
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
			var ls = this._listeners;
			if (ls && ls["tick"]) {
				// reset & reuse the event object to avoid construction / GC costs:
				evtObj.target = null;
				evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
				this.dispatchEvent(evtObj);
			}
		};
	
		/**
		 * @method _testHit
		 * @protected
		 * @param {CanvasRenderingContext2D} ctx
		 * @return {Boolean}
		 **/
		p._testHit = function(ctx) {
			try {
				var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
			} catch (e) {
				if (!DisplayObject.suppressCrossDomainErrors) {
					throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
				}
			}
			return hit;
		};
	
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform){
			return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
		};
	
		/**
		 * @method _transformBounds
		 * @param {Rectangle} bounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform
		 * @return {Rectangle}
		 * @protected
		 **/
		p._transformBounds = function(bounds, matrix, ignoreTransform) {
			if (!bounds) { return bounds; }
			var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
			mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
			
			if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.
			if (matrix) { mtx.prependMatrix(matrix); }
			
			var x_a = width*mtx.a, x_b = width*mtx.b;
			var y_c = height*mtx.c, y_d = height*mtx.d;
			var tx = mtx.tx, ty = mtx.ty;
			
			var minX = tx, maxX = tx, minY = ty, maxY = ty;
	
			if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
	
			if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
	
			return bounds.setValues(minX, minY, maxX-minX, maxY-minY);
		};
	
		/**
		 * Indicates whether the display object has any mouse event listeners or a cursor.
		 * @method _isMouseOpaque
		 * @return {Boolean}
		 * @protected
		 **/
		p._hasMouseEventListener = function() {
			var evts = DisplayObject._MOUSE_EVENTS;
			for (var i= 0, l=evts.length; i<l; i++) {
				if (this.hasEventListener(evts[i])) { return true; }
			}
			return !!this.cursor;
		};
	
		createjs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");
	}());
	
	//##############################################################################
	// Container.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
		
	
	// constructor:
	/**
	 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
	 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
	 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
	 * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent
	 * Container.
	 *
	 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>
	 * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.
	 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
	 *
	 * <h4>Example</h4>
	 *
	 *      var container = new createjs.Container();
	 *      container.addChild(bitmapInstance, shapeInstance);
	 *      container.x = 100;
	 *
	 * @class Container
	 * @extends DisplayObject
	 * @constructor
	 **/
		function Container() {
			this.DisplayObject_constructor();
			
		// public properties:
			/**
			 * The array of children in the display list. You should usually use the child management methods such as
			 * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},
			 * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is
			 * included for advanced uses.
			 * @property children
			 * @type Array
			 * @default null
			 **/
			this.children = [];
			
			/**
			 * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
			 * If false, the children will be aggregated under the container - for example, a click on a child shape would
			 * trigger a click event on the container.
			 * @property mouseChildren
			 * @type Boolean
			 * @default true
			 **/
			this.mouseChildren = true;
			
			/**
			 * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
			 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
			 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
			 * @property tickChildren
			 * @type Boolean
			 * @default true
			 **/
			this.tickChildren = true;
		}
		var p = createjs.extend(Container, createjs.DisplayObject);
		
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.
		 * @method _getNumChildren
		 * @protected
		 * @return {Number}
		 **/
		p._getNumChildren = function() {
			return this.children.length;
		};
		// Container.getNumChildren is @deprecated. Remove for 1.1+
		p.getNumChildren = createjs.deprecate(p._getNumChildren, "Container.getNumChildren");
	
		/**
		 * Returns the number of children in the container.
		 * @property numChildren
		 * @type {Number}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				numChildren: { get: p._getNumChildren }
			});
		} catch (e) {}
		
	
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Container; // TODO: deprecated.
		
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || this.children.length;
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			
			// this ensures we don't have issues with display list changes that occur during a draw:
			var list = this.children.slice();
			for (var i=0,l=list.length; i<l; i++) {
				var child = list[i];
				if (!child.isVisible()) { continue; }
				
				// draw the child:
				ctx.save();
				child.updateContext(ctx);
				child.draw(ctx);
				ctx.restore();
			}
			return true;
		};
		
		/**
		 * Adds a child to the top of the display list.
		 *
		 * <h4>Example</h4>
		 *
		 * 		container.addChild(bitmapInstance);
		 *
		 * You can also add multiple children at once:
		 *
		 * 		container.addChild(bitmapInstance, shapeInstance, textInstance);
		 *
		 * @method addChild
		 * @param {DisplayObject} child The display object to add.
		 * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
		 **/
		p.addChild = function(child) {
			if (child == null) { return child; }
			var l = arguments.length;
			if (l > 1) {
				for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
				return arguments[l-1];
			}
			// Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
			var par=child.parent, silent = par === this;
			par&&par._removeChildAt(createjs.indexOf(par.children, child), silent);
			child.parent = this;
			this.children.push(child);
			if (!silent) { child.dispatchEvent("added"); }
			return child;
		};
	
		/**
		 * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
		 * setting its parent to this Container.
		 *
		 * <h4>Example</h4>
		 *
		 *      addChildAt(child1, index);
		 *
		 * You can also add multiple children, such as:
		 *
		 *      addChildAt(child1, child2, ..., index);
		 *
		 * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
		 * you could use:
		 *
		 *      container.addChildAt(myShape, container.getChildIndex(otherShape));
		 *
		 * This would also bump otherShape's index up by one. Fails silently if the index is out of range.
		 *
		 * @method addChildAt
		 * @param {DisplayObject} child The display object to add.
		 * @param {Number} index The index to add the child at.
		 * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
		 **/
		p.addChildAt = function(child, index) {
			var l = arguments.length;
			var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
			if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
			if (l > 2) {
				for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
				return arguments[l-2];
			}
			var par=child.parent, silent = par === this;
			par&&par._removeChildAt(createjs.indexOf(par.children, child), silent);
			child.parent = this;
			this.children.splice(index, 0, child);
			if (!silent) { child.dispatchEvent("added"); }
			return child;
		};
	
		/**
		 * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
		 * already known.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.removeChild(child);
		 *
		 * You can also remove multiple children:
		 *
		 *      removeChild(child1, child2, ...);
		 *
		 * Returns true if the child (or children) was removed, or false if it was not in the display list.
		 * @method removeChild
		 * @param {DisplayObject} child The child to remove.
		 * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
		 **/
		p.removeChild = function(child) {
			var l = arguments.length;
			if (l > 1) {
				var good = true;
				for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
				return good;
			}
			return this._removeChildAt(createjs.indexOf(this.children, child));
		};
	
		/**
		 * Removes the child at the specified index from the display list, and sets its parent to null.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.removeChildAt(2);
		 *
		 * You can also remove multiple children:
		 *
		 *      container.removeChild(2, 7, ...)
		 *
		 * Returns true if the child (or children) was removed, or false if any index was out of range.
		 * @method removeChildAt
		 * @param {Number} index The index of the child to remove.
		 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
		 **/
		p.removeChildAt = function(index) {
			var l = arguments.length;
			if (l > 1) {
				var a = [];
				for (var i=0; i<l; i++) { a[i] = arguments[i]; }
				a.sort(function(a, b) { return b-a; });
				var good = true;
				for (var i=0; i<l; i++) { good = good && this._removeChildAt(a[i]); }
				return good;
			}
			return this._removeChildAt(index);
		};
	
		/**
		 * Removes all children from the display list.
		 *
		 * <h4>Example</h4>
		 *
		 * 	container.removeAllChildren();
		 *
		 * @method removeAllChildren
		 **/
		p.removeAllChildren = function() {
			var kids = this.children;
			while (kids.length) { this._removeChildAt(0); }
		};
	
		/**
		 * Returns the child at the specified index.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.getChildAt(2);
		 *
		 * @method getChildAt
		 * @param {Number} index The index of the child to return.
		 * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
		 **/
		p.getChildAt = function(index) {
			return this.children[index];
		};
		
		/**
		 * Returns the child with the specified name.
		 * @method getChildByName
		 * @param {String} name The name of the child to return.
		 * @return {DisplayObject} The child with the specified name.
		 **/
		p.getChildByName = function(name) {
			var kids = this.children;
			for (var i=0,l=kids.length;i<l;i++) {
				if(kids[i].name == name) { return kids[i]; }
			}
			return null;
		};
	
		/**
		 * Performs an array sort operation on the child list.
		 *
		 * <h4>Example: Display children with a higher y in front.</h4>
		 * 
		 *      var sortFunction = function(obj1, obj2, options) {
		 *          if (obj1.y > obj2.y) { return 1; }
		 *          if (obj1.y < obj2.y) { return -1; }
		 *          return 0;
		 *      }
		 *      container.sortChildren(sortFunction);
		 *
		 * @method sortChildren
		 * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>
		 * documentation for details.
		 **/
		p.sortChildren = function(sortFunction) {
			this.children.sort(sortFunction);
		};
	
		/**
		 * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
		 *
		 * <h4>Example</h4>
		 *
		 *      var index = container.getChildIndex(child);
		 *
		 * @method getChildIndex
		 * @param {DisplayObject} child The child to return the index of.
		 * @return {Number} The index of the specified child. -1 if the child is not found.
		 **/
		p.getChildIndex = function(child) {
			return createjs.indexOf(this.children, child);
		};
		
		/**
		 * Swaps the children at the specified indexes. Fails silently if either index is out of range.
		 * @method swapChildrenAt
		 * @param {Number} index1
		 * @param {Number} index2
		 **/
		p.swapChildrenAt = function(index1, index2) {
			var kids = this.children;
			var o1 = kids[index1];
			var o2 = kids[index2];
			if (!o1 || !o2) { return; }
			kids[index1] = o2;
			kids[index2] = o1;
		};
		
		/**
		 * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
		 * Container.
		 * @method swapChildren
		 * @param {DisplayObject} child1
		 * @param {DisplayObject} child2
		 **/
		p.swapChildren = function(child1, child2) {
			var kids = this.children;
			var index1,index2;
			for (var i=0,l=kids.length;i<l;i++) {
				if (kids[i] == child1) { index1 = i; }
				if (kids[i] == child2) { index2 = i; }
				if (index1 != null && index2 != null) { break; }
			}
			if (i==l) { return; } // TODO: throw error?
			kids[index1] = child2;
			kids[index2] = child1;
		};
		
		/**
		 * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
		 * @param {DisplayObject} child
		 * @param {Number} index  
		 * @method setChildIndex
		 **/
		p.setChildIndex = function(child, index) {
			var kids = this.children, l=kids.length;
			if (child.parent != this || index < 0 || index >= l) { return; }
			for (var i=0;i<l;i++) {
				if (kids[i] == child) { break; }
			}
			if (i==l || i == index) { return; }
			kids.splice(i,1);
			kids.splice(index,0,child);
		};
	
		/**
		 * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
		 * of this container.
		 * @method contains
		 * @param {DisplayObject} child The DisplayObject to be checked.
		 * @return {Boolean} true if the specified display object either is this container or is a descendent.
		 **/
		p.contains = function(child) {
			while (child) {
				if (child == this) { return true; }
				child = child.parent;
			}
			return false;
		};
	
		/**
		 * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
		 * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
		 * transform properties including regX/Y.
		 * @method hitTest
		 * @param {Number} x The x position to check in the display object's local coordinates.
		 * @param {Number} y The y position to check in the display object's local coordinates.
		 * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
		 * coordinates.
		 **/
		p.hitTest = function(x, y) {
			// TODO: optimize to use the fast cache check where possible.
			return (this.getObjectUnderPoint(x, y) != null);
		};
	
		/**
		 * Returns an array of all display objects under the specified coordinates that are in this container's display
		 * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
		 * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.
		 * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
		 * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),
		 * and only if the mouse's position has changed.
		 * 
		 * <ul>
		 *     <li>By default (mode=0) this method evaluates all display objects.</li>
		 *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
		 * 		and {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>
		 * 	   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
		 * 	   	listeners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects
		 * 	   	that would normally intercept mouse interaction will be included. This can significantly improve performance
		 * 	   	in some cases by reducing the number of display objects that need to be tested.</li>
		 * </li>
		 * 
		 * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.
		 * @method getObjectsUnderPoint
		 * @param {Number} x The x position in the container to test.
		 * @param {Number} y The y position in the container to test.
		 * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
		 * @return {Array} An Array of DisplayObjects under the specified coordinates.
		 **/
		p.getObjectsUnderPoint = function(x, y, mode) {
			var arr = [];
			var pt = this.localToGlobal(x, y);
			this._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);
			return arr;
		};
	
		/**
		 * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display
		 * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive
		 * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.
		 * @method getObjectUnderPoint
		 * @param {Number} x The x position in the container to test.
		 * @param {Number} y The y position in the container to test.
		 * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
		 * @return {DisplayObject} The top-most display object under the specified coordinates.
		 **/
		p.getObjectUnderPoint = function(x, y, mode) {
			var pt = this.localToGlobal(x, y);
			return this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);
		};
		
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			return this._getBounds(null, true);
		};
		
		
		/**
		 * Docced in superclass.
		 */
		p.getTransformedBounds = function() {
			return this._getBounds();
		};
	
		/**
		 * Returns a clone of this Container. Some properties that are specific to this instance's current context are
		 * reverted to their defaults (for example .parent).
		 * @method clone
		 * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
		 * properties of the container will be cloned, but the new instance will not have any children.
		 * @return {Container} A clone of the current Container instance.
		 **/
		p.clone = function(recursive) {
			var o = this._cloneProps(new Container());
			if (recursive) { this._cloneChildren(o); }
			return o;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Container (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			if (this.tickChildren) {
				for (var i=this.children.length-1; i>=0; i--) {
					var child = this.children[i];
					if (child.tickEnabled && child._tick) { child._tick(evtObj); }
				}
			}
			this.DisplayObject__tick(evtObj);
		};
		
		/**
		 * Recursively clones all children of this container, and adds them to the target container.
		 * @method cloneChildren
		 * @protected
		 * @param {Container} o The target container.
		 **/
		p._cloneChildren = function(o) {
			if (o.children.length) { o.removeAllChildren(); }
			var arr = o.children;
			for (var i=0, l=this.children.length; i<l; i++) {
				var clone = this.children[i].clone(true);
				clone.parent = o;
				arr.push(clone);
			}
		};
		
		/**
		 * Removes the child at the specified index from the display list, and sets its parent to null.
		 * Used by `removeChildAt`, `addChild`, and `addChildAt`.
		 * @method removeChildAt
		 * @protected
		 * @param {Number} index The index of the child to remove.
		 * @param {Boolean} [silent] Prevents dispatch of `removed` event if true.
		 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
		 **/
		p._removeChildAt = function(index, silent) {
			if (index < 0 || index > this.children.length-1) { return false; }
			var child = this.children[index];
			if (child) { child.parent = null; }
			this.children.splice(index, 1);
			if (!silent) { child.dispatchEvent("removed"); }
			return true;
		};
	
		/**
		 * @method _getObjectsUnderPoint
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Array} arr
		 * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
		 * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
		 * @param {Number} currentDepth Indicates the current depth of the search.
		 * @return {DisplayObject}
		 * @protected
		 **/
		p._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {
			currentDepth = currentDepth || 0;
			if (!currentDepth && !this._testMask(this, x, y)) { return null; }
			var mtx, ctx = createjs.DisplayObject._hitTestContext;
			activeListener = activeListener || (mouse&&this._hasMouseEventListener());
	
			// draw children one at a time, and check if we get a hit:
			var children = this.children, l = children.length;
			for (var i=l-1; i>=0; i--) {
				var child = children[i];
				var hitArea = child.hitArea;
				if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }
				if (!hitArea && !this._testMask(child, x, y)) { continue; }
				
				// if a child container has a hitArea then we only need to check its hitAre2a, so we can treat it as a normal DO:
				if (!hitArea && child instanceof Container) {
					var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);
					if (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }
				} else {
					if (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }
					
					// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
					var props = child.getConcatenatedDisplayProps(child._props);
					mtx = props.matrix;
					
					if (hitArea) {
						mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
						props.alpha = hitArea.alpha;
					}
					
					ctx.globalAlpha = props.alpha;
					ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
					(hitArea||child).draw(ctx);
					if (!this._testHit(ctx)) { continue; }
					ctx.setTransform(1, 0, 0, 1, 0, 0);
					ctx.clearRect(0, 0, 2, 2);
					if (arr) { arr.push(child); }
					else { return (mouse && !this.mouseChildren) ? this : child; }
				}
			}
			return null;
		};
		
		/**
		 * @method _testMask
		 * @param {DisplayObject} target
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Boolean} Indicates whether the x/y is within the masked region.
		 * @protected
		 **/
		p._testMask = function(target, x, y) {
			var mask = target.mask;
			if (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }
			
			var mtx = this._props.matrix, parent = target.parent;
			mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
			mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
			
			var ctx = createjs.DisplayObject._hitTestContext;
			ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
			
			// draw the mask as a solid fill:
			mask.graphics.drawAsPath(ctx);
			ctx.fillStyle = "#000";
			ctx.fill();
			
			if (!this._testHit(ctx)) { return false; }
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, 2, 2);
			
			return true;
		};
		
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform) {
			var bounds = this.DisplayObject_getBounds();
			if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
			
			var mtx = this._props.matrix;
			mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
			if (matrix) { mtx.prependMatrix(matrix); }
			
			var l = this.children.length, rect=null;
			for (var i=0; i<l; i++) {
				var child = this.children[i];
				if (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }
				if (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }
				else { rect = bounds.clone(); }
			}
			return rect;
		};
	
	
		createjs.Container = createjs.promote(Container, "DisplayObject");
	}());
	
	//##############################################################################
	// Stage.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}
		 * method is called, it will render its display list to its target canvas.
		 *
		 * <h4>Example</h4>
		 * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child
		 * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.
		 *
		 *      var stage = new createjs.Stage("canvasElementId");
		 *      var image = new createjs.Bitmap("imagePath.png");
		 *      stage.addChild(image);
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          image.x += 10;
		 *          stage.update();
		 *      }
		 *
		 * @class Stage
		 * @extends Container
		 * @constructor
		 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
		 * of a canvas object in the current document.
		 **/
		function Stage(canvas) {
			this.Container_constructor();
		
		
		// public properties:
			/**
			 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>
			 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
			 * example).
			 *
			 * <h4>Example</h4>
			 *
			 *      var stage = new createjs.Stage("canvasId");
			 *      stage.autoClear = false;
			 *
			 * @property autoClear
			 * @type Boolean
			 * @default true
			 **/
			this.autoClear = true;
		
			/**
			 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
			 * first stage that will be ticked (or they will clear each other's render).
			 *
			 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
			 * new canvas or mouse events will not work as expected. For example:
			 *
			 *      myStage.enableDOMEvents(false);
			 *      myStage.canvas = anotherCanvas;
			 *      myStage.enableDOMEvents(true);
			 *
			 * @property canvas
			 * @type HTMLCanvasElement | Object
			 **/
			this.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;
		
			/**
			 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
			 * position over the canvas, and mouseInBounds will be set to false.
			 * @property mouseX
			 * @type Number
			 * @readonly
			 **/
			this.mouseX = 0;
		
			/**
			 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
			 * position over the canvas, and mouseInBounds will be set to false.
			 * @property mouseY
			 * @type Number
			 * @readonly
			 **/
			this.mouseY = 0;
		
			/**
			 * Specifies the area of the stage to affect when calling update. This can be use to selectively
			 * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
			 * @property drawRect
			 * @type {Rectangle}
			 */
			this.drawRect = null;
		
			/**
			 * Indicates whether display objects should be rendered on whole pixels. You can set the
			 * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of
			 * display objects to false to enable/disable this behaviour on a per instance basis.
			 * @property snapToPixelEnabled
			 * @type Boolean
			 * @default false
			 **/
			this.snapToPixelEnabled = false;
		
			/**
			 * Indicates whether the mouse is currently within the bounds of the canvas.
			 * @property mouseInBounds
			 * @type Boolean
			 * @default false
			 **/
			this.mouseInBounds = false;
		
			/**
			 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
			 * @property tickOnUpdate
			 * @type Boolean
			 * @default true
			 **/
			this.tickOnUpdate = true;
		
			/**
			 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
			 * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}
			 * x/y/rawX/rawY.
			 * @property mouseMoveOutside
			 * @type Boolean
			 * @default false
			 **/
			this.mouseMoveOutside = false;
			
			
			/**
			 * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
			 * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
			 * @property preventSelection
			 * @type Boolean
			 * @default true
			 **/
			this.preventSelection = true;
		
			/**
			 * The hitArea property is not supported for Stage.
			 * @property hitArea
			 * @type {DisplayObject}
			 * @default null
			 */
			 
			 
		// private properties:
			/**
			 * Holds objects with data for each active pointer id. Each object has the following properties:
			 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
			 * @property _pointerData
			 * @type {Object}
			 * @private
			 */
			this._pointerData = {};
		
			/**
			 * Number of active pointers.
			 * @property _pointerCount
			 * @type {Object}
			 * @private
			 */
			this._pointerCount = 0;
		
			/**
			 * The ID of the primary pointer.
			 * @property _primaryPointerID
			 * @type {Object}
			 * @private
			 */
			this._primaryPointerID = null;
		
			/**
			 * @property _mouseOverIntervalID
			 * @protected
			 * @type Number
			 **/
			this._mouseOverIntervalID = null;
			
			/**
			 * @property _nextStage
			 * @protected
			 * @type Stage
			 **/
			this._nextStage = null;
			
			/**
			 * @property _prevStage
			 * @protected
			 * @type Stage
			 **/
			this._prevStage = null;
			
			
		// initialize:
			this.enableDOMEvents(true);
		}
		var p = createjs.extend(Stage, createjs.Container);
	
	// events:
		/**
		 * Dispatched when the user moves the mouse over the canvas.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event stagemousemove
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event stagemousedown
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
		 * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event stagemouseup
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
		 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event mouseleave
		 * @since 0.7.0
		 */
	
		/**
		 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
		 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event mouseenter
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately before the tick event is propagated through the display list.
		 * You can call preventDefault on the event object to cancel propagating the tick event.
		 * @event tickstart
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
		 * tickOnUpdate is false. Precedes the "drawstart" event.
		 * @event tickend
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
		 * You can call preventDefault on the event object to cancel the draw.
		 * @event drawstart
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
		 * @event drawend
		 * @since 0.7.0
		 */
	
		 
	// getter / setters:
		/**
		 * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.
		 * This can be useful in cases where you have multiple layered canvases and want user interactions
		 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
		 *
		 *      topStage.nextStage = bottomStage;
		 *
		 * To disable relaying, set nextStage to null.
		 * 
		 * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
		 * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
		 * Considerations when using roll over in relay targets:<OL>
		 * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>
		 * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>
		 * <LI> All relay targets will share the frequency value of the top-most stage</LI>
		 * </OL>
		 * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing
		 * 30 as it's desired frequency):
		 * 	topStage.nextStage = targetStage;
		 * 	topStage.enableMouseOver(10);
		 * 	targetStage.enableMouseOver(30);
		 * 
		 * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its
		 * DOM events using:
		 * 
		 *	targetStage.enableDOMEvents(false);
		 * 
		 * @property nextStage
		 * @type {Stage}
		 **/
		p._get_nextStage = function() {
			return this._nextStage;
		};
		p._set_nextStage = function(value) {
			if (this._nextStage) { this._nextStage._prevStage = null; }
			if (value) { value._prevStage = this; }
			this._nextStage = value;
		};
		
		try {
			Object.defineProperties(p, {
				nextStage: { get: p._get_nextStage, set: p._set_nextStage }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}
		 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,
		 * and then render the display list to the canvas.
		 *
		 * @method update
		 * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.
		 **/
		p.update = function(props) {
			if (!this.canvas) { return; }
			if (this.tickOnUpdate) { this.tick(props); }
			if (this.dispatchEvent("drawstart", false, true) === false) { return; }
			createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
			var r = this.drawRect, ctx = this.canvas.getContext("2d");
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			if (this.autoClear) {
				if (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }
				else { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }
			}
			ctx.save();
			if (this.drawRect) {
				ctx.beginPath();
				ctx.rect(r.x, r.y, r.width, r.height);
				ctx.clip();
			}
			this.updateContext(ctx);
			this.draw(ctx, false);
			ctx.restore();
			this.dispatchEvent("drawend");
		};
		
		/**
		 * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}
		 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.
		 *
		 * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
		 * propagated to listeners.
		 *
		 * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that
		 * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be
		 * passed as the `props` parameter to `tick()`. For example:
		 *
		 * 	Ticker.on("tick", handleTick);
		 * 	function handleTick(evtObj) {
		 * 		// clone the event object from Ticker, and add some custom data to it:
		 * 		var evt = evtObj.clone().set({greeting:"hello", name:"world"});
		 * 		
		 * 		// pass it to stage.update():
		 * 		myStage.update(evt); // subsequently calls tick() with the same param
		 * 	}
		 * 	
		 * 	// ...
		 * 	myDisplayObject.on("tick", handleDisplayObjectTick);
		 * 	function handleDisplayObjectTick(evt) {
		 * 		console.log(evt.delta); // the delta property from the Ticker tick event object
		 * 		console.log(evt.greeting, evt.name); // custom data: "hello world"
		 * 	}
		 * 
		 * @method tick
		 * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
		 **/
		p.tick = function(props) {
			if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }
			var evtObj = new createjs.Event("tick");
			if (props) {
				for (var n in props) {
					if (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }
				}
			}
			this._tick(evtObj);
			this.dispatchEvent("tickend");
		};
	
		/**
		 * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}
		 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}
		 * directly, using:
		 *
		 *      Ticker.addEventListener("tick", myStage);
		 *
		 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
		 * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.
		 * @property handleEvent
		 * @type Function
		 **/
		p.handleEvent = function(evt) {
			if (evt.type == "tick") { this.update(evt); }
		};
	
		/**
		 * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.
		 * @method clear
		 **/
		p.clear = function() {
			if (!this.canvas) { return; }
			var ctx = this.canvas.getContext("2d");
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
		};
	
		/**
		 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
		 * be specified as the src value of an image element.
		 * @method toDataURL
		 * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
		 * value is allowed. The default value is a transparent background.
		 * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type
		 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
		 * @return {String} a Base64 encoded image.
		 **/
		p.toDataURL = function(backgroundColor, mimeType) {
			var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;
	
			if (backgroundColor) {
				data = ctx.getImageData(0, 0, w, h);
				var compositeOperation = ctx.globalCompositeOperation;
				ctx.globalCompositeOperation = "destination-over";
				
				ctx.fillStyle = backgroundColor;
				ctx.fillRect(0, 0, w, h);
			}
	
			var dataURL = this.canvas.toDataURL(mimeType||"image/png");
	
			if(backgroundColor) {
				ctx.putImageData(data, 0, 0);
				ctx.globalCompositeOperation = compositeOperation;
			}
	
			return dataURL;
		};
	
		/**
		 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage's display list. These events can
		 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
		 * independently of mouse move events via the optional `frequency` parameter.
		 *
		 * <h4>Example</h4>
		 *
		 *      var stage = new createjs.Stage("canvasId");
		 *      stage.enableMouseOver(10); // 10 updates per second
		 *
		 * @method enableMouseOver
		 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
		 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
		 * responsive, but uses less CPU.
		 **/
		p.enableMouseOver = function(frequency) {
			if (this._mouseOverIntervalID) {
				clearInterval(this._mouseOverIntervalID);
				this._mouseOverIntervalID = null;
				if (frequency == 0) {
					this._testMouseOver(true);
				}
			}
			if (frequency == null) { frequency = 20; }
			else if (frequency <= 0) { return; }
			var o = this;
			this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
		};
	
		/**
		 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
		 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
		 * events from the page.
		 *
		 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
		 * new canvas or mouse events will not work as expected. For example:
		 *
		 *      myStage.enableDOMEvents(false);
		 *      myStage.canvas = anotherCanvas;
		 *      myStage.enableDOMEvents(true);
		 *
		 * @method enableDOMEvents
		 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
		 **/
		p.enableDOMEvents = function(enable) {
			if (enable == null) { enable = true; }
			var n, o, ls = this._eventListeners;
			if (!enable && ls) {
				for (n in ls) {
					o = ls[n];
					o.t.removeEventListener(n, o.f, false);
				}
				this._eventListeners = null;
			} else if (enable && !ls && this.canvas) {
				var t = window.addEventListener ? window : document;
				var _this = this;
				ls = this._eventListeners = {};
				ls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
				ls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
				ls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };
				ls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };
	
				for (n in ls) {
					o = ls[n];
					o.t.addEventListener(n, o.f, false);
				}
			}
		};
	
		/**
		 * Stage instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			throw("Stage cannot be cloned.");
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Stage (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * @method _getElementRect
		 * @protected
		 * @param {HTMLElement} e
		 **/
		p._getElementRect = function(e) {
			var bounds;
			try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
			catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }
	
			var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
			var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);
	
			var styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.
			var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
			var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
			var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
			var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);
	
			// note: in some browsers bounds properties are read only.
			return {
				left: bounds.left+offX+padL,
				right: bounds.right+offX-padR,
				top: bounds.top+offY+padT,
				bottom: bounds.bottom+offY-padB
			}
		};
	
		/**
		 * @method _getPointerData
		 * @protected
		 * @param {Number} id
		 **/
		p._getPointerData = function(id) {
			var data = this._pointerData[id];
			if (!data) { data = this._pointerData[id] = {x:0,y:0}; }
			return data;
		};
	
		/**
		 * @method _handleMouseMove
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseMove = function(e) {
			if(!e){ e = window.event; }
			this._handlePointerMove(-1, e, e.pageX, e.pageY);
		};
	
		/**
		 * @method _handlePointerMove
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerMove = function(id, e, pageX, pageY, owner) {
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			if (!this.canvas) { return; }
			var nextStage=this._nextStage, o=this._getPointerData(id);
	
			var inBounds = o.inBounds;
			this._updatePointerPosition(id, e, pageX, pageY);
			if (inBounds || o.inBounds || this.mouseMoveOutside) {
				if (id === -1 && o.inBounds == !inBounds) {
					this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
				}
				
				this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
				this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
			}
			
			nextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);
		};
	
		/**
		 * @method _updatePointerPosition
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 **/
		p._updatePointerPosition = function(id, e, pageX, pageY) {
			var rect = this._getElementRect(this.canvas);
			pageX -= rect.left;
			pageY -= rect.top;
	
			var w = this.canvas.width;
			var h = this.canvas.height;
			pageX /= (rect.right-rect.left)/w;
			pageY /= (rect.bottom-rect.top)/h;
			var o = this._getPointerData(id);
			if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {
				o.x = pageX;
				o.y = pageY;
			} else if (this.mouseMoveOutside) {
				o.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);
				o.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);
			}
	
			o.posEvtObj = e;
			o.rawX = pageX;
			o.rawY = pageY;
	
			if (id === this._primaryPointerID || id === -1) {
				this.mouseX = o.x;
				this.mouseY = o.y;
				this.mouseInBounds = o.inBounds;
			}
		};
	
		/**
		 * @method _handleMouseUp
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseUp = function(e) {
			this._handlePointerUp(-1, e, false);
		};
	
		/**
		 * @method _handlePointerUp
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Boolean} clear
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerUp = function(id, e, clear, owner) {
			var nextStage = this._nextStage, o = this._getPointerData(id);
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			
			var target=null, oTarget = o.target;
			if (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
			
			if (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }
			
			if (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }
			this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
			
			if (clear) {
				if (id==this._primaryPointerID) { this._primaryPointerID = null; }
				delete(this._pointerData[id]);
			} else { o.target = null; }
			
			nextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);
		};
	
		/**
		 * @method _handleMouseDown
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseDown = function(e) {
			this._handlePointerDown(-1, e, e.pageX, e.pageY);
		};
	
		/**
		 * @method _handlePointerDown
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerDown = function(id, e, pageX, pageY, owner) {
			if (this.preventSelection) { e.preventDefault(); }
			if (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.
			
			if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
			var target = null, nextStage = this._nextStage, o = this._getPointerData(id);
			if (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
	
			if (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }
			this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
			
			nextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);
		};
	
		/**
		 * @method _testMouseOver
		 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 * @param {Stage} eventTarget The stage that the cursor is actively over.
		 * @protected
		 **/
		p._testMouseOver = function(clear, owner, eventTarget) {
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			
			var nextStage = this._nextStage;
			if (!this._mouseOverIntervalID) {
				// not enabled for mouseover, but should still relay the event.
				nextStage&&nextStage._testMouseOver(clear, owner, eventTarget);
				return;
			}
			var o = this._getPointerData(-1);
			// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
			if (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }
			
			var e = o.posEvtObj;
			var isEventTarget = eventTarget || e&&(e.target == this.canvas);
			var target=null, common = -1, cursor="", t, i, l;
			
			if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
				target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
				this._mouseOverX = this.mouseX;
				this._mouseOverY = this.mouseY;
			}
	
			var oldList = this._mouseOverTarget||[];
			var oldTarget = oldList[oldList.length-1];
			var list = this._mouseOverTarget = [];
	
			// generate ancestor list and check for cursor:
			t = target;
			while (t) {
				list.unshift(t);
				if (!cursor) { cursor = t.cursor; }
				t = t.parent;
			}
			this.canvas.style.cursor = cursor;
			if (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }
	
			// find common ancestor:
			for (i=0,l=list.length; i<l; i++) {
				if (list[i] != oldList[i]) { break; }
				common = i;
			}
	
			if (oldTarget != target) {
				this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
			}
	
			for (i=oldList.length-1; i>common; i--) {
				this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
			}
	
			for (i=list.length-1; i>common; i--) {
				this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
			}
	
			if (oldTarget != target) {
				this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
			}
			
			nextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);
		};
	
		/**
		 * @method _handleDoubleClick
		 * @protected
		 * @param {MouseEvent} e
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handleDoubleClick = function(e, owner) {
			var target=null, nextStage=this._nextStage, o=this._getPointerData(-1);
			if (!owner) {
				target = this._getObjectsUnderPoint(o.x, o.y, null, true);
				this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
			}
			nextStage&&nextStage._handleDoubleClick(e, owner || target && this);
		};
	
		/**
		 * @method _dispatchMouseEvent
		 * @protected
		 * @param {DisplayObject} target
		 * @param {String} type
		 * @param {Boolean} bubbles
		 * @param {Number} pointerId
		 * @param {Object} o
		 * @param {MouseEvent} [nativeEvent]
		 * @param {DisplayObject} [relatedTarget]
		 **/
		p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
			// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
			if (!target || (!bubbles && !target.hasEventListener(type))) { return; }
			/*
			// TODO: account for stage transformations?
			this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
			var pt = this._mtx.transformPoint(o.x, o.y);
			var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
			*/
			var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
			target.dispatchEvent(evt);
		};
	
	
		createjs.Stage = createjs.promote(Stage, "Container");
	}());
	
	//##############################################################################
	// StageGL.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/*
	 * README IF EDITING:
	 * Terminology for developers:
	 *
	 * Vertex: a point that help defines a shape, 3 per triangle. Usually has an x,y,z but can have more/less info.
	 * Vertex Property: a piece of information attached to the vertex like a vector3 containing x,y,z
	 * Index/Indices: used in groups of 3 to define a triangle, points to vertices by their index in an array (some render
	 * 		modes do not use these)
	 * Card: a group of 2 triangles used to display a rectangular image
	 * U/V: common names for the [0-1] texture co-ordinates on an image
	 * Batch: a single call to the renderer, best done as little as possible so multiple cards are put into a single batch
	 * Buffer: WebGL array data
	 * Program/Shader: For every vertex we run the Vertex shader. The results are used per pixel by the Fragment shader. When
	 * 		combined and paired these are a shader "program"
	 * Texture: WebGL representation of image data and associated extra information
	 * Slot: A space on the GPU into which textures can be loaded for use in a batch, using "ActiveTexture" switches texture slot.
	 */
	
	(function () {
		"use strict";
	
		/**
		 * A StageGL instance is the root level {{#crossLink "Container"}}{{/crossLink}} for an WebGL-optimized display list,
		 * which is used in place of the usual {{#crossLink "Stage"}}{{/crossLink}}. This class should behave identically to
		 * a {{#crossLink "Stage"}}{{/crossLink}} except for WebGL-specific functionality.
		 *
		 * Each time the {{#crossLink "Stage/tick"}}{{/crossLink}} method is called, the display list is rendered to the
		 * target &lt;canvas/&gt; instance, ignoring non-WebGL-compatible display objects. On devices and browsers that don't
		 * support WebGL, content will automatically be rendered to canvas 2D context instead.
		 *
		 * <h4>Limitations</h4>
		 * - {{#crossLink "Shape"}}{{/crossLink}}, {{#crossLink "Shadow"}}{{/crossLink}}, and {{#crossLink "Text"}}{{/crossLink}}
		 * 	are not rendered when added to the display list.
		 * - To display something StageGL cannot render, {{#crossLink "displayObject/cache"}}{{/crossLink}} the object.
		 *	Caches can be rendered regardless of source.
		 * - Images are wrapped as a webGL "Texture". Each graphics card has a limit to its concurrent Textures, too many 
		 * Textures will noticeably slow performance.
		 * - Each cache counts as an individual Texture. As such {{#crossLink "SpriteSheet"}}{{/crossLink}} and 
		 * {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}} are recommended practices to help keep texture counts low.
		 * - To use any image node (DOM Image/Canvas Element) between multiple StageGL instances it must be a 
		 * {{#crossLink "Bitmap/clone"}}{{/crossLink}}, otherwise the GPU texture loading and tracking will get confused.
		 * - to avoid an up/down scaled render you must call {{#crossLink "StageGL/updateViewport"}}{{/crossLink}} if you
		 * resize your canvas after making a StageGL instance, this will properly size the WebGL context stored in memory.
		 * - Best performance in demanding scenarios will come from manual management of texture memory, but it is handled
		 * automatically by default. See {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}} for details.
		 *
		 * <h4>Example</h4>
		 * This example creates a StageGL instance, adds a child to it, then uses the EaselJS {{#crossLink "Ticker"}}{{/crossLink}}
		 * to update the child and redraw the stage.
		 *
		 *      var stage = new createjs.StageGL("canvasElementId");
		 *
		 *      var image = new createjs.Bitmap("imagePath.png");
		 *      stage.addChild(image);
		 *
		 *      createjs.Ticker.on("tick", handleTick);
		 *
		 *      function handleTick(event) {
		 *          image.x += 10;
		 *          stage.update();
		 *      }
		 *
		 * <h4>Notes</h4>
		 * - StageGL is not currently included in the minified version of EaselJS.
		 * - {{#crossLink "SpriteContainer"}}{{/crossLink}} (the previous approach to WebGL with EaselJS) has been deprecated.
		 * - Earlier versions of WebGL support in EaselJS (SpriteStage and SpriteContainer) had hard limitations on images
		 * 	per container, which have been solved.
		 *
		 * @class StageGL
		 * @extends Stage
		 * @constructor
		 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that StageGL will render to, or the string id
		 *  of a canvas object in the current DOM.
		 * @param {Object} options All the option parameters in a reference object, some are not supported by some browsers.
		 * @param {Boolean} [options.preserveBuffer=false] If `true`, the canvas is NOT auto-cleared by WebGL (the spec
		 *  discourages setting this to `true`). This is useful if you want persistent draw effects.
		 * @param {Boolean} [options.antialias=false] Specifies whether or not the browser's WebGL implementation should try
		 *  to perform anti-aliasing. This will also enable linear pixel sampling on power-of-two textures (smoother images).
		 * @param {Boolean} [options.transparent=false] If `true`, the canvas is transparent. This is <strong>very</strong>
		 * expensive, and should be used with caution.
		 * @param {Boolean} [options.premultiply=false] Alters color handling. If `true`, this assumes the shader must
		 * account for pre-multiplied alpha. This can help avoid visual halo effects with some assets, but may also cause
		 * problems with other assets.
		 * @param {Integer} [options.autoPurge=1200] How often the system should automatically dump unused textures with
		 * `purgeTextures(autoPurge)` every `autoPurge/2` draws. See {{#crossLink "StageGL/purgeTextures"}}{{/crossLink}} for more
		 * information.
		 */
		function StageGL(canvas, options) {
			this.Stage_constructor(canvas);
	
			if (options !== undefined) {
				if (typeof options !== "object"){ throw("Invalid options object"); }
				var premultiply = options.premultiply;
				var transparent = options.transparent;
				var antialias = options.antialias;
				var preserveBuffer = options.preserveBuffer;
				var autoPurge = options.autoPurge;
			}
	
	// public properties:
			/**
			 * Console log potential issues and problems. This is designed to have <em>minimal</em> performance impact, so
			 * if extensive debugging information is required, this may be inadequate. See {{#crossLink "WebGLInspector"}}{{/crossLink}}
			 * @property vocalDebug
			 * @type {Boolean}
			 * @default false
			 */
			this.vocalDebug = false;
	
	// private properties:
			/**
			 * Specifies whether or not the canvas is auto-cleared by WebGL. The WebGL spec discourages `true`.
			 * If true, the canvas is NOT auto-cleared by WebGL. Used when the canvas context is created and requires
			 * context re-creation to update.
			 * @property _preserveBuffer
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._preserveBuffer = preserveBuffer||false;
	
			/**
			 * Specifies whether or not the browser's WebGL implementation should try to perform anti-aliasing.
			 * @property _antialias
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._antialias = antialias||false;
	
			/**
			 * Specifies whether or not the browser's WebGL implementation should be transparent.
			 * @property _transparent
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._transparent = transparent||false;
	
			/**
			 * Specifies whether or not StageGL is handling colours as premultiplied alpha.
			 * @property _premultiply
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._premultiply = premultiply||false;
	
			/**
			 * Internal value of {{#crossLink "StageGL/autoPurge"}}{{/crossLink}}
			 * @property _autoPurge
			 * @protected
			 * @type {Integer}
			 * @default null
			 */
			this._autoPurge = undefined;
			this.autoPurge = autoPurge;	//getter/setter handles setting the real value and validating
	
			/**
			 * The width in px of the drawing surface saved in memory.
			 * @property _viewportWidth
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._viewportWidth = 0;
	
			/**
			 * The height in px of the drawing surface saved in memory.
			 * @property _viewportHeight
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._viewportHeight = 0;
	
			/**
			 * A 2D projection matrix used to convert WebGL's viewspace into canvas co-ordinates. Regular canvas display
			 * uses Top-Left values of [0,0] where WebGL uses a Center [0,0] Top-Right [1,1] (euclidean) system.
			 * @property _projectionMatrix
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._projectionMatrix = null;
	
			/**
			 * The current WebGL canvas context. Often shorthanded to just "gl" in many parts of the code.
			 * @property _webGLContext
			 * @protected
			 * @type {WebGLRenderingContext}
			 * @default null
			 */
			this._webGLContext = null;
	
			/**
			 * The color to use when the WebGL canvas has been cleared. May appear as a background color. Defaults to grey.
			 * @property _clearColor
			 * @protected
			 * @type {Object}
			 * @default {r: 0.50, g: 0.50, b: 0.50, a: 0.00}
			 */
			this._clearColor = {r: 0.50, g: 0.50, b: 0.50, a: 0.00};
	
			/**
			 * The maximum number of cards (aka a single sprite) that can be drawn in one draw call. Use getter/setters to
			 * modify otherwise internal buffers may be incorrect sizes.
			 * @property _maxCardsPerBatch
			 * @protected
			 * @type {Number}
			 * @default StageGL.DEFAULT_MAX_BATCH_SIZE (10000)
			 */
			this._maxCardsPerBatch = StageGL.DEFAULT_MAX_BATCH_SIZE;														//TODO: write getter/setters for this
	
			/**
			 * The shader program used to draw the current batch.
			 * @property _activeShader
			 * @protected
			 * @type {WebGLProgram}
			 * @default null
			 */
			this._activeShader = null;
	
			/**
			 * The vertex position data for the current draw call.
			 * @property _vertices
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._vertices = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_vertices:property"}}{{/crossLink}}.
			 * @property _vertexPositionBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._vertexPositionBuffer = null;
	
			/**
			 * The vertex U/V data for the current draw call.
			 * @property _uvs
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._uvs = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_uvs:property"}}{{/crossLink}}.
			 * @property _uvPositionBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._uvPositionBuffer = null;
	
			/**
			 * The vertex indices data for the current draw call.
			 * @property _indices
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._indices = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_indices:property"}}{{/crossLink}}.
			 * @property _textureIndexBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._textureIndexBuffer = null;
	
			/**
			 * The vertices data for the current draw call.
			 * @property _alphas
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._alphas = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_alphas:property"}}{{/crossLink}}.
			 * @property _alphaBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._alphaBuffer = null;
	
			/**
			 * An index based lookup of every WebGL Texture currently in use.
			 * @property _drawTexture
			 * @protected
			 * @type {Array}
			 */
			this._textureDictionary = [];
	
			/**
			 * A string based lookup hash of which index a texture is stored at in the dictionary. The lookup string is
			 * often the src url.
			 * @property _textureIDs
			 * @protected
			 * @type {Object}
			 */
			this._textureIDs = {};
	
			/**
			 * An array of all the textures currently loaded into the GPU. The index in the array matches the GPU index.
			 * @property _batchTextures
			 * @protected
			 * @type {Array}
			 */
			this._batchTextures = [];
	
			/**
			 * An array of all the simple filler textures used to prevent issues with missing textures in a batch.
			 * @property _baseTextures
			 * @protected
			 * @type {Array}
			 */
			this._baseTextures = [];
	
			/**
			 * The number of concurrent textures the GPU can handle. This value is dynamically set from WebGL during initialization
			 * via `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)`. The WebGL spec states that the lowest guaranteed value is 8,
			 * but it could be higher. Do not set this value higher than the value returned by the GPU. Setting it lower will
			 * probably reduce performance, but may be advisable to reserve slots for custom filter work.
			 * NOTE: Can also act as a length for {{#crossLink "StageGL/_batchTextures:property"}}.
			 * @property _batchTextureCount
			 * @protected
			 * @type {Number}
			 * @default 8
			 */
			this._batchTextureCount = 8;
	
			/**
			 * The location at which the last texture was inserted into a GPU slot in {{#crossLink "StageGL/_batchTextures:property"}}{{/crossLink}}.
			 * Manual control of this variable can yield improvements in performance by intelligently replacing textures
			 * inside a batch to reduce texture re-load. It is impossible to write automated general use code, as it requires
			 * display list look ahead inspection and/or render foreknowledge.
			 * @property _lastTextureInsert
			 * @protected
			 * @type {Number}
			 * @default -1
			 */
			this._lastTextureInsert = -1;
	
			/**
			 * The current batch being drawn, A batch consists of a call to `drawElements` on the GPU. Many of these calls
			 * can occur per draw.
			 * @property _batchId
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._batchID = 0;
	
			/**
			 * The current draw being performed, may contain multiple batches. Comparing to {{#crossLink "StageGL/_batchID:property"}}{{/crossLink}}
			 * can reveal batching efficiency.
			 * @property _drawID
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._drawID = 0;
	
			/**
			 * Used to prevent textures in certain GPU slots from being replaced by an insert.
			 * @property _slotBlackList
			 * @protected
			 * @type {Array}
			 */
			this._slotBlacklist = [];
	
			/**
			 * Used to prevent nested draw calls from accidentally overwriting drawing information by tracking depth.
			 * @property _isDrawing
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._isDrawing = 0;
	
			/**
			 * Used to ensure every canvas used as a texture source has a unique ID.
			 * @property _lastTrackedCanvas
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._lastTrackedCanvas = 0;
	
			/**
			 * Controls whether final rendering output of a {{#crossLink "cacheDraw"}}{{/crossLink}} is the canvas or a render
			 * texture. See the {{#crossLink "cache"}}{{/crossLink}} function modifications for full implications and discussion.
			 * @property isCacheControlled
			 * @protected
			 * @type {Boolean}
			 * @default false
			 * @todo LM: is this supposed to be _isCacheControlled since its private?
			 */
			this.isCacheControlled = false;
	
			/**
			 * Used to counter-position the object being cached so it aligns with the cache surface. Additionally ensures
			 * that all rendering starts with a top level container.
			 * @property _cacheContainer
			 * @protected
			 * @type {Container}
			 * @default An instance of an EaselJS Container.
			 */
			this._cacheContainer = new createjs.Container();
	
			// and begin
			this._initializeWebGL();
		}
		var p = createjs.extend(StageGL, createjs.Stage);
	
	// static methods:
		/**
		 * Calculate the U/V co-ordinate based info for sprite frames. Instead of pixel count it uses a 0-1 space. Also includes
		 * the ability to get info back for a specific frame, or only calculate that one frame.
		 *
		 *     //generate UV rects for all entries
		 *     StageGL.buildUVRects( spriteSheetA );
		 *     //generate all, fetch the first
		 *     var firstFrame = StageGL.buildUVRects( spriteSheetB, 0 );
		 *     //generate the rect for just a single frame for performance's sake
		 *     var newFrame = StageGL.buildUVRects( dynamicSpriteSheet, newFrameIndex, true );
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method buildUVRects
		 * @param  {SpriteSheet} spritesheet The spritesheet to find the frames on
		 * @param  {int} [target=-1] The index of the frame to return
		 * @param  {Boolean} [onlyTarget=false] Whether "target" is the only frame that gets calculated
		 * @static
		 * @return {Object} the target frame if supplied and present or a generic frame {t, l, b, r}
		 */
		StageGL.buildUVRects = function (spritesheet, target, onlyTarget) {
			if (!spritesheet || !spritesheet._frames) { return null; }
			if (target === undefined) { target = -1; }
			if (onlyTarget === undefined) { onlyTarget = false; }
	
			var start = (target != -1 && onlyTarget)?(target):(0);
			var end = (target != -1 && onlyTarget)?(target+1):(spritesheet._frames.length);
			for (var i=start; i<end; i++) {
				var f = spritesheet._frames[i];
				if (f.uvRect || f.image.width <= 0 || f.image.height <= 0) { continue; }
	
				var r = f.rect;
				f.uvRect = {
					t: r.y / f.image.height,
					l: r.x / f.image.width,
					b: (r.y + r.height) / f.image.height,
					r: (r.x + r.width) / f.image.width
				};
			}
	
			return spritesheet._frames[(target != -1) ? target : 0].uvRect || {t:0, l:0, b:1, r:1};
		};
	
		/**
		 * Test a context to see if it has WebGL enabled on it.
		 * @method isWebGLActive
		 * @param {CanvasContext} ctx The context to test
		 * @static
		 * @return {Boolean} Whether WebGL is enabled
		 */
		StageGL.isWebGLActive = function (ctx) {
			return ctx &&
				ctx instanceof WebGLRenderingContext &&
				typeof WebGLRenderingContext !== 'undefined';
		};
	
	// static properties:
		/**
		 * The number of properties defined per vertex (x, y, textureU, textureV, textureIndex, alpha)
		 * @property VERTEX_PROPERTY_COUNT
		 * @static
		 * @final
		 * @type {Number}
		 * @default 6
		 * @readonly
		 */
		StageGL.VERTEX_PROPERTY_COUNT = 6;
	
		/**
		 * The number of triangle indices it takes to form a Card. 3 per triangle, 2 triangles.
		 * @property INDICIES_PER_CARD
		 * @static
		 * @final
		 * @type {Number}
		 * @default 6
		 * @readonly
		 */
		StageGL.INDICIES_PER_CARD = 6;
	
		/**
		 * The default value for the maximum number of cards we want to process in a batch. See
		 * {{#crossLink "StageGL/WEBGL_MAX_INDEX_NUM:property"}}{{/crossLink}} for a hard limit.
		 * @property DEFAULT_MAX_BATCH_SIZE
		 * @static
		 * @final
		 * @type {Number}
		 * @default 10000
		 * @readonly
		 */
		StageGL.DEFAULT_MAX_BATCH_SIZE = 10000;
	
		/**
		 * The maximum size WebGL allows for element index numbers. Uses a 16 bit unsigned integer. It takes 6 indices to
		 * make a unique card.
		 * @property WEBGL_MAX_INDEX_NUM
		 * @static
		 * @final
		 * @type {Number}
		 * @default 65536
		 * @readonly
		 */
		StageGL.WEBGL_MAX_INDEX_NUM = Math.pow(2, 16);
	
		/**
		 * Default U/V rect for dealing with full coverage from an image source.
		 * @property UV_RECT
		 * @static
		 * @final
		 * @type {Object}
		 * @default {t:0, l:0, b:1, r:1}
		 * @readonly
		 */
		StageGL.UV_RECT = {t:0, l:0, b:1, r:1};
	
		/**
		 * Vertex positions for a card that covers the entire render. Used with render targets primarily.
		 * @property COVER_VERT
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_VERT = new Float32Array([
			-1,		 1,		//TL
			1,		 1,		//TR
			-1,		-1,		//BL
			1,		 1,		//TR
			1,		-1,		//BR
			-1,		-1		//BL
		]);
	
		/**
		 * U/V for {{#crossLink "StageGL/COVER_VERT:property"}}{{/crossLink}}.
		 * @property COVER_UV
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_UV = new Float32Array([
			 0,		 0,		//TL
			 1,		 0,		//TR
			 0,		 1,		//BL
			 1,		 0,		//TR
			 1,		 1,		//BR
			 0,		 1		//BL
		]);
	
		/**
		 * Flipped U/V for {{#crossLink "StageGL:COVER_VERT:property"}}{{/crossLink}}.
		 * @property COVER_UV_FLIP
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_UV_FLIP = new Float32Array([
			 0,		 1,		//TL
			 1,		 1,		//TR
			 0,		 0,		//BL
			 1,		 1,		//TR
			 1,		 0,		//BR
			 0,		 0		//BL
		]);
	
		/**
		 * Portion of the shader that contains the "varying" properties required in both vertex and fragment shaders. The
		 * regular shader is designed to render all expected objects. Shader code may contain templates that are replaced
		 * pre-compile.
		 * @property REGULAR_VARYING_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VARYING_HEADER = (
			"precision mediump float;" +
			"varying vec2 vTextureCoord;" +
			"varying lowp float indexPicker;" +
			"varying lowp float alphaValue;"
		);
	
		/**
		 * Actual full header for the vertex shader. Includes the varying header. The regular shader is designed to render
		 * all expected objects. Shader code may contain templates that are replaced pre-compile.
		 * @property REGULAR_VERTEX_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VERTEX_HEADER = (
			StageGL.REGULAR_VARYING_HEADER +
			"attribute vec2 vertexPosition;" +
			"attribute vec2 uvPosition;" +
			"attribute lowp float textureIndex;" +
			"attribute lowp float objectAlpha;" +
			"uniform mat4 pMatrix;"
		);
	
		/**
		 * Actual full header for the fragment shader. Includes the varying header. The regular shader is designed to render
		 * all expected objects. Shader code may contain templates that are replaced pre-compile.
		 * @property REGULAR_FRAGMENT_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_FRAGMENT_HEADER = (
			StageGL.REGULAR_VARYING_HEADER +
			"uniform sampler2D uSampler[{{count}}];"
		);
	
		/**
		 * Body of the vertex shader. The regular shader is designed to render all expected objects. Shader code may contain
		 * templates that are replaced pre-compile.
		 * @property REGULAR_VERTEX_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VERTEX_BODY  = (
			"void main(void) {" +
				//DHG TODO: This doesn't work. Must be something wrong with the hand built matrix see js... bypass for now
				//vertexPosition, round if flag
				//"gl_Position = pMatrix * vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);" +
				"gl_Position = vec4("+
					"(vertexPosition.x * pMatrix[0][0]) + pMatrix[3][0]," +
					"(vertexPosition.y * pMatrix[1][1]) + pMatrix[3][1]," +
					"pMatrix[3][2]," +
					"1.0" +
				");" +
				"alphaValue = objectAlpha;" +
				"indexPicker = textureIndex;" +
				"vTextureCoord = uvPosition;" +
			"}"
		);
	
		/**
		 * Body of the fragment shader. The regular shader is designed to render all expected objects. Shader code may
		 * contain templates that are replaced pre-compile.
		 * @property REGULAR_FRAGMENT_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_FRAGMENT_BODY = (
			"void main(void) {" +
				"vec4 color = vec4(1.0, 0.0, 0.0, 1.0);" +
	
				"if (indexPicker <= 0.5) {" +
					"color = texture2D(uSampler[0], vTextureCoord);" +
					"{{alternates}}" +
				"}" +
	
				"gl_FragColor = vec4(color.rgb{{premultiply}}, color.a * alphaValue);" +
			"}"
		);
	
		//TODO: DHG: a real particle shader
		/**
		 * @property PARTICLE_VERTEX_BODY
		 * @todo
		 * @final
		 * @static
		 * @type {String}
		 * @readonly
		 */
		StageGL.PARTICLE_VERTEX_BODY = (
			StageGL.REGULAR_VERTEX_BODY
		);
		/**
		 * @property PARTICLE_FRAGMENT_BODY
		 * @todo
		 * @final
		 * @static
		 * @type {String}
		 * @readonly
		 */
		StageGL.PARTICLE_FRAGMENT_BODY = (
			StageGL.REGULAR_FRAGMENT_BODY
		);
	
		/**
		 * Portion of the shader that contains the "varying" properties required in both vertex and fragment shaders. The
		 * cover shader is designed to be a simple vertex/uv only texture render that covers the render surface. Shader
		 * code may contain templates that are replaced pre-compile.
		 * @property COVER_VARYING_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VARYING_HEADER = (
			"precision mediump float;" +
	
			"varying highp vec2 vRenderCoord;" +
			"varying highp vec2 vTextureCoord;"
		);
	
		/**
		 * Actual full header for the vertex shader. Includes the varying header. The cover shader is designed to be a
		 * simple vertex/uv only texture render that covers the render surface. Shader code may contain templates that are
		 * replaced pre-compile.
		 * @property COVER_VERTEX_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VERTEX_HEADER = (
			StageGL.COVER_VARYING_HEADER +
			"attribute vec2 vertexPosition;" +
			"attribute vec2 uvPosition;" +
			"uniform float uUpright;"
		);
	
		/**
		 * Actual full header for the fragment shader. Includes the varying header. The cover shader is designed to be a
		 * simple vertex/uv only texture render that covers the render surface. Shader code may contain templates that are
		 * replaced pre-compile.
		 * @property COVER_FRAGMENT_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_FRAGMENT_HEADER = (
			StageGL.COVER_VARYING_HEADER +
			"uniform sampler2D uSampler;"
		);
	
		/**
		 * Body of the vertex shader. The cover shader is designed to be a simple vertex/uv only texture render that covers
		 * the render surface. Shader code may contain templates that are replaced pre-compile.
		 * @property COVER_VERTEX_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VERTEX_BODY  = (
			"void main(void) {" +
				"gl_Position = vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);" +
				"vRenderCoord = uvPosition;" +
				"vTextureCoord = vec2(uvPosition.x, abs(uUpright - uvPosition.y));" +
			"}"
		);
	
		/**
		 * Body of the fragment shader. The cover shader is designed to be a simple vertex/uv only texture render that
		 * covers the render surface. Shader code may contain templates that are replaced pre-compile.
		 * @property COVER_FRAGMENT_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_FRAGMENT_BODY = (
			"void main(void) {" +
				"vec4 color = texture2D(uSampler, vRenderCoord);" +
				"gl_FragColor = color;" +
			"}"
		);
	
	// events:
		/**
		 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it. You can call
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}} on the event to cancel the draw.
		 * @event drawstart
		 */
	
		/**
		 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
		 * @event drawend
		 */
	
	// getter / setters:
		p._get_isWebGL = function () {
			return !!this._webGLContext;
		};
	
		p._set_autoPurge = function (value) {
			value = isNaN(value)?1200:value;
			if (value != -1) {
				value = value<10?10:value;
			}
			this._autoPurge = value;
		};
		p._get_autoPurge = function () {
			return Number(this._autoPurge);
		};
	
		try {
			Object.defineProperties(p, {
				/**
				 * Indicates whether WebGL is being used for rendering. For example, this would be `false` if WebGL is not
				 * supported in the browser.
				 * @property isWebGL
				 * @type {Boolean}
				 * @readonly
				 */
				isWebGL: { get: p._get_isWebGL },
	
				/**
				 * Specifies whether or not StageGL is automatically purging unused textures. Higher numbers purge less
				 * often. Values below 10 are upgraded to 10, and -1 disables this feature.
				 * @property autoPurge
				 * @protected
				 * @type {Integer}
				 * @default 1000
				 */
				autoPurge: { get: p._get_autoPurge, set: p._set_autoPurge }
			});
		} catch (e) {} // TODO: use Log
	
	
	// constructor methods:
		/**
		 * Create and properly initialize the WebGL instance.
		 * @method _initializeWebGL
		 * @protected
		 * @return {WebGLRenderingContext}
		 */
		p._initializeWebGL = function () {
			if (this.canvas) {
				if (!this._webGLContext || this._webGLContext.canvas !== this.canvas) {
					// A context hasn't been defined yet,
					// OR the defined context belongs to a different canvas, so reinitialize.
	
					// defaults and options
					var options = {
						depth: false, // Disable the depth buffer as it isn't used.
						alpha: this._transparent, // Make the canvas background transparent.
						stencil: true,
						antialias: this._antialias,
						premultipliedAlpha: this._premultiply, // Assume the drawing buffer contains colors with premultiplied alpha.
						preserveDrawingBuffer: this._preserveBuffer
					};
	
					var gl = this._webGLContext = this._fetchWebGLContext(this.canvas, options);
					if (!gl) { return null; }
	
					this.updateSimultaneousTextureCount(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
					this._maxTextureSlots = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
					this._createBuffers(gl);
					this._initTextures(gl);
	
					gl.disable(gl.DEPTH_TEST);
					gl.enable(gl.BLEND);
					gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
					gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiply);
					//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
	
					this._webGLContext.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
					this.updateViewport(this._viewportWidth || this.canvas.width, this._viewportHeight || this.canvas.height);
				}
			} else {
				this._webGLContext = null;
			}
			return this._webGLContext;
		};
	
	// public methods:
		/**
		 * Docced in superclass
		 */
		p.update = function (props) {
			if (!this.canvas) { return; }
			if (this.tickOnUpdate) { this.tick(props); }
			this.dispatchEvent("drawstart");
			if (this.autoClear) { this.clear(); }
	
			if (this._webGLContext) {
				// Use WebGL.
				this._batchDraw(this, this._webGLContext);
				if (this._autoPurge != -1 && !(this._drawID%((this._autoPurge/2)|0))) {
					this.purgeTextures(this._autoPurge);
				}
			} else {
				// Use 2D.
				var ctx = this.canvas.getContext("2d");
				ctx.save();
				this.updateContext(ctx);
				this.draw(ctx, false);
				ctx.restore();
			}
			this.dispatchEvent("drawend");
		};
	
		/**
		 * Docced in superclass
		 */
		p.clear = function () {
			if (!this.canvas) { return; }
			if (StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				var cc = this._clearColor;
				var adjust = this._transparent ? cc.a : 1.0;
				// Use WebGL settings; adjust for pre multiplied alpha appropriate to scenario
				this._webGLContext.clearColor(cc.r * adjust, cc.g * adjust, cc.b * adjust, adjust);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._webGLContext.clearColor(cc.r, cc.g, cc.b, cc.a);
			} else {
				// Use 2D.
				this.Stage_clear();
			}
		};
	
		/**
		 * Draws the stage into the supplied context if possible. Many WebGL properties only exist on their context. As such
		 * you cannot share contexts among many StageGLs and each context requires a unique StageGL instance. Contexts that
		 * don't match the context managed by this StageGL will be treated as a 2D context.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D | WebGLRenderingContext} context The context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For
		 *  example, used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean} If the draw was handled by this function
		 */
		p.draw = function (context, ignoreCache) {
			if (context === this._webGLContext && StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				this._batchDraw(this, gl, ignoreCache);
				return true;
			} else {
				return this.Stage_draw(context, ignoreCache);
			}
		};
	
		/**
		 * Draws the target into the correct context, be it a canvas or Render Texture using WebGL.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method cacheDraw
		 * @param {DisplayObject} target The object we're drawing into cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 * @return {Boolean} If the draw was handled by this function
		 */
		p.cacheDraw = function (target, filters, manager) {
			if (StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				this._cacheDraw(gl, target, filters, manager);
				return true;
			} else {
				return false;
			}
		};
	
		/**
		 * Blocks, or frees a texture "slot" on the GPU. Can be useful if you are overflowing textures. When overflowing
		 * textures they are re-uploaded to the GPU every time they're encountered, this can be expensive with large textures.
		 * By blocking the slot you reduce available slots, potentially increasing draw calls, but mostly you prevent a
		 * texture being re-uploaded if it would have moved slots due to overflow.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * For example, block the slot a background image is stored in so there is less re-loading of that image.
		 * @method protectTextureSlot
		 * @param  {Number} id The slot to be affected
		 * @param  {Boolean} [lock=false] Whether this slot is the one being locked.
		 */
		p.protectTextureSlot = function (id, lock) {
			if (id > this._maxTextureSlots || id < 0) {
				throw "Slot outside of acceptable range";
			}
			this._slotBlacklist[id] = !!lock;
		};
	
		/**
		 * Render textures can't draw into themselves so any item being used for renderTextures needs two to alternate between.
		 * This function creates, gets, and toggles the render surface between the two.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method getTargetRenderTexture
		 * @param  {DisplayObject} target The object associated with the render textures, usually a cached object.
		 * @param  {Number} w The width to create the texture at.
		 * @param  {Number} h The height to create the texture at.
		 * @return {Objet}
		 * @todo fill in return type
		 */
		p.getTargetRenderTexture = function (target, w, h) {
			var result, toggle = false;
			var gl = this._webGLContext;
			if (target.__lastRT !== undefined && target.__lastRT === target.__rtA) { toggle = true; }
			if (!toggle) {
				if (target.__rtA === undefined) {
					target.__rtA = this.getRenderBufferTexture(w, h);
				} else {
					if (w != target.__rtA._width || h != target.__rtA._height) {
						this.resizeTexture(target.__rtA, w, h);
					}
					this.setTextureParams(gl);
				}
				result = target.__rtA;
			} else {
				if (target.__rtB === undefined) {
					target.__rtB = this.getRenderBufferTexture(w, h);
				} else {
					if (w != target.__rtB._width || h != target.__rtB._height) {
						this.resizeTexture(target.__rtB, w, h);
					}
					this.setTextureParams(gl);
				}
				result = target.__rtB;
			}
			if (!result) {
				throw "Problems creating render textures, known causes include using too much VRAM by not releasing WebGL texture instances";
			}
			target.__lastRT = result;
			return result;
		};
	
		/**
		 * For every image encountered StageGL registers and tracks it automatically. This tracking can cause memory leaks 
		 * if not purged. StageGL, by default, automatically purges them. This does have a cost and may unfortunately find
		 * false positives. This function is for manual management of this memory instead of the automatic system controlled
		 * by the {{#crossLink "StageGL/autoPurge:property"}}{{/crossLink}} property.
		 *
		 * This function will recursively remove all textures found on the object, its children, cache, etc. It will uncache 
		 * objects and remove any texture it finds REGARDLESS of whether it is currently in use elsewhere. It is up to the
		 * developer to ensure that a texture in use is not removed.
		 *
		 * Textures in use, or to be used again shortly, should not be removed. This is simply for performance reasons.
		 * Removing a texture in use will cause the texture to have to be re-uploaded slowing rendering.
		 * @method releaseTexture
		 * @param  {DisplayObject | Texture | Image | Canvas} item An object that used the texture to be discarded.
		 */
		p.releaseTexture = function (item) {
			var i, l;
			if (!item) { return; }
	
			// this is a container object
			if (item.children) {
				for (i = 0, l = item.children.length; i < l; i++) {
					this.releaseTexture(item.children[i]);
				}
			}
	
			// this has a cache canvas
			if (item.cacheCanvas) {
				item.uncache();
			}
	
			var foundImage = undefined;
			if (item._storeID !== undefined) {
				// this is a texture itself
				if (item === this._textureDictionary[item._storeID]) {
					this._killTextureObject(item);
					item._storeID = undefined;
					return;
				}
	
				// this is an image or canvas
				foundImage = item;
			} else if (item._webGLRenderStyle === 2) {
				// this is a Bitmap class
				foundImage = item.image;
			} else if (item._webGLRenderStyle === 1) {
				// this is a SpriteSheet, we can't tell which image we used from the list easily so remove them all!
				for (i = 0, l = item.spriteSheet._images.length; i < l; i++) {
					this.releaseTexture(item.spriteSheet._images[i]);
				}
				return;
			}
	
			// did we find anything
			if (foundImage === undefined) {
				if (this.vocalDebug) {
					console.log("No associated texture found on release");
				}
				return;
			}
	
			// remove it
			this._killTextureObject(this._textureDictionary[foundImage._storeID]);
			foundImage._storeID = undefined;
		};
	
		/**
		 * Similar to {{#crossLink "releaseTexture"}}{{/crossLink}}, but this function differs by searching for textures to
		 * release. It works by assuming that it can purge any texture which was last used more than "count" draw calls ago.
		 * Because this process is unaware of the objects and whether they may be used on your stage, false positives can
		 * occur. It is recommended to manually manage your memory with {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}},
		 * however, there are many use cases where this is simpler and error-free. This process is also run by default under
		 * the hood to prevent leaks. To disable it see the {{#crossLink "StageGL/autoPurge:property"}}{{/crossLink}} property.
		 * @method purgeTextures
		 * @param {Number} [count=100] How many renders ago the texture was last used
		 */
		p.purgeTextures = function (count) {
			if (count == undefined){ count = 100; }
	
			var dict = this._textureDictionary;
			var l = dict.length;
			for (var i= 0; i<l; i++) {
				var item = dict[i];
				if (!item) { continue; }
				if (item._drawID + count <= this._drawID) {	// use draw not batch as draw is more indicative of time
					this._killTextureObject(item);
				}
			}
		};
	
		/**
		 * Try to set the max textures the system can handle. It should default to the hardware maximum, and lower values
		 * may limit performance. Some devices have been known to mis-report their max textures, or you may need a standard
		 * baseline cross devices for testing. Barring the previous suggestions, there is little need to call this function
		 * as the library will automatically try to find the best value.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method updateSimultaneousTextureCount
		 * @param {Number} [count=1] The number of textures intended for simultaneous loading.
		 */
		p.updateSimultaneousTextureCount = function (count) {
			// TODO: DHG: make sure API works in all instances, may be some issues with buffers etc I haven't foreseen
			var gl = this._webGLContext;
			var success = false;
	
			if (count < 1 || isNaN(count)) { count = 1; }
			this._batchTextureCount = count;
	
			while (!success) {
				try {
					this._activeShader = this._fetchShaderProgram(gl);
					success = true;
				} catch(e) {
					if (this._batchTextureCount == 1) {
						throw "Cannot compile shader " + e;
					}
	
					this._batchTextureCount -= 4;
					if (this._batchTextureCount < 1) { this._batchTextureCount = 1; }
	
					if (this.vocalDebug) {
						console.log("Reducing desired texture count due to errors: " + this._batchTextureCount);
					}
				}
			}
		};
	
		/**
		 * Update the WebGL viewport. Note that this does <strong>not</strong> update the canvas element's width/height, but
		 * the render surface's instead. This is necessary after manually resizing the canvas element on the DOM to avoid a
		 * up/down scaled render.
		 * @method updateViewport
		 * @param {Integer} width The width of the render surface in pixels.
		 * @param {Integer} height The height of the render surface in pixels.
		 */
		p.updateViewport = function (width, height) {
			this._viewportWidth = width|0;
			this._viewportHeight = height|0;
			var gl = this._webGLContext;
	
			if (gl) {
				gl.viewport(0, 0, this._viewportWidth, this._viewportHeight);
	
				// WebGL works with a -1,1 space on its screen. It also follows Y-Up
				// we need to flip the y, scale and then translate the co-ordinates to match this
				// additionally we offset into they Y so the polygons are inside the camera's "clipping" plane
				this._projectionMatrix = new Float32Array([
					2 / this._viewportWidth,	0,								0,							0,
					0,							-2 / this._viewportHeight,		1,							0,
					0,							0,								1,							0,
					-1,							1,								0.1,						0
				]);
				// create the flipped version for use with render texture flipping
				// DHG: this would be a slice/clone but some platforms don't offer them for Float32Array
				this._projectionMatrixFlip = new Float32Array([0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]);
				this._projectionMatrixFlip.set(this._projectionMatrix);
				this._projectionMatrixFlip[5] *= -1;
				this._projectionMatrixFlip[13] *= -1;
			}
		};
	
		/**
		 * Fetches the shader compiled and set up to work with the provided filter/object. The shader is compiled on first
		 * use and returned on subsequent calls.
		 * @method getFilterShader
		 * @param  {Filter|Object} filter The object which will provide the information needed to construct the filter shader.
		 * @return {WebGLProgram}
		 */
		p.getFilterShader = function (filter) {
			if (!filter) { filter = this; }
	
			var gl = this._webGLContext;
			var targetShader = this._activeShader;
	
			if (filter._builtShader) {
				targetShader = filter._builtShader;
				if (filter.shaderParamSetup) {
					gl.useProgram(targetShader);
					filter.shaderParamSetup(gl, this, targetShader);
				}
			} else {
				try {
					targetShader = this._fetchShaderProgram(
						gl, "filter",
						filter.VTX_SHADER_BODY, filter.FRAG_SHADER_BODY,
						filter.shaderParamSetup && filter.shaderParamSetup.bind(filter)
					);
					filter._builtShader = targetShader;
					targetShader._name = filter.toString();
				} catch (e) {
					console && console.log("SHADER SWITCH FAILURE", e);
				}
			}
			return targetShader;
		};
	
		/**
		 * Returns a base texture that has no image or data loaded. Not intended for loading images. It may return `null`
		 * in some error cases, and trying to use a "null" texture can cause renders to fail.
		 * @method getBaseTexture
		 * @param  {uint} [w=1] The width of the texture in pixels, defaults to 1
		 * @param  {uint} [h=1] The height of the texture in pixels, defaults to 1
		 */
		p.getBaseTexture = function (w, h) {
			var width = Math.ceil(w > 0 ? w : 1) || 1;
			var height = Math.ceil(h > 0 ? h : 1) || 1;
	
			var gl = this._webGLContext;
			var texture = gl.createTexture();
			this.resizeTexture(texture, width, height);
			this.setTextureParams(gl, false);
	
			return texture;
		};
	
		/**
		 * Resizes a supplied texture element. May generate invalid textures in some error cases such as; when the texture
		 * is too large, when an out of texture memory error occurs, or other error scenarios. Trying to use an invalid texture
		 * can cause renders to hard stop on some devices. Check the WebGL bound texture after running this function.
		 *
		 * NOTE: The supplied texture must have been made with the WebGL "texImage2D" function, all default APIs in StageGL
		 * use this, so this note only matters for library developers and plugins.
		 *
		 * @protected
		 * @method resizeTexture
		 * @param  {WebGLTexture} texture The GL Texture to be modified.
		 * @param  {uint} [width=1] The width of the texture in pixels, defaults to 1
		 * @param  {uint} [height=1] The height of the texture in pixels, defaults to 1
		 */
		p.resizeTexture = function (texture, width,height) {
			var gl = this._webGLContext;
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(
				gl.TEXTURE_2D,				// target
				0,							// level of detail
				gl.RGBA,					// internal format
				width, height, 0,			// width, height, border (only for array/null sourced textures)
				gl.RGBA,					// format (match internal format)
				gl.UNSIGNED_BYTE,			// type of texture(pixel color depth)
				null						// image data, we can do null because we're doing array data
			);
			texture.width = width;
			texture.height = height;
		};
	
		/**
		 * Returns a base texture (see {{#crossLink "StageGL/getBaseTexture"}}{{/crossLink}}) for details. Also includes an
		 * attached and linked render buffer in `texture._frameBuffer`. RenderTextures can be thought of as an internal
		 * canvas on the GPU that can be drawn to.
		 * @method getRenderBufferTexture
		 * @param  {Number} w The width of the texture in pixels.
		 * @param  {Number} h The height of the texture in pixels.
		 * @return {Texture} the basic texture instance with a render buffer property.
		 */
		p.getRenderBufferTexture = function (w, h) {
			var gl = this._webGLContext;
	
			// get the texture
			var renderTexture = this.getBaseTexture(w, h);
			if (!renderTexture) { return null; }
	
			// get the frame buffer
			var frameBuffer = gl.createFramebuffer();
			if (!frameBuffer) { return null; }
	
			// set its width and height for spoofing as an image
			renderTexture.width = w;
			renderTexture.height = h;
	
			// attach frame buffer to texture and provide cross links to look up each other
			gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
			frameBuffer._renderTexture = renderTexture;
			renderTexture._frameBuffer = frameBuffer;
	
			// these keep track of themselves simply to reduce complexity of some lookup code
			renderTexture._storeID = this._textureDictionary.length;
			this._textureDictionary[renderTexture._storeID] = renderTexture;
	
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			return renderTexture;
		};
	
		/**
		 * Common utility function used to apply the correct texture processing parameters for the bound texture.
		 * @method setTextureParams
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {Boolean} [isPOT=false] Marks whether the texture is "Power of Two", this may allow better quality AA.
		 */
		p.setTextureParams = function (gl, isPOT) {
			if (isPOT && this._antialias) {
				//non POT linear works in some devices, but performance is NOT good, investigate
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			} else {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			}
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		};
	
		/**
		 * Changes the webGL clear, aka "background" color to the provided value. A transparent clear is recommended, as
		 * non-transparent colours may create undesired boxes around some visuals.
		 *
		 * The clear color will also be used for filters and other "render textures". The stage background will ignore the
		 * transparency value and display a solid color normally. For the stage to recognize and use transparency it must be
		 * created with the transparent flag set to `true` (see {{#crossLink "StageGL/constructor"}}{{/crossLink}})).
		 *
		 * Using "transparent white" to demonstrate, the valid data formats are as follows:
		 * <ul>
		 *     <li>"#FFF"</li>
		 *     <li>"#FFFFFF"</li>
		 *     <li>"#FFFFFF00"</li>
		 *     <li>"rgba(255,255,255,0.0)"</li>
		 * </ul>
		 * @method setClearColor
		 * @param {String|int} [color=0x00000000] The new color to use as the background
		 */
		p.setClearColor = function (color) {
			var r, g, b, a, output;
	
			if (typeof color == "string") {
				if (color.indexOf("#") == 0) {
					if (color.length == 4) {
						color = "#" + color.charAt(1)+color.charAt(1) + color.charAt(2)+color.charAt(2) + color.charAt(3)+color.charAt(3)
					}
					r = Number("0x"+color.slice(1, 3))/255;
					g = Number("0x"+color.slice(3, 5))/255;
					b = Number("0x"+color.slice(5, 7))/255;
					a = Number("0x"+color.slice(7, 9))/255;
				} else if (color.indexOf("rgba(") == 0) {
					output = color.slice(5, -1).split(",");
					r = Number(output[0])/255;
					g = Number(output[1])/255;
					b = Number(output[2])/255;
					a = Number(output[3]);
				}
			} else {	// >>> is an unsigned shift which is what we want as 0x80000000 and up are negative values
				r = ((color & 0xFF000000) >>> 24)/255;
				g = ((color & 0x00FF0000) >>> 16)/255;
				b = ((color & 0x0000FF00) >>> 8)/255;
				a = (color & 0x000000FF)/255;
			}
	
			this._clearColor.r = r || 0;
			this._clearColor.g = g || 0;
			this._clearColor.b = b || 0;
			this._clearColor.a = a || 0;
	
			if (!this._webGLContext) { return; }
			this._webGLContext.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
		};
	
		/**
		 * docced in subclass
		 */
		p.toString = function () {
			return "[StageGL (name="+  this.name +")]";
		};
	
	// private methods:
		/**
		 * Sets up and returns the WebGL context for the canvas. May return undefined in error scenarios. These can include 
		 * situations where the canvas element already has a context, 2D or GL.
		 * @param  {Canvas} canvas The DOM canvas element to attach to
		 * @param  {Object} options The options to be handed into the WebGL object, see WebGL spec
		 * @method _fetchWebGLContext
		 * @protected
		 * @return {WebGLRenderingContext} The WebGL context, may return undefined in error scenarios
		 */
		p._fetchWebGLContext = function (canvas, options) {
			var gl;
	
			try {
				gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
			} catch (e) {
				// don't do anything in catch, null check will handle it
			}
	
			if (!gl) {
				var msg = "Could not initialize WebGL";
				console.error?console.error(msg):console.log(msg);
			} else {
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
	
			return gl;
		};
	
		/**
		 * Create the completed Shader Program from the vertex and fragment shaders. Allows building of custom shaders for
		 * filters. Once compiled, shaders are saved so. If the Shader code requires dynamic alterations re-run this function
		 * to generate a new shader.
		 * @method _fetchShaderProgram
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {String} [shaderName="regular"] Working values: "regular", "override", and "filter". Which type of shader to build.
		 * Filter and override both accept the custom params. Regular and override have all features. Filter is a special case reduced feature shader meant to be over-ridden.
		 * @param  {String} [customVTX] Extra vertex shader information to replace a regular draw, see 
		 * {{#crossLink "StageGL/COVER_VERTEX_BODY"}}{{/crossLink}} for default and {{#crossLink "Filter"}}{{/crossLink}} for examples.
		 * @param  {String} [customFRAG] Extra fragment shader information to replace a regular draw, see 
		 * {{#crossLink "StageGL/COVER_FRAGMENT_BODY"}}{{/crossLink}} for default and {{#crossLink "Filter"}}{{/crossLink}} for examples.
		 * @param  {Function} [shaderParamSetup] Function to run so custom shader parameters can get applied for the render.
		 * @protected
		 * @return {WebGLProgram} The compiled and linked shader
		 */
		p._fetchShaderProgram = function (gl, shaderName, customVTX, customFRAG, shaderParamSetup) {
			gl.useProgram(null);		// safety to avoid collisions
	
			// build the correct shader string out of the right headers and bodies
			var targetFrag, targetVtx;
			switch (shaderName) {
				case "filter":
					targetVtx = StageGL.COVER_VERTEX_HEADER + (customVTX || StageGL.COVER_VERTEX_BODY);
					targetFrag = StageGL.COVER_FRAGMENT_HEADER + (customFRAG || StageGL.COVER_FRAGMENT_BODY);
					break;
				case "particle": //TODO
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + StageGL.PARTICLE_VERTEX_BODY;
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + StageGL.PARTICLE_FRAGMENT_BODY;
					break;
				case "override":
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + (customVTX || StageGL.REGULAR_VERTEX_BODY);
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + (customFRAG || StageGL.REGULAR_FRAGMENT_BODY);
					break;
				case "regular":
				default:
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + StageGL.REGULAR_VERTEX_BODY;
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + StageGL.REGULAR_FRAGMENT_BODY;
					break;
			}
	
			// create the separate vars
			var vertexShader = this._createShader(gl, gl.VERTEX_SHADER, targetVtx);
			var fragmentShader = this._createShader(gl, gl.FRAGMENT_SHADER, targetFrag);
	
			// link them together
			var shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);
			shaderProgram._type = shaderName;
	
			// check compile status
			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				gl.useProgram(this._activeShader);
				throw gl.getProgramInfoLog(shaderProgram);
			}
	
			// set up the parameters on the shader
			gl.useProgram(shaderProgram);
			switch (shaderName) {
				case "filter":
					// get the places in memory the shader is stored so we can feed information into them
					// then save it off on the shader because it's so tied to the shader itself
					shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPosition");
					gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	
					shaderProgram.uvPositionAttribute = gl.getAttribLocation(shaderProgram, "uvPosition");
					gl.enableVertexAttribArray(shaderProgram.uvPositionAttribute);
	
					shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
					gl.uniform1i(shaderProgram.samplerUniform, 0);
	
					shaderProgram.uprightUniform = gl.getUniformLocation(shaderProgram, "uUpright");
					gl.uniform1f(shaderProgram.uprightUniform, 0);
	
					// if there's some custom attributes be sure to hook them up
					if (shaderParamSetup) {
						shaderParamSetup(gl, this, shaderProgram);
					}
					break;
				case "override":
				case "particle":
				case "regular":
				default:
					// get the places in memory the shader is stored so we can feed information into them
					// then save it off on the shader because it's so tied to the shader itself
					shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPosition");
					gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	
					shaderProgram.uvPositionAttribute = gl.getAttribLocation(shaderProgram, "uvPosition");
					gl.enableVertexAttribArray(shaderProgram.uvPositionAttribute);
	
					shaderProgram.textureIndexAttribute = gl.getAttribLocation(shaderProgram, "textureIndex");
					gl.enableVertexAttribArray(shaderProgram.textureIndexAttribute);
	
					shaderProgram.alphaAttribute = gl.getAttribLocation(shaderProgram, "objectAlpha");
					gl.enableVertexAttribArray(shaderProgram.alphaAttribute);
	
					var samplers = [];
					for (var i = 0; i < this._batchTextureCount; i++) {
						samplers[i] = i;
					}
	
					shaderProgram.samplerData = samplers;
					shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
					gl.uniform1iv(shaderProgram.samplerUniform, samplers);
	
					shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "pMatrix");
					break;
			}
	
			gl.useProgram(this._activeShader);
			return shaderProgram;
		};
	
		/**
		 * Creates a shader from the specified string replacing templates. Template items are defined via `{{` `key` `}}``.
		 * @method _createShader
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {Number} type The type of shader to create. gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
		 * @param  {String} str The definition for the shader.
		 * @return {WebGLShader}
		 * @protected
		 */
		p._createShader = function (gl, type, str) {
			// inject the static number
			str = str.replace(/{{count}}/g, this._batchTextureCount);
	
			// resolve issue with no dynamic samplers by creating correct samplers in if else chain
			// TODO: WebGL 2.0 does not need this support
			var insert = "";
			for (var i = 1; i<this._batchTextureCount; i++) {
				insert += "} else if (indexPicker <= "+ i +".5) { color = texture2D(uSampler["+ i +"], vTextureCoord);";
			}
			str = str.replace(/{{alternates}}/g, insert);
			str = str.replace(/{{premultiply}}/g, this._premultiply ? "/color.a" : "");
	
			// actually compile the shader
			var shader = gl.createShader(type);
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
	
			// check compile status
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				throw gl.getShaderInfoLog(shader);
			}
	
			return shader;
		};
	
		/**
		 * Sets up the necessary vertex property buffers, including position and U/V.
		 * @method _createBuffers
		 * @param {WebGLRenderingContext} gl
		 * @protected
		 */
		p._createBuffers = function (gl) {
			var groupCount = this._maxCardsPerBatch * StageGL.INDICIES_PER_CARD;
			var groupSize, i, l;
	
			// INFO:
			// all buffers are created using this pattern
			// create a WebGL buffer
			// attach it to context
			// figure out how many parts it has to an entry
			// fill it with empty data to reserve the memory
			// attach the empty data to the GPU
			// track the sizes on the buffer object
	
			// INFO:
			// a single buffer may be optimal in some situations and would be approached like this,
			// currently not implemented due to lack of need and potential complications with drawCover
	
			// var vertexBuffer = this._vertexBuffer = gl.createBuffer();
			// gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			// groupSize = 2 + 2 + 1 + 1; //x/y, u/v, index, alpha
			// var vertexData = this._vertexData = new Float32Array(groupCount * groupSize);
			// for (i=0; i<vertexData.length; i+=groupSize) {
			// 	vertexData[i+0] = vertexData[i+1] = 0;
			// 	vertexData[i+2] = vertexData[i+3] = 0.5;
			// 	vertexData[i+4] = 0;
			// 	vertexData[i+5] = 1;
			// }
			// vertexBuffer.itemSize = groupSize;
			// vertexBuffer.numItems = groupCount;
			// TODO bechmark and test using unified buffer
	
			// the actual position information
			var vertexPositionBuffer = this._vertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			groupSize = 2;
			var vertices = this._vertices = new Float32Array(groupCount * groupSize);
			for (i=0, l=vertices.length; i<l; i+=groupSize) { vertices[i] = vertices[i+1] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
			vertexPositionBuffer.itemSize = groupSize;
			vertexPositionBuffer.numItems = groupCount;
	
			// where on the texture it gets its information
			var uvPositionBuffer = this._uvPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			groupSize = 2;
			var uvs = this._uvs = new Float32Array(groupCount * groupSize);
			for (i=0, l=uvs.length; i<l; i+=groupSize) { uvs[i] = uvs[i+1] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.DYNAMIC_DRAW);
			uvPositionBuffer.itemSize = groupSize;
			uvPositionBuffer.numItems = groupCount;
	
			// what texture it should use
			var textureIndexBuffer = this._textureIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, textureIndexBuffer);
			groupSize = 1;
			var indices = this._indices = new Float32Array(groupCount * groupSize);
			for (i=0, l=indices.length; i<l; i++) { indices[i] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, indices, gl.DYNAMIC_DRAW);
			textureIndexBuffer.itemSize = groupSize;
			textureIndexBuffer.numItems = groupCount;
	
			// what alpha it should have
			var alphaBuffer = this._alphaBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
			groupSize = 1;
			var alphas = this._alphas = new Float32Array(groupCount * groupSize);
			for (i=0, l=alphas.length; i<l; i++) { alphas[i] = 1; }
			gl.bufferData(gl.ARRAY_BUFFER, alphas, gl.DYNAMIC_DRAW);
			alphaBuffer.itemSize = groupSize;
			alphaBuffer.numItems = groupCount;
		};
	
		/**
		 * Do all the setup steps for textures in the system.
		 * @method _initTextures
		 * @protected
		 */
		p._initTextures = function () {
			//TODO: DHG: add a cleanup routine in here in case this happens mid stream
	
			// reset counters
			this._lastTextureInsert = -1;
	
			// clear containers
			this._textureDictionary = [];
			this._textureIDs = {};
			this._baseTextures = [];
			this._batchTextures = [];
	
			// fill in blanks as it helps the renderer be stable while textures are loading and reduces need for safety code
			for (var i=0; i<this._batchTextureCount;i++) {
				var tex = this.getBaseTexture();
				this._baseTextures[i] = this._batchTextures[i] = tex;
				if (!tex) {
					throw "Problems creating basic textures, known causes include using too much VRAM by not releasing WebGL texture instances";
				}
			}
		};
	
		/**
		 * Load a specific texture, accounting for potential delay, as it might not be preloaded.
		 * @method _loadTextureImage
		 * @param {WebGLRenderingContext} gl
		 * @param {Image} image Actual image to be loaded
		 * @return {WebGLTexture} The resulting Texture object
		 * @protected
		 */
		p._loadTextureImage = function (gl, image) {
			var src = image.src;
	
			if (!src) {
				// one time canvas property setup
				image._isCanvas = true;
				src = image.src = "canvas_" + this._lastTrackedCanvas++;
			}
	
			// put the texture into our storage system
			var storeID = this._textureIDs[src];
			if (storeID === undefined) {
				storeID = this._textureIDs[src] = this._textureDictionary.length;
			}
			if (this._textureDictionary[storeID] === undefined) {
				this._textureDictionary[storeID] = this.getBaseTexture();
			}
	
			var texture = this._textureDictionary[storeID];
	
			if (texture) {
				// get texture params all set up
				texture._batchID = this._batchID;
				texture._storeID = storeID;
				texture._imageData = image;
				this._insertTextureInBatch(gl, texture);
	
				// get the data into the texture or wait for it to load
				image._storeID = storeID;
				if (image.complete || image.naturalWidth || image._isCanvas) {	// is it already loaded
					this._updateTextureImageData(gl, image);
				} else  {
					image.addEventListener("load", this._updateTextureImageData.bind(this, gl, image));
				}
			} else {
				// we really really should have a texture, try to recover the error by using a saved empty texture so we don't crash
				var msg = "Problem creating desired texture, known causes include using too much VRAM by not releasing WebGL texture instances";
				(console.error && console.error(msg)) || console.log(msg);
	
				texture = this._baseTextures[0];
				texture._batchID = this._batchID;
				texture._storeID = -1;
				texture._imageData = texture;
				this._insertTextureInBatch(gl, texture);
			}
	
			return texture;
		};
	
		/**
		 * Necessary to upload the actual image data to the GPU. Without this the texture will be blank. Called automatically
		 * in most cases due to loading and caching APIs. Flagging an image source with `_invalid = true` will trigger this
		 * next time the image is rendered.
		 * @param {WebGLRenderingContext} gl
		 * @param {Image | Canvas} image The image data to be uploaded
		 * @protected
		 */
		p._updateTextureImageData = function (gl, image) {
			// the bitwise & is intentional, cheap exponent 2 check
			var isNPOT = (image.width & image.width-1) || (image.height & image.height-1);
			var texture = this._textureDictionary[image._storeID];
	
			gl.activeTexture(gl.TEXTURE0 + texture._activeIndex);
			gl.bindTexture(gl.TEXTURE_2D, texture);
	
			texture.isPOT = !isNPOT;
			this.setTextureParams(gl, texture.isPOT);
	
			try {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			} catch(e) {
				var errString = "\nAn error has occurred. This is most likely due to security restrictions on WebGL images with local or cross-domain origins";
				if(console.error) {
					//TODO: LM: I recommend putting this into a log function internally, since you do it so often, and each is implemented differently.
					console.error(errString);
					console.error(e);
				} else if (console) {
					console.log(errString);
					console.log(e);
				}
			}
	
			image._invalid = false;
	
			texture._w = image.width;
			texture._h = image.height;
	
			if (this.vocalDebug) {
				if (isNPOT) {
					console.warn("NPOT(Non Power of Two) Texture: "+ image.src);
				}
				if (image.width > gl.MAX_TEXTURE_SIZE || image.height > gl.MAX_TEXTURE_SIZE){
					console && console.error("Oversized Texture: "+ image.width+"x"+image.height +" vs "+ gl.MAX_TEXTURE_SIZE +"max");
				}
			}
		};
	
		/**
		 * Adds the texture to a spot in the current batch, forcing a draw if no spots are free.
		 * @method _insertTextureInBatch
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {WebGLTexture} texture The texture to be inserted.
		 * @protected
		 */
		p._insertTextureInBatch = function (gl, texture) {
			// if it wasn't used last batch
			if (this._batchTextures[texture._activeIndex] !== texture) {
				// we've got to find it a a spot.
				var found = -1;
				var start = (this._lastTextureInsert+1) % this._batchTextureCount;
				var look = start;
				do {
					if (this._batchTextures[look]._batchID != this._batchID && !this._slotBlacklist[look]) {
						found = look;
						break;
					}
					look = (look+1) % this._batchTextureCount;
				} while (look !== start);
	
				// we couldn't find anywhere for it go, meaning we're maxed out
				if (found === -1) {
					this.batchReason = "textureOverflow";
					this._drawBuffers(gl);		// <------------------------------------------------------------------------
					this.batchCardCount = 0;
					found = start;
				}
	
				// lets put it into that spot
				this._batchTextures[found] = texture;
				texture._activeIndex = found;
				var image = texture._imageData;
				if (image && image._invalid && texture._drawID !== undefined) {
					this._updateTextureImageData(gl, image);
				} else {
					gl.activeTexture(gl.TEXTURE0 + found);
					gl.bindTexture(gl.TEXTURE_2D, texture);
					this.setTextureParams(gl);
				}
				this._lastTextureInsert = found;
			} else {
				var image = texture._imageData;
				if (texture._storeID != undefined && image && image._invalid) {
					this._updateTextureImageData(gl, image);
				}
			}
	
			texture._drawID = this._drawID;
			texture._batchID = this._batchID;
		};
	
		/**
		 * Remove and clean the texture, expects a texture and is inflexible. Mostly for internal use, recommended to call 
		 * {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}} instead as it will call this with the correct texture object(s).
		 * Note: Testing shows this may not happen immediately, have to wait frames for WebGL to have actually adjust memory.
		 * @method _killTextureObject
		 * @param {Texture} tex The texture to be cleaned out
		 * @protected
		 */
		p._killTextureObject = function (tex) {
			if (!tex) { return; }
			var gl = this._webGLContext;
	
			// remove linkage
			if (tex._storeID !== undefined && tex._storeID >= 0) {
				this._textureDictionary[tex._storeID] = undefined;
				for (var n in this._textureIDs) {
					if (this._textureIDs[n] == tex._storeID) { delete this._textureIDs[n]; }
				}
				if(tex._imageData) { tex._imageData._storeID = undefined; }
				tex._imageData = tex._storeID = undefined;
			}
	
			// make sure to drop it out of an active slot
			if (tex._activeIndex !== undefined && this._batchTextures[tex._activeIndex] === tex) {
				this._batchTextures[tex._activeIndex] = this._baseTextures[tex._activeIndex];
			}
	
			// remove buffers if present
			try {
				if (tex._frameBuffer) { gl.deleteFramebuffer(tex._frameBuffer); }
				tex._frameBuffer = undefined;
			} catch(e) {
				/* suppress delete errors because it's already gone or didn't need deleting probably */
				if (this.vocalDebug) { console.log(e); }
			}
	
			// remove entry
			try {
				gl.deleteTexture(tex);
			} catch(e) {
				/* suppress delete errors because it's already gone or didn't need deleting probably */
				if (this.vocalDebug) { console.log(e); }
			}
		};
	
		/**
		 * Store or restore current batch textures into a backup array
		 * @method _backupBatchTextures
		 * @param {Boolean} restore Perform a restore instead of a store.
		 * @param {Array} [target=this._backupTextures] Where to perform the backup, defaults to internal backup.
		 * @protected
		 */
		p._backupBatchTextures = function (restore, target) {
			var gl = this._webGLContext;
	
			if (!this._backupTextures) { this._backupTextures = []; }
			if (target === undefined) { target = this._backupTextures; }
	
			for (var i=0; i<this._batchTextureCount; i++) {
				gl.activeTexture(gl.TEXTURE0 + i);
				if (restore) {
					this._batchTextures[i] = target[i];
				} else {
					target[i] = this._batchTextures[i];
					this._batchTextures[i] = this._baseTextures[i];
				}
				gl.bindTexture(gl.TEXTURE_2D, this._batchTextures[i]);
				this.setTextureParams(gl, this._batchTextures[i].isPOT);
			}
	
			if (restore && target === this._backupTextures) { this._backupTextures = []; }
		};
	
		/**
		 * Begin the drawing process for a regular render.
		 * @method _batchDraw
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Stage || Container} sceneGraph {{#crossLink "Container"}}{{/crossLink}} object with all that needs to rendered, preferably a Stage.
		 * @param {Boolean} ignoreCache
		 * @protected
		 */
		p._batchDraw = function (sceneGraph, gl, ignoreCache) {
			if (this._isDrawing > 0) {
				this._drawBuffers(gl);
			}
			this._isDrawing++;
			this._drawID++;
	
			this.batchCardCount = 0;
			this.depth = 0;
	
			this._appendToBatchGroup(sceneGraph, gl, new createjs.Matrix2D(), this.alpha, ignoreCache);
	
			this.batchReason = "drawFinish";
			this._drawBuffers(gl);								// <--------------------------------------------------------
			this._isDrawing--;
		};
	
		/**
		 * Perform the drawing process to fill a specific cache texture, including applying filters.
		 * @method _cacheDraw
		 * @param {DisplayObject} target The object we're drawing into the cache. For example, used for drawing the cache
		 * (to prevent it from simply drawing an existing cache back into itself).
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 * @protected
		 */
		p._cacheDraw = function (gl, target, filters, manager) {
			/*
			Implicitly there are 4 modes to this function: filtered-sameContext, filtered-uniqueContext, sameContext, uniqueContext.
			Each situation must be handled slightly differently as 'sameContext' or 'uniqueContext' define how the output works,
			one drawing directly into the main context and the other drawing into a stored renderTexture respectively.
			When the draw is a 'filtered' draw, the filters are applied sequentially and will draw into saved textures repeatedly.
			Once the final filter is done the final output is treated depending upon whether it is a same or unique context.
			The internal complexity comes from reducing over-draw, shared code, and issues like textures needing to be flipped
			sometimes when written to render textures.
			*/
			var renderTexture;
			var shaderBackup = this._activeShader;
			var blackListBackup = this._slotBlacklist;
			var lastTextureSlot = this._maxTextureSlots-1;
			var wBackup = this._viewportWidth, hBackup = this._viewportHeight;
	
			// protect the last slot so that we have somewhere to bind the renderTextures so it doesn't get upset
			this.protectTextureSlot(lastTextureSlot, true);
	
			// create offset container for drawing item
			var mtx = target.getMatrix();
			mtx = mtx.clone();
			mtx.scale(1/manager.scale, 1/manager.scale);
			mtx = mtx.invert();
			mtx.translate(-manager.offX/manager.scale, -manager.offY/manager.scale);
			var container = this._cacheContainer;
			container.children = [target];
			container.transformMatrix = mtx;
	
			this._backupBatchTextures(false);
	
			var filterCount = filters && filters.length;
			if (filterCount) {
				this._drawFilters(target, filters, manager);
			} else {
				// is this for another stage or mine?
				if (this.isCacheControlled) {
					// draw item to canvas				I -> C
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._batchDraw(container, gl, true);
				} else {
					gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
					target.cacheCanvas = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
					renderTexture = target.cacheCanvas;
	
					// draw item to render texture		I -> T
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
					this.updateViewport(manager._drawWidth, manager._drawHeight);
					this._projectionMatrix = this._projectionMatrixFlip;
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._batchDraw(container, gl, true);
	
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					this.updateViewport(wBackup, hBackup);
				}
			}
	
			this._backupBatchTextures(true);
	
			this.protectTextureSlot(lastTextureSlot, false);
			this._activeShader = shaderBackup;
			this._slotBlacklist = blackListBackup;
		};
	
		/**
		 * Sub portion of _cacheDraw, split off for readability. Do not call independently.
		 * @method _drawFilters
		 * @param {DisplayObject} target The object we're drawing with a filter.
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 */
		p._drawFilters = function (target, filters, manager) {
			var gl = this._webGLContext;
			var renderTexture;
			var lastTextureSlot = this._maxTextureSlots-1;
			var wBackup = this._viewportWidth, hBackup = this._viewportHeight;
	
			var container = this._cacheContainer;
			var filterCount = filters && filters.length;
	
			// we don't know which texture slot we're dealing with previously and we need one out of the way
			// once we're using that slot activate it so when we make and bind our RenderTexture it's safe there
			gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
			renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
	
			// draw item to render texture		I -> T
			gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
			this.updateViewport(manager._drawWidth, manager._drawHeight);
			gl.clear(gl.COLOR_BUFFER_BIT);
			this._batchDraw(container, gl, true);
	
			// bind the result texture to slot 0 as all filters and cover draws assume original content is in slot 0
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, renderTexture);
			this.setTextureParams(gl);
	
			var flipY = false;
	
			// apply each filter in order, but remember to toggle used texture and render buffer
			for (var i=0; i<filterCount; i++) {
				var filter = filters[i];
	
				// swap to correct shader
				this._activeShader = this.getFilterShader(filter);
				if (!this._activeShader) { continue; }
	
				// now the old result is stored in slot 0, make a new render texture
				gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
				renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
	
				// draw result to render texture	R -> T
				gl.viewport(0, 0, manager._drawWidth, manager._drawHeight);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._drawCover(gl, flipY);
	
				// bind the result texture to slot 0 as all filters and cover draws assume original content is in slot 0
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, renderTexture);
				this.setTextureParams(gl);
	
				// use flipping to keep things upright, things already cancel out on a single filter
				if (filterCount > 1) {
					flipY = !flipY;
				}
			}
	
			// is this for another stage or mine
			if (this.isCacheControlled) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				this.updateViewport(wBackup, hBackup);
	
				// draw result to canvas			R -> C
				this._activeShader = this.getFilterShader(this);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._drawCover(gl, flipY);
			} else {
				//TODO: DHG: this is less than ideal. A flipped initial render for this circumstance might help. Adjust the perspective matrix?
				if (flipY) {
					gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
					renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
	
					this._activeShader = this.getFilterShader(this);
					gl.viewport(0, 0, manager._drawWidth, manager._drawHeight);
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._drawCover(gl, !flipY);
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				this.updateViewport(wBackup, hBackup);
	
				// make sure the last texture is the active thing to draw
				target.cacheCanvas = renderTexture;
			}
		};
	
		/**
		 * Add all the contents of a container to the pending buffers, called recursively on each container. This may
		 * trigger a draw if a buffer runs out of space. This is the main workforce of the render loop.
		 * @method _appendToBatchGroup
		 * @param {Container} container The {{#crossLink "Container"}}{{/crossLink}} that contains everything to be drawn.
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Matrix2D} concatMtx The effective (concatenated) transformation matrix when beginning this container
		 * @param {Number} concatAlpha The effective (concatenated) alpha when beginning this container
		 * @param {Boolean} ignoreCache Don't use an element's cache during this draw
		 * @protected
		 */
		p._appendToBatchGroup = function (container, gl, concatMtx, concatAlpha, ignoreCache) {
			// sort out shared properties
			if (!container._glMtx) { container._glMtx = new createjs.Matrix2D(); }
			var cMtx = container._glMtx;
			cMtx.copy(concatMtx);
			if (container.transformMatrix) {
				cMtx.appendMatrix(container.transformMatrix);
			} else {
				cMtx.appendTransform(
					container.x, container.y,
					container.scaleX, container.scaleY,
					container.rotation, container.skewX, container.skewY,
					container.regX, container.regY
				);
			}
	
			// sub components of figuring out the position an object holds
			var subL, subT, subR, subB;
	
			// actually apply its data to the buffers
			var l = container.children.length;
			for (var i = 0; i < l; i++) {
				var item = container.children[i];
	
				if (!(item.visible && concatAlpha)) { continue; }
				if (!item.cacheCanvas || ignoreCache) {
					if (item._updateState){
						item._updateState();
					}
					if (item.children) {
						this._appendToBatchGroup(item, gl, cMtx, item.alpha * concatAlpha);
						continue;
					}
				}
	
				// check for overflowing batch, if yes then force a render
				// TODO: DHG: consider making this polygon count dependant for things like vector draws
				if (this.batchCardCount+1 > this._maxCardsPerBatch) {
					this.batchReason = "vertexOverflow";
					this._drawBuffers(gl);					// <------------------------------------------------------------
					this.batchCardCount = 0;
				}
	
				// keep track of concatenated position
				if (!item._glMtx) { item._glMtx = new createjs.Matrix2D(); }
				var iMtx = item._glMtx;
				iMtx.copy(cMtx);
				if (item.transformMatrix) {
					iMtx.appendMatrix(item.transformMatrix);
				} else {
					iMtx.appendTransform(
						item.x, item.y,
						item.scaleX, item.scaleY,
						item.rotation, item.skewX, item.skewY,
						item.regX, item.regY
					);
				}
	
				var uvRect, texIndex, image, frame, texture, src;
				var useCache = item.cacheCanvas && !ignoreCache;
	
				if (item._webGLRenderStyle === 2 || useCache) {			// BITMAP / Cached Canvas
					image = (ignoreCache?false:item.cacheCanvas) || item.image;
				} else if (item._webGLRenderStyle === 1) {											// SPRITE
					frame = item.spriteSheet.getFrame(item.currentFrame);	//TODO: Faster way?
					if (frame === null) { continue; }
					image = frame.image;
				} else {																			// MISC (DOM objects render themselves later)
					continue;
				}
	
				var uvs = this._uvs;
				var vertices = this._vertices;
				var texI = this._indices;
				var alphas = this._alphas;
	
				// calculate texture
				if (!image) { continue; }
				if (image._storeID === undefined) {
					// this texture is new to us so load it and add it to the batch
					texture = this._loadTextureImage(gl, image);
					this._insertTextureInBatch(gl, texture);
				} else {
					// fetch the texture (render textures know how to look themselves up to simplify this logic)
					texture = this._textureDictionary[image._storeID];
					if (!texture){
						if (this.vocalDebug){ console.log("Texture should not be looked up while not being stored."); }
						continue;
					}
	
					// put it in the batch if needed
					if (texture._batchID !== this._batchID) {
						this._insertTextureInBatch(gl, texture);
					}
				}
				texIndex = texture._activeIndex;
	
				if (item._webGLRenderStyle === 2 || useCache) {			// BITMAP / Cached Canvas
					if (!useCache && item.sourceRect) {
						// calculate uvs
						if (!item._uvRect) { item._uvRect = {}; }
						src = item.sourceRect;
						uvRect = item._uvRect;
						uvRect.t = (src.y)/image.height;
						uvRect.l = (src.x)/image.width;
						uvRect.b = (src.y + src.height)/image.height;
						uvRect.r = (src.x + src.width)/image.width;
	
						// calculate vertices
						subL = 0;							subT = 0;
						subR = src.width+subL;				subB = src.height+subT;
					} else {
						// calculate uvs
						uvRect = StageGL.UV_RECT;
						// calculate vertices
						if (useCache) {
							src = item.bitmapCache;
							subL = src.x+(src._filterOffX/src.scale);	subT = src.y+(src._filterOffY/src.scale);
							subR = (src._drawWidth/src.scale)+subL;		subB = (src._drawHeight/src.scale)+subT;
						} else {
							subL = 0;						subT = 0;
							subR = image.width+subL;		subB = image.height+subT;
						}
					}
				} else if (item._webGLRenderStyle === 1) {											// SPRITE
					var rect = frame.rect;
	
					// calculate uvs
					uvRect = frame.uvRect;
					if (!uvRect) {
						uvRect = StageGL.buildUVRects(item.spriteSheet, item.currentFrame, false);
					}
	
					// calculate vertices
					subL = -frame.regX;								subT = -frame.regY;
					subR = rect.width-frame.regX;					subB = rect.height-frame.regY;
				}
	
				// These must be calculated here else a forced draw might happen after they're set
				var offV1 = this.batchCardCount*StageGL.INDICIES_PER_CARD;		// offset for 1 component vectors
				var offV2 = offV1*2;											// offset for 2 component vectors
	
				//DHG: See Matrix2D.transformPoint for why this math specifically
				// apply vertices
				vertices[offV2] =		subL *iMtx.a + subT *iMtx.c +iMtx.tx;		vertices[offV2+1] =		subL *iMtx.b + subT *iMtx.d +iMtx.ty;
				vertices[offV2+2] =		subL *iMtx.a + subB *iMtx.c +iMtx.tx;		vertices[offV2+3] =		subL *iMtx.b + subB *iMtx.d +iMtx.ty;
				vertices[offV2+4] =		subR *iMtx.a + subT *iMtx.c +iMtx.tx;		vertices[offV2+5] =		subR *iMtx.b + subT *iMtx.d +iMtx.ty;
				vertices[offV2+6] =		vertices[offV2+2];							vertices[offV2+7] =		vertices[offV2+3];
				vertices[offV2+8] =		vertices[offV2+4];							vertices[offV2+9] =		vertices[offV2+5];
				vertices[offV2+10] =	subR *iMtx.a + subB *iMtx.c +iMtx.tx;		vertices[offV2+11] =	subR *iMtx.b + subB *iMtx.d +iMtx.ty;
	
				// apply uvs
				uvs[offV2] =	uvRect.l;			uvs[offV2+1] =	uvRect.t;
				uvs[offV2+2] =	uvRect.l;			uvs[offV2+3] =	uvRect.b;
				uvs[offV2+4] =	uvRect.r;			uvs[offV2+5] =	uvRect.t;
				uvs[offV2+6] =	uvRect.l;			uvs[offV2+7] =	uvRect.b;
				uvs[offV2+8] =	uvRect.r;			uvs[offV2+9] =	uvRect.t;
				uvs[offV2+10] =	uvRect.r;			uvs[offV2+11] =	uvRect.b;
	
				// apply texture
				texI[offV1] = texI[offV1+1] = texI[offV1+2] = texI[offV1+3] = texI[offV1+4] = texI[offV1+5] = texIndex;
	
				// apply alpha
				alphas[offV1] = alphas[offV1+1] = alphas[offV1+2] = alphas[offV1+3] = alphas[offV1+4] = alphas[offV1+5] = item.alpha * concatAlpha;
	
				this.batchCardCount++;
			}
		};
	
		/**
		 * Draws all the currently defined cards in the buffer to the render surface.
		 * @method _drawBuffers
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @protected
		 */
		p._drawBuffers = function (gl) {
			if (this.batchCardCount <= 0) { return; }	// prevents error logs on stages filled with un-renederable content.
	
			if (this.vocalDebug) {
				console.log("Draw["+ this._drawID +":"+ this._batchID +"] : "+ this.batchReason);
			}
			var shaderProgram = this._activeShader;
			var vertexPositionBuffer = this._vertexPositionBuffer;
			var textureIndexBuffer = this._textureIndexBuffer;
			var uvPositionBuffer = this._uvPositionBuffer;
			var alphaBuffer = this._alphaBuffer;
	
			gl.useProgram(shaderProgram);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, textureIndexBuffer);
			gl.vertexAttribPointer(shaderProgram.textureIndexAttribute, textureIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._indices);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.uvPositionAttribute, uvPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._uvs);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
			gl.vertexAttribPointer(shaderProgram.alphaAttribute, alphaBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._alphas);
	
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, gl.FALSE, this._projectionMatrix);
	
			for (var i = 0; i < this._batchTextureCount; i++) {
				var texture = this._batchTextures[i];
				gl.activeTexture(gl.TEXTURE0 + i);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				this.setTextureParams(gl, texture.isPOT);
			}
	
			gl.drawArrays(gl.TRIANGLES, 0, this.batchCardCount*StageGL.INDICIES_PER_CARD);
			this._batchID++;
		};
	
		/**
		 * Draws a card that covers the entire render surface. Mainly used for filters.
		 * @method _drawBuffers
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Boolean} flipY Covers are used for things like RenderTextures and because of 3D vs Canvas space this can
		 * end up meaning the `y` space sometimes requires flipping in the render.
		 * @protected
		 */
		p._drawCover = function (gl, flipY) {
			if (this._isDrawing > 0) {
				this._drawBuffers(gl);
			}
	
			if (this.vocalDebug) {
				console.log("Draw["+ this._drawID +":"+ this._batchID +"] : "+ "Cover");
			}
			var shaderProgram = this._activeShader;
			var vertexPositionBuffer = this._vertexPositionBuffer;
			var uvPositionBuffer = this._uvPositionBuffer;
	
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.useProgram(shaderProgram);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, StageGL.COVER_VERT);
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.uvPositionAttribute, uvPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, flipY?StageGL.COVER_UV_FLIP:StageGL.COVER_UV);
	
			gl.uniform1i(shaderProgram.samplerUniform, 0);
			gl.uniform1f(shaderProgram.uprightUniform, flipY?0:1);
	
			gl.drawArrays(gl.TRIANGLES, 0, StageGL.INDICIES_PER_CARD);
		};
	
		createjs.StageGL = createjs.promote(StageGL, "Stage");
	}());
	
	//##############################################################################
	// Bitmap.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		
		/**
		 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
		 * HTML element, or a string.
		 *
		 * <h4>Example</h4>
		 *
		 * 	var bitmap = new createjs.Bitmap("imagePath.jpg");
		 *
		 * <strong>Notes:</strong>
		 * <ol>
		 * 	<li>When using a video source that may loop or seek, use a {{#crossLink "VideoBuffer"}}{{/crossLink}} object to
		 * 	 prevent blinking / flashing.
		 * 	<li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
		 * 	 will be displayed.</li>
		 * 	<li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
		 * 	the Bitmap can be cached.</li>
		 * 	<li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
		 * 	happens in all browsers except recent Firefox builds.</li>
		 * 	<li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
		 * 	methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
		 * 	`crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
		 * </ol>
		 *
		 * @class Bitmap
		 * @extends DisplayObject
		 * @constructor
		 * @param {CanvasImageSource | String | Object} imageOrUri The source image to display. This can be a CanvasImageSource
		 * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
		 * If the latter, a new Image instance with the URL as its src will be used.
		 **/
		function Bitmap(imageOrUri) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The source image to display. This can be a CanvasImageSource
			 * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
			 * If the latter, a new Image instance with the URL as its src will be used.
			 * @property image
			 * @type CanvasImageSource | Object
			 **/
			if (typeof imageOrUri == "string") {
				this.image = document.createElement("img");
				this.image.src = imageOrUri;
			} else {
				this.image = imageOrUri;
			}
		
			/**
			 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
			 * Notes:
			 * <ul>
			 *     <li>that video sources must have a width / height set to work correctly with `sourceRect`</li>
			 *     <li>Cached objects will ignore the `sourceRect` property</li>
			 * </ul>
			 * @property sourceRect
			 * @type Rectangle
			 * @default null
			 */
			this.sourceRect = null;
	
		// private properties:
			/**
			 * Docced in superclass.
			 */
			this._webGLRenderStyle = createjs.DisplayObject._StageGL_BITMAP;
		}
		var p = createjs.extend(Bitmap, createjs.DisplayObject);
		
		
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Bitmap; // TODO: deprecated.
	
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var image = this.image;
			var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			var img = this.image, rect = this.sourceRect;
			if (img.getImage) { img = img.getImage(); }
			if (!img) { return true; }
			if (rect) {
				// some browsers choke on out of bound values, so we'll fix them:
				var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;
				if (x1 < 0) { x -= x1; x1 = 0; }
				if (x2 > w) { x2 = w; }
				if (y1 < 0) { y -= y1; y1 = 0; }
				if (y2 > h) { y2 = h; }
				ctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);
			} else {
				ctx.drawImage(img, 0, 0);
			}
			return true;
		};
		
		//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
		//Bitmap. This is why they have no method implementations.
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method cache
		 **/
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method updateCache
		 **/
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method uncache
		 **/
	
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			var rect = this.DisplayObject_getBounds();
			if (rect) { return rect; }
			var image = this.image, o = this.sourceRect || image;
			var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
			return hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;
		};
		
		/**
		 * Returns a clone of the Bitmap instance.
		 * @method clone
		 * @param {Boolean} node Whether the underlying dom element should be cloned as well.
		 * @return {Bitmap} a clone of the Bitmap instance.
		 **/
		p.clone = function(node) {
			var image = this.image;
			if(image && node){ image = image.cloneNode(); }
			var o = new Bitmap(image);
			if (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }
			this._cloneProps(o);
			return o;
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Bitmap (name="+  this.name +")]";
		};
	
		
		createjs.Bitmap = createjs.promote(Bitmap, "DisplayObject");
	}());
	
	//##############################################################################
	// Sprite.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of
		 * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100
		 * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,
		 * play frames as an animation, and even sequence animations together.
		 *
		 * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.
		 *
		 * <h4>Example</h4>
		 *
		 *      var instance = new createjs.Sprite(spriteSheet);
		 *      instance.gotoAndStop("frameName");
		 *
		 * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,
		 * only the first defined frame defined in the sprite sheet will be displayed.
		 *
		 * @class Sprite
		 * @extends DisplayObject
		 * @constructor
		 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame
		 * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
		 * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.
		 **/
		function Sprite(spriteSheet, frameOrAnimation) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}
			 * definitions, this will advance non-sequentially. This will always be an integer value.
			 * @property currentFrame
			 * @type {Number}
			 * @default 0
			 * @readonly
			 **/
			this.currentFrame = 0;
		
			/**
			 * Returns the name of the currently playing animation.
			 * @property currentAnimation
			 * @type {String}
			 * @final
			 * @readonly
			 **/
			this.currentAnimation = null;
		
			/**
			 * Prevents the animation from advancing each tick automatically. For example, you could create a sprite
			 * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.
			 * @property paused
			 * @type {Boolean}
			 * @default false
			 **/
			this.paused = true;
		
			/**
			 * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame
			 * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
			 * @property spriteSheet
			 * @type {SpriteSheet}
			 * @readonly
			 **/
			this.spriteSheet = spriteSheet;
		
			/**
			 * Specifies the current frame index within the currently playing animation. When playing normally, this will increase
			 * from 0 to n-1, where n is the number of frames in the current animation.
			 *
			 * This could be a non-integer value if
			 * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation's speed is
			 * not an integer.
			 * @property currentAnimationFrame
			 * @type {Number}
			 * @default 0
			 **/
			this.currentAnimationFrame = 0;
		
			/**
			 * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related
			 * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
			 * framerate.
			 *
			 * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will
			 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
			 * vary slightly between frames.
			 *
			 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
			 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
			 * @property framerate
			 * @type {Number}
			 * @default 0
			 **/
			this.framerate = 0;
		
		
		// private properties:
			/**
			 * Current animation object.
			 * @property _animation
			 * @protected
			 * @type {Object}
			 * @default null
			 **/
			this._animation = null;
		
			/**
			 * Current frame index.
			 * @property _currentFrame
			 * @protected
			 * @type {Number}
			 * @default null
			 **/
			this._currentFrame = null;
			
			/**
			 * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame
			 * @property _skipAdvance
			 * @protected
			 * @type {Boolean}
			 * @default false
			 **/
			this._skipAdvance = false;
	
			/**
			 * Docced in superclass.
			 */
			this._webGLRenderStyle = createjs.DisplayObject._StageGL_SPRITE;
	
			if (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }
		}
		var p = createjs.extend(Sprite, createjs.DisplayObject);
	
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Sprite; // TODO: Deprecated. This is for backwards support of Flash/Animate spritesheet export.
	
	
	// events:
		/**
		 * Dispatched when an animation reaches its ends.
		 * @event animationend
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {String} name The name of the animation that just ended.
		 * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.
		 * @since 0.6.0
		 */
		 
		/**
		 * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,
		 * or calling gotoAndPlay() or gotoAndStop().
		 * @event change
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 */
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || this.spriteSheet.complete;
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this._normalizeFrame();
			var o = this.spriteSheet.getFrame(this._currentFrame|0);
			if (!o) { return false; }
			var rect = o.rect;
			if (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }
			return true;
		};
	
		//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
		//Bitmap. This is why they have no method implementations.
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method cache
		 **/
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method updateCache
		 **/
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method uncache
		 **/
	
		/**
		 * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}
		 * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain
		 * unchanged.
		 * @method play
		 **/
		p.play = function() {
			this.paused = false;
		};
	
		/**
		 * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}
		 * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}
		 * will resume playback.
		 * @method stop
		 **/
		p.stop = function() {
			this.paused = true;
		};
	
		/**
		 * Sets paused to false and plays the specified animation name, named frame, or frame number.
		 * @method gotoAndPlay
		 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
		 * and begin playing.
		 **/
		p.gotoAndPlay = function(frameOrAnimation) {
			this.paused = false;
			this._skipAdvance = true;
			this._goto(frameOrAnimation);
		};
	
		/**
		 * Sets paused to true and seeks to the specified animation name, named frame, or frame number.
		 * @method gotoAndStop
		 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
		 * and stop.
		 **/
		p.gotoAndStop = function(frameOrAnimation) {
			this.paused = true;
			this._goto(frameOrAnimation);
		};
	
		/**
		 * Advances the playhead. This occurs automatically each tick by default.
		 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite
		 * or its SpriteSheet.
		 * @method advance
		*/
		p.advance = function(time) {
			var fps = this.framerate || this.spriteSheet.framerate;
			var t = (fps && time != null) ? time/(1000/fps) : 1;
			this._normalizeFrame(t);
		};
		
		/**
		 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to
		 * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a
		 * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.
		 *
		 * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.
		 * @method getBounds
		 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully
		 * loaded.
		 **/
		p.getBounds = function() {
			// TODO: should this normalizeFrame?
			return this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);
		};
	
		/**
		 * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned
		 * instances.
		 * @method clone
		 * @return {Sprite} a clone of the Sprite instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new Sprite(this.spriteSheet));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Sprite (name="+  this.name +")]";
		};
	
	// private methods:
		/**
		 * @method _cloneProps
		 * @param {Sprite} o
		 * @return {Sprite} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			this.DisplayObject__cloneProps(o);
			o.currentFrame = this.currentFrame;
			o.currentAnimation = this.currentAnimation;
			o.paused = this.paused;
			o.currentAnimationFrame = this.currentAnimationFrame;
			o.framerate = this.framerate;
			
			o._animation = this._animation;
			o._currentFrame = this._currentFrame;
			o._skipAdvance = this._skipAdvance;
			return o;
		};
		
		/**
		 * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}
		 * ticks.
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 * @method _tick
		 **/
		p._tick = function(evtObj) {
			if (!this.paused) {
				if (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }
				this._skipAdvance = false;
			}
			this.DisplayObject__tick(evtObj);
		};
	
	
		/**
		 * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.
		 * @protected
		 * @method _normalizeFrame
		 **/
		p._normalizeFrame = function(frameDelta) {
			frameDelta = frameDelta || 0;
			var animation = this._animation;
			var paused = this.paused;
			var frame = this._currentFrame;
			var l;
			
			if (animation) {
				var speed = animation.speed || 1;
				var animFrame = this.currentAnimationFrame;
				l = animation.frames.length;
				if (animFrame + frameDelta * speed >= l) {
					var next = animation.next;
					if (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {
						// something changed in the event stack, so we shouldn't make any more changes here.
						return;
					} else if (next) {
						// sequence. Automatically calls _normalizeFrame again with the remaining frames.
						return this._goto(next, frameDelta - (l - animFrame) / speed);
					} else {
						// end.
						this.paused = true;
						animFrame = animation.frames.length - 1;
					}
				} else {
					animFrame += frameDelta * speed;
				}
				this.currentAnimationFrame = animFrame;
				this._currentFrame = animation.frames[animFrame | 0]
			} else {
				frame = (this._currentFrame += frameDelta);
				l = this.spriteSheet.getNumFrames();
				if (frame >= l && l > 0) {
					if (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {
						// looped.
						if ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }
					}
				}
			}
			frame = this._currentFrame | 0;
			if (this.currentFrame != frame) {
				this.currentFrame = frame;
				this.dispatchEvent("change");
			}
		};
	
		/**
		 * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},
		 * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)
		 * @property _dispatchAnimationEnd
		 * @private
		 * @type {Function}
		 **/
		p._dispatchAnimationEnd = function(animation, frame, paused, next, end) {
			var name = animation ? animation.name : null;
			if (this.hasEventListener("animationend")) {
				var evt = new createjs.Event("animationend");
				evt.name = name;
				evt.next = next;
				this.dispatchEvent(evt);
			}
			// did the animation get changed in the event stack?:
			var changed = (this._animation != animation || this._currentFrame != frame);
			// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:
			if (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }
			return changed;
		};
	
		/**
		 * Moves the playhead to the specified frame number or animation.
		 * @method _goto
		 * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.
		 * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.
		 * @protected
		 **/
		p._goto = function(frameOrAnimation, frame) {
			this.currentAnimationFrame = 0;
			if (isNaN(frameOrAnimation)) {
				var data = this.spriteSheet.getAnimation(frameOrAnimation);
				if (data) {
					this._animation = data;
					this.currentAnimation = frameOrAnimation;
					this._normalizeFrame(frame);
				}
			} else {
				this.currentAnimation = this._animation = null;
				this._currentFrame = frameOrAnimation;
				this._normalizeFrame();
			}
		};
	
	
		createjs.Sprite = createjs.promote(Sprite, "DisplayObject");
	}());
	
	//##############################################################################
	// Shape.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}
		 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
		 * instances to display the same vector graphics with different positions or transforms.
		 *
		 * If the vector art will not
		 * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the
		 * rendering cost.
		 *
		 * <h4>Example</h4>
		 *
		 *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
		 *      var shape = new createjs.Shape(graphics);
		 *
		 *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
		 *      var shape = new createjs.Shape();
		 *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
		 *
		 * @class Shape
		 * @extends DisplayObject
		 * @constructor
		 * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.
		 **/
		function Shape(graphics) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The graphics instance to display.
			 * @property graphics
			 * @type Graphics
			 **/
			this.graphics = graphics ? graphics : new createjs.Graphics();
		}
		var p = createjs.extend(Shape, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if
		 * the draw was handled (useful for overriding functionality).
		 *
		 * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
		 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this.graphics.draw(ctx, this);
			return true;
		};
	
		/**
		 * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
		 * their defaults (for example .parent).
		 * @method clone
		 * @param {Boolean} recursive If true, this Shape's {{#crossLink "Graphics"}}{{/crossLink}} instance will also be
		 * cloned. If false, the Graphics instance will be shared with the new Shape.
		 **/
		p.clone = function(recursive) {
			var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
			return  this._cloneProps(new Shape(g));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Shape (name="+  this.name +")]";
		};
	
	
		createjs.Shape = createjs.promote(Shape, "DisplayObject");
	}());
	
	//##############################################################################
	// Text.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the
		 * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML
		 * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
		 * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.
		 *
		 * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use
		 * multiple font styles, you will need to create multiple text instances, and position them manually.
		 *
		 * <h4>Example</h4>
		 *
		 *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");
		 *      text.x = 100;
		 *      text.textBaseline = "alphabetic";
		 *
		 * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser
		 * before it can be displayed.
		 *
		 * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all
		 * browsers will render Text exactly the same.
		 * @class Text
		 * @extends DisplayObject
		 * @constructor
		 * @param {String} [text] The text to display.
		 * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold
		 * 36px Arial").
		 * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.
		 * "#F00", "red", or "#FF0000").
		 **/
		function Text(text, font, color) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The text to display.
			 * @property text
			 * @type String
			 **/
			this.text = text;
		
			/**
			 * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
			 * @property font
			 * @type String
			 **/
			this.font = font;
		
			/**
			 * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
			 * It will also accept valid canvas fillStyle values.
			 * @property color
			 * @type String
			 **/
			this.color = color;
		
			/**
			 * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed
			 * information view the
			 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>. Default is "left".
			 * @property textAlign
			 * @type String
			 **/
			this.textAlign = "left";
		
			/**
			 * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or
			 * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>. Default is "top".
			 * @property textBaseline
			 * @type String
			*/
			this.textBaseline = "top";
		
			/**
			 * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
			 * shrunk to make it fit in this width. For detailed information view the
			 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>.
			 * @property maxWidth
			 * @type Number
			*/
			this.maxWidth = null;
		
			/**
			 * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
			 * @property outline
			 * @type Number
			 **/
			this.outline = 0;
		
			/**
			 * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
			 * the value of getMeasuredLineHeight is used.
			 * @property lineHeight
			 * @type Number
			 **/
			this.lineHeight = 0;
		
			/**
			 * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
			 * the text will not be wrapped.
			 * @property lineWidth
			 * @type Number
			 **/
			this.lineWidth = null;
		}
		var p = createjs.extend(Text, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		
	// static properties:
		/**
		 * @property _workingContext
		 * @type CanvasRenderingContext2D
		 * @private
		 **/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }
		
		
	// constants:
		/**
		 * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.
		 * @property H_OFFSETS
		 * @type Object
		 * @protected
		 * @static
		 **/
		Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};
		
		/**
		 * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.
		 * @property H_OFFSETS
		 * @type Object
		 * @protected
		 * @static
		 **/
		Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
	
			var col = this.color || "#000";
			if (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }
			else { ctx.fillStyle = col; }
			
			this._drawText(this._prepContext(ctx));
			return true;
		};
	
		/**
		 * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
		 * @method getMeasuredWidth
		 * @return {Number} The measured, untransformed width of the text.
		 **/
		p.getMeasuredWidth = function() {
			return this._getMeasuredWidth(this.text);
		};
	
		/**
		 * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
		 * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
		 * @method getMeasuredLineHeight
		 * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
		 * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
		 **/
		p.getMeasuredLineHeight = function() {
			return this._getMeasuredWidth("M")*1.2;
		};
	
		/**
		 * Returns the approximate height of multi-line text by multiplying the number of lines against either the
		 * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that
		 * this operation requires the text flowing logic to run, which has an associated CPU cost.
		 * @method getMeasuredHeight
		 * @return {Number} The approximate height of the untransformed multi-line text.
		 **/
		p.getMeasuredHeight = function() {
			return this._drawText(null,{}).height;
		};
	
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			var rect = this.DisplayObject_getBounds();
			if (rect) { return rect; }
			if (this.text == null || this.text === "") { return null; }
			var o = this._drawText(null, {});
			var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
			var x = w * Text.H_OFFSETS[this.textAlign||"left"];
			var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
			var y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
			return this._rectangle.setValues(x, y, w, o.height);
		};
		
		/**
		 * Returns an object with width, height, and lines properties. The width and height are the visual width and height
		 * of the drawn text. The lines property contains an array of strings, one for
		 * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
		 * whitespace removed.
		 * @method getMetrics
		 * @return {Object} An object with width, height, and lines properties.
		 **/
		p.getMetrics = function() {
			var o = {lines:[]};
			o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
			o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
			return this._drawText(null, o, o.lines);
		};
	
		/**
		 * Returns a clone of the Text instance.
		 * @method clone
		 * @return {Text} a clone of the Text instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new Text(this.text, this.font, this.color));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";
		};
	
	
	// private methods:
		/**
		 * @method _cloneProps
		 * @param {Text} o
		 * @protected
		 * @return {Text} o
		 **/
		p._cloneProps = function(o) {
			this.DisplayObject__cloneProps(o);
			o.textAlign = this.textAlign;
			o.textBaseline = this.textBaseline;
			o.maxWidth = this.maxWidth;
			o.outline = this.outline;
			o.lineHeight = this.lineHeight;
			o.lineWidth = this.lineWidth;
			return o;
		};
	
		/**
		 * @method _getWorkingContext
		 * @param {CanvasRenderingContext2D} ctx
		 * @return {CanvasRenderingContext2D}
		 * @protected
		 **/
		p._prepContext = function(ctx) {
			ctx.font = this.font||"10px sans-serif";
			ctx.textAlign = this.textAlign||"left";
			ctx.textBaseline = this.textBaseline||"top";
			ctx.lineJoin = "miter";
			ctx.miterLimit = 2.5;
			return ctx;
		};
	
		/**
		 * Draws multiline text.
		 * @method _drawText
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {Object} o
		 * @param {Array} lines
		 * @return {Object}
		 * @protected
		 **/
		p._drawText = function(ctx, o, lines) {
			var paint = !!ctx;
			if (!paint) {
				ctx = Text._workingContext;
				ctx.save();
				this._prepContext(ctx);
			}
			var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
			
			var maxW = 0, count = 0;
			var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
			for (var i=0, l=hardLines.length; i<l; i++) {
				var str = hardLines[i];
				var w = null;
				
				if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
					// text wrapping:
					var words = str.split(/(\s)/);
					str = words[0];
					w = ctx.measureText(str).width;
					
					for (var j=1, jl=words.length; j<jl; j+=2) {
						// Line needs to wrap:
						var wordW = ctx.measureText(words[j] + words[j+1]).width;
						if (w + wordW > this.lineWidth) {
							if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
							if (lines) { lines.push(str); }
							if (w > maxW) { maxW = w; }
							str = words[j+1];
							w = ctx.measureText(str).width;
							count++;
						} else {
							str += words[j] + words[j+1];
							w += wordW;
						}
					}
				}
				
				if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
				if (lines) { lines.push(str); }
				if (o && w == null) { w = ctx.measureText(str).width; }
				if (w > maxW) { maxW = w; }
				count++;
			}
			
			if (o) {
				o.width = maxW;
				o.height = count*lineHeight;
			}
			if (!paint) { ctx.restore(); }
			return o;
		};
	
		/**
		 * @method _drawTextLine
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {String} text
		 * @param {Number} y
		 * @protected
		 **/
		p._drawTextLine = function(ctx, text, y) {
			// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
			if (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }
			else { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }
		};
		
		
		/**
		 * @method _getMeasuredWidth
		 * @param {String} text
		 * @protected
		 **/
		p._getMeasuredWidth = function(text) {
			var ctx = Text._workingContext;
			ctx.save();
			var w = this._prepContext(ctx).measureText(text).width;
			ctx.restore();
			return w;
		};
	
	
		createjs.Text = createjs.promote(Text, "DisplayObject");
	}());
	
	//##############################################################################
	// BitmapText.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
	
	
	// constructor:
		/**
		 * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported using new line characters,
		 * but automatic wrapping is not supported. See the {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}
		 * property for more information on defining glyphs.
		 *
		 * <strong>Important:</strong> While BitmapText extends Container, it is not designed to be used as one.
		 * As such, methods like addChild and removeChild are disabled.
		 *
		 *
		 * @class BitmapText
		 * @extends DisplayObject
		 * @param {String} [text=""] The text to display.
		 * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.
		 * @constructor
		 **/
		function BitmapText(text, spriteSheet) {
			this.Container_constructor();
			
			
		// public properties:
			/**
			 * The text to display.
			 * @property text
			 * @type String
			 * @default ""
			 **/
			this.text = text||"";
			
			/**
			 * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character
			 * should have a single frame animation defined in the sprite sheet named the same as
			 * corresponding character. For example, the following animation definition:
			 *
			 * 		"A": {frames: [0]}
			 *
			 * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form
			 * is also acceptable:
			 * 
			 * 		"A": 0
			 *
			 * Note that if a character in the text is not found in the sprite sheet, it will also
			 * try to use the alternate case (upper or lower).
			 *
			 * See SpriteSheet for more information on defining sprite sheet data.
			 * @property spriteSheet
			 * @type SpriteSheet
			 * @default null
			 **/
			this.spriteSheet = spriteSheet;
		
			/**
			 * The height of each line of text. If 0, then it will use a line height calculated
			 * by checking for the height of the "1", "T", or "L" character (in that order). If
			 * those characters are not defined, it will use the height of the first frame of the
			 * sprite sheet.
			 * @property lineHeight
			 * @type Number
			 * @default 0
			 **/
			this.lineHeight = 0;
		
			/**
			 * This spacing (in pixels) will be added after each character in the output.
			 * @property letterSpacing
			 * @type Number
			 * @default 0
			 **/
			this.letterSpacing = 0;
		
			/**
			 * If a space character is not defined in the sprite sheet, then empty pixels equal to
			 * spaceWidth will be inserted instead. If 0, then it will use a value calculated
			 * by checking for the width of the "1", "l", "E", or "A" character (in that order). If
			 * those characters are not defined, it will use the width of the first frame of the
			 * sprite sheet.
			 * @property spaceWidth
			 * @type Number
			 * @default 0
			 **/
			this.spaceWidth = 0;
			
			
		// private properties:
		 	/**
			 * @property _oldProps
			 * @type Object
			 * @protected
			 **/
			this._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};
	
			/**
			 * Used to track the object which this class attached listeners to, helps optimize listener attachment.
			 * @property _oldStage
			 * @type Stage
			 * @protected
			 */
			this._oldStage = null;
			/**
			 * The event listener proxy triggered drawing draw for special circumstances.
			 * @property _drawAction
			 * @type function
			 * @protected
			 */
			this._drawAction = null;
		}
		var p = createjs.extend(BitmapText, createjs.Container);
	
	// static properties:
		/**
		 * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains
		 * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be
		 * retained, slightly increasing memory use, but reducing instantiation.
		 * @property maxPoolSize
		 * @type Number
		 * @static
		 * @default 100
		 **/
		BitmapText.maxPoolSize = 100;
		
		/**
		 * Sprite object pool.
		 * @type {Array}
		 * @static
		 * @private
		 */
		BitmapText._spritePool = [];
	
		
	// public methods:
		/**
		 * Docced in superclass.
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return; }
			this._updateState();
			this.Container_draw(ctx, ignoreCache);
		};
		
		/**
		 * Docced in superclass.
		 **/
		p.getBounds = function() {
			this._updateText();
			return this.Container_getBounds();
		};
		
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);
			return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
		};
		
		p.clone = function() {
			return this._cloneProps(new BitmapText(this.text, this.spriteSheet));
		};
		
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method addChild
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method addChildAt
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeChild
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeChildAt
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeAllChildren
		 **/
		p.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};
	
	
	// private methods:
		/**
		 * Docced in superclass.
		 **/
		p._updateState = function() {
			this._updateText();
		};
	
	 	/**
		 * @method _cloneProps
		 * @param {BitmapText} o
		 * @return {BitmapText} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			this.Container__cloneProps(o);
			o.lineHeight = this.lineHeight;
			o.letterSpacing = this.letterSpacing;
			o.spaceWidth = this.spaceWidth;
			return o;
		};
		
		/**
		 * @method _getFrameIndex
		 * @param {String} character
		 * @param {SpriteSheet} spriteSheet
		 * @return {Number}
		 * @protected
		 **/
		p._getFrameIndex = function(character, spriteSheet) {
			var c, o = spriteSheet.getAnimation(character);
			if (!o) {
				(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);
				if (c) { o = spriteSheet.getAnimation(c); }
			}
			return o && o.frames[0];
		};
		
		/**
		 * @method _getFrame
		 * @param {String} character
		 * @param {SpriteSheet} spriteSheet
		 * @return {Object}
		 * @protected
		 **/
		p._getFrame = function(character, spriteSheet) {
			var index = this._getFrameIndex(character, spriteSheet);
			return index == null ? index : spriteSheet.getFrame(index);
		};
	
		/**
		 * @method _getLineHeight
		 * @param {SpriteSheet} ss
		 * @return {Number}
		 * @protected
		 **/
		p._getLineHeight = function(ss) {
			var frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);
			return frame ? frame.rect.height : 1;
		};
	
		/**
		 * @method _getSpaceWidth
		 * @param {SpriteSheet} ss
		 * @return {Number}
		 * @protected
		 **/
		p._getSpaceWidth = function(ss) {
			var frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);
			return frame ? frame.rect.width : 1;
		};
	
		/**
		 * @method _updateText
		 * @protected
		 **/
		p._updateText = function() {
			var x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;
			var pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;
			
			for (var n in o) {
				if (o[n] != this[n]) {
					o[n] = this[n];
					change = true;
				}
			}
			if (!change) { return; }
			
			var hasSpace = !!this._getFrame(" ", ss);
			if (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }
			if (!lineH) { lineH = this._getLineHeight(ss); }
			
			for(var i=0, l=this.text.length; i<l; i++) {
				var character = this.text.charAt(i);
				if (character == " " && !hasSpace) {
					x += spaceW;
					continue;
				} else if (character=="\n" || character=="\r") {
					if (character=="\r" && this.text.charAt(i+1) == "\n") { i++; } // crlf
					x = 0;
					y += lineH;
					continue;
				}
	
				var index = this._getFrameIndex(character, ss);
				if (index == null) { continue; }
				
				if (childIndex < numKids) {
					sprite = kids[childIndex];
				} else {
					kids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());
					sprite.parent = this;
					numKids++;
				}
				sprite.spriteSheet = ss;
				sprite.gotoAndStop(index);
				sprite.x = x;
				sprite.y = y;
				childIndex++;
				
				x += sprite.getBounds().width + this.letterSpacing;
			}
			while (numKids > childIndex) {
				 // faster than removeChild.
				pool.push(sprite = kids.pop());
				sprite.parent = null;
				numKids--;
			}
			if (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }
		};
	
	
		createjs.BitmapText = createjs.promote(BitmapText, "Container");
	}());
	
	//##############################################################################
	// MovieClip.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink "Container"}}{{/crossLink}}. It allows
		 * you to create objects which encapsulate timeline animations, state changes, and synched actions. The MovieClip
		 * class has been included in the EaselJS minified file since 0.7.0.
		 *
		 * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have
		 * been made to support time-based timelines in the future.
		 *
		 * <h4>Example</h4>
		 * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in
		 * the animation using {{#crossLink "MovieClip/gotoAndPlay"}}{{/crossLink}}.
		 *
		 *      var stage = new createjs.Stage("canvas");
		 *      createjs.Ticker.addEventListener("tick", stage);
		 *
		 *      var mc = new createjs.MovieClip({loop:-1, labels:{myLabel:20}});
		 *      stage.addChild(mc);
		 *
		 *      var child1 = new createjs.Shape(
		 *          new createjs.Graphics().beginFill("#999999")
		 *              .drawCircle(30,30,30));
		 *      var child2 = new createjs.Shape(
		 *          new createjs.Graphics().beginFill("#5a9cfb")
		 *              .drawCircle(30,30,30));
		 *
		 *      mc.timeline.addTween(
		 *          createjs.Tween.get(child1)
		 *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));
		 *      mc.timeline.addTween(
		 *          createjs.Tween.get(child2)
		 *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));
		 *
		 *      mc.gotoAndPlay("start");
		 *
		 * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set
		 * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the
		 * <code>tween.set()</code> method to affect properties will likely not provide the desired result.
		 *
		 * @class MovieClip
		 * @main MovieClip
		 * @param {Object} [props] The configuration properties to apply to this instance (ex. `{mode:MovieClip.SYNCHED}`).
		 * Supported props for the MovieClip are listed below. These props are set on the corresponding instance properties except where
		 * specified.<UL>
		 *    <LI> `mode`</LI>
		 *    <LI> `startPosition`</LI>
		 *    <LI> `frameBounds`</LI>
		 * </UL>
		 * 
		 * This object will also be passed into the Timeline instance associated with this MovieClip. See the documentation
		 * for Timeline for a list of supported props (ex. `paused`, `labels`, `loop`, `reversed`, etc.)
		 * @extends Container
		 * @constructor
		 **/
		function MovieClip(props) {
			this.Container_constructor();
			!MovieClip.inited&&MovieClip.init(); // static init
			
			var mode, startPosition, loop, labels;
			
			// handle old params (mode, startPosition, loop, labels):
			// TODO: deprecated param handling:
			if (props instanceof String || arguments.length > 1) {
				mode = props;
				startPosition = arguments[1];
				loop = arguments[2];
				labels = arguments[3];
				if (loop == null) { loop = -1; }
				props = null;
			} else if (props) {
				mode = props.mode;
				startPosition = props.startPosition;
				loop = props.loop;
				labels = props.labels;
			}
			if (!props) { props = {labels:labels}; }
			
			
		// public properties:
			/**
			 * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).
			 * See each constant for a description of the behaviour.
			 * @property mode
			 * @type String
			 * @default null
			 **/
			this.mode = mode||MovieClip.INDEPENDENT;
		
			/**
			 * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.
			 * @property startPosition
			 * @type Number
			 * @default 0
			 */
			this.startPosition = startPosition||0;
		
			/**
			 * Specifies how many times this MovieClip should loop. A value of -1 indicates it should loop indefinitely. A value of
			 * 1 would cause it to loop once (ie. play a total of twice).
			 * @property loop
			 * @type Number
			 * @default -1
			 */
			this.loop = loop === true ? -1 : (loop || 0);
		
			/**
			 * The current frame of the movieclip.
			 * @property currentFrame
			 * @type Number
			 * @default 0
			 * @readonly
			 */
			this.currentFrame = 0;
		
			/**
			 * If true, the MovieClip's position will not advance when ticked.
			 * @property paused
			 * @type Boolean
			 * @default false
			 */
			this.paused = props.paused||false;
		
			/**
			 * If true, actions in this MovieClip's tweens will be run when the playhead advances.
			 * @property actionsEnabled
			 * @type Boolean
			 * @default true
			 */
			this.actionsEnabled = true;
		
			/**
			 * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds
			 * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.
			 * <br><br>
			 * For example, if you had a character animation with a "body" child MovieClip instance
			 * with different costumes on each frame, you could set body.autoReset = false, so that
			 * you can manually change the frame it is on, without worrying that it will be reset
			 * automatically.
			 * @property autoReset
			 * @type Boolean
			 * @default true
			 */
			this.autoReset = true;
			
			/**
			 * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.
			 * @property frameBounds
			 * @type Array
			 * @default null
			 */
			this.frameBounds = this.frameBounds||props.frameBounds; // frameBounds are set on the prototype in Animate.
			
			/**
			 * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip
			 * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
			 * framerate.
			 *
			 * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will
			 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
			 * vary slightly between frames.
			 *
			 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
			 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
			 * @property framerate
			 * @type {Number}
			 * @default null
			 **/
			this.framerate = null;
			
			// set up the needed props for Timeline:
			props.useTicks = props.paused = true;
			
			/**
			 * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip
			 * instance is initialized. Animations are created by adding <a href="http://tweenjs.com">TweenJS</a> Tween
			 * instances to the timeline.
			 *
			 * <h4>Example</h4>
			 *
			 *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);
			 *      var mc = new createjs.MovieClip();
			 *      mc.timeline.addTween(tween);
			 *
			 * Elements can be added and removed from the timeline by toggling an "_off" property
			 * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to
			 * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for
			 * frame 1. You can use the "visible" property to achieve the same effect.
			 *
			 *      var tween = createjs.Tween.get(target).to({_off:false})
			 *          .wait(1).to({_off:true})
			 *          .wait(1).to({_off:false});
			 *
			 * @property timeline
			 * @type Timeline
			 * @default null
			 */
			this.timeline = new createjs.Timeline(props);
			
			
		// private properties:
			/**
			 * @property _synchOffset
			 * @type Number
			 * @default 0
			 * @private
			 */
			this._synchOffset = 0;
		
			/**
			 * @property _rawPosition
			 * @type Number
			 * @default -1
			 * @private
			 */
			this._rawPosition = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.
			
			/**
			 * @property _bound_resolveState
			 * @type Function
			 * @private
			 */
			this._bound_resolveState = this._resolveState.bind(this);
		
		
			/**
			 * The time remaining from the previous tick, only applicable when .framerate is set.
			 * @property _t
			 * @type Number
			 * @private
			 */
			this._t = 0;
		
			/**
			 * List of display objects that are actively being managed by the MovieClip.
			 * @property _managed
			 * @type Object
			 * @private
			 */
			this._managed = {};
		}
		var p = createjs.extend(MovieClip, createjs.Container);
	
	
	// constants:
		/**
		 * The MovieClip will advance independently of its parent, even if its parent is paused.
		 * This is the default mode.
		 * @property INDEPENDENT
		 * @static
		 * @type String
		 * @default "independent"
		 * @readonly
		 **/
		MovieClip.INDEPENDENT = "independent";
	
		/**
		 * The MovieClip will only display a single frame (as determined by the startPosition property).
		 * @property SINGLE_FRAME
		 * @static
		 * @type String
		 * @default "single"
		 * @readonly
		 **/
		MovieClip.SINGLE_FRAME = "single";
	
		/**
		 * The MovieClip will be advanced only when its parent advances and will be synched to the position of
		 * the parent MovieClip.
		 * @property SYNCHED
		 * @static
		 * @type String
		 * @default "synched"
		 * @readonly
		 **/
		MovieClip.SYNCHED = "synched";
		
		
	// static properties:
		MovieClip.inited = false;
		
		
	// static methods:
		MovieClip.init = function() {
			if (MovieClip.inited) { return; }
			// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.
			MovieClipPlugin.install();
			MovieClip.inited = true;
		};
		
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "MovieClip/labels:property"}}{{/crossLink}} property instead.
		 * @method _getLabels
		 * @protected
		 * @return {Array}
		 **/
		p._getLabels = function() {
			return this.timeline.getLabels();
		};
		// MovieClip.getLabels is @deprecated. Remove for 1.1+
		p.getLabels = createjs.deprecate(p._getLabels, "MovieClip.getLabels");
	
		/**
		 * Use the {{#crossLink "MovieClip/currentLabel:property"}}{{/crossLink}} property instead.
		 * @method _getCurrentLabel
		 * @protected
		 * @return {String}
		 **/
		p._getCurrentLabel = function() {
			return this.timeline.currentLabel;
		};
		// MovieClip.getCurrentLabel is @deprecated. Remove for 1.1+
		p.getCurrentLabel = createjs.deprecate(p._getCurrentLabel, "MovieClip.getCurrentLabel");
	
		/**
		 * Use the {{#crossLink "MovieClip/duration:property"}}{{/crossLink}} property instead.
		 * @method _getDuration
		 * @protected
		 * @return {Number}
		 **/
		p._getDuration = function() {
			return this.timeline.duration;
		};
		// MovieClip.getDuration is @deprecated. Remove for 1.1+
		p.getDuration = createjs.deprecate(p._getDuration, "MovieClip.getDuration");
	
		/**
		 * Returns an array of objects with label and position (aka frame) properties, sorted by position.
		 * @property labels
		 * @type {Array}
		 * @readonly
		 **/
		
		/**
		 * Returns the name of the label on or immediately before the current frame.
		 * @property currentLabel
		 * @type {String}
		 * @readonly
		 **/
		
		/**
		 * Returns the duration of this MovieClip in seconds or ticks.
		 * @property totalFrames
		 * @type {Number}
		 * @readonly
		 **/
		
		/**
		 * Returns the duration of this MovieClip in seconds or ticks.
		 * @property duration
		 * @type {Number}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				labels: { get: p._getLabels },
				currentLabel: { get: p._getCurrentLabel },
				totalFrames: { get: p._getDuration },
				duration: { get: p._getDuration }
				// TODO: can we just proxy .currentFrame to tl.position as well? Ditto for .loop (or just remove entirely).
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of Adobe Flash/Animate
	
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			// children are placed in draw, so we can't determine if we have content.
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			// draw to cache first:
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this._updateState();
			this.Container_draw(ctx, ignoreCache);
			return true;
		};
	
		/**
		 * Sets paused to false.
		 * @method play
		 **/
		p.play = function() {
			this.paused = false;
		};
		
		/**
		 * Sets paused to true.
		 * @method stop
		 **/
		p.stop = function() {
			this.paused = true;
		};
		
		/**
		 * Advances this movie clip to the specified position or label and sets paused to false.
		 * @method gotoAndPlay
		 * @param {String|Number} positionOrLabel The animation name or frame number to go to.
		 **/
		p.gotoAndPlay = function(positionOrLabel) {
			this.paused = false;
			this._goto(positionOrLabel);
		};
		
		/**
		 * Advances this movie clip to the specified position or label and sets paused to true.
		 * @method gotoAndStop
		 * @param {String|Number} positionOrLabel The animation or frame name to go to.
		 **/
		p.gotoAndStop = function(positionOrLabel) {
			this.paused = true;
			this._goto(positionOrLabel);
		};
		
		/**
		 * Advances the playhead. This occurs automatically each tick by default.
		 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.
		 * @method advance
		*/
		p.advance = function(time) {
			var independent = MovieClip.INDEPENDENT;
			if (this.mode !== independent) { return; } // update happens in draw for synched clips
			
			// if this MC doesn't have a framerate, hunt ancestors for one:
			var o=this, fps = o.framerate;
			while ((o = o.parent) && fps === null) { if (o.mode === independent) { fps = o._framerate; } }
			this._framerate = fps;
			
			if (this.paused) { return; }
			
			// calculate how many frames to advance:
			var t = (fps !== null && fps !== -1 && time !== null) ? time/(1000/fps) + this._t : 1;
			var frames = t|0;
			this._t = t-frames; // leftover time, save to add to next advance.
			
			while (frames--) { this._updateTimeline(this._rawPosition+1, false); }
		};
		
		/**
		 * MovieClip instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.
			throw("MovieClip cannot be cloned.");
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[MovieClip (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * Docced in superclass.
		 **/
		p._updateState = function() {
			if (this._rawPosition === -1 || this.mode !== MovieClip.INDEPENDENT) { this._updateTimeline(-1); }
		};
	
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * function.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			this.advance(evtObj&&evtObj.delta);
			this.Container__tick(evtObj);
		};
		
		/**
		 * @method _goto
		 * @param {String|Number} positionOrLabel The animation name or frame number to go to.
		 * @protected
		 **/
		p._goto = function(positionOrLabel) {
			var pos = this.timeline.resolve(positionOrLabel);
			if (pos == null) { return; }
			this._t = 0;
			this._updateTimeline(pos, true);
		};
		
		/**
		 * @method _reset
		 * @private
		 **/
		p._reset = function() {
			this._rawPosition = -1;
			this._t = this.currentFrame = 0;
			this.paused = false;
		};
		
		/**
		 * @method _updateTimeline
		 * @param {Boolean} jump Indicates whether this update is due to jumping (via gotoAndXX) to a new position.
		 * @protected
		 **/
		p._updateTimeline = function(rawPosition, jump) {
			var synced = this.mode !== MovieClip.INDEPENDENT, tl = this.timeline;
			if (synced) { rawPosition = this.startPosition + (this.mode===MovieClip.SINGLE_FRAME?0:this._synchOffset); }
			if (rawPosition < 0) { rawPosition = 0; }
			if (this._rawPosition === rawPosition && !synced) { return; }
			this._rawPosition = rawPosition;
			
			// update timeline position, ignoring actions if this is a graphic.
			tl.loop = this.loop; // TODO: should we maintain this on MovieClip, or just have it on timeline?
			tl.setPosition(rawPosition, synced || !this.actionsEnabled, jump, this._bound_resolveState);
		};
		
		/**
		 * Renders position 0 without running actions or updating _rawPosition.
		 * Primarily used by Animate CC to build out the first frame in the constructor of MC symbols.
		 * NOTE: not tested when run after the MC advances past the first frame.
		 * @method _renderFirstFrame
		 * @protected
		 **/
		p._renderFirstFrame = function() {
			var tl = this.timeline, pos = tl.rawPosition;
			tl.setPosition(0, true, true, this._bound_resolveState);
			tl.rawPosition = pos;
		};
		
		/**
		 * Runs via a callback after timeline property updates and before actions.
		 * @method _resolveState
		 * @protected
		 **/
		p._resolveState = function() {
			var tl = this.timeline;
			this.currentFrame = tl.position;
			
			for (var n in this._managed) { this._managed[n] = 1; }
	
			var tweens = tl.tweens;
			for (var i=0, l=tweens.length; i<l; i++) {
				var tween = tweens[i],  target = tween.target;
				if (target === this || tween.passive) { continue; } // TODO: this assumes the actions tween from Animate has `this` as the target. There's likely a better approach.
				var offset = tween._stepPosition;
	
				if (target instanceof createjs.DisplayObject) {
					// motion tween.
					this._addManagedChild(target, offset);
				} else {
					// state tween.
					this._setState(target.state, offset);
				}
			}
	
			var kids = this.children;
			for (i=kids.length-1; i>=0; i--) {
				var id = kids[i].id;
				if (this._managed[id] === 1) {
					this.removeChildAt(i);
					delete(this._managed[id]);
				}
			}
		};
	
		/**
		 * @method _setState
		 * @param {Array} state
		 * @param {Number} offset
		 * @protected
		 **/
		p._setState = function(state, offset) {
			if (!state) { return; }
			for (var i=state.length-1;i>=0;i--) {
				var o = state[i];
				var target = o.t;
				var props = o.p;
				for (var n in props) { target[n] = props[n]; }
				this._addManagedChild(target, offset);
			}
		};
	
		/**
		 * Adds a child to the timeline, and sets it up as a managed child.
		 * @method _addManagedChild
		 * @param {MovieClip} child The child MovieClip to manage
		 * @param {Number} offset
		 * @private
		 **/
		p._addManagedChild = function(child, offset) {
			if (child._off) { return; }
			this.addChildAt(child,0);
	
			if (child instanceof MovieClip) {
				child._synchOffset = offset;
				// TODO: this does not precisely match Adobe Flash/Animate, which loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.
				// TODO: should also reset when MovieClip loops, though that will be a bit tricky to detect.
				if (child.mode === MovieClip.INDEPENDENT && child.autoReset && (!this._managed[child.id])) { child._reset(); }
			}
			this._managed[child.id] = 2;
		};
		
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform) {
			var bounds = this.DisplayObject_getBounds();
			if (!bounds) {
				if (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }
			}
			if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
			return this.Container__getBounds(matrix, ignoreTransform);
		};
	
	
		createjs.MovieClip = createjs.promote(MovieClip, "Container");
	
	
	
	// MovieClipPlugin for TweenJS:
		/**
		 * This plugin works with <a href="http://tweenjs.com" target="_blank">TweenJS</a> to prevent the startPosition
		 * property from tweening.
		 * @private
		 * @class MovieClipPlugin
		 * @constructor
		 **/
		function MovieClipPlugin() {
			throw("MovieClipPlugin cannot be instantiated.")
		}
		
		/**
		 * @property priority
		 * @type {Number}
		 * @static
		 * @readonly
		 **/
		MovieClipPlugin.priority = 100; // very high priority, should run first
		
		/**
		 * @property ID
		 * @type {String}
		 * @static
		 * @readonly
		 **/
		MovieClipPlugin.ID = "MovieClip";
	
		/**
		 * @method install
		 * @static
		 **/
		MovieClipPlugin.install = function() {
			createjs.Tween._installPlugin(MovieClipPlugin);
		};
		
		/**
		 * @method init
		 * @param {Tween} tween
		 * @param {String} prop
		 * @param {*} value
		 * @static
		 **/
		MovieClipPlugin.init = function(tween, prop, value) {
			if (prop === "startPosition" && tween.target instanceof MovieClip) { tween._addPlugin(MovieClipPlugin); }
		};
		
		/**
		 * @method step
		 * @param {Tween} tween
		 * @param {TweenStep} step
		 * @param {Object} props
		 * @static
		 **/
		MovieClipPlugin.step = function(tween, step, props) {};
	
		/**
		 * @method change
		 * @param {Tween} tween
		 * @param {TweenStep} step
		 * @param {*} value
		 * @param {Number} ratio
		 * @param {Object} end
		 * @return {*}
		 * @static
		 */
		MovieClipPlugin.change = function(tween, step, prop, value, ratio, end) {
			if (prop === "startPosition") { return (ratio === 1 ? step.props[prop] : step.prev.props[prop]); }
		};
	
	}());
	
	//##############################################################################
	// SpriteSheetUtils.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
		
		
	// constructor:
		/**
		 * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.
		 * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For
		 * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across
		 * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.
		 * @class SpriteSheetUtils
		 * @static
		 **/
		function SpriteSheetUtils() {
			throw "SpriteSheetUtils cannot be instantiated";
		}
	
	
	// private static properties:
		/**
		 * @property _workingCanvas
		 * @static
		 * @type HTMLCanvasElement | Object
		 * @protected
		*/
		/**
		 * @property _workingContext
		 * @static
		 * @type CanvasRenderingContext2D
		 * @protected
		*/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) {
			SpriteSheetUtils._workingCanvas = canvas;
			SpriteSheetUtils._workingContext = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	
	// public static methods:
		/**
		 * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is
		 * to use a spritesheet frame as the source for a bitmap fill.
		 *
		 * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}
		 * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this
		 * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}
		 * property of {{#crossLink "Bitmap"}}{{/crossLink}}.
		 *
		 * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.
		 * @method extractFrame
		 * @static
		 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.
		 * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation
		 * name is specified, only the first frame of the animation will be extracted.
		 * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.
		*/
		SpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {
			if (isNaN(frameOrAnimation)) {
				frameOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];
			}
			var data = spriteSheet.getFrame(frameOrAnimation);
			if (!data) { return null; }
			var r = data.rect;
			var canvas = SpriteSheetUtils._workingCanvas;
			canvas.width = r.width;
			canvas.height = r.height;
			SpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
			var img = document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			return img;
		};
	
		// SpriteSheetUtils.addFlippedFrames is @deprecated. Remove for 1.1+
		SpriteSheetUtils.addFlippedFrames = createjs.deprecate(null, "SpriteSheetUtils.addFlippedFrames");
	
		// SpriteSheetUtils.addFlippedFrames is @deprecated. Remove for 1.1+
		SpriteSheetUtils.mergeAlpha = createjs.deprecate(null, "SpriteSheetUtils.mergeAlpha");
	
		
	// private static methods:
		SpriteSheetUtils._flip = function(spriteSheet, count, h, v) {
			var imgs = spriteSheet._images;
			var canvas = SpriteSheetUtils._workingCanvas;
			var ctx = SpriteSheetUtils._workingContext;
			var il = imgs.length/count;
			for (var i=0;i<il;i++) {
				var src = imgs[i];
				src.__tmp = i; // a bit hacky, but faster than doing indexOf below.
				ctx.setTransform(1,0,0,1,0,0);
				ctx.clearRect(0,0,canvas.width+1,canvas.height+1);
				canvas.width = src.width;
				canvas.height = src.height;
				ctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);
				ctx.drawImage(src,0,0);
				var img = document.createElement("img");
				img.src = canvas.toDataURL("image/png");
				// work around a strange bug in Safari:
				img.width = (src.width||src.naturalWidth);
				img.height = (src.height||src.naturalHeight);
				imgs.push(img);
			}
	
			var frames = spriteSheet._frames;
			var fl = frames.length/count;
			for (i=0;i<fl;i++) {
				src = frames[i];
				var rect = src.rect.clone();
				img = imgs[src.image.__tmp+il*count];
	
				var frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};
				if (h) {
					rect.x = (img.width||img.naturalWidth)-rect.x-rect.width; // update rect
					frame.regX = rect.width-src.regX; // update registration point
				}
				if (v) {
					rect.y = (img.height||img.naturalHeight)-rect.y-rect.height;  // update rect
					frame.regY = rect.height-src.regY; // update registration point
				}
				frames.push(frame);
			}
	
			var sfx = "_"+(h?"h":"")+(v?"v":"");
			var names = spriteSheet._animations;
			var data = spriteSheet._data;
			var al = names.length/count;
			for (i=0;i<al;i++) {
				var name = names[i];
				src = data[name];
				var anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};
				if (src.next) { anim.next += sfx; }
				frames = src.frames;
				for (var j=0,l=frames.length;j<l;j++) {
					anim.frames.push(frames[j]+fl*count);
				}
				data[anim.name] = anim;
				names.push(anim.name);
			}
		};
	
	
		createjs.SpriteSheetUtils = SpriteSheetUtils;
	}());
	
	//##############################################################################
	// SpriteSheetBuilder.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The SpriteSheetBuilder allows you to generate {{#crossLink "SpriteSheet"}}{{/crossLink}} instances at run time
		 * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and
		 * render them at run time as SpriteSheets for better performance.
		 *
		 * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated
		 * without locking the UI.
		 *
		 * Note that the "images" used in the generated SpriteSheet are actually canvas elements, and that they will be
		 * sized to the nearest power of 2 up to the value of {{#crossLink "SpriteSheetBuilder/maxWidth:property"}}{{/crossLink}}
		 * or {{#crossLink "SpriteSheetBuilder/maxHeight:property"}}{{/crossLink}}.
		 * @class SpriteSheetBuilder
		 * @param {Number} [framerate=0] The {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} of
		 * {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are created.
		 * @extends EventDispatcher
		 * @constructor
		 **/
		function SpriteSheetBuilder(framerate) {
			this.EventDispatcher_constructor();
			
		// public properties:
			/**
			 * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to
			 * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max
			 * dimensions, then additional images will be created as needed.
			 * @property maxWidth
			 * @type Number
			 * @default 2048
			*/
			this.maxWidth = 2048;
		
			/**
			 * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to
			 * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max
			 * dimensions, then additional images will be created as needed.
			 * @property maxHeight
			 * @type Number
			 * @default 2048
			 **/
			this.maxHeight = 2048;
		
			/**
			 * The SpriteSheet that was generated. This will be null before a build is completed successfully.
			 * @property spriteSheet
			 * @type SpriteSheet
			 **/
			this.spriteSheet = null;
		
			/**
			 * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified
			 * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored
			 * to the a specific device resolution (ex. tablet vs mobile).
			 * @property scale
			 * @type Number
			 * @default 1
			 **/
			this.scale = 1;
		
			/**
			* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
			* @property padding
			* @type Number
			* @default 1
			**/
			this.padding = 1;
		
			/**
			 * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
			 * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
			 * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
			 * Defaults to 0.3.
			 * @property timeSlice
			 * @type Number
			 * @default 0.3
			 **/
			this.timeSlice = 0.3;
		
			/**
			 * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
			 * been initiated.
			 * @property progress
			 * @type Number
			 * @default -1
			 * @readonly
			 */
			this.progress = -1;
	
			/**
			 * A {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} value that will be passed to new {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are
			 * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink "Ticker"}}{{/crossLink}}
			 * framerate.
			 * @property framerate
			 * @type Number
			 * @default 0
			 */
			this.framerate = framerate || 0;
		
		
		// private properties:
			/**
			 * @property _frames
			 * @protected
			 * @type Array
			 **/
			this._frames = [];
		
			/**
			 * @property _animations
			 * @protected
			 * @type Array
			 **/
			this._animations = {};
		
			/**
			 * @property _data
			 * @protected
			 * @type Array
			 **/
			this._data = null;
		
			/**
			 * @property _nextFrameIndex
			 * @protected
			 * @type Number
			 **/
			this._nextFrameIndex = 0;
		
			/**
			 * @property _index
			 * @protected
			 * @type Number
			 **/
			this._index = 0;
		
			/**
			 * @property _timerID
			 * @protected
			 * @type Number
			 **/
			this._timerID = null;
		
			/**
			 * @property _scale
			 * @protected
			 * @type Number
			 **/
			this._scale = 1;
		}
		var p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);
	
	// constants:
		SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";
		SpriteSheetBuilder.ERR_RUNNING = "a build is already running";
	
	// events:
		/**
		 * Dispatched when a build completes.
		 * @event complete
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when an asynchronous build has progress.
		 * @event progress
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Number} progress The current progress value (0-1).
		 * @since 0.6.0
		 */
	
	
	// public methods:
		/**
		 * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you
		 * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have
		 * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
		 * times, but manipulate it or its children to change it to generate different frames.
		 *
		 * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply
		 * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}
		 * and pass in the Container as the source.
		 * @method addFrame
		 * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.
		 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the
		 * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or
		 * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.
		 * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
		 * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.
		 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
		 * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
		 **/
		p.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			var rect = sourceRect||source.bounds||source.nominalBounds;
			if (!rect&&source.getBounds) { rect = source.getBounds(); }
			if (!rect) { return null; }
			scale = scale||1;
			return this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;
		};
	
		/**
		 * Adds an animation that will be included in the created {{#crossLink "SpriteSheet"}}{{/crossLink}}.
		 * @method addAnimation
		 * @param {String} name The name for the animation.
		 * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
		 * that played frame indexes 3, 6, and 5 in that order.
		 * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
		 * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
		 * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would
		 * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had
		 * the opposite effect.
		 **/
		p.addAnimation = function(name, frames, next, speed) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this._animations[name] = {frames:frames, next:next, speed:speed};
		};
	
		/**
		 * This will take a {{#crossLink "MovieClip"}}{{/crossLink}} instance, and add its frames and labels to this
		 * builder. Labels will be added as an animation running from the label index to the next label. For example, if
		 * there is a label named "foo" at frame 0 and a label named "bar" at frame 10, in a MovieClip with 15 frames, it
		 * will add an animation named "foo" that runs from frame index 0 to 9, and an animation named "bar" that runs from
		 * frame index 10 to 14.
		 *
		 * Note that this will iterate through the full MovieClip with {{#crossLink "MovieClip/actionsEnabled:property"}}{{/crossLink}}
		 * set to `false`, ending on the last frame.
		 * @method addMovieClip
		 * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.
		 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to
		 * draw to the frame. If not specified, it will look for a {{#crossLink "DisplayObject/getBounds"}}{{/crossLink}}
		 * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not
		 * found, the MovieClip will be skipped.
		 * @param {Number} [scale=1] The scale to draw the movie clip at.
		 * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called
		 * with three parameters: the source, setupData, and the frame index.
		 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
		 * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four
		 * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)
		 * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.
		 **/
		p.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			var rects = source.frameBounds;
			var rect = sourceRect||source.bounds||source.nominalBounds;
			if (!rect&&source.getBounds) { rect = source.getBounds(); }
			if (!rect && !rects) { return; }
	
			var i, l, baseFrameIndex = this._frames.length;
			var duration = source.timeline.duration;
			for (i=0; i<duration; i++) {
				var r = (rects&&rects[i]) ? rects[i] : rect;
				this.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});
			}
			var labels = source.timeline._labels;
			var lbls = [];
			for (var n in labels) {
				lbls.push({index:labels[n], label:n});
			}
			if (lbls.length) {
				lbls.sort(function(a,b){ return a.index-b.index; });
				for (i=0,l=lbls.length; i<l; i++) {
					var label = lbls[i].label;
					var start = baseFrameIndex+lbls[i].index;
					var end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);
					var frames = [];
					for (var j=start; j<end; j++) { frames.push(j); }
					if (labelFunction) {
						label = labelFunction(label, source, start, end);
						if (!label) { continue; }
					}
					this.addAnimation(label, frames, true); // for now, this loops all animations.
				}
			}
		};
	
		/**
		 * Builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames.
		 * @method build
		 * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error
		 * occurred.
		 **/
		p.build = function() {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this._startBuild();
			while (this._drawNext()) {}
			this._endBuild();
			return this.spriteSheet;
		};
	
		/**
		 * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will
		 * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the
		 * specified callback.
		 * @method buildAsync
		 * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
		 **/
		p.buildAsync = function(timeSlice) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this.timeSlice = timeSlice;
			this._startBuild();
			var _this = this;
			this._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);
		};
	
		/**
		 * Stops the current asynchronous build.
		 * @method stopAsync
		 **/
		p.stopAsync = function() {
			clearTimeout(this._timerID);
			this._data = null;
		};
	
		/**
		 * SpriteSheetBuilder instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			throw("SpriteSheetBuilder cannot be cloned.");
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[SpriteSheetBuilder]";
		};
	
	
	// private methods:
		/**
		 * @method _startBuild
		 * @protected
		 **/
		p._startBuild = function() {
			var pad = this.padding||0;
			this.progress = 0;
			this.spriteSheet = null;
			this._index = 0;
			this._scale = this.scale;
			var dataFrames = [];
			this._data = {
				images: [],
				frames: dataFrames,
				framerate: this.framerate,
				animations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?
			};
	
			var frames = this._frames.slice();
			frames.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });
	
			if (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
			var y=0, x=0;
			var img = 0;
			while (frames.length) {
				var o = this._fillRow(frames, y, img, dataFrames, pad);
				if (o.w > x) { x = o.w; }
				y += o.h;
				if (!o.h || !frames.length) {
					var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
					canvas.width = this._getSize(x,this.maxWidth);
					canvas.height = this._getSize(y,this.maxHeight);
					this._data.images[img] = canvas;
					if (!o.h) {
						x=y=0;
						img++;
					}
				}
			}
		};
		
		/**
		 * @method _setupMovieClipFrame
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._setupMovieClipFrame = function(source, data) {
			var ae = source.actionsEnabled;
			source.actionsEnabled = false;
			source.gotoAndStop(data.i);
			source.actionsEnabled = ae;
			data.f&&data.f(source, data.d, data.i);
		};
	
		/**
		 * @method _getSize
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._getSize = function(size,max) {
			var pow = 4;
			while (Math.pow(2,++pow) < size){}
			return Math.min(max,Math.pow(2,pow));
		};
	
		/**
		 * @method _fillRow
		 * @param {Array} frames
		 * @param {Number} y
		 * @param {HTMLImageElement} img
		 * @param {Object} dataFrames
		 * @param {Number} pad
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._fillRow = function(frames, y, img, dataFrames, pad) {
			var w = this.maxWidth;
			var maxH = this.maxHeight;
			y += pad;
			var h = maxH-y;
			var x = pad;
			var height = 0;
			for (var i=frames.length-1; i>=0; i--) {
				var frame = frames[i];
				var sc = this._scale*frame.scale;
				var rect = frame.sourceRect;
				var source = frame.source;
				var rx = Math.floor(sc*rect.x-pad);
				var ry = Math.floor(sc*rect.y-pad);
				var rh = Math.ceil(sc*rect.height+pad*2);
				var rw = Math.ceil(sc*rect.width+pad*2);
				if (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
				if (rh > h || x+rw > w) { continue; }
				frame.img = img;
				frame.rect = new createjs.Rectangle(x,y,rw,rh);
				height = height || rh;
				frames.splice(i,1);
				dataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];
				x += rw;
			}
			return {w:x, h:height};
		};
	
		/**
		 * @method _endBuild
		 * @protected
		 **/
		p._endBuild = function() {
			this.spriteSheet = new createjs.SpriteSheet(this._data);
			this._data = null;
			this.progress = 1;
			this.dispatchEvent("complete");
		};
	
		/**
		 * @method _run
		 * @protected
		 **/
		p._run = function() {
			var ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;
			var t = (new Date()).getTime()+ts;
			var complete = false;
			while (t > (new Date()).getTime()) {
				if (!this._drawNext()) { complete = true; break; }
			}
			if (complete) {
				this._endBuild();
			} else {
				var _this = this;
				this._timerID = setTimeout(function() { _this._run(); }, 50-ts);
			}
			var p = this.progress = this._index/this._frames.length;
			if (this.hasEventListener("progress")) {
				var evt = new createjs.Event("progress");
				evt.progress = p;
				this.dispatchEvent(evt);
			}
		};
	
		/**
		 * @method _drawNext
		 * @protected
		 * @return Boolean Returns false if this is the last draw.
		 **/
		p._drawNext = function() {
			var frame = this._frames[this._index];
			var sc = frame.scale*this._scale;
			var rect = frame.rect;
			var sourceRect = frame.sourceRect;
			var canvas = this._data.images[frame.img];
			var ctx = canvas.getContext("2d");
			frame.funct&&frame.funct(frame.source, frame.data);
			ctx.save();
			ctx.beginPath();
			ctx.rect(rect.x, rect.y, rect.width, rect.height);
			ctx.clip();
			ctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));
			ctx.scale(sc,sc);
			frame.source.draw(ctx); // display object will draw itself.
			ctx.restore();
			return (++this._index) < this._frames.length;
		};
	
	
		createjs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");
	}());
	
	//##############################################################################
	// DOMElement.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>
		 *
		 * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed
		 * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is
		 * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be
		 * drawn in front of or behind the canvas).
		 *
		 * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that
		 * the DOM Object be added to a div that also contains the canvas so that they share the same position
		 * on the page.
		 *
		 * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements
		 * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML
		 * content.
		 *
		 * <h4>Mouse Interaction</h4>
		 *
		 * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse
		 * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to
		 * the htmlElement (note, this does not support EventDispatcher)
		 *
		 *      var domElement = new createjs.DOMElement(htmlElement);
		 *      domElement.htmlElement.onclick = function() {
		 *          console.log("clicked");
		 *      }
		 *
		 * <strong>Important:</strong> This class needs to be notified it is about to be drawn, this will happen automatically
		 * if you call stage.update, calling stage.draw or disabling tickEnabled will miss important steps and it will render
		 * stale information.
		 *
		 * @class DOMElement
		 * @extends DisplayObject
		 * @constructor
		 * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.
		 */
		function DOMElement(htmlElement) {
			this.DisplayObject_constructor();
			
			if (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }
			this.mouseEnabled = false;
			
			var style = htmlElement.style;
			style.position = "absolute";
			style.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";
			
			
		// public properties:
			/**
			 * The DOM object to manage.
			 * @property htmlElement
			 * @type HTMLElement
			 */
			this.htmlElement = htmlElement;
		
		
		// private properties:
			/**
			 * @property _oldMtx
			 * @type Matrix2D
			 * @protected
			 */
			this._oldProps = null;
	
			/**
			 * Used to track the object which this class attached listeners to, helps optimize listener attachment.
			 * @property _oldStage
			 * @type Stage
			 * @protected
			 */
			this._oldStage = null;
			/**
			 * The event listener proxy triggered drawing draw for special circumstances.
			 * @property _drawAction
			 * @type function
			 * @protected
			 */
			this._drawAction = null;
		}
		var p = createjs.extend(DOMElement, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 */
		p.isVisible = function() {
			return this.htmlElement != null;
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 * @return {Boolean}
		 */
		p.draw = function(ctx, ignoreCache) {
			// this relies on the _tick method because draw isn't called if the parent is not visible.
			// the actual update happens in _handleDrawEnd
			return true;
		};
	
		/**
		 * Not applicable to DOMElement.
		 * @method cache
		 */
		p.cache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method uncache
		 */
		p.uncache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method updateCache
		 */
		p.updateCache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method hitTest
		 */
		p.hitTest = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method localToGlobal
		 */
		p.localToGlobal = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method globalToLocal
		 */
		p.globalToLocal = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method localToLocal
		 */
		p.localToLocal = function() {};
	
		/**
		 * DOMElement cannot be cloned. Throws an error.
		 * @method clone
		 */
		p.clone = function() {
			throw("DOMElement cannot be cloned.")
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 */
		p.toString = function() {
			return "[DOMElement (name="+  this.name +")]";
		};
	
		/**
	     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
		 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		 * @event click
		 */
	
	     /**
	     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		 * @event dblClick
		 */
	
	     /**
	      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 	  * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		  * @event mousedown
		  */
	
	     /**
	      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.
	      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.
	      * @event mouseover
		  */
	
	     /**
	      * Not applicable to DOMElement.
		  * @event tick
		  */
	
	
	// private methods:
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * function.
		 * @protected
		 */
		p._tick = function(evtObj) {
			var stage = this.stage;
			if(stage && stage !== this._oldStage) {
				this._drawAction && stage.off("drawend", this._drawAction);
				this._drawAction = stage.on("drawend", this._handleDrawEnd, this);
				this._oldStage = stage;
			}
			this.DisplayObject__tick(evtObj);
		};
		
		/**
		 * @method _handleDrawEnd
		 * @param {Event} evt
		 * @protected
		 */
		p._handleDrawEnd = function(evt) {
			var o = this.htmlElement;
			if (!o) { return; }
			var style = o.style;
			
			var props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;
			
			var visibility = props.visible ? "visible" : "hidden";
			if (visibility != style.visibility) { style.visibility = visibility; }
			if (!props.visible) { return; }
			
			var oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;
			var n = 10000; // precision
			
			if (!oldMtx || !oldMtx.equals(mtx)) {
				var str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);
				style.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";
				style.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";
				if (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, null); }
				oldProps.matrix.copy(mtx);
			}
			
			if (oldProps.alpha != props.alpha) {
				style.opacity = ""+(props.alpha*n|0)/n;
				oldProps.alpha = props.alpha;
			}
		};
	
	
		createjs.DOMElement = createjs.promote(DOMElement, "DisplayObject");
	}());
	
	//##############################################################################
	// Filter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
		 * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
		 * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.
		 *
		 * <h4>Example</h4>
		 *
		 *      myInstance.filters = [
		 *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
		 *          new createjs.BlurFilter(5, 5, 10)
		 *      ];
		 *      myInstance.cache(0,0, 100, 100);
		 *
		 * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the
		 * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}
		 * will cause an object to feather outwards, resulting in a margin around the shape.
		 *
		 * <h4>EaselJS Filters</h4>
		 * EaselJS comes with a number of pre-built filters:
		 * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
		 *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
		 *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
		 *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
		 *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
		 * </ul>
		 *
		 * @class Filter
		 * @constructor
		 **/
		function Filter() {
			/**
			 * A flag stating that this filter uses a context draw mode and cannot be batched into imageData processing.
			 * @property usesContext
			 * @type {boolean}
			 * @default false
			 */
			this.usesContext = false;
	
			/**
			 * Pre-processed template shader code. It will be parsed before being fed in into the shader compiler.
			 * This should be based upon StageGL.SHADER_VERTEX_BODY_REGULAR
			 * @property VTX_SHADER
			 * @virtual
			 * @type {String}
			 * @readonly
			 */
			this.VTX_SHADER_BODY = null;
	
			/**
			 * Pre-processed template shader code. It will be parsed before being fed in into the shader compiler.
			 * This should be based upon StageGL.SHADER_FRAGMENT_BODY_REGULAR
			 * @property FRAG_SHADER
			 * @virtual
			 * @type {String}
			 * @readonly
			 */
			this.FRAG_SHADER_BODY = null;
		}
		var p = Filter.prototype;
	
	// public methods:
		/**
		 * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
		 * @method getBounds
		 * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
		 * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
		 **/
		p.getBounds = function(rect) {
			return rect;
		};
	
		/**
		 * Assign any unique uniforms or other setup functionality here.
		 * @method shaderParamSetup
		 * @virtual
		 * @param {WebGLContext} gl The context associated with the stage performing the render.
		 * @param {StageGL} stage The stage instance that will be rendering.
		 * @param {ShaderProgram} shaderProgram The compiled shader that is going to be used to perform the render.
		 */
		p.shaderParamSetup = function(gl, stage, shaderProgram) {};
	
		/**
		 * Applies the filter to the specified context.
		 * @method applyFilter
		 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
		 * @param {Number} x The x position to use for the source rect.
		 * @param {Number} y The y position to use for the source rect.
		 * @param {Number} width The width to use for the source rect.
		 * @param {Number} height The height to use for the source rect.
		 * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
		 * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.
		 * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.
		 * @return {Boolean} If the filter was applied successfully.
		 **/
		p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
			// this is the default behaviour because most filters access pixel data. It is overridden when not needed.
			targetCtx = targetCtx || ctx;
			if (targetX == null) { targetX = x; }
			if (targetY == null) { targetY = y; }
			try {
				var imageData = ctx.getImageData(x, y, width, height);
			} catch (e) {
				return false;
			}
			if (this._applyFilter(imageData)) {
				targetCtx.putImageData(imageData, targetX, targetY);
				return true;
			}
			return false;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Filter]";
		};
	
		/**
		 * Returns a clone of this Filter instance.
		 * @method clone
		 * @return {Filter} A clone of the current Filter instance.
		 **/
		p.clone = function() {
			return new Filter();
		};
		
	// private methods:
		/**
		 * @method _applyFilter
		 * @param {ImageData} imageData Target ImageData instance.
		 * @return {Boolean}
		 **/
		p._applyFilter = function(imageData) { return true; };
	
	
		createjs.Filter = Filter;
	}());
	
	//##############################################################################
	// BitmapCache.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The BitmapCache is an internal representation of all the cache properties and logic required in order to "cache"
		 * an object. This information and functionality used to be located on a {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method in {{#crossLink "DisplayObject"}}{{/crossLink}}, but was moved to its own class.
		 *
		 * Caching in this context is purely visual, and will render the DisplayObject out into an image to be used instead
		 * of the object. The actual cache itself is still stored on the target with the {{#crossLink "DisplayObject/cacheCanvas:property"}}{{/crossLink}}.
		 * Working with a singular image like a {{#crossLink "Bitmap"}}{{/crossLink}} there is little benefit to performing 
		 * a cache as it is already a single image. Caching is best done on containers containing multiple complex parts that 
		 * do not move often, so that rendering the image instead will improve overall rendering speed. A cached object will 
		 * not visually update until explicitly told to do so with a call to update, much like a Stage. If a cache is being 
		 * updated every frame it is likely not improving rendering performance. Cache are best used when updates will be sparse.
		 *
		 * Caching is also a co-requisite for applying filters to prevent expensive filters running constantly without need, 
		 * and to physically enable some effects. The BitmapCache is also responsible for applying filters to objects and 
		 * reads each {{#crossLink "Filter"}}{{/crossLink}} due to this relationship. Real-time Filters are not recommended 
		 * performance wise when dealing with a Context2D canvas. For best performance and to still allow for some visual 
		 * effects use a compositeOperation when possible.
		 * @class BitmapCache
		 * @constructor
		 **/
		function BitmapCache() {
	
			// public:
			/**
			 * Width of the cache relative to the target object.
			 * @property width
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.width = undefined;
	
			/**
			 * Height of the cache relative to the target object.
			 * @property height
			 * @protected
			 * @type {Number}
			 * @default undefined
			 * @todo Should the width and height be protected?
			 **/
			this.height = undefined;
	
			/**
			 * Horizontal position of the cache relative to the target's origin.
			 * @property x
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.x = undefined;
	
			/**
			 * Vertical position of the cache relative to target's origin.
			 * @property y
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.y = undefined;
	
			/**
			 * The internal scale of the cache image, does not affects display size. This is useful to both increase and
			 * decrease render quality. Objects with increased scales are more likely to look good when scaled up or rotated.
			 * Objects with decreased scales can save on rendering performance.
			 * @property scale
			 * @protected
			 * @type {Number}
			 * @default 1
			 **/
			this.scale = 1;
	
			/**
			 * The x offset used for drawing into the cache itself, accounts for both transforms applied.
			 * @property offX
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.offX = 0;
	
			/**
			 * The y offset used for drawing into the cache itself, accounts for both transforms applied.
			 * @property offY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.offY = 0;
	
			/**
			 * Track how many times the cache has been updated, mostly used for preventing duplicate cacheURLs.
			 * This can be useful to see if a cache has been updated.
			 * @property cacheID
			 * @type {Number}
			 * @default 0
			 **/
			this.cacheID = 0;
	
			// protected:
			/**
			 * The relative offset of the filter's x position, used for drawing the cache onto its container.
			 * Re-calculated every update call before drawing.
			 * @property _filterOffY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._filterOffX = 0;
	
			/**
			 * The relative offset of the filter's y position, used for drawing the cache onto its container.
			 * Re-calculated every update call before drawing.
			 * @property _filterOffY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._filterOffY = 0;
	
			/**
			 * The cacheID when a DataURL was requested.
			 * @property _cacheDataURLID
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._cacheDataURLID = 0;
	
			/**
			 * The cache's DataURL, generated on-demand using the getter.
			 * @property _cacheDataURL
			 * @protected
			 * @type {String}
			 * @default null
			 **/
			this._cacheDataURL = null;
	
			/**
			 * Internal tracking of final bounding width, approximately width*scale; however, filters can complicate the actual value.
			 * @property _drawWidth
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._drawWidth = 0;
	
			/**
			 * Internal tracking of final bounding height, approximately height*scale; however, filters can complicate the actual value.
			 * @property _drawHeight
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._drawHeight = 0;
		}
		var p = BitmapCache.prototype;
	
		/**
		 * Returns the bounds that surround all applied filters, relies on each filter to describe how it changes bounds.
		 * @method getFilterBounds
		 * @param {DisplayObject} target The object to check the filter bounds for.
		 * @param {Rectangle} [output=null] Optional parameter, if provided then calculated bounds will be applied to that object.
		 * @return {Rectangle} bounds object representing the bounds with filters.
		 * @static
		 **/
		BitmapCache.getFilterBounds = function(target, output) {
			if(!output){ output = new createjs.Rectangle(); }
			var filters = target.filters;
			var filterCount = filters && filters.length;
			if (!!filterCount <= 0) { return output; }
	
			for(var i=0; i<filterCount; i++) {
				var f = filters[i];
				if(!f || !f.getBounds){ continue; }
				var test = f.getBounds();
				if(!test){ continue; }
				if(i==0) {
					output.setValues(test.x, test.y, test.width, test.height);
				} else {
					output.extend(test.x, test.y, test.width, test.height);
				}
			}
	
			return output;
		};
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[BitmapCache]";
		};
	
		/**
		 * Actually create the correct cache surface and properties associated with it. Caching and it's benefits are discussed
		 * by the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} function and this class description. Here are the detailed
		 * specifics of how to use the options object.
		 *
		 * - If options.useGL is set to "new" a StageGL is created and contained on this for use when rendering the cache.
		 * - If options.useGL is set to "stage" if the current stage is a StageGL it will be used. If not then it will default to "new".
		 * - If options.useGL is a StageGL instance it will not create one but use the one provided.
		 * - If options.useGL is undefined a Context 2D cache will be performed.
		 *
		 * This means you can use any combination of StageGL and 2D with either, neither, or both the stage and cache being
		 * WebGL. Using "new" with a StageGL display list is highly unrecommended, but still an option. It should be avoided
		 * due to negative performance reasons and the Image loading limitation noted in the class complications above.
		 *
		 * When "options.useGL" is set to the parent stage of the target and WebGL, performance is increased by using
		 * "RenderTextures" instead of canvas elements. These are internal Textures on the graphics card stored in the GPU.
		 * Because they are no longer canvases you cannot perform operations you could with a regular canvas. The benefit
		 * is that this avoids the slowdown of copying the texture back and forth from the GPU to a Canvas element.
		 * This means "stage" is the recommended option when available.
		 *
		 * A StageGL cache does not infer the ability to draw objects a StageGL cannot currently draw, i.e. do not use a
		 * WebGL context cache when caching a Shape, Text, etc.
		 * <h4>WebGL cache with a 2D context</h4>
		 *
		 *     var stage = new createjs.Stage();
		 *     var bmp = new createjs.Bitmap(src);
		 *     bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "new"});          // no StageGL to use, so make one
		 *
		 *     var shape = new createjs.Shape();
		 *     shape.graphics.clear().fill("red").drawRect(0,0,20,20);
		 *     shape.cache(0, 0, 20, 20, 1);                             // cannot use WebGL cache
		 *
		 * <h4>WebGL cache with a WebGL context</h4>
		 *
		 *     var stageGL = new createjs.StageGL();
		 *     var bmp = new createjs.Bitmap(src);
		 *     bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "stage"});       // use our StageGL to cache
		 *
		 *     var shape = new createjs.Shape();
		 *     shape.graphics.clear().fill("red").drawRect(0,0,20,20);
		 *     shape.cache(0, 0, 20, 20, 1);                             // cannot use WebGL cache
		 *
		 * You may wish to create your own StageGL instance to control factors like clear color, transparency, AA, and
		 * others. If you do, pass a new instance in instead of "true", the library will automatically set the
		 * {{#crossLink "StageGL/isCacheControlled"}}{{/crossLink}} to true on your instance. This will trigger it to behave
		 * correctly, and not assume your main context is WebGL.
		 *
		 * @public
		 * @method BitmapCache.cache
		 * @param {Number} x The x coordinate origin for the cache region.
		 * @param {Number} y The y coordinate origin for the cache region.
		 * @param {Number} width The width of the cache region.
		 * @param {Number} height The height of the cache region.
		 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape
		 * using myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and
		 * rotate cached elements with greater fidelity. Default is 1.
		 * @param {Object} [options=undefined] Specify additional parameters for the cache logic
		 * @param {undefined|"new"|"stage"|StageGL} [options.useGL=undefined] Select whether to use context 2D, or WebGL rendering, and
		 * whether to make a new stage instance or use an existing one. See above for extensive details on use.
		 * @for BitmapCache
		 */
		 p.define = function(target, x, y, width, height, scale, options) {
			if(!target){ throw "No symbol to cache"; }
			this._options = options;
			this.target = target;
	
			this.width =		width >= 1 ? width : 1;
			this.height =		height >= 1 ? height : 1;
			this.x =			x || 0;
			this.y =			y || 0;
			this.scale =		scale || 1;
	
			this.update();
		};
	
		/**
		 * Directly called via {{#crossLink "DisplayObject/updateCache:method"}}{{/crossLink}}, but also internally. This
		 * has the dual responsibility of making sure the surface is ready to be drawn to, and performing the draw. For
		 * full details of each behaviour, check the protected functions {{#crossLink "BitmapCache/_updateSurface"}}{{/crossLink}}
		 * and {{#crossLink "BitmapCache/_drawToCache"}}{{/crossLink}} respectively.
		 * @method update
		 * @param {String} [compositeOperation=null] The DisplayObject this cache is linked to.
		 **/
		p.update = function(compositeOperation) {
			if(!this.target) { throw "define() must be called before update()"; }
	
			var filterBounds = BitmapCache.getFilterBounds(this.target);
			var surface = this.target.cacheCanvas;
	
			this._drawWidth = Math.ceil(this.width*this.scale) + filterBounds.width;
			this._drawHeight = Math.ceil(this.height*this.scale) + filterBounds.height;
	
			if(!surface || this._drawWidth != surface.width || this._drawHeight != surface.height) {
				this._updateSurface();
			}
	
			this._filterOffX = filterBounds.x;
			this._filterOffY = filterBounds.y;
			this.offX = this.x*this.scale + this._filterOffX;
			this.offY = this.y*this.scale + this._filterOffY;
	
			this._drawToCache(compositeOperation);
	
			this.cacheID = this.cacheID?this.cacheID+1:1;
		};
	
		/**
		 * Reset and release all the properties and memory associated with this cache.
		 * @method release
		 **/
		p.release = function() {
			if (this._webGLCache) {
				// if it isn't cache controlled clean up after yourself
				if (!this._webGLCache.isCacheControlled) {
					if (this.__lastRT){ this.__lastRT = undefined; }
					if (this.__rtA){ this._webGLCache._killTextureObject(this.__rtA); }
					if (this.__rtB){ this._webGLCache._killTextureObject(this.__rtB); }
					if (this.target && this.target.cacheCanvas){ this._webGLCache._killTextureObject(this.target.cacheCanvas); }
				}
				// set the context to none and let the garbage collector get the rest when the canvas itself gets removed
				this._webGLCache = false;
			} else {
				var stage = this.target.stage;
				if (stage instanceof createjs.StageGL){
					stage.releaseTexture(this.target.cacheCanvas);
				}
			}
	
			this.target = this.target.cacheCanvas = null;
			this.cacheID = this._cacheDataURLID = this._cacheDataURL = undefined;
			this.width = this.height = this.x = this.y = this.offX = this.offY = 0;
			this.scale = 1;
		};
	
		/**
		 * Returns a data URL for the cache, or `null` if this display object is not cached.
		 * Uses {{#crossLink "BitmapCache/cacheID:property"}}{{/crossLink}} to ensure a new data URL is not generated if the
		 * cache has not changed.
		 * @method getCacheDataURL
		 * @return {String} The image data url for the cache.
		 **/
		p.getCacheDataURL = function() {
			var cacheCanvas = this.target && this.target.cacheCanvas;
			if (!cacheCanvas) { return null; }
			if (this.cacheID != this._cacheDataURLID) {
				this._cacheDataURLID = this.cacheID;
				this._cacheDataURL = cacheCanvas.toDataURL?cacheCanvas.toDataURL():null;	// incase function is
			}
			return this._cacheDataURL;
		};
	
		/**
		 * Use context2D drawing commands to display the cache canvas being used.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The context to draw into.
		 * @return {Boolean} Whether the draw was handled successfully.
		 **/
		p.draw = function(ctx) {
			if(!this.target) { return false; }
			ctx.drawImage(this.target.cacheCanvas,
				this.x + (this._filterOffX/this.scale),		this.y + (this._filterOffY/this.scale),
				this._drawWidth/this.scale,					this._drawHeight/this.scale
			);
			return true;
		};
	
	// private methods:
		/**
		 * Create or resize the invisible canvas/surface that is needed for the display object(s) to draw to,
		 * and in turn be used in their stead when drawing. The surface is resized to the size defined
		 * by the width and height, factoring in scaling and filters. Adjust them to adjust the output size.
		 * @method _updateSurface
		 * @protected
		 **/
		p._updateSurface = function() {
			if (!this._options || !this._options.useGL) {
				var surface = this.target.cacheCanvas;
	
				// create it if it's missing
				if(!surface) {
					surface = this.target.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				}
	
				// now size it
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
				return;
			}
	
			// create it if it's missing
			if (!this._webGLCache) {
				if (this._options.useGL === "stage") {
					if(!(this.target.stage && this.target.stage.isWebGL)){
						var error = "Cannot use 'stage' for cache because the object's parent stage is ";
						error += this.target.stage ? "non WebGL." : "not set, please addChild to the correct stage.";
						throw error;
					}
					this.target.cacheCanvas = true; // will be replaced with RenderTexture, temporary positive value for old "isCached" checks
					this._webGLCache = this.target.stage;
	
				} else if(this._options.useGL === "new") {
					this.target.cacheCanvas = document.createElement("canvas"); // we can turn off autopurge because we wont be making textures here
					this._webGLCache = new createjs.StageGL(this.target.cacheCanvas, {antialias: true, transparent: true, autoPurge: -1});
					this._webGLCache.isCacheControlled = true;	// use this flag to control stage sizing and final output
	
				} else if(this._options.useGL instanceof createjs.StageGL) {
					this.target.cacheCanvas = true; // will be replaced with RenderTexture, temporary positive value for old "isCached" checks
					this._webGLCache = this._options.useGL;
					this._webGLCache.isCacheControlled = true;	// use this flag to control stage sizing and final output
	
				} else {
					throw "Invalid option provided to useGL, expected ['stage', 'new', StageGL, undefined], got "+ this._options.useGL;
				}
			}
	
			// now size render surfaces
			var surface = this.target.cacheCanvas;
			var stageGL = this._webGLCache;
	
			// if we have a dedicated stage we've gotta size it
			if (stageGL.isCacheControlled) {
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
				stageGL.updateViewport(this._drawWidth, this._drawHeight);
			}
			if (this.target.filters) {
				// with filters we can't tell how many we'll need but the most we'll ever need is two, so make them now
				stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
				stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
			} else {
				// without filters then we only need one RenderTexture, and that's only if its not a dedicated stage
				if (!stageGL.isCacheControlled) {
					stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
				}
			}
		};
	
		/**
		 * Perform the cache draw out for context 2D now that the setup properties have been performed.
		 * @method _drawToCache
		 * @protected
		 **/
		p._drawToCache = function(compositeOperation) {
			var surface = this.target.cacheCanvas;
			var target = this.target;
			var webGL = this._webGLCache;
	
			if (webGL){
				//TODO: auto split blur into an x/y pass
				webGL.cacheDraw(target, target.filters, this);
	
				// we may of swapped around which element the surface is, so we re-fetch it
				surface = this.target.cacheCanvas;
	
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
			} else {
				var ctx = surface.getContext("2d");
	
				if (!compositeOperation) {
					ctx.clearRect(0, 0, this._drawWidth+1, this._drawHeight+1);
				}
	
				ctx.save();
				ctx.globalCompositeOperation = compositeOperation;
				ctx.setTransform(this.scale,0,0,this.scale, -this._filterOffX,-this._filterOffY);
				ctx.translate(-this.x, -this.y);
				target.draw(ctx, true);
				ctx.restore();
	
	
				if (target.filters && target.filters.length) {
					this._applyFilters(ctx);
				}
			}
			surface._invalid = true;
		};
	
		/**
		 * Work through every filter and apply its individual visual transformation.
		 * @method _applyFilters
		 * @protected
		 **/
		p._applyFilters = function(ctx) {
			var filters = this.target.filters;
	
			var w = this._drawWidth;
			var h = this._drawHeight;
	
			var data;
	
			var l = filters.length;
			for (var i=0; i<l; i++) {
				var filter = filters[i];
				if(filter.usesContext){
					if(data) {
						ctx.putImageData(data, 0,0);
						data = null;
					}
					filter.applyFilter(ctx, 0,0, w,h);
				} else {
					if(!data) {
						data = ctx.getImageData(0,0, w,h);
					}
					filter._applyFilter(data);
				}
			}
	
			//done
			if(data) {
				ctx.putImageData(data, 0,0);
			}
		};
	
		createjs.BitmapCache = BitmapCache;
	}());
	
	//##############################################################################
	// BlurFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies a box blur to DisplayObjects in context 2D and a Gaussian blur in webgl. Note that this filter is fairly
		 * intensive, particularly if the quality is set higher than 1.
		 *
		 * <h4>Example</h4>
		 * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}
		 * method to account for the spread that the blur causes.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      var blurFilter = new createjs.BlurFilter(5, 5, 1);
		 *      shape.filters = [blurFilter];
		 *      var bounds = blurFilter.getBounds();
		 *
		 *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class BlurFilter
		 * @extends Filter
		 * @constructor
		 * @param {Number} [blurX=0] The horizontal blur radius in pixels.
		 * @param {Number} [blurY=0] The vertical blur radius in pixels.
		 * @param {Number} [quality=1] The number of blur iterations.
		 **/
		function BlurFilter( blurX, blurY, quality) {
			this.Filter_constructor();
	
			// public properties:
			/**
			 * Horizontal blur radius in pixels
			 * @property blurX
			 * @default 0
			 * @type Number
			 **/
			this._blurX = blurX;
			this._blurXTable = [];
			this._lastBlurX = null;
	
			/**
			 * Vertical blur radius in pixels
			 * @property blurY
			 * @default 0
			 * @type Number
			 **/
			this._blurY = blurY;
			this._blurYTable = [];
			this._lastBlurY = null;
	
			/**
			 * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a
			 * smoother blur, but take twice as long to run.
			 * @property quality
			 * @default 1
			 * @type Number
			 **/
			this._quality;
			this._lastQuality = null;
	
			/**
			 * This is a template to generate the shader for {{#crossLink FRAG_SHADER_BODY}}{{/crossLink}}
			 */
			this.FRAG_SHADER_TEMPLATE = (
				"uniform float xWeight[{{blurX}}];" +
				"uniform float yWeight[{{blurY}}];" +
				"uniform vec2 textureOffset;" +
				"void main(void) {" +
					"vec4 color = vec4(0.0);" +
	
					"float xAdj = ({{blurX}}.0-1.0)/2.0;" +
					"float yAdj = ({{blurY}}.0-1.0)/2.0;" +
					"vec2 sampleOffset;" +
	
					"for(int i=0; i<{{blurX}}; i++) {" +
						"for(int j=0; j<{{blurY}}; j++) {" +
							"sampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));" +
							"color += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);" +
						"}" +
					"}" +
	
					"gl_FragColor = color.rgba;" +
				"}"
			);
	
			// update the filter using the setters
			if(isNaN(quality) || quality < 1){ quality = 1; }
			this.setQuality(quality|0);
		}
		var p = createjs.extend(BlurFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		p.getBlurX = function() { return this._blurX; };
		p.getBlurY = function() { return this._blurY; };
		p.setBlurX = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._blurX = value;
		};
		p.setBlurY = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._blurY = value;
		};
		p.getQuality = function() { return this._quality; };
		p.setQuality = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._quality = value | 0;
		};
		p._getShader = function() {
			var xChange = this._lastBlurX !== this._blurX;
			var yChange = this._lastBlurY !== this._blurY;
			var qChange = this._lastQuality !== this._quality;
			if(xChange || yChange || qChange) {
				if(xChange || qChange) { this._blurXTable = this._getTable(this._blurX * this._quality); }
				if(yChange || qChange) { this._blurYTable = this._getTable(this._blurY * this._quality); }
				this._updateShader();
				this._lastBlurX = this._blurX;
				this._lastBlurY = this._blurY;
				this._lastQuality = this._quality;
				return undefined; // force a rebuild
			}
			return this._compiledShader;
		};
		p._setShader = function() { this._compiledShader; };
	
		try {
			Object.defineProperties(p, {
				blurX: { get: p.getBlurX, set: p.setBlurX },
				blurY: { get: p.getBlurY, set: p.setBlurY },
				quality: { get: p.getQuality, set: p.setQuality },
				_builtShader: { get: p._getShader, set: p._setShader}
			});
		} catch (e) { console.log(e); }
	
		/**
		 * Internal lookup function to create gaussian distribution.
		 * @method _getTable
		 * @param {Number} spread How many steps in the curve.
		 * @return {Array<Number>} An array with Math.ceil(spread*2) entries with appropriately distributed weights.
		 */
		p._getTable = function(spread) {
			var EDGE = 4.2;
			if(spread<=1) { return [1]; }
	
			var result = [];
			var count = Math.ceil(spread*2);
			count += (count%2)?0:1;
			var adjust = (count/2)|0;
			for(var i = -adjust; i<=adjust; i++) {
				var x = (i/adjust)*EDGE;
				result.push(1/Math.sqrt(2*Math.PI) * Math.pow(Math.E, -(Math.pow(x,2)/4)));
			}
			var factor = result.reduce(function(a, b) { return a + b; });
			return result.map(function(currentValue, index, array) { return currentValue/factor; });
		};
	
		/**
		 * Internal update function to create shader properties.
		 * @method _updateShader
		 */
		p._updateShader = function() {
			if(this._blurX === undefined || this._blurY === undefined){ return; }
			var result = this.FRAG_SHADER_TEMPLATE;
			result = result.replace(/\{\{blurX\}\}/g, (this._blurXTable.length).toFixed(0));
			result = result.replace(/\{\{blurY\}\}/g, (this._blurYTable.length).toFixed(0));
			this.FRAG_SHADER_BODY = result;
		};
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			// load the normalized gaussian weight tables
			gl.uniform1fv(
				gl.getUniformLocation(shaderProgram, "xWeight"),
				this._blurXTable
			);
			gl.uniform1fv(
				gl.getUniformLocation(shaderProgram, "yWeight"),
				this._blurYTable
			);
	
			// what is the size of a single pixel in -1, 1 (webGL) space
			gl.uniform2f(
				gl.getUniformLocation(shaderProgram, "textureOffset"),
				2/(stage._viewportWidth*this._quality), 2/(stage._viewportHeight*this._quality)
			);
		};
	
	// constants:
		/**
		 * Array of multiply values for blur calculations.
		 * @property MUL_TABLE
		 * @type Array
		 * @protected
		 * @static
		 **/
		BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];
	
		/**
		 * Array of shift values for blur calculations.
		 * @property SHG_TABLE
		 * @type Array
		 * @protected
		 * @static
		 **/
		BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];
	
	// public methods:
		/** docced in super class **/
		p.getBounds = function (rect) {
			var x = this.blurX|0, y = this.blurY| 0;
			if(x <= 0 && y <= 0) { return rect; }
			var q = Math.pow(this.quality, 0.2);
			return (rect || new createjs.Rectangle()).pad(y*q+1,x*q+1,y*q+1,x*q+1);
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new BlurFilter(this.blurX, this.blurY, this.quality);
		};
	
		/** docced in super class **/
		p.toString = function() {
			return "[BlurFilter]";
		};
	
	
	// private methods:
	
		/** docced in super class **/
		p._applyFilter = function (imageData) {
			var radiusX = this._blurX >> 1;
			if (isNaN(radiusX) || radiusX < 0) return false;
			var radiusY = this._blurY >> 1;
			if (isNaN(radiusY) || radiusY < 0) return false;
			if (radiusX == 0 && radiusY == 0) return false;
	
			var iterations = this.quality;
			if (isNaN(iterations) || iterations < 1) iterations = 1;
			iterations |= 0;
			if (iterations > 3) iterations = 3;
			if (iterations < 1) iterations = 1;
	
			var px = imageData.data;
			var x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;
	
			var divx = (radiusX + radiusX + 1) | 0;
			var divy = (radiusY + radiusY + 1) | 0;
			var w = imageData.width | 0;
			var h = imageData.height | 0;
	
			var w1 = (w - 1) | 0;
			var h1 = (h - 1) | 0;
			var rxp1 = (radiusX + 1) | 0;
			var ryp1 = (radiusY + 1) | 0;
	
			var ssx = {r:0,b:0,g:0,a:0};
			var sx = ssx;
			for ( i = 1; i < divx; i++ )
			{
				sx = sx.n = {r:0,b:0,g:0,a:0};
			}
			sx.n = ssx;
	
			var ssy = {r:0,b:0,g:0,a:0};
			var sy = ssy;
			for ( i = 1; i < divy; i++ )
			{
				sy = sy.n = {r:0,b:0,g:0,a:0};
			}
			sy.n = ssy;
	
			var si = null;
	
	
			var mtx = BlurFilter.MUL_TABLE[radiusX] | 0;
			var stx = BlurFilter.SHG_TABLE[radiusX] | 0;
			var mty = BlurFilter.MUL_TABLE[radiusY] | 0;
			var sty = BlurFilter.SHG_TABLE[radiusY] | 0;
	
			while (iterations-- > 0) {
	
				yw = yi = 0;
				var ms = mtx;
				var ss = stx;
				for (y = h; --y > -1;) {
					r = rxp1 * (pr = px[(yi) | 0]);
					g = rxp1 * (pg = px[(yi + 1) | 0]);
					b = rxp1 * (pb = px[(yi + 2) | 0]);
					a = rxp1 * (pa = px[(yi + 3) | 0]);
	
					sx = ssx;
	
					for( i = rxp1; --i > -1; )
					{
						sx.r = pr;
						sx.g = pg;
						sx.b = pb;
						sx.a = pa;
						sx = sx.n;
					}
	
					for( i = 1; i < rxp1; i++ )
					{
						p = (yi + ((w1 < i ? w1 : i) << 2)) | 0;
						r += ( sx.r = px[p]);
						g += ( sx.g = px[p+1]);
						b += ( sx.b = px[p+2]);
						a += ( sx.a = px[p+3]);
	
						sx = sx.n;
					}
	
					si = ssx;
					for ( x = 0; x < w; x++ )
					{
						px[yi++] = (r * ms) >>> ss;
						px[yi++] = (g * ms) >>> ss;
						px[yi++] = (b * ms) >>> ss;
						px[yi++] = (a * ms) >>> ss;
	
						p = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);
	
						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);
	
						si = si.n;
	
					}
					yw += w;
				}
	
				ms = mty;
				ss = sty;
				for (x = 0; x < w; x++) {
					yi = (x << 2) | 0;
	
					r = (ryp1 * (pr = px[yi])) | 0;
					g = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;
					b = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;
					a = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;
	
					sy = ssy;
					for( i = 0; i < ryp1; i++ )
					{
						sy.r = pr;
						sy.g = pg;
						sy.b = pb;
						sy.a = pa;
						sy = sy.n;
					}
	
					yp = w;
	
					for( i = 1; i <= radiusY; i++ )
					{
						yi = ( yp + x ) << 2;
	
						r += ( sy.r = px[yi]);
						g += ( sy.g = px[yi+1]);
						b += ( sy.b = px[yi+2]);
						a += ( sy.a = px[yi+3]);
	
						sy = sy.n;
	
						if( i < h1 )
						{
							yp += w;
						}
					}
	
					yi = x;
					si = ssy;
					if ( iterations > 0 )
					{
						for ( y = 0; y < h; y++ )
						{
							p = yi << 2;
							px[p+3] = pa =(a * ms) >>> ss;
							if ( pa > 0 )
							{
								px[p]   = ((r * ms) >>> ss );
								px[p+1] = ((g * ms) >>> ss );
								px[p+2] = ((b * ms) >>> ss );
							} else {
								px[p] = px[p+1] = px[p+2] = 0
							}
	
							p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;
	
							r -= si.r - ( si.r = px[p]);
							g -= si.g - ( si.g = px[p+1]);
							b -= si.b - ( si.b = px[p+2]);
							a -= si.a - ( si.a = px[p+3]);
	
							si = si.n;
	
							yi += w;
						}
					} else {
						for ( y = 0; y < h; y++ )
						{
							p = yi << 2;
							px[p+3] = pa =(a * ms) >>> ss;
							if ( pa > 0 )
							{
								pa = 255 / pa;
								px[p]   = ((r * ms) >>> ss ) * pa;
								px[p+1] = ((g * ms) >>> ss ) * pa;
								px[p+2] = ((b * ms) >>> ss ) * pa;
							} else {
								px[p] = px[p+1] = px[p+2] = 0
							}
	
							p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;
	
							r -= si.r - ( si.r = px[p]);
							g -= si.g - ( si.g = px[p+1]);
							b -= si.b - ( si.b = px[p+2]);
							a -= si.a - ( si.a = px[p+3]);
	
							si = si.n;
	
							yi += w;
						}
					}
				}
	
			}
			return true;
		};
	
		createjs.BlurFilter = createjs.promote(BlurFilter, "Filter");
	}());
	
	//##############################################################################
	// AlphaMapFilter.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
		
		
	// constructor:
		/**
		 * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will
		 * be copied from the red channel of the map, and the RGB channels will be copied from the target.
		 *
		 * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much
		 * better performance.
		 *
		 * <h4>Example</h4>
		 * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.
		 *
		 *       var box = new createjs.Shape();
		 *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)
		 *       box.graphics.drawRect(0, 0, 100, 100);
		 *       box.cache(0, 0, 100, 100);
		 *
		 *       var bmp = new createjs.Bitmap("path/to/image.jpg");
		 *       bmp.filters = [
		 *           new createjs.AlphaMapFilter(box.cacheCanvas)
		 *       ];
		 *       bmp.cache(0, 0, 100, 100);
		 *       stage.addChild(bmp);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
		 * @class AlphaMapFilter
		 * @extends Filter
		 * @constructor
		 * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the
		 * result. This should be exactly the same dimensions as the target.
		 **/
		function AlphaMapFilter(alphaMap) {
			this.Filter_constructor();
		
		// public properties:
			/**
			 * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same
			 * dimensions as the target.
			 * @property alphaMap
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this.alphaMap = alphaMap;
			
			
		// private properties:
			/**
			 * @property _alphaMap
			 * @protected
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this._alphaMap = null;
			
			/**
			 * @property _mapData
			 * @protected
			 * @type Uint8ClampedArray
			 **/
			this._mapData = null;
			this._mapTexture = null;
	
			this.FRAG_SHADER_BODY = (
				"uniform sampler2D uAlphaSampler;"+
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
					"vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);" +
	
					// some image formats can have transparent white rgba(1,1,1, 0) when put on the GPU, this means we need a slight tweak
					// using ceil ensure that the colour will be used so long as it exists but pure transparency will be treated black
					"gl_FragColor = vec4(color.rgb, color.a * (alphaMap.r * ceil(alphaMap.a)));" +
				"}"
			);
		}
		var p = createjs.extend(AlphaMapFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			if(!this._mapTexture) { this._mapTexture = gl.createTexture(); }
	
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this._mapTexture);
			stage.setTextureParams(gl);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.alphaMap);
	
			gl.uniform1i(
				gl.getUniformLocation(shaderProgram, "uAlphaSampler"),
				1
			);
		};
	
	// public methods:
		/** docced in super class **/
		p.clone = function () {
			var o = new AlphaMapFilter(this.alphaMap);
			o._alphaMap = this._alphaMap;
			o._mapData = this._mapData;
			return o;
		};
	
		/** docced in super class **/
		p.toString = function () {
			return "[AlphaMapFilter]";
		};
	
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function (imageData) {
			if (!this.alphaMap) { return true; }
			if (!this._prepAlphaMap()) { return false; }
			
			// TODO: update to support scenarios where the target has different dimensions.
			var data = imageData.data;
			var map = this._mapData;
			for(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }
			
			return true;
		};
	
		/**
		 * @method _prepAlphaMap
		 * @protected
		 **/
		p._prepAlphaMap = function () {
			if (!this.alphaMap) { return false; }
			if (this.alphaMap == this._alphaMap && this._mapData) { return true; }
	
			this._mapData = null;
			var map = this._alphaMap = this.alphaMap;
			var canvas = map;
			var ctx;
			if (map instanceof HTMLCanvasElement) {
				ctx = canvas.getContext("2d");
			} else {
				canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");
				canvas.width = map.width;
				canvas.height = map.height;
				ctx = canvas.getContext("2d");
				ctx.drawImage(map, 0, 0);
			}
	
			try {
				var imgData = ctx.getImageData(0, 0, map.width, map.height);
			} catch (e) {
				//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
				return false;
			}
			
			this._mapData = imgData.data;
			return true;
		};
	
	
		createjs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");
	}());
	
	//##############################################################################
	// AlphaMaskFilter.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will
		 * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to
		 * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32
		 * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.
		 *
		 * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>
		 *
		 * <h4>Example</h4>
		 * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.
		 *
		 *      var box = new createjs.Shape();
		 *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)
		 *      box.graphics.drawRect(0, 0, 100, 100);
		 *      box.cache(0, 0, 100, 100);
		 *
		 *      var bmp = new createjs.Bitmap("path/to/image.jpg");
		 *      bmp.filters = [
		 *          new createjs.AlphaMaskFilter(box.cacheCanvas)
		 *      ];
		 *      bmp.cache(0, 0, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
		 * @class AlphaMaskFilter
		 * @extends Filter
		 * @constructor
		 * @param {HTMLImageElement|HTMLCanvasElement} mask
		 **/
		function AlphaMaskFilter(mask) {
			this.Filter_constructor();
		
		// public properties:
			/**
			 * The image (or canvas) to use as the mask.
			 * @property mask
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this.mask = mask;
	
			/** docced in super class **/
			this.usesContext = true;
	
			this.FRAG_SHADER_BODY = (
				"uniform sampler2D uAlphaSampler;"+
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
					"vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);" +
	
					"gl_FragColor = vec4(color.rgb, color.a * alphaMap.a);" +
				"}"
			);
		}
		var p = createjs.extend(AlphaMaskFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			if(!this._mapTexture) { this._mapTexture = gl.createTexture(); }
	
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this._mapTexture);
			stage.setTextureParams(gl);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.mask);
	
			gl.uniform1i(
				gl.getUniformLocation(shaderProgram, "uAlphaSampler"),
				1
			);
		};
	
	// public methods:
		/**
		 * Applies the filter to the specified context.
		 *
		 * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters
		 * correctly.</strong>
		 * @method applyFilter
		 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
		 * @param {Number} x The x position to use for the source rect.
		 * @param {Number} y The y position to use for the source rect.
		 * @param {Number} width The width to use for the source rect.
		 * @param {Number} height The height to use for the source rect.
		 * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.
		 * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.
		 * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.
		 * @return {Boolean} If the filter was applied successfully.
		 **/
		p.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {
			if (!this.mask) { return true; }
			targetCtx = targetCtx || ctx;
			if (targetX == null) { targetX = x; }
			if (targetY == null) { targetY = y; }
	
			targetCtx.save();
			if (ctx != targetCtx) {
				// TODO: support targetCtx and targetX/Y
				// clearRect, then draw the ctx in?
				return false;
			}
	
			targetCtx.globalCompositeOperation = "destination-in";
			targetCtx.drawImage(this.mask, targetX, targetY);
			targetCtx.restore();
			return true;
		};
	
		/** docced in super class **/
		p.clone = function () {
			return new AlphaMaskFilter(this.mask);
		};
	
		/** docced in super class **/
		p.toString = function () {
			return "[AlphaMaskFilter]";
		};
	
	
		createjs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");
	}());
	
	//##############################################################################
	// ColorFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies a color transform to DisplayObjects.
		 *
		 * <h4>Example</h4>
		 * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels
		 * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      shape.filters = [
		 *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)
		 *      ];
		 *      shape.cache(-50, -50, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class ColorFilter
		 * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.
		 * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.
		 * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.
		 * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.
		 * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range
		 * between -255 and 255.
		 * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @constructor
		 * @extends Filter
		 **/
		function ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
			this.Filter_constructor();
	
		// public properties:
			/**
			 * Red channel multiplier.
			 * @property redMultiplier
			 * @type Number
			 **/
			this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
		
			/**
			 * Green channel multiplier.
			 * @property greenMultiplier
			 * @type Number
			 **/
			this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
		
			/**
			 * Blue channel multiplier.
			 * @property blueMultiplier
			 * @type Number
			 **/
			this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
		
			/**
			 * Alpha channel multiplier.
			 * @property alphaMultiplier
			 * @type Number
			 **/
			this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
		
			/**
			 * Red channel offset (added to value).
			 * @property redOffset
			 * @type Number
			 **/
			this.redOffset = redOffset || 0;
		
			/**
			 * Green channel offset (added to value).
			 * @property greenOffset
			 * @type Number
			 **/
			this.greenOffset = greenOffset || 0;
		
			/**
			 * Blue channel offset (added to value).
			 * @property blueOffset
			 * @type Number
			 **/
			this.blueOffset = blueOffset || 0;
		
			/**
			 * Alpha channel offset (added to value).
			 * @property alphaOffset
			 * @type Number
			 **/
			this.alphaOffset = alphaOffset || 0;
	
			this.FRAG_SHADER_BODY = (
				"uniform vec4 uColorMultiplier;" +
				"uniform vec4 uColorOffset;" +
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
	
					"gl_FragColor = (color * uColorMultiplier) + uColorOffset;" +
				"}"
			);
	
		}
		var p = createjs.extend(ColorFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorMultiplier"),
				this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier
			);
	
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorOffset"),
				this.redOffset/255, this.greenOffset/255, this.blueOffset/255, this.alphaOffset/255
			);
		};
	
		/** docced in super class **/
		p.toString = function() {
			return "[ColorFilter]";
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new ColorFilter(
				this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier,
				this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset
			);
		};
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function(imageData) {
			var data = imageData.data;
			var l = data.length;
			for (var i=0; i<l; i+=4) {
				data[i] = data[i]*this.redMultiplier+this.redOffset;
				data[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;
				data[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;
				data[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;
			}
			return true;
		};
	
	
		createjs.ColorFilter = createjs.promote(ColorFilter, "Filter");
	}());
	
	//##############################################################################
	// ColorMatrix.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.
		 * Most methods return the instance to facilitate chained calls.
		 *
		 * <h4>Example</h4>
		 *
		 *      myColorMatrix.adjustHue(20).adjustBrightness(50);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}
		 * for an example of how to use ColorMatrix to change a DisplayObject's color.
		 * @class ColorMatrix
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @constructor
		 **/
		function ColorMatrix(brightness, contrast, saturation, hue) {
			this.setColor(brightness, contrast, saturation, hue);
		}
		var p = ColorMatrix.prototype;
	
	// constants:
		/**
		 * Array of delta values for contrast calculations.
		 * @property DELTA_INDEX
		 * @type Array
		 * @protected
		 * @static
		 **/
		ColorMatrix.DELTA_INDEX = [
			0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,
			0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
			0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
			0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
			0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
			1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
			1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,
			2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,
			4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,
			7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,
			10.0
		];
	
		/**
		 * Identity matrix values.
		 * @property IDENTITY_MATRIX
		 * @type Array
		 * @protected
		 * @static
		 **/
		ColorMatrix.IDENTITY_MATRIX = [
			1,0,0,0,0,
			0,1,0,0,0,
			0,0,1,0,0,
			0,0,0,1,0,
			0,0,0,0,1
		];
	
		/**
		 * The constant length of a color matrix.
		 * @property LENGTH
		 * @type Number
		 * @protected
		 * @static
		 **/
		ColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;
	
	
	// public methods:
		/**
		 * Resets the instance with the specified values.
		 * @method setColor
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 */
		p.setColor = function(brightness,contrast,saturation,hue) {
			return this.reset().adjustColor(brightness,contrast,saturation,hue);
		};
	
		/**
		 * Resets the matrix to identity values.
		 * @method reset
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 */
		p.reset = function() {
			return this.copy(ColorMatrix.IDENTITY_MATRIX);
		};
	
		/**
		 * Shortcut method to adjust brightness, contrast, saturation and hue.
		 * Equivalent to calling adjustHue(hue), adjustContrast(contrast),
		 * adjustBrightness(brightness), adjustSaturation(saturation), in that order.
		 * @method adjustColor
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustColor = function(brightness,contrast,saturation,hue) {
			this.adjustHue(hue);
			this.adjustContrast(contrast);
			this.adjustBrightness(brightness);
			return this.adjustSaturation(saturation);
		};
	
		/**
		 * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.
		 * Positive values will make the image brighter, negative values will make it darker.
		 * @method adjustBrightness
		 * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustBrightness = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,255);
			this._multiplyMatrix([
				1,0,0,0,value,
				0,1,0,0,value,
				0,0,1,0,value,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Adjusts the contrast of pixel color.
		 * Positive values will increase contrast, negative values will decrease contrast.
		 * @method adjustContrast
		 * @param {Number} value A value between -100 & 100.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustContrast = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,100);
			var x;
			if (value<0) {
				x = 127+value/100*127;
			} else {
				x = value%1;
				if (x == 0) {
					x = ColorMatrix.DELTA_INDEX[value];
				} else {
					x = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.
				}
				x = x*127+127;
			}
			this._multiplyMatrix([
				x/127,0,0,0,0.5*(127-x),
				0,x/127,0,0,0.5*(127-x),
				0,0,x/127,0,0.5*(127-x),
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Adjusts the color saturation of the pixel.
		 * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).
		 * @method adjustSaturation
		 * @param {Number} value A value between -100 & 100.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustSaturation = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,100);
			var x = 1+((value > 0) ? 3*value/100 : value/100);
			var lumR = 0.3086;
			var lumG = 0.6094;
			var lumB = 0.0820;
			this._multiplyMatrix([
				lumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,
				lumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,
				lumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
	
		/**
		 * Adjusts the hue of the pixel color.
		 * @method adjustHue
		 * @param {Number} value A value between -180 & 180.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustHue = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,180)/180*Math.PI;
			var cosVal = Math.cos(value);
			var sinVal = Math.sin(value);
			var lumR = 0.213;
			var lumG = 0.715;
			var lumB = 0.072;
			this._multiplyMatrix([
				lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
				lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
				lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Concatenates (multiplies) the specified matrix with this one.
		 * @method concat
		 * @param {Array} matrix An array or ColorMatrix instance.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.concat = function(matrix) {
			matrix = this._fixMatrix(matrix);
			if (matrix.length != ColorMatrix.LENGTH) { return this; }
			this._multiplyMatrix(matrix);
			return this;
		};
	
		/**
		 * Returns a clone of this ColorMatrix.
		 * @method clone
		 * @return {ColorMatrix} A clone of this ColorMatrix.
		 **/
		p.clone = function() {
			return (new ColorMatrix()).copy(this);
		};
	
		/**
		 * Return a length 25 (5x5) array instance containing this matrix's values.
		 * @method toArray
		 * @return {Array} An array holding this matrix's values.
		 **/
		p.toArray = function() {
			var arr = [];
			for (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {
				arr[i] = this[i];
			}
			return arr;
		};
	
		/**
		 * Copy the specified matrix's values to this matrix.
		 * @method copy
		 * @param {Array} matrix An array or ColorMatrix instance.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.copy = function(matrix) {
			var l = ColorMatrix.LENGTH;
			for (var i=0;i<l;i++) {
				this[i] = matrix[i];
			}
			return this;
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[ColorMatrix]";
		};
	
	
	// private methods:
		/**
		 * @method _multiplyMatrix
		 * @param {Array} matrix
		 * @protected
		 **/
		p._multiplyMatrix = function(matrix) {
			var i, j, k, col = [];
	
			for (i=0;i<5;i++) {
				for (j=0;j<5;j++) {
					col[j] = this[j+i*5];
				}
				for (j=0;j<5;j++) {
					var val=0;
					for (k=0;k<5;k++) {
						val += matrix[j+k*5]*col[k];
					}
					this[j+i*5] = val;
				}
			}
		};
	
		/**
		 * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.
		 * @method _cleanValue
		 * @param {Number} value The raw number
		 * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.
		 * @protected
		 **/
		p._cleanValue = function(value, limit) {
			return Math.min(limit,Math.max(-limit,value));
		};
	
		/**
		 * Makes sure matrixes are 5x5 (25 long).
		 * @method _fixMatrix
		 * @param {Array} matrix
		 * @protected
		 **/
		p._fixMatrix = function(matrix) {
			if (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }
			if (matrix.length < ColorMatrix.LENGTH) {
				matrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));
			} else if (matrix.length > ColorMatrix.LENGTH) {
				matrix = matrix.slice(0,ColorMatrix.LENGTH);
			}
			return matrix;
		};
	
	
		createjs.ColorMatrix = ColorMatrix;
	}());
	
	//##############################################################################
	// ColorMatrixFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the
		 * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,
		 * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);
		 *      shape.filters = [
		 *          new createjs.ColorMatrixFilter(matrix)
		 *      ];
		 *
		 *      shape.cache(-50, -50, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class ColorMatrixFilter
		 * @constructor
		 * @extends Filter
		 * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
		 * class.
		 **/
		function ColorMatrixFilter(matrix) {
			this.Filter_constructor();
	
		// public properties:
			/**
			 * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
			 * @property matrix
			 * @type Array | ColorMatrix
			 **/
			this.matrix = matrix;
	
			this.FRAG_SHADER_BODY = (
				"uniform mat4 uColorMatrix;" +
				"uniform vec4 uColorMatrixOffset;" +
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
	
					"mat4 m = uColorMatrix;" +
					"vec4 newColor = vec4(0,0,0,0);" +
					"newColor.r = color.r*m[0][0] + color.g*m[0][1] + color.b*m[0][2] + color.a*m[0][3];" +
					"newColor.g = color.r*m[1][0] + color.g*m[1][1] + color.b*m[1][2] + color.a*m[1][3];" +
					"newColor.b = color.r*m[2][0] + color.g*m[2][1] + color.b*m[2][2] + color.a*m[2][3];" +
					"newColor.a = color.r*m[3][0] + color.g*m[3][1] + color.b*m[3][2] + color.a*m[3][3];" +
	
					"gl_FragColor = newColor + uColorMatrixOffset;" +
				"}"
			);
		}
		var p = createjs.extend(ColorMatrixFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			var mat = this.matrix;
			var colorMatrix = new Float32Array([
				mat[0],mat[1],mat[2],mat[3],
				mat[5],mat[6],mat[7],mat[8],
				mat[10],mat[11],mat[12],mat[13],
				mat[15],mat[16],mat[17],mat[18]
			]);
	
			gl.uniformMatrix4fv(
				gl.getUniformLocation(shaderProgram, "uColorMatrix"),
				false, colorMatrix
			);
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorMatrixOffset"),
				mat[4]/255, mat[9]/255, mat[14]/255, mat[19]/255
			);
		};
	
	// public methods:
		/** docced in super class **/
		p.toString = function() {
			return "[ColorMatrixFilter]";
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new ColorMatrixFilter(this.matrix);
		};
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function(imageData) { 
			var data = imageData.data;
			var l = data.length;
			var r,g,b,a;
			var mtx = this.matrix;
			var m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];
			var m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];
			var m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];
			var m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];
	
			for (var i=0; i<l; i+=4) {
				r = data[i];
				g = data[i+1];
				b = data[i+2];
				a = data[i+3];
				data[i] = r*m0+g*m1+b*m2+a*m3+m4; // red
				data[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green
				data[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue
				data[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha
			}
			return true;
		};
	
		createjs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");
	}());
	
	//##############################################################################
	// Touch.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
	 * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and
	 * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.
	 *
	 * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have
	 * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.
	 *
	 * <h4>Example</h4>
	 *
	 *      var stage = new createjs.Stage("canvasId");
	 *      createjs.Touch.enable(stage);
	 *
	 * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:
	 *
	 *      createjs.Touch.disable(stage);
	 *
	 * @class Touch
	 * @static
	 **/
		function Touch() {
			throw "Touch cannot be instantiated";
		}
	
	
	// public static methods:
		/**
		 * Returns `true` if touch is supported in the current browser.
		 * @method isSupported
		 * @return {Boolean} Indicates whether touch is supported in the current browser.
		 * @static
		 **/
		Touch.isSupported = function() {
			return	!!(('ontouchstart' in window) // iOS & Android
				|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10
				|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+
		};
	
		/**
		 * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS
		 * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and
		 * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for
		 * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}
		 * for more information.
		 * @method enable
		 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.
		 * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.
		 * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be
		 * allowed when the user is interacting with the target canvas.
		 * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.
		 * @static
		 **/
		Touch.enable = function(stage, singleTouch, allowDefault) {
			if (!stage || !stage.canvas || !Touch.isSupported()) { return false; }
			if (stage.__touch) { return true; }
	
			// inject required properties on stage:
			stage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};
	
			// note that in the future we may need to disable the standard mouse event model before adding
			// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.
			if ('ontouchstart' in window) { Touch._IOS_enable(stage); }
			else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }
			return true;
		};
	
		/**
		 * Removes all listeners that were set up when calling `Touch.enable()` on a stage.
		 * @method disable
		 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.
		 * @static
		 **/
		Touch.disable = function(stage) {
			if (!stage) { return; }
			if ('ontouchstart' in window) { Touch._IOS_disable(stage); }
			else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }
			
			delete stage.__touch;
		};
	
	
	// Private static methods:
		/**
		 * @method _IOS_enable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IOS_enable = function(stage) {
			var canvas = stage.canvas;
			var f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };
			canvas.addEventListener("touchstart", f, false);
			canvas.addEventListener("touchmove", f, false);
			canvas.addEventListener("touchend", f, false);
			canvas.addEventListener("touchcancel", f, false);
		};
	
		/**
		 * @method _IOS_disable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IOS_disable = function(stage) {
			var canvas = stage.canvas;
			if (!canvas) { return; }
			var f = stage.__touch.f;
			canvas.removeEventListener("touchstart", f, false);
			canvas.removeEventListener("touchmove", f, false);
			canvas.removeEventListener("touchend", f, false);
			canvas.removeEventListener("touchcancel", f, false);
		};
	
		/**
		 * @method _IOS_handleEvent
		 * @param {Stage} stage
		 * @param {Object} e The event to handle
		 * @protected
		 * @static
		 **/
		Touch._IOS_handleEvent = function(stage, e) {
			if (!stage) { return; }
			if (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }
			var touches = e.changedTouches;
			var type = e.type;
			for (var i= 0,l=touches.length; i<l; i++) {
				var touch = touches[i];
				var id = touch.identifier;
				if (touch.target != stage.canvas) { continue; }
	
				if (type == "touchstart") {
					this._handleStart(stage, id, e, touch.pageX, touch.pageY);
				} else if (type == "touchmove") {
					this._handleMove(stage, id, e, touch.pageX, touch.pageY);
				} else if (type == "touchend" || type == "touchcancel") {
					this._handleEnd(stage, id, e);
				}
			}
		};
	
		/**
		 * @method _IE_enable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IE_enable = function(stage) {
			var canvas = stage.canvas;
			var f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };
	
			if (window.navigator["pointerEnabled"] === undefined) {
				canvas.addEventListener("MSPointerDown", f, false);
				window.addEventListener("MSPointerMove", f, false);
				window.addEventListener("MSPointerUp", f, false);
				window.addEventListener("MSPointerCancel", f, false);
				if (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }
			} else {
				canvas.addEventListener("pointerdown", f, false);
				window.addEventListener("pointermove", f, false);
				window.addEventListener("pointerup", f, false);
				window.addEventListener("pointercancel", f, false);
				if (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }
	
			}
			stage.__touch.activeIDs = {};
		};
	
		/**
		 * @method _IE_disable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IE_disable = function(stage) {
			var f = stage.__touch.f;
	
			if (window.navigator["pointerEnabled"] === undefined) {
				window.removeEventListener("MSPointerMove", f, false);
				window.removeEventListener("MSPointerUp", f, false);
				window.removeEventListener("MSPointerCancel", f, false);
				if (stage.canvas) {
					stage.canvas.removeEventListener("MSPointerDown", f, false);
				}
			} else {
				window.removeEventListener("pointermove", f, false);
				window.removeEventListener("pointerup", f, false);
				window.removeEventListener("pointercancel", f, false);
				if (stage.canvas) {
					stage.canvas.removeEventListener("pointerdown", f, false);
				}
			}
		};
	
		/**
		 * @method _IE_handleEvent
		 * @param {Stage} stage
		 * @param {Object} e The event to handle.
		 * @protected
		 * @static
		 **/
		Touch._IE_handleEvent = function(stage, e) {
			if (!stage) { return; }
			if (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }
			var type = e.type;
			var id = e.pointerId;
			var ids = stage.__touch.activeIDs;
	
			if (type == "MSPointerDown" || type == "pointerdown") {
				if (e.srcElement != stage.canvas) { return; }
				ids[id] = true;
				this._handleStart(stage, id, e, e.pageX, e.pageY);
			} else if (ids[id]) { // it's an id we're watching
				if (type == "MSPointerMove" || type == "pointermove") {
					this._handleMove(stage, id, e, e.pageX, e.pageY);
				} else if (type == "MSPointerUp" || type == "MSPointerCancel"
						|| type == "pointerup" || type == "pointercancel") {
					delete(ids[id]);
					this._handleEnd(stage, id, e);
				}
			}
		};
	
		/**
		 * @method _handleStart
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 **/
		Touch._handleStart = function(stage, id, e, x, y) {
			var props = stage.__touch;
			if (!props.multitouch && props.count) { return; }
			var ids = props.pointers;
			if (ids[id]) { return; }
			ids[id] = true;
			props.count++;
			stage._handlePointerDown(id, e, x, y);
		};
	
		/**
		 * @method _handleMove
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 **/
		Touch._handleMove = function(stage, id, e, x, y) {
			if (!stage.__touch.pointers[id]) { return; }
			stage._handlePointerMove(id, e, x, y);
		};
	
		/**
		 * @method _handleEnd
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @protected
		 **/
		Touch._handleEnd = function(stage, id, e) {
			// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).
			var props = stage.__touch;
			var ids = props.pointers;
			if (!ids[id]) { return; }
			props.count--;
			stage._handlePointerUp(id, e, true);
			delete(ids[id]);
		};
	
	
		createjs.Touch = Touch;
	}());
	
	//##############################################################################
	// version.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function() {
		"use strict";
	
		/**
		 * Static class holding library specific information such as the version and buildDate of
		 * the library.
		 * @class EaselJS
		 **/
		var s = createjs.EaselJS = createjs.EaselJS || {};
	
		/**
		 * The version string for this release.
		 * @property version
		 * @type String
		 * @static
		 **/
		s.version = /*=version*/"NEXT"; // injected by build process
	
		/**
		 * The build date for this release in UTC format.
		 * @property buildDate
		 * @type String
		 * @static
		 **/
		s.buildDate = /*=date*/"Tue, 04 Jul 2017 15:42:51 GMT"; // injected by build process
	
	})();
	
	module.exports = createjs;

/***/ },
/* 92 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}
	
	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;
	
	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}
	
	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
	
	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` or `self` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	
	/* globals self */
	var scope = typeof global !== "undefined" ? global : self;
	var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
	
	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);
	
	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.
	
	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396
	
	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}
	
	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.jss
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;
	
	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}
	
	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html
	
	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.
	
	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }
	
	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.
	
	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }
	
	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.
	
	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.
	
	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);
	
	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}
	
	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
	
	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _headerComponent = __webpack_require__(95);
	
	var _mainComponent = __webpack_require__(98);
	
	var _layersListComponent = __webpack_require__(97);
	
	var _asideComponent = __webpack_require__(94);
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _shape = __webpack_require__(16);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// import logo from './logo.svg';
	
	
	// import Flatten from 'flatten-js';
	// import { Parser } from './models/parser';
	// import { Layer } from './models/layer';
	
	// let {Point} = Flatten;
	
	var App = function (_Component) {
	    _inherits(App, _Component);
	
	    function App(props) {
	        _classCallCheck(this, App);
	
	        var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));
	
	        _this.state = _this.props.store.getState();
	        _this.props.store.subscribe(function () {
	            _this.setState(_this.props.store.getState());
	        });
	
	        _this.clickOnShape = _this.clickOnShape.bind(_this);
	        return _this;
	    }
	
	    _createClass(App, [{
	        key: 'handlePaste',
	        value: function handlePaste(event) {
	            var _this2 = this;
	
	            if (this.state.layers.length === 0) return;
	
	            var layer = this.state.layers.find(function (lay) {
	                return lay.affected;
	            });
	            if (!layer) return;
	
	            var parser = this.state.app.parser;
	            var dispatch = this.dispatch;
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = event.clipboardData.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var item = _step.value;
	
	                    item.getAsString(function (string) {
	                        var poly = parser.parseToPolygon(string);
	                        // TODO: add something like poly.valid()
	                        if (poly.edges.size > 0 && poly.faces.size > 0) {
	                            var watch = parser.parseToWatchArray(string);
	
	                            var shape = new _shape.Shape(poly, _this2.state.stage, {}, watch);
	
	                            _this2.dispatch({
	                                type: ActionTypes.NEW_SHAPE_PASTED,
	                                shape: shape
	                            });
	
	                            dispatch({
	                                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                shape: shape
	                            });
	                        }
	                    });
	
	                    break;
	                }
	
	                // let point = new Point(0, 0);
	                // let seg1 = new Segment(new Point(-10, 0), new Point(10, 0));
	                // let seg2 = new Segment(new Point(0, -10), new Point(0, 10));
	
	                // layer.add(point);
	                // layer.add(seg1);
	                // layer.add(seg2);
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'clickOnShape',
	        value: function clickOnShape(event) {
	            var shape = event.target;
	            this.dispatch({
	                type: ActionTypes.PAN_TO_COORDINATE,
	                x: shape.geom.x,
	                y: shape.geom.y
	            });
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this3 = this;
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'App' },
	                _react2.default.createElement(_headerComponent.HeaderComponent, this.props),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'App-body',
	                        onPaste: function onPaste(e) {
	                            return _this3.handlePaste(e);
	                        } },
	                    _react2.default.createElement(_mainComponent.MainComponent, this.props),
	                    _react2.default.createElement(_layersListComponent.LayersListComponent, this.props),
	                    _react2.default.createElement(_asideComponent.AsideComponent, this.props)
	                )
	            );
	        }
	    }]);
	
	    return App;
	}(_react.Component);
	
	exports.default = App;
	
	/*
	 <div className="App">
	 <div className="App-header">
	 <h2>Debug Viewer</h2>
	 </div>
	
	 </div>
	*/
	
	/*
	 <img src={logo} className="App-logo" alt="logo" />
	 */

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AsideComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _sample = __webpack_require__(110);
	
	var _layers = __webpack_require__(23);
	
	var _shape = __webpack_require__(16);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 06/05/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var WatchElement = function (_Component) {
	    _inherits(WatchElement, _Component);
	
	    function WatchElement() {
	        _classCallCheck(this, WatchElement);
	
	        return _possibleConstructorReturn(this, (WatchElement.__proto__ || Object.getPrototypeOf(WatchElement)).apply(this, arguments));
	    }
	
	    _createClass(WatchElement, [{
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            var watch = this.props.shape.watch;
	            if (watch === undefined) return null;
	            var expandedSign = this.props.shape.expanded ? '-' : '+';
	            return _react2.default.createElement(
	                'div',
	                null,
	                this.props.shape.expanded ? watch.map(function (edgeWatch, index) {
	                    return _react2.default.createElement(
	                        'div',
	                        {
	                            key: index,
	                            className: 'Watch-element-title'
	                        },
	                        _react2.default.createElement(
	                            'div',
	                            {
	                                style: { flex: 1 },
	                                onClick: function onClick(event) {
	                                    return _this2.props.onToggleWatchExpandButtonClicked(_this2.props.shape);
	                                } },
	                            '-'
	                        ),
	                        _react2.default.createElement(
	                            'div',
	                            {
	                                title: edgeWatch,
	                                onClick: function onClick(event) {
	                                    return _this2.props.onSelectShapeClicked(_this2.props.shape);
	                                } },
	                            edgeWatch
	                        )
	                    );
	                }) : _react2.default.createElement(
	                    'div',
	                    { className: 'Watch-element-title'
	                    },
	                    _react2.default.createElement(
	                        'div',
	                        {
	                            style: { flex: 1 },
	                            onClick: function onClick(event) {
	                                return _this2.props.onToggleWatchExpandButtonClicked(_this2.props.shape);
	                            } },
	                        expandedSign
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        {
	                            title: watch[0],
	                            onClick: function onClick(event) {
	                                return _this2.props.onSelectShapeClicked(_this2.props.shape);
	                            } },
	                        watch[0]
	                    )
	                )
	            );
	        }
	    }]);
	
	    return WatchElement;
	}(_react.Component);
	
	var AsideComponent = exports.AsideComponent = function (_Component2) {
	    _inherits(AsideComponent, _Component2);
	
	    function AsideComponent() {
	        _classCallCheck(this, AsideComponent);
	
	        var _this3 = _possibleConstructorReturn(this, (AsideComponent.__proto__ || Object.getPrototypeOf(AsideComponent)).call(this));
	
	        _this3.onToggleWatchExpandButtonClicked = _this3.onToggleWatchExpandButtonClicked.bind(_this3);
	        _this3.onSelectShapeClicked = _this3.onSelectShapeClicked.bind(_this3);
	        _this3.addSamplePolygon = _this3.addSamplePolygon.bind(_this3);
	        _this3.height = 0;
	        return _this3;
	    }
	
	    _createClass(AsideComponent, [{
	        key: 'onToggleWatchExpandButtonClicked',
	        value: function onToggleWatchExpandButtonClicked(shape) {
	            if (!shape) return;
	            this.dispatch({
	                type: ActionTypes.TOGGLE_WATCH_EXPAND_CLICKED,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'onSelectShapeClicked',
	        value: function onSelectShapeClicked(shape) {
	            if (!shape) return;
	            this.dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'addSamplePolygon',
	        value: function addSamplePolygon() {
	            var parser = this.state.app.parser;
	            var poly = parser.parseToPolygon(_sample.debug_str);
	            var watch = parser.parseToWatchArray(_sample.debug_str);
	
	            var shape = new _shape.Shape(poly, this.state.stage, {}, watch);
	
	            this.dispatch({
	                type: ActionTypes.NEW_SHAPE_PASTED,
	                shape: shape
	            });
	
	            this.dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.height = this.refs.aside.clientHeight;
	            // let container = this.refs.watchContainer;
	            // let parentHeight = container.parentElement.clientHeight;
	            // container.style.maxHeight = 0.7*parentHeight;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this4 = this;
	
	            var layer = _layers.Layers.getAffected(this.state.layers);
	            var shapes = layer ? [].concat(_toConsumableArray(layer.shapes)) : undefined;
	            var title = layer ? layer.title : "";
	            var watchContainerHeight = 0.75 * this.height;
	            return _react2.default.createElement(
	                'aside',
	                { className: 'App-aside', ref: 'aside' },
	                _react2.default.createElement(
	                    'h4',
	                    null,
	                    'Info'
	                ),
	                _react2.default.createElement(
	                    'h4',
	                    null,
	                    title
	                ),
	                _react2.default.createElement(
	                    'div',
	                    {
	                        className: 'Watch-container',
	                        style: { maxHeight: watchContainerHeight }
	                    },
	                    shapes ? shapes.map(function (shape, index) {
	                        return _react2.default.createElement(WatchElement, {
	                            key: index,
	                            shape: shape,
	                            onToggleWatchExpandButtonClicked: _this4.onToggleWatchExpandButtonClicked,
	                            onSelectShapeClicked: _this4.onSelectShapeClicked
	                        });
	                    }) : null
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { className: 'Aside-add-sample-polygon',
	                        onClick: this.addSamplePolygon
	                    },
	                    'Add sample polygon'
	                )
	            );
	        }
	    }]);

	    return AsideComponent;
	}(_react.Component);

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HeaderComponent = undefined;
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	
	var HeaderComponent = exports.HeaderComponent = function HeaderComponent(props) {
	    var state = props.store.getState();
	    return _react2.default.createElement(
	        'header',
	        { className: 'App-header' },
	        _react2.default.createElement(
	            'h2',
	            null,
	            state.app.title
	        )
	    );
	};
	// import logo from './logo.svg';

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayerListElement = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import { ListGroupItem } from 'react-bootstrap';
	
	var LayerListElement = exports.LayerListElement = function (_Component) {
	    _inherits(LayerListElement, _Component);
	
	    function LayerListElement() {
	        _classCallCheck(this, LayerListElement);
	
	        return _possibleConstructorReturn(this, (LayerListElement.__proto__ || Object.getPrototypeOf(LayerListElement)).apply(this, arguments));
	    }
	
	    _createClass(LayerListElement, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (document.activeElement.nodeName === "CANVAS") return;
	            var elem = this.refs.layerName;
	            if (this.props.layer.affected) {
	                elem.focus();
	            }
	
	            // for (let shape of this.props.layer.shapes) {
	            //     shape.alpha = this.props.layer.displayed ? 1 : 0;
	            //     shape.redraw();
	            // }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            // let style = this.props.layer.displayed ?
	            //     styleSheet.displayed : styleSheet.undisplayed;
	
	            var displayed = this.props.layer.displayed ? "Layer-displayed" : "Layer-undisplayed";
	            var color = displayed ? this.props.layer.color : "black";
	            var alpha = this.props.layer.affected ? 1 : 0;
	            return this.props.layer.edited ? _react2.default.createElement(
	                'div',
	                {
	                    className: 'Layer ' + displayed,
	                    onClick: this.props.onLayerClicked
	                },
	                _react2.default.createElement('input', { val: this.props.layer.name })
	            ) : _react2.default.createElement(
	                'li',
	                {
	                    className: 'Layer ' + displayed,
	                    onClick: this.props.onLayerClicked,
	                    onDoubleClick: this.props.onLayerDoubleClicked },
	                _react2.default.createElement(
	                    'div',
	                    {
	                        style: { flex: 2 },
	                        onClick: this.props.onAffectedBoxClicked
	                    },
	                    _react2.default.createElement(
	                        'h4',
	                        { style: { opacity: alpha, color: color } },
	                        'V'
	                    )
	                ),
	                _react2.default.createElement(
	                    'h4',
	                    { ref: 'layerName',
	                        style: { flex: 8, color: color },
	                        title: this.props.layer.name,
	                        tabIndex: '1'
	                    },
	                    this.props.layer.name
	                )
	            );
	        }
	    }]);

	    return LayerListElement;
	}(_react.Component);

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayersListComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _layerListElement = __webpack_require__(96);
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(23);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import { ListGroup } from 'react-bootstrap';
	
	
	var LayersListComponent = exports.LayersListComponent = function (_Component) {
	    _inherits(LayersListComponent, _Component);
	
	    function LayersListComponent() {
	        _classCallCheck(this, LayersListComponent);
	
	        var _this = _possibleConstructorReturn(this, (LayersListComponent.__proto__ || Object.getPrototypeOf(LayersListComponent)).call(this));
	
	        _this.onLayerListClicked = _this.onLayerListClicked.bind(_this);
	        _this.onLayerClicked = _this.onLayerClicked.bind(_this);
	        _this.onLayerDoubleClicked = _this.onLayerDoubleClicked.bind(_this);
	        _this.onAddLayerSelected = _this.onAddLayerSelected.bind(_this);
	        _this.onAffectedBoxClicked = _this.onAffectedBoxClicked.bind(_this);
	        _this.handleKeyDown = _this.handleKeyDown.bind(_this);
	        _this.height = 0;
	        return _this;
	    }
	
	    _createClass(LayersListComponent, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'onLayerListClicked',
	        value: function onLayerListClicked() {
	            this.dispatch({
	                type: ActionTypes.LAYER_LIST_PANEL_PRESSED
	            });
	        }
	    }, {
	        key: 'onLayerClicked',
	        value: function onLayerClicked(layer) {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onLayerDoubleClicked',
	        value: function onLayerDoubleClicked(layer) {
	            // this.dispatch({
	            //     type: ActionTypes.EDIT_LAYER_NAME_PRESSED,
	            //     layer: layer
	            // });
	        }
	    }, {
	        key: 'onAffectedBoxClicked',
	        value: function onAffectedBoxClicked(layer) {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_AFFECTED_LAYER_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onAddLayerSelected',
	        value: function onAddLayerSelected() {
	            var layer = _layers.Layers.newLayer(this.state.stage, this.state.layers);
	
	            this.dispatch({
	                type: ActionTypes.ADD_LAYER_PRESSED,
	                stage: this.state.stage,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'handleKeyDown',
	        value: function handleKeyDown(e) {
	            e.stopPropagation();
	            e.preventDefault();
	
	            if (e.target.parentElement.parentElement.id !== "layersList") return;
	
	            switch (e.code) {
	                case "ArrowRight":
	                case "ArrowDown":
	                    this.dispatch({
	                        type: ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED
	                    });
	                    break;
	                case "ArrowLeft":
	                case "ArrowUp":
	                    this.dispatch({
	                        type: ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED
	                    });
	                    break;
	                /* tab does not work properly
	                case "Tab":
	                if (e.shiftKey) {
	                    this.dispatch({
	                        type: ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED
	                    });
	                }
	                else {
	                    this.dispatch({
	                        type: ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED
	                    });
	                }
	                break;
	                */
	                default:
	                    break;
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            // Keyboard event
	            // var _keydown = _.throttle(this.keydown, 100);
	            document.addEventListener('keydown', this.handleKeyDown);
	            // var _keyup = _.throttle(this.keyup, 500);
	            // document.addEventListener('keyup', this.handleKeyUp);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.height = this.refs.layersComponent.clientHeight;
	            // let container = this.refs.watchContainer;
	            // let parentHeight = container.parentElement.clientHeight;
	            // container.style.maxHeight = 0.7*parentHeight;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            // let addLayer =
	            //     (<div
	            //         style={{padding:4, backgroundColor: "lightgray"}}
	            //         onClick={this.onAddLayerSelected}>
	            //         <h4 style={{margin:0}}>Add layer</h4>
	            //     </div>)
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'App-layers',
	                    ref: 'layersComponent',
	                    onClick: this.onLayerListClicked
	                },
	                _react2.default.createElement(
	                    'h4',
	                    null,
	                    'Layers'
	                ),
	                _react2.default.createElement(
	                    'ul',
	                    { id: 'layersList',
	                        style: { maxHeight: 0.82 * (this.height - 40), padding: 0, overflow: 'auto' } },
	                    this.state.layers.map(function (layer) {
	                        return _react2.default.createElement(_layerListElement.LayerListElement, {
	                            onLayerClicked: function onLayerClicked() {
	                                return _this2.onLayerClicked(layer);
	                            },
	                            onLayerDoubleClicked: function onLayerDoubleClicked() {
	                                return _this2.onLayerDoubleClicked(layer);
	                            },
	                            onAffectedBoxClicked: function onAffectedBoxClicked() {
	                                return _this2.onAffectedBoxClicked(layer);
	                            },
	                            key: layer.name,
	                            layer: layer
	                        });
	                    })
	                )
	            );
	        }
	    }]);

	    return LayersListComponent;
	}(_react.Component);

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MainComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _toolbarComponent = __webpack_require__(102);
	
	var _stageComponent = __webpack_require__(100);
	
	var _statusComponent = __webpack_require__(101);
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(23);
	
	var _polygonTool = __webpack_require__(112);
	
	var _measurePointsTool = __webpack_require__(111);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import { CanvasComponent } from './canvasComponent';
	
	// import { LayerComponent } from './layerComponent';
	
	// import {Stage} from '../models/stage';
	// import {Layer} from '../models/layer';
	
	
	var MainComponent = exports.MainComponent = function (_Component) {
	    _inherits(MainComponent, _Component);
	
	    function MainComponent() {
	        _classCallCheck(this, MainComponent);
	
	        var _this = _possibleConstructorReturn(this, (MainComponent.__proto__ || Object.getPrototypeOf(MainComponent)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	        _this.handleMouseWheelMove = _this.handleMouseWheelMove.bind(_this);
	        _this.registerStage = _this.registerStage.bind(_this);
	        _this.toggleUnits = _this.toggleUnits.bind(_this);
	
	        _this.onMouseRollOverShape = _this.onMouseRollOverShape.bind(_this);
	        _this.onMouseRollOutShape = _this.onMouseRollOutShape.bind(_this);
	
	        _this.resizeStage = _this.resizeStage.bind(_this);
	
	        _this.setHomeView = _this.setHomeView.bind(_this);
	        _this.toggleWidthMode = _this.toggleWidthMode.bind(_this);
	        _this.toggleDisplayVertices = _this.toggleDisplayVertices.bind(_this);
	        _this.onMeasurePointsButtonPressed = _this.onMeasurePointsButtonPressed.bind(_this);
	        _this.onMeasureBetweenContoursButtonPressed = _this.onMeasureBetweenContoursButtonPressed.bind(_this);
	        _this.onPanByDragPressed = _this.onPanByDragPressed.bind(_this);
	        return _this;
	    }
	
	    _createClass(MainComponent, [{
	        key: 'registerStage',
	        value: function registerStage(stage) {
	            // let layer = Layers.newLayer(stage, this.state.layers);
	            this.dispatch({
	                type: ActionTypes.NEW_STAGE_CREATED,
	                stage: stage
	            });
	        }
	    }, {
	        key: 'resizeStage',
	        value: function resizeStage() {
	            // alert("resized")
	            this.dispatch({
	                type: ActionTypes.STAGE_RESIZED
	            });
	        }
	    }, {
	        key: 'toggleUnits',
	        value: function toggleUnits() {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_UNITS_CLICKED
	            });
	        }
	    }, {
	        key: 'handleMouseMove',
	        value: function handleMouseMove(stageX, stageY) {
	            this.dispatch({
	                type: ActionTypes.MOUSE_MOVED_ON_STAGE,
	                x: stageX,
	                y: stageY,
	                dx: this.state.mouse.startX ? stageX - this.state.mouse.startX : undefined,
	                dy: this.state.mouse.startY ? stageY - this.state.mouse.startY : undefined
	            });
	        }
	    }, {
	        key: 'handleMouseDown',
	        value: function handleMouseDown(stageX, stageY) {
	            // start pan stage
	            this.dispatch({
	                type: ActionTypes.MOUSE_DOWN_ON_STAGE,
	                x: stageX,
	                y: stageY
	            });
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(stageX, stageY) {
	            // stop pan stage
	            // Patch bug in Firefox when dispatch is not fired
	            this.state.stage.panByMouseStop();
	            this.dispatch({
	                type: ActionTypes.MOUSE_UP_ON_STAGE,
	                x: event.stageX,
	                y: event.stageY
	            });
	        }
	    }, {
	        key: 'handleMouseWheelMove',
	        value: function handleMouseWheelMove(stageX, stageY, delta) {
	            if (delta !== 0) {
	                this.dispatch({
	                    type: ActionTypes.MOUSE_WHEEL_MOVE_ON_STAGE,
	                    x: stageX,
	                    y: stageY,
	                    delta: delta
	                });
	            }
	        }
	    }, {
	        key: 'onMouseRollOverShape',
	        value: function onMouseRollOverShape(shape) {
	            this.dispatch({
	                type: ActionTypes.MOUSE_ROLL_OVER_SHAPE,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'onMouseRollOutShape',
	        value: function onMouseRollOutShape() {
	            this.dispatch({
	                type: ActionTypes.MOUSE_ROLL_OUT_SHAPE
	            });
	        }
	    }, {
	        key: 'setHomeView',
	        value: function setHomeView() {
	            var layer = _layers.Layers.getAffected(this.state.layers);
	            if (!layer) return;
	            // TODO: dispatch PAN_AND_ZOOM instead ?
	            this.dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                shape: layer
	            });
	        }
	    }, {
	        key: 'onPanByDragPressed',
	        value: function onPanByDragPressed() {
	            this.dispatch({
	                type: ActionTypes.PAN_BY_DRAG_BUTTON_CLICKED
	            });
	        }
	    }, {
	        key: 'toggleWidthMode',
	        value: function toggleWidthMode() {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_WIDTH_MODE_CLICKED
	            });
	        }
	    }, {
	        key: 'toggleDisplayVertices',
	        value: function toggleDisplayVertices() {
	            if (this.state.app.widthOn) return;
	            this.dispatch({
	                type: ActionTypes.TOGGLE_DISPLAY_VERTICES_CLICKED
	            });
	        }
	    }, {
	        key: 'onMeasurePointsButtonPressed',
	        value: function onMeasurePointsButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.MEASURE_POINTS_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'onMeasureBetweenContoursButtonPressed',
	        value: function onMeasureBetweenContoursButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.MEASURE_CONTOURS_BUTTON_PRESSED
	            });
	            alert("Not implemented yet");
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            window.onresize = this.resizeStage;
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.state.stage.canvas && this.state.stage.canvas.getContext('2d')) {
	                this.state.stage.update();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            // let state = this.props.store.getState();
	            var stage = this.state.stage;
	
	            var decimals = this.state.app.decimals;
	            var divisor = this.state.app.divisor;
	            var coordX = 0;
	            var coordY = 0;
	            if (stage) {
	                coordX = (stage.C2W_X(this.state.mouse.x) / divisor).toFixed(decimals);
	                coordY = (stage.C2W_Y(this.state.mouse.y) / divisor).toFixed(decimals);
	            }
	
	            return _react2.default.createElement(
	                'main',
	                { className: 'App-content' },
	                _react2.default.createElement(_toolbarComponent.ToolbarComponent, Object.assign({}, this.props, {
	                    onHomeButtonPressed: this.setHomeView,
	                    onPanByDragPressed: this.onPanByDragPressed,
	                    onMeasurePointsButtonPressed: this.onMeasurePointsButtonPressed,
	                    onMeasureBetweenContoursButtonPressed: this.onMeasureBetweenContoursButtonPressed,
	                    onToggleWidthModePressed: this.toggleWidthMode
	                })),
	                _react2.default.createElement(_stageComponent.StageComponent, {
	                    stage: this.state.stage,
	                    onStageCreated: this.registerStage,
	                    onMouseDown: this.handleMouseDown,
	                    onMouseMove: this.handleMouseMove,
	                    onMouseUp: this.handleMouseUp,
	                    onMouseWheelMove: this.handleMouseWheelMove,
	                    onHomeKeyPressed: this.setHomeView,
	                    onToggleWidthModePressed: this.toggleWidthMode,
	                    onToggleDisplayVerticesPressed: this.toggleDisplayVertices
	                }),
	                this.state.app.measurePointsActive ? _react2.default.createElement(_measurePointsTool.MeasurePointsTool, {
	                    stage: this.state.stage,
	                    divisor: this.state.app.divisor,
	                    decimals: this.state.app.decimals,
	                    onMouseWheelMove: this.handleMouseWheelMove
	                }) : null,
	                this.state.layers.map(function (layer) {
	                    /*
	                    let initialScale = this.state.stage.scalingFactor();
	                    let scale = this.state.stage.scalingFactor() / this.state.stage.initialScalingFactor;
	                    let origin = this.state.stage.origin;
	                    let tx = this.state.stage.tx;
	                    let ty = this.state.stage.ty;*/
	                    return [].concat(_toConsumableArray(layer.shapes)).map(function (shape, index) {
	                        return _react2.default.createElement(_polygonTool.PolygonTool, {
	                            key: index,
	                            polygon: shape,
	                            displayed: layer.displayed,
	                            color: layer.color,
	                            widthOn: _this2.state.app.widthOn,
	                            displayVertices: _this2.state.app.displayVertices,
	                            onMouseOver: _this2.onMouseRollOverShape,
	                            onMouseOut: _this2.onMouseRollOutShape
	                        });
	                    });
	                }),
	                _react2.default.createElement(_statusComponent.StatusComponent, {
	                    units: this.state.app.units,
	                    decimals: this.state.app.decimals,
	                    coordX: coordX,
	                    coordY: coordY,
	                    onUnitClicked: this.toggleUnits
	                })
	            );
	        }
	    }]);

	    return MainComponent;
	}(_react.Component);

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ReadFilesComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(23);
	
	var _shape2 = __webpack_require__(16);
	
	var _parserXML = __webpack_require__(107);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 06/05/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var ReadFilesComponent = exports.ReadFilesComponent = function (_Component) {
	    _inherits(ReadFilesComponent, _Component);
	
	    function ReadFilesComponent() {
	        _classCallCheck(this, ReadFilesComponent);
	
	        var _this = _possibleConstructorReturn(this, (ReadFilesComponent.__proto__ || Object.getPrototypeOf(ReadFilesComponent)).call(this));
	
	        _this.handleFileSelect = _this.handleFileSelect.bind(_this);
	        return _this;
	    }
	
	    _createClass(ReadFilesComponent, [{
	        key: 'readFile',
	        value: function readFile(file) {
	            if (!file.type.match('text.*')) return; // validate type is text
	
	            var reader = new FileReader();
	
	            var self = this;
	            // Closure to capture file information and "this" component
	            reader.onload = function (theFile, thisComponent) {
	                return function (event) {
	                    var string = event.target.result;
	                    var stage = thisComponent.state.stage;
	                    var layers = thisComponent.state.layers;
	
	                    var job = (0, _parserXML.parseXML)(theFile.name, string);
	
	                    var layer = _layers.Layers.newLayer(stage, layers);
	                    if (theFile.name !== "") {
	                        layer.name = theFile.name;
	                    }
	                    // layer.displayed = true;
	                    // layer.affected = true;
	                    layer.title = job.title;
	
	                    var _iteratorNormalCompletion = true;
	                    var _didIteratorError = false;
	                    var _iteratorError = undefined;
	
	                    try {
	                        for (var _iterator = job.profiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                            var polygon = _step.value;
	
	                            if (polygon.edges.size > 0 && polygon.faces.size > 0) {
	                                var watch = undefined; //  parser.parseToWatchArray(string);
	                                var shape = new _shape2.Shape(polygon, stage, polygon.style, watch);
	
	                                layer.add(shape);
	                                // thisComponent.dispatch({
	                                //     type: ActionTypes.NEW_SHAPE_PASTED,
	                                //     shape: shape
	                                // });
	                                //
	                                // thisComponent.dispatch({
	                                //     type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                //     shape: shape
	                                // });
	                            }
	                        }
	                    } catch (err) {
	                        _didIteratorError = true;
	                        _iteratorError = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion && _iterator.return) {
	                                _iterator.return();
	                            }
	                        } finally {
	                            if (_didIteratorError) {
	                                throw _iteratorError;
	                            }
	                        }
	                    }
	
	                    var _iteratorNormalCompletion2 = true;
	                    var _didIteratorError2 = false;
	                    var _iteratorError2 = undefined;
	
	                    try {
	                        for (var _iterator2 = job.materials[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                            var _polygon = _step2.value;
	
	                            if (_polygon.edges.size > 0 && _polygon.faces.size > 0) {
	                                var _watch = undefined; //  parser.parseToWatchArray(string);
	                                var _shape = new _shape2.Shape(_polygon, stage, _polygon.style, _watch);
	
	                                layer.add(_shape);
	                            }
	                        }
	                    } catch (err) {
	                        _didIteratorError2 = true;
	                        _iteratorError2 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                _iterator2.return();
	                            }
	                        } finally {
	                            if (_didIteratorError2) {
	                                throw _iteratorError2;
	                            }
	                        }
	                    }
	
	                    layers.push(layer);
	
	                    thisComponent.dispatch({
	                        type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                        shape: layer
	                    });
	                };
	            }(file, self);
	
	            reader.readAsText(file);
	        }
	    }, {
	        key: 'handleFileSelect',
	        value: function handleFileSelect(event) {
	            if (!(File && FileReader && FileList)) return;
	
	            var files = event.target.files; // FileList object
	
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = files[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var file = _step3.value;
	
	                    this.readFile(file);
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('input', { style: { fontSize: 16, marginTop: 5, marginBottom: 5, display: "none" },
	                type: 'file', id: 'browseFiles', name: 'files[]', multiple: true,
	                onChange: this.handleFileSelect
	            });
	        }
	    }]);

	    return ReadFilesComponent;
	}(_react.Component);

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.StageComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	var _stage = __webpack_require__(108);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	// import { LayerComponent } from '../components/layerComponent';
	
	
	// import {PolygonTool} from '../tools/polygonTool';
	
	// import {Layer} from '../models/layer';
	// import {Layers} from '../models/layers';
	
	// import * as ActionTypes from '../actions/action-types';
	
	var StageComponent = exports.StageComponent = function (_Component) {
	    _inherits(StageComponent, _Component);
	
	    function StageComponent() {
	        _classCallCheck(this, StageComponent);
	
	        var _this = _possibleConstructorReturn(this, (StageComponent.__proto__ || Object.getPrototypeOf(StageComponent)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	        _this.handleMouseLeave = _this.handleMouseLeave.bind(_this);
	        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
	        _this.handleMouseWheelFox = _this.handleMouseWheelFox.bind(_this);
	        _this.handleKeyDown = _this.handleKeyDown.bind(_this);
	        _this.handleKeyUp = _this.handleKeyUp.bind(_this);
	        return _this;
	    }
	
	    _createClass(StageComponent, [{
	        key: 'handleMouseMove',
	        value: function handleMouseMove(event) {
	            this.props.stage.canvas.focus();
	            this.props.onMouseMove(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseDown',
	        value: function handleMouseDown(event) {
	            this.props.onMouseDown(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(event) {
	            event.stopPropagation();
	            event.preventDefault();
	            this.props.onMouseUp(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseLeave',
	        value: function handleMouseLeave(event) {
	            // nothing works except click
	            this.props.stage.canvas.blur();
	            document.body.focus();
	        }
	    }, {
	        key: 'handleMouseWheel',
	        value: function handleMouseWheel(event) {
	            event.preventDefault();
	
	            var delta = event.detail || event.wheelDelta;
	            if (delta !== 0) {
	                this.props.onMouseWheelMove(event.offsetX, event.offsetY, delta);
	            }
	        }
	    }, {
	        key: 'handleMouseWheelFox',
	        value: function handleMouseWheelFox(event) {
	            event.preventDefault();
	            if (event.detail !== 0) {
	                this.props.onMousewheelMove(event.layerX, event.layerY, -event.detail);
	            }
	        }
	    }, {
	        key: 'handleKeyDown',
	        value: function handleKeyDown(e) {
	            // let ctrl = e.ctrlKey;
	            if (e.target.id !== "mainCanvas") return;
	            switch (e.code) {
	                case "KeyH":
	                    this.props.onHomeKeyPressed();
	                    break;
	
	                case "KeyW":
	                    this.props.onToggleWidthModePressed(); // toggle width On/Off in graphics model
	                    break;
	
	                case "KeyE":
	                    this.props.onToggleDisplayVerticesPressed(); // toggle vertices On/Off
	                    break;
	
	                case "ArrowRight":
	                    break;
	                case "ArrowLeft":
	                    break;
	                case "ArrowUp":
	                    break;
	                case "ArrowDown":
	                    break;
	                default:
	                    break;
	            }
	        }
	    }, {
	        key: 'handleKeyUp',
	        value: function handleKeyUp(event) {}
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            // this.dispatch = this.props.store.dispatch;
	            // this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var stage = new _stage.Stage(this.refs.canvas);
	
	            // stage.setClearColor("#F1F1F1");
	
	            stage.on("stagemousemove", this.handleMouseMove);
	            stage.on("stagemousedown", this.handleMouseDown);
	            stage.on("stagemouseup", this.handleMouseUp);
	            stage.on("mouseleave", this.handleMouseLeave);
	            stage.canvas.addEventListener("mousewheel", this.handleMouseWheel);
	            stage.canvas.addEventListener("DOMMouseScroll", this.handleMouseWheelFox);
	
	            // Keyboard event
	            // var _keydown = _.throttle(this.keydown, 100);
	            document.addEventListener('keydown', this.handleKeyDown);
	            // var _keyup = _.throttle(this.keyup, 500);
	            document.addEventListener('keyup', this.handleKeyUp);
	
	            // var r = 50;
	            // var graphics = new createjs.Graphics();
	            // graphics.beginFill("red")
	            //     .drawCircle(200,50, r)
	            //     .endFill();
	            //
	            // var cached = new createjs.Shape(graphics);
	            //
	            // stage.addChild(cached);
	            //
	            // cached.x = 0;
	            // cached.y = 0;
	            //
	            // cached.cache(200-r,50-r, r*2,r*2);
	            //
	            // stage.update();
	
	            this.props.onStageCreated(stage);
	        }
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            return nextProps.stage ? nextProps.stage.needToBeUpdated : true;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            // if (this.props.stage.canvas && this.props.stage.canvas.getContext('2d')) {
	            this.props.stage.update();
	            // }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('canvas', { tabIndex: '1', ref: 'canvas', id: 'mainCanvas', className: 'App-canvas' });
	        }
	    }]);
	
	    return StageComponent;
	}(_react.Component);
	/*
	 {
	 this.props.layers.map((layer) =>
	 <LayerComponent
	 key={layer.name}
	 layer={layer}
	 />)
	 }

	 */

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.StatusComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/06/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	// import '../App.css';
	
	var StatusComponent = exports.StatusComponent = function (_Component) {
	    _inherits(StatusComponent, _Component);
	
	    function StatusComponent() {
	        _classCallCheck(this, StatusComponent);
	
	        return _possibleConstructorReturn(this, (StatusComponent.__proto__ || Object.getPrototypeOf(StatusComponent)).apply(this, arguments));
	    }
	
	    _createClass(StatusComponent, [{
	        key: "render",
	        value: function render() {
	            return _react2.default.createElement(
	                "div",
	                { className: "App-status-bar" },
	                _react2.default.createElement(
	                    "div",
	                    { style: { flex: 4, textAlign: "left", marginLeft: 10, padding: 5 } },
	                    _react2.default.createElement(
	                        "h4",
	                        null,
	                        "X: " + this.props.coordX + " Y: " + this.props.coordY
	                    )
	                ),
	                _react2.default.createElement(
	                    "div",
	                    {
	                        style: { flex: 4, textAlign: "right", marginRight: 10, padding: 5 },
	                        onClick: this.props.onUnitClicked
	                    },
	                    _react2.default.createElement(
	                        "h4",
	                        null,
	                        "Units: " + this.props.units
	                    )
	                )
	            );
	        }
	    }]);

	    return StatusComponent;
	}(_react.Component);

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ToolbarComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Browse = __webpack_require__(241);
	
	var _Browse2 = _interopRequireDefault(_Browse);
	
	var _homeIcon20x = __webpack_require__(245);
	
	var _homeIcon20x2 = _interopRequireDefault(_homeIcon20x);
	
	var _handDrag = __webpack_require__(244);
	
	var _handDrag2 = _interopRequireDefault(_handDrag);
	
	var _measureContour = __webpack_require__(246);
	
	var _measureContour2 = _interopRequireDefault(_measureContour);
	
	var _measurePoints = __webpack_require__(247);
	
	var _measurePoints2 = _interopRequireDefault(_measurePoints);
	
	var _WidthOn = __webpack_require__(243);
	
	var _WidthOn2 = _interopRequireDefault(_WidthOn);
	
	var _Setting = __webpack_require__(242);
	
	var _Setting2 = _interopRequireDefault(_Setting);
	
	var _About = __webpack_require__(240);
	
	var _About2 = _interopRequireDefault(_About);
	
	__webpack_require__(10);
	
	var _readFilesComponent = __webpack_require__(99);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import { ButtonToolbar, Button } from 'react-bootstrap';
	// import logo from '../logo.svg';
	
	var ToolbarComponent = exports.ToolbarComponent = function (_Component) {
	    _inherits(ToolbarComponent, _Component);
	
	    function ToolbarComponent() {
	        _classCallCheck(this, ToolbarComponent);
	
	        var _this = _possibleConstructorReturn(this, (ToolbarComponent.__proto__ || Object.getPrototypeOf(ToolbarComponent)).call(this));
	
	        _this.openJobButtonClicked = _this.openJobButtonClicked.bind(_this);
	        _this.notImplemented = _this.notImplemented.bind(_this);
	        return _this;
	    }
	
	    _createClass(ToolbarComponent, [{
	        key: 'openJobButtonClicked',
	        value: function openJobButtonClicked() {
	            document.getElementById("browseFiles").click();
	        }
	    }, {
	        key: 'notImplemented',
	        value: function notImplemented() {
	            alert("Not implemented yet");
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'App-toolbar' },
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Open file', onClick: this.openJobButtonClicked },
	                    _react2.default.createElement('img', { src: _Browse2.default, alt: 'open' })
	                ),
	                _react2.default.createElement(_readFilesComponent.ReadFilesComponent, {
	                    store: this.props.store
	                }),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Zoom and pan to home view', onClick: this.props.onHomeButtonPressed },
	                    _react2.default.createElement('img', { src: _homeIcon20x2.default, alt: 'home' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Pan by drag', onClick: this.props.onPanByDragPressed },
	                    _react2.default.createElement('img', { src: _handDrag2.default, alt: 'panByDrag' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Measure distance between points', onClick: this.props.onMeasurePointsButtonPressed },
	                    _react2.default.createElement('img', { src: _measurePoints2.default, alt: 'measurePoints' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Measure distance between contours', onClick: this.props.onMeasureBetweenContoursButtonPressed },
	                    _react2.default.createElement('img', { src: _measureContour2.default, alt: 'measureContour' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Display solid or wire', onClick: this.props.onToggleWidthModePressed },
	                    _react2.default.createElement('img', { src: _WidthOn2.default, alt: 'width' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Settings', onClick: this.notImplemented },
	                    _react2.default.createElement('img', { src: _Setting2.default, alt: 'setting' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'About', onClick: this.notImplemented },
	                    _react2.default.createElement('img', { src: _About2.default, alt: 'about' })
	                )
	            );
	        }
	    }]);
	
	    return ToolbarComponent;
	}(_react.Component);
	
	;
	
	/*
	            <ButtonToolbar className="App-toolbar">
	                <Button>
	                    <img src={setting} style={{height:20}} alt="setting" />
	                </Button>
	                <Button>
	                    <img src={width} style={{height:20}} alt="width on/off" />
	                </Button>
	                <Button>
	                    <img src={about} style={{height:20}} alt="about" />
	                </Button>
	            </ButtonToolbar>
	
	 */
	/*
	 <button
	 className="Button-select-feature"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-drag"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-zoom-area"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-home"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-pan-to-coordinated"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-measure-between-points"
	 onClick={this.props.buttonClicked} />
	 <button
	 className="Button-measure-between-features"
	 onClick={this.props.buttonClicked} />



	 */

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(156);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _App = __webpack_require__(93);
	
	var _App2 = _interopRequireDefault(_App);
	
	__webpack_require__(114);
	
	var _redux = __webpack_require__(89);
	
	var _reducer = __webpack_require__(109);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import 'bootstrap/dist/css/bootstrap.css';
	// import 'bootstrap/dist/css/bootstrap-theme.css';
	
	var store = (0, _redux.createStore)(_reducer.reducer);
	
	_reactDom2.default.render(_react2.default.createElement(_App2.default, { store: store }), document.getElementById('root'));

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Job = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Box = _flattenJs2.default.Box;
	
	var Job = exports.Job = function () {
	    function Job() {
	        _classCallCheck(this, Job);
	
	        this.filename = "";
	        this.title = "";
	        this.profiles = []; // array of FlattenJS Polygons
	        this.materials = []; // array of FlattenJS Polygons
	    }
	
	    _createClass(Job, [{
	        key: "box",
	        get: function get() {
	            var b = new Box();
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = this.profiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var shape = _step.value;
	
	                    b.merge(shape.box);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.materials[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var _shape = _step2.value;
	
	                    b.merge(_shape.box);
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return b;
	        }
	    }]);

	    return Job;
	}();

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Layer = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _shape = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Layer = exports.Layer = function () {
	    function Layer(stage) {
	        _classCallCheck(this, Layer);
	
	        // super();
	        // cannot define Layer as extension of PlanarSet due to bug in compiler ?
	        this.stage = stage;
	        this.shapes = new _flattenJs2.default.PlanarSet();
	        this.name = "";
	        this.color = "";
	        this.title = "";
	        this.displayed = false;
	        this.edited = false;
	        this.affected = false;
	    }
	
	    _createClass(Layer, [{
	        key: 'clone',
	        value: function clone() {
	            var layer = new Layer(this.stage);
	            return Object.assign(layer, this);
	        }
	    }, {
	        key: 'add',
	        value: function add(shape) {
	            if (shape instanceof _shape.Shape) {
	                this.shapes.add(shape);
	            } else {
	                var geom = shape;
	                var newShape = new _shape.Shape(geom, this.stage);
	                this.shapes.add(newShape);
	            }
	            return this;
	        }
	    }, {
	        key: 'toggleDisplayed',
	        value: function toggleDisplayed(color) {
	            return Object.assign(this.clone(), {
	                displayed: !this.displayed,
	                color: color
	            });
	        }
	    }, {
	        key: 'setAffected',
	        value: function setAffected(affected) {
	            return Object.assign(this.clone(), {
	                affected: affected
	            });
	        }
	    }, {
	        key: 'setAlpha',
	        value: function setAlpha() {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = this.shapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var shape = _step.value;
	
	                    shape.alpha = this.displayed ? 1 : 0;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return this.shapes;
	        }
	    }, {
	        key: 'toggleExpanded',
	        value: function toggleExpanded(shapeToggle) {
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.shapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var shape = _step2.value;
	
	                    if (shape === shapeToggle) {
	                        shape.expanded = !shape.expanded;
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return this;
	        }
	    }, {
	        key: 'box',
	        get: function get() {
	            var box = new _flattenJs2.default.Box();
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = this.shapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var shape = _step3.value;
	
	                    box = box.merge(shape.box);
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            return box;
	        }
	    }, {
	        key: 'center',
	        get: function get() {
	            var box = this.box;
	            return new _flattenJs2.default.Point((box.xmin + box.xmax) / 2, (box.ymin + box.ymax) / 2);
	        }
	    }]);

	    return Layer;
	}();

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Parser = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 01/05/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon;
	var vector = _flattenJs2.default.vector;
	
	/*
	let debug_str = `+		[0]	{nrec=27 nalloc=27 h_ind_id=-1 ...} mat_cont_hdr_struc	mat_cont_struc
	    +		[1]	{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc	mat_cont_struc
	+		[2]	{nedge=23 nalloc=25 ntop=2 ...} mat_cont_poly_struc	mat_cont_struc
	+		[3]	{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc	mat_cont_struc
	+		[4]	{ps=59192738,6363124 pe=59216000,6372800 pc=59216000,6340000 cw=1} mat_curve_struc	mat_cont_struc
	+		[5]	{ps=59216000,6372800 pe=59267652,6372800} mat_seg_struc	mat_cont_struc
	+		[6]	{ps=59267652,6372800 pe=59267652,6307200 pc=59360000,6340000 cw=1} mat_curve_struc	mat_cont_struc
	+		[7]	{ps=59267652,6307200 pe=59229586,6307200} mat_seg_struc	mat_cont_struc
	+		[8]	{ps=59229586,6307200 pe=59212000,6289614} mat_seg_struc	mat_cont_struc
	+		[9]	{ps=59212000,6289614 pe=59212000,6056386} mat_seg_struc	mat_cont_struc
	+		[10]	{ps=59212000,6056386 pe=59229586,6038800} mat_seg_struc	mat_cont_struc
	+		[11]	{ps=59229586,6038800 pe=59469614,6038800} mat_seg_struc	mat_cont_struc
	+		[12]	{ps=59469614,6038800 pe=59487200,6056386} mat_seg_struc	mat_cont_struc
	+		[13]	{ps=59487200,6056386 pe=59487200,6100500} mat_seg_struc	mat_cont_struc
	+		[14]	{ps=59487200,6100500 pe=59434000,6180000 pc=59520000,6180000 cw=1} mat_curve_struc	mat_cont_struc
	+		[15]	{ps=59434000,6180000 pe=59552800,6100500 pc=59520000,6180000 cw=1} mat_curve_struc	mat_cont_struc
	+		[16]	{ps=59552800,6100500 pe=59552800,6042800} mat_seg_struc	mat_cont_struc
	+		[17]	{ps=59552800,6042800 pe=59543124,6019538 pc=59520000,6042800 cw=1} mat_curve_struc	mat_cont_struc
	+		[18]	{ps=59543124,6019538 pe=59506462,5982876} mat_seg_struc	mat_cont_struc
	+		[19]	{ps=59506462,5982876 pe=59483200,5973200 pc=59483200,6006000 cw=1} mat_curve_struc	mat_cont_struc
	+		[20]	{ps=59483200,5973200 pe=59216000,5973200} mat_seg_struc	mat_cont_struc
	+		[21]	{ps=59216000,5973200 pe=59192738,5982876 pc=59216000,6006000 cw=1} mat_curve_struc	mat_cont_struc
	+		[22]	{ps=59192738,5982876 pe=59156076,6019538} mat_seg_struc	mat_cont_struc
	+		[23]	{ps=59156076,6019538 pe=59146400,6042800 pc=59179200,6042800 cw=1} mat_curve_struc	mat_cont_struc
	+		[24]	{ps=59146400,6042800 pe=59146400,6303200} mat_seg_struc	mat_cont_struc
	+		[25]	{ps=59146400,6303200 pe=59156076,6326462 pc=59179200,6303200 cw=1} mat_curve_struc	mat_cont_struc
	+		[26]	{ps=59156076,6326462 pe=59192738,6363124} mat_seg_struc	mat_cont_struc
	`;
	*/
	
	var Parser = exports.Parser = function () {
	    function Parser() {
	        _classCallCheck(this, Parser);
	    }
	
	    _createClass(Parser, [{
	        key: 'parseToWatchArray',
	        value: function parseToWatchArray(str) {
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	            var watchArray = [];
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = arrayOfLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var line = _step.value;
	
	                    watchArray.push(line.substring(line.indexOf('{')));
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return watchArray;
	        }
	    }, {
	        key: 'parseToPolygon',
	        value: function parseToPolygon(str) {
	            var polygon = new Polygon();
	            // let mulitystr = debug_str;
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	
	            for (var i = 0; i < arrayOfLines.length; i++) {
	                var line = arrayOfLines[i];
	                if (line.search('mat_cont_poly_struc') >= 0) {
	                    var parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	                    var termArr = parenth.split(' '); // array of terms "attr=value"
	                    var nedgesTerm = termArr[0]; // "nedge=nn"
	                    var nedgesStr = nedgesTerm.split('=')[1];
	                    var nedges = parseInt(nedgesStr, 10);
	
	                    // Create new face from next #nedges of segments and arcs
	                    var edges = [];
	                    for (var j = i + 2; j < i + 2 + nedges; j++) {
	                        line = arrayOfLines[j];
	                        var _parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	                        var _termArr = _parenth.split(' '); // array of terms "attr=value"
	
	                        if (line.search('mat_seg_struc') >= 0) {
	                            var psArr = _termArr[0].split('=')[1].split(',');
	                            var ps = new Point(parseInt(psArr[0], 10), parseInt(psArr[1], 10));
	
	                            var peArr = _termArr[1].split('=')[1].split(',');
	                            var pe = new Point(parseInt(peArr[0], 10), parseInt(peArr[1], 10));
	
	                            edges.push(new Segment(ps, pe));
	                        } else if (line.search('mat_curve_struc') >= 0) {
	                            var _psArr = _termArr[0].split('=')[1].split(',');
	                            var _ps = new Point(parseInt(_psArr[0], 10), parseInt(_psArr[1], 10));
	
	                            var _peArr = _termArr[1].split('=')[1].split(',');
	                            var _pe = new Point(parseInt(_peArr[0], 10), parseInt(_peArr[1], 10));
	
	                            var pcArr = _termArr[2].split('=')[1].split(',');
	                            var pc = new Point(parseInt(pcArr[0], 10), parseInt(pcArr[1], 10));
	
	                            var cwStr = _termArr[3].split('=')[1];
	                            var counterClockwise = cwStr === '0' ? true : false;
	
	                            var startAngle = vector(pc, _ps).slope;
	                            var endAngle = vector(pc, _pe).slope;
	
	                            var r = vector(pc, _ps).length;
	
	                            edges.push(new Arc(pc, r, startAngle, endAngle, counterClockwise));
	                        }
	                    }
	                    polygon.addFace(edges);
	                }
	            }
	            return polygon;
	        }
	    }]);

	    return Parser;
	}();

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseXML = parseXML;
	
	var _job = __webpack_require__(104);
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon;
	var vector = _flattenJs2.default.vector;
	function parseXML(filename, str) {
	    var job = new _job.Job();
	
	    job.filename = filename;
	
	    var parser = new DOMParser();
	    var xmlDoc = parser.parseFromString(str, "text/xml");
	
	    // Parse document title
	    var titles = xmlDoc.getElementsByTagName('title');
	    if (titles && titles.length > 0) {
	        job.title = titles[0].firstChild.nodeValue; // take the first title if more than one
	    }
	
	    // Parse profiles and add polygons to the job
	    var profilesXML = xmlDoc.getElementsByTagName('profile');
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = profilesXML[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var profileXML = _step.value;
	
	            var polygon = parsePolygon(profileXML);
	            job.profiles.push(polygon);
	        }
	
	        // Parse materials and add polygons to the job
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    var materialXML = xmlDoc.getElementsByTagName('material');
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = materialXML[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var shapeXML = _step2.value;
	
	            var polygon = parsePolygon(shapeXML);
	            job.materials.push(polygon);
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    return job;
	}
	
	function parsePolygon(polygonsXML) {
	    var polygon = new Polygon();
	
	    // let nedges = parseInt(profile.getAttribute("n_edges"), 10);
	
	    // Augment Flatten object with style
	    var color = polygonsXML.getAttribute("color");
	    polygon.style = {
	        stroke: color || undefined,
	        fill: color || undefined,
	        alpha: 1.0
	    };
	
	    // Add islands
	    var islands = polygonsXML.getElementsByTagName('island');
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = islands[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var island = _step3.value;
	
	            var edgesXML = island.getElementsByTagName('edge');
	            polygon.addFace(parseEdges(edgesXML));
	        }
	
	        // Add holes
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    var holes = polygonsXML.getElementsByTagName('holes');
	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;
	
	    try {
	        for (var _iterator4 = holes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var hole = _step4.value;
	
	            var edgesXML = hole.getElementsByTagName('edge');
	            polygon.addFace(parseEdges(edgesXML));
	        }
	    } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                _iterator4.return();
	            }
	        } finally {
	            if (_didIteratorError4) {
	                throw _iteratorError4;
	            }
	        }
	    }
	
	    return polygon;
	}
	
	function parseEdges(edgesXML) {
	    var edges = [];
	
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;
	
	    try {
	        for (var _iterator5 = edgesXML[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var edge = _step5.value;
	
	            var type = edge.getAttribute('type');
	
	            if (type === "segment") {
	                var ps = new Point(parseInt(edge.getAttribute('xs'), 10), parseInt(edge.getAttribute('ys'), 10));
	                var pe = new Point(parseInt(edge.getAttribute('xe'), 10), parseInt(edge.getAttribute('ye'), 10));
	
	                edges.push(new Segment(ps, pe));
	            }
	
	            if (type === "curve") {
	                var _ps = new Point(parseInt(edge.getAttribute('xs'), 10), parseInt(edge.getAttribute('ys'), 10));
	                var _pe = new Point(parseInt(edge.getAttribute('xe'), 10), parseInt(edge.getAttribute('ye'), 10));
	                var pc = new Point(parseInt(edge.getAttribute('xc'), 10), parseInt(edge.getAttribute('yc'), 10));
	
	                var counterClockwise = edge.getAttribute('cw') === 'no' ? true : false;
	
	                var startAngle = vector(pc, _ps).slope;
	                var endAngle = vector(pc, _pe).slope;
	
	                var r = vector(pc, _ps).length;
	
	                edges.push(new Arc(pc, r, startAngle, endAngle, counterClockwise));
	            }
	        }
	    } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                _iterator5.return();
	            }
	        } finally {
	            if (_didIteratorError5) {
	                throw _iteratorError5;
	            }
	        }
	    }
	
	    return edges;
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Stage = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _easeljsNEXTCombined = __webpack_require__(91);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _flattenJs = __webpack_require__(17);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _shape = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	// import createjs from 'easel-js';
	
	
	var Stage = exports.Stage = function (_createjs$Stage) {
	    _inherits(Stage, _createjs$Stage);
	
	    function Stage(canvas) {
	        _classCallCheck(this, Stage);
	
	        var _this = _possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this, canvas));
	
	        createjs.Touch.enable(_this);
	        _this.mouseMoveOutside = false; // true;
	        _this.enableMouseOver(20);
	
	        if (_this.canvas.clientWidth > 0 && _this.canvas.clientHeight > 0) {
	            _this.canvas.width = _this.canvas.clientWidth;
	            _this.canvas.height = _this.canvas.clientHeight;
	        }
	        _this.origin = { x: _this.canvas.width / 2, y: _this.canvas.height / 2 };
	        _this.oldOrigin = { x: undefined, y: undefined }; // used by pan
	        _this.resolution = 0.00001; // MM 2 Pixels when zoomFactor = 1;
	        _this.zoomFactor = 1.0;
	
	        _this.needToBeUpdated = false;
	        return _this;
	    }
	
	    _createClass(Stage, [{
	        key: 'clone',
	        value: function clone() {
	            var stage = new Stage(this.canvas);
	            return Object.assign(stage, this);
	        }
	    }, {
	        key: 'add',
	        value: function add(shape) {
	            this.addChild(shape);
	            return this;
	        }
	    }, {
	        key: 'scalingFactor',
	        value: function scalingFactor() {
	            return this.resolution * this.zoomFactor;
	        }
	    }, {
	        key: 'C2W_Scalar',
	        value: function C2W_Scalar(scalar) {
	            return scalar / this.scalingFactor();
	        }
	    }, {
	        key: 'W2C_Scalar',
	        value: function W2C_Scalar(scalar) {
	            return this.scalingFactor() * scalar;
	        }
	    }, {
	        key: 'C2W_X',
	        value: function C2W_X(canvasX) {
	            return (canvasX - this.origin.x) / this.scalingFactor();
	        }
	    }, {
	        key: 'C2W_Y',
	        value: function C2W_Y(canvasY) {
	            return (this.origin.y - canvasY) / this.scalingFactor();
	        }
	    }, {
	        key: 'W2C_X',
	        value: function W2C_X(worldX) {
	            return this.scalingFactor() * worldX + this.origin.x;
	        }
	    }, {
	        key: 'W2C_Y',
	        value: function W2C_Y(worldY) {
	            return this.origin.y - this.scalingFactor() * worldY;
	        }
	    }, {
	        key: 'W2C',
	        value: function W2C(point) {
	            return { x: this.W2C_X(point.x), y: this.W2C_Y(point.y) };
	        }
	    }, {
	        key: 'panTo',
	        value: function panTo(newOrigin) {
	            this.origin = { x: newOrigin.x, y: newOrigin.y };
	        }
	    }, {
	        key: 'panBy',
	        value: function panBy(deltaX, deltaY) {
	            this.origin = {
	                x: this.origin.x + deltaX,
	                y: this.origin.y + deltaY
	            };
	        }
	
	        // zoom by 10% each time
	
	    }, {
	        key: 'zoomIn',
	        value: function zoomIn(ratio) {
	            var curRatio = ratio || 1.1;
	            this.zoomFactor = Math.min(100000, curRatio * this.zoomFactor);
	        }
	    }, {
	        key: 'zoomOut',
	        value: function zoomOut(ratio) {
	            var curRatio = ratio || 1.1;
	            this.zoomFactor = Math.max(0.1, this.zoomFactor / curRatio);
	        }
	
	        // ZoomIn/Out + "Focus follows mouse"
	
	    }, {
	        key: 'zoom',
	        value: function zoom(focusX, focusY, bIn, ratio) {
	            var worldX = this.C2W_X(focusX); // world coordinate of mouse focus before zoom
	            var worldY = this.C2W_Y(focusY);
	
	            bIn ? this.zoomIn(ratio) : this.zoomOut(ratio);
	
	            var newFocusX = this.W2C_X(worldX); // canvas coordinate after zoom
	            var newFocusY = this.W2C_Y(worldY);
	
	            this.panBy(focusX - newFocusX, focusY - newFocusY);
	
	            return [newFocusX, newFocusY];
	        }
	    }, {
	        key: 'zoomByMouse',
	        value: function zoomByMouse(focusX, focusY, bIn, ratio) {
	            this.zoom(focusX, focusY, bIn, ratio);
	        }
	    }, {
	        key: 'zoomToLimits',
	        value: function zoomToLimits(width, height) {
	            var resolution = Math.min(this.canvas.width / (1.1 * width), this.canvas.height / (1.1 * height));
	            var zoomFactor = resolution / this.resolution;
	            var ratio = zoomFactor / this.zoomFactor;
	            var bIn = true; //ratio > 1;
	
	            var focusX = this.canvas.width / 2;
	            var focusY = this.canvas.height / 2;
	            this.zoom(focusX, focusY, bIn, ratio);
	        }
	    }, {
	        key: 'resize',
	        value: function resize() {
	            // this.origin.x = this.canvas.width / 2;
	            // this.origin.y = this.canvas.height / 2;
	            if (this.canvas.clientWidth > 0 && this.canvas.clientHeight > 0) {
	                this.canvas.width = this.canvas.clientWidth;
	                this.canvas.height = this.canvas.clientHeight;
	            }
	        }
	    }, {
	        key: 'drawSomething',
	        value: function drawSomething() {
	            var shape = new _shape.Shape();
	            shape.graphics.beginFill('red').drawRect(0, 0, 20, 20);
	            this.addChild(shape);
	            this.update();
	        }
	    }, {
	        key: 'panByMouseStart',
	        value: function panByMouseStart() {
	            this.oldOrigin.x = this.origin.x;
	            this.oldOrigin.y = this.origin.y;
	        }
	    }, {
	        key: 'panByMouseMove',
	        value: function panByMouseMove(dx, dy) {
	            if (dx !== undefined && dy !== undefined && this.oldOrigin.x !== undefined && this.oldOrigin.y !== undefined) {
	                this.origin = {
	                    x: this.oldOrigin.x + dx,
	                    y: this.oldOrigin.y + dy
	                };
	            }
	        }
	    }, {
	        key: 'panByMouseStop',
	        value: function panByMouseStop() {
	            this.oldOrigin.x = undefined;
	            this.oldOrigin.y = undefined;
	            this.tx = undefined;
	            this.ty = undefined;
	        }
	    }, {
	        key: 'panToCoordinate',
	        value: function panToCoordinate(x, y) {
	            var canvasX = this.W2C_X(x);
	            var canvasY = this.W2C_Y(y);
	
	            var dx = this.canvas.width / 2 - canvasX;
	            var dy = this.canvas.height / 2 - canvasY;
	            this.panBy(dx, dy);
	        }
	    }, {
	        key: 'box',
	        get: function get() {
	            var minX = this.C2W_X(0);
	            var minY = this.C2W_Y(this.canvas.height);
	            var maxX = this.C2W_X(this.canvas.width);
	            var maxY = this.C2W_Y(0);
	
	            return new _flattenJs2.default.Box(minX, minY, maxX, maxY);
	        }
	    }]);
	
	    return Stage;
	}(createjs.Stage);

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.reducer = undefined;
	
	var _actionTypes = __webpack_require__(15);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _redux = __webpack_require__(89);
	
	var _layers = __webpack_require__(23);
	
	var _parser = __webpack_require__(106);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * Created by alexanderbol on 13/04/2017.
	                                                                                                                                                                                                     */
	
	// import {Stage} from './models/stage';
	// import {Layer} from './models/layer';
	
	
	var unitsList = [{
	    name: "pixels",
	    decimals: 0,
	    divisor: 1
	}, {
	    name: "inch",
	    decimals: 7,
	    divisor: 10160000
	}, {
	    name: "mm",
	    decimals: 6,
	    divisor: 400000
	}];
	
	var defaultAppState = {
	    title: "Debug Viewer",
	    units: "pixels",
	    decimals: 0,
	    divisor: 1,
	    bg: "#F1F1F1",
	    hoveredShape: null,
	    parser: new _parser.Parser(),
	    widthOn: true,
	    displayVertices: false,
	    measurePointsActive: false
	};
	
	var defaultMouseState = {
	    x: 0,
	    y: 0,
	    startX: undefined,
	    startY: undefined
	};
	
	function app() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAppState;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.STAGE_UPDATED:
	            return state;
	        case ActionTypes.TOGGLE_UNITS_CLICKED:
	            var curUnitsId = unitsList.findIndex(function (units) {
	                return state.units === units.name;
	            });
	            var newUnits = unitsList[(curUnitsId + 1) % 3];
	            return Object.assign({}, state, {
	                units: newUnits.name,
	                decimals: newUnits.decimals,
	                divisor: newUnits.divisor
	            });
	        case ActionTypes.MOUSE_ROLL_OVER_SHAPE:
	            return Object.assign({}, state, {
	                hoveredShape: action.shape
	            });
	        case ActionTypes.MOUSE_ROLL_OUT_SHAPE:
	            return Object.assign({}, state, {
	                hoveredShape: null
	            });
	        case ActionTypes.PAN_BY_DRAG_BUTTON_CLICKED:
	            return Object.assign({}, state, {
	                measurePointsActive: false
	            });
	        case ActionTypes.TOGGLE_WIDTH_MODE_CLICKED:
	            return Object.assign({}, state, {
	                widthOn: !state.widthOn,
	                displayVertices: state.widthOn ? state.displayVertices : false
	            });
	        case ActionTypes.TOGGLE_DISPLAY_VERTICES_CLICKED:
	            return Object.assign({}, state, {
	                displayVertices: !state.displayVertices
	            });
	        case ActionTypes.MEASURE_POINTS_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                measurePointsActive: true
	            });
	        case ActionTypes.MEASURE_CONTOURS_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                measurePointsActive: false
	            });
	        case ActionTypes.LAYER_LIST_PANEL_PRESSED:
	            return state; // only to cause refresh of layers list component
	        default:
	            return state;
	    }
	}
	
	function layers() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var action = arguments[1];
	
	    var curLayer = state.find(function (layer) {
	        return layer.affected;
	    });
	    var curLayerId = state.findIndex(function (layer) {
	        return layer.affected;
	    });
	
	    switch (action.type) {
	        /*
	        case ActionTypes.NEW_STAGE_CREATED:
	            return [...state, action.layer];
	            */
	
	        case ActionTypes.ADD_LAYER_PRESSED:
	            return [].concat(_toConsumableArray(state), [action.layer]);
	
	        case ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED:
	            var color = "";
	            if (!action.layer.displayed) {
	                color = _layers.Layers.getNextColor(state);
	                if (color === "") return; // no free colors
	            }
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    // if action.layer will be undisplayed,
	                    // it cannot become affected, then
	                    // keep affected on this layer
	                    if (action.layer.displayed) {
	                        return layer;
	                    } else {
	                        return layer.setAffected(false);
	                    }
	                } else {
	                    var newLayer = layer.toggleDisplayed(color);
	                    newLayer.affected = newLayer.displayed;
	                    return newLayer;
	                }
	                // return layer.toggleDisplayed(color);
	            });
	
	        case ActionTypes.TOGGLE_AFFECTED_LAYER_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer.setAffected(false);
	                } else {
	                    return layer.setAffected(!layer.affected);
	                }
	            });
	
	        case ActionTypes.NEW_SHAPE_PASTED:
	            return state.map(function (layer) {
	                if (layer.affected) {
	                    return layer.add(action.shape);
	                } else {
	                    return layer;
	                }
	            });
	
	        case ActionTypes.TOGGLE_WATCH_EXPAND_CLICKED:
	            return state.map(function (layer) {
	                if (layer.affected) {
	                    return layer.toggleExpanded(action.shape);
	                } else {
	                    return layer;
	                }
	            });
	
	        case ActionTypes.EDIT_LAYER_NAME_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer;
	                }
	                return Object.assign({}, layer, {
	                    edited: true
	                });
	            });
	
	        case ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED:
	            if (curLayerId === state.length - 1) {
	                return state;
	            } else {
	
	                var nextLayer = state[curLayerId + 1];
	
	                return state.map(function (layer) {
	                    if (layer === curLayer) {
	                        var newCurLayer = layer.toggleDisplayed("");
	                        newCurLayer.affected = false;
	                        return newCurLayer;
	                    } else if (layer === nextLayer) {
	                        var _color = curLayer.color;
	                        var newNextLayer = layer.toggleDisplayed(_color);
	                        newNextLayer.affected = true;
	                        return newNextLayer;
	                    } else {
	                        return layer;
	                    }
	                });
	            }
	
	        case ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED:
	            if (curLayerId === 0) {
	                return state;
	            } else {
	                var _nextLayer = state[curLayerId - 1];
	
	                return state.map(function (layer) {
	                    if (layer === curLayer) {
	                        var newCurLayer = layer.toggleDisplayed("");
	                        newCurLayer.affected = false;
	                        return newCurLayer;
	                    } else if (layer === _nextLayer) {
	                        var newNextLayer = layer.toggleDisplayed(curLayer.color);
	                        newNextLayer.displayed = true;
	                        newNextLayer.affected = true;
	                        return newNextLayer;
	                    } else {
	                        return layer;
	                    }
	                });
	            }
	
	        default:
	            return state;
	    }
	}
	
	function stage() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.NEW_STAGE_CREATED:
	            return action.stage;
	
	        case ActionTypes.STAGE_RESIZED:
	            state.resize();
	            return state;
	
	        case ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED:
	            state.needToBeUpdated = true;
	            return state;
	
	        case ActionTypes.ADD_SHAPE_TO_STAGE:
	            state.needToBeUpdated = true;
	            return state;
	
	        // return state.add(action.shape);   // stage already mutated !!!
	        case ActionTypes.PAN_TO_COORDINATE:
	            state.panToCoordinate(action.x, action.y);
	            state.needToBeUpdated = true;
	            return state;
	
	        case ActionTypes.PAN_AND_ZOOM_TO_SHAPE:
	            var center = action.shape.center;
	            var box = action.shape.box;
	            state.panToCoordinate(center.x, center.y);
	            state.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	            state.needToBeUpdated = true;
	            return state;
	
	        case ActionTypes.MOUSE_DOWN_ON_STAGE:
	            state.panByMouseStart();
	            state.needToBeUpdated = false;
	            return state;
	
	        case ActionTypes.MOUSE_MOVED_ON_STAGE:
	            if (action.dx !== undefined && action.dy !== undefined) {
	                state.panByMouseMove(action.dx, action.dy);
	                state.needToBeUpdated = true;
	            }
	            return state;
	
	        case ActionTypes.MOUSE_UP_ON_STAGE:
	            state.panByMouseStop();
	            state.needToBeUpdated = false;
	            return state;
	
	        case ActionTypes.MOUSE_WHEEL_MOVE_ON_STAGE:
	            var bIn = action.delta > 0;
	            state.zoomByMouse(action.x, action.y, bIn, 1.05);
	            state.needToBeUpdated = true;
	            return state;
	
	        // case ActionTypes.HOME_BUTTON_CLICKED:
	        //     state.needToBeUpdated = true;
	        //     return state;
	
	        default:
	            if (state) {
	                state.needToBeUpdated = false;
	            }
	            return state;
	    }
	}
	
	function mouse() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMouseState;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.MOUSE_MOVED_ON_STAGE:
	            return Object.assign({}, state, {
	                x: action.x,
	                y: action.y
	            });
	        case ActionTypes.MOUSE_DOWN_ON_STAGE:
	            return Object.assign({}, state, {
	                startX: action.x,
	                startY: action.y
	            });
	        case ActionTypes.MOUSE_UP_ON_STAGE:
	            return Object.assign({}, state, {
	                startX: undefined,
	                startY: undefined
	            });
	        default:
	            return state;
	    }
	}
	
	var reducer = exports.reducer = (0, _redux.combineReducers)({
	    app: app,
	    layers: layers,
	    stage: stage,
	    mouse: mouse
	});

/***/ },
/* 110 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Created by alexanderbol on 02/07/2017.
	 */
	
	var debug_str = exports.debug_str = "+\t\t[0]\t{nrec=27 nalloc=27 h_ind_id=-1 ...} mat_cont_hdr_struc\tmat_cont_struc\n    +\t\t[1]\t{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc\tmat_cont_struc\n+\t\t[2]\t{nedge=23 nalloc=25 ntop=2 ...} mat_cont_poly_struc\tmat_cont_struc\n+\t\t[3]\t{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc\tmat_cont_struc\n+\t\t[4]\t{ps=59192738,6363124 pe=59216000,6372800 pc=59216000,6340000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[5]\t{ps=59216000,6372800 pe=59267652,6372800} mat_seg_struc\tmat_cont_struc\n+\t\t[6]\t{ps=59267652,6372800 pe=59267652,6307200 pc=59360000,6340000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[7]\t{ps=59267652,6307200 pe=59229586,6307200} mat_seg_struc\tmat_cont_struc\n+\t\t[8]\t{ps=59229586,6307200 pe=59212000,6289614} mat_seg_struc\tmat_cont_struc\n+\t\t[9]\t{ps=59212000,6289614 pe=59212000,6056386} mat_seg_struc\tmat_cont_struc\n+\t\t[10]\t{ps=59212000,6056386 pe=59229586,6038800} mat_seg_struc\tmat_cont_struc\n+\t\t[11]\t{ps=59229586,6038800 pe=59469614,6038800} mat_seg_struc\tmat_cont_struc\n+\t\t[12]\t{ps=59469614,6038800 pe=59487200,6056386} mat_seg_struc\tmat_cont_struc\n+\t\t[13]\t{ps=59487200,6056386 pe=59487200,6100500} mat_seg_struc\tmat_cont_struc\n+\t\t[14]\t{ps=59487200,6100500 pe=59434000,6180000 pc=59520000,6180000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[15]\t{ps=59434000,6180000 pe=59552800,6100500 pc=59520000,6180000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[16]\t{ps=59552800,6100500 pe=59552800,6042800} mat_seg_struc\tmat_cont_struc\n+\t\t[17]\t{ps=59552800,6042800 pe=59543124,6019538 pc=59520000,6042800 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[18]\t{ps=59543124,6019538 pe=59506462,5982876} mat_seg_struc\tmat_cont_struc\n+\t\t[19]\t{ps=59506462,5982876 pe=59483200,5973200 pc=59483200,6006000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[20]\t{ps=59483200,5973200 pe=59216000,5973200} mat_seg_struc\tmat_cont_struc\n+\t\t[21]\t{ps=59216000,5973200 pe=59192738,5982876 pc=59216000,6006000 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[22]\t{ps=59192738,5982876 pe=59156076,6019538} mat_seg_struc\tmat_cont_struc\n+\t\t[23]\t{ps=59156076,6019538 pe=59146400,6042800 pc=59179200,6042800 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[24]\t{ps=59146400,6042800 pe=59146400,6303200} mat_seg_struc\tmat_cont_struc\n+\t\t[25]\t{ps=59146400,6303200 pe=59156076,6326462 pc=59179200,6303200 cw=1} mat_curve_struc\tmat_cont_struc\n+\t\t[26]\t{ps=59156076,6326462 pe=59192738,6363124} mat_seg_struc\tmat_cont_struc\n";

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MeasurePointsTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(10);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	var MeasurePointsTool = exports.MeasurePointsTool = function (_Component) {
	    _inherits(MeasurePointsTool, _Component);
	
	    function MeasurePointsTool() {
	        _classCallCheck(this, MeasurePointsTool);
	
	        var _this = _possibleConstructorReturn(this, (MeasurePointsTool.__proto__ || Object.getPrototypeOf(MeasurePointsTool)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	
	        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
	        _this.handleMouseWheelFox = _this.handleMouseWheelFox.bind(_this);
	
	        _this.startX = undefined;
	        _this.startY = undefined;
	        _this.endX = undefined;
	        _this.endY = undefined;
	        _this.measureStarted = false;
	        return _this;
	    }
	
	    _createClass(MeasurePointsTool, [{
	        key: 'handleMouseDown',
	        value: function handleMouseDown(event) {
	            event.preventDefault();
	
	            var canvas = this.refs.measureCanvas;
	            var stage = this.props.stage;
	
	            canvas.width = canvas.width;
	
	            var coordX = event.offsetX || event.originalEvent.layerX; // layerX for Firefox
	            var coordY = event.offsetY || event.originalEvent.layerY; // layery for Firefox
	
	            if (this.measureStarted) {
	                // second click - clear measurement
	                this.startX = undefined;
	                this.startY = undefined;
	                this.endX = undefined;
	                this.endY = undefined;
	                this.measureStarted = false;
	                canvas.style.cursor = "auto";
	            } else {
	                // first click - start measurment
	                this.startX = stage.C2W_X(coordX);
	                this.startY = stage.C2W_Y(coordY);
	                this.measureStarted = true;
	                canvas.style.cursor = "crosshair";
	            }
	        }
	    }, {
	        key: 'handleMouseMove',
	        value: function handleMouseMove(event) {
	            var stage = this.props.stage;
	
	            var coordX = event.offsetX /*|| event.originalEvent ? event.originalEvent.layerX : undefined*/; // layerX for Firefox
	            var coordY = event.offsetY /*|| event.originalEvent ? event.originalEvent.layerY : undefined*/; // layerY for Firefox
	
	            if (this.measureStarted) {
	                this.endX = stage.C2W_X(coordX);
	                this.endY = stage.C2W_Y(coordY);
	
	                this.draw();
	            }
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(event) {}
	    }, {
	        key: 'handleMouseWheel',
	        value: function handleMouseWheel(event) {
	            event.preventDefault();
	
	            var delta = event.detail || event.wheelDelta;
	            if (delta !== 0) {
	                this.props.onMouseWheelMove(event.offsetX, event.offsetY, delta);
	            }
	        }
	    }, {
	        key: 'handleMouseWheelFox',
	        value: function handleMouseWheelFox(event) {
	            event.preventDefault();
	
	            if (event.detail !== 0) {
	                this.props.onMousewheelMove(event.layerX, event.layerY, -event.detail);
	            }
	        }
	    }, {
	        key: 'draw',
	        value: function draw() {
	            var canvas = this.refs.measureCanvas;
	            var context = canvas.getContext('2d');
	            var stage = this.props.stage;
	
	            canvas.width = canvas.width;
	
	            // Draw rectangle
	            var pllX = Math.min(stage.W2C_X(this.startX), stage.W2C_X(this.endX));
	            var pllY = Math.min(stage.W2C_Y(this.startY), stage.W2C_Y(this.endY));
	            var width = Math.abs(stage.W2C_Scalar(this.startX - this.endX));
	            var height = Math.abs(stage.W2C_Scalar(this.startY - this.endY));
	
	            context.beginPath();
	            context.rect(pllX, pllY, width, height);
	
	            // Draw segment
	            context.moveTo(stage.W2C_X(this.startX), stage.W2C_Y(this.startY));
	            context.lineTo(stage.W2C_X(this.endX), stage.W2C_Y(this.endY));
	
	            context.lineWidth = 1;
	            context.strokeStyle = 'black';
	            context.stroke();
	
	            // Draw text
	            var textX = void 0,
	                textY = void 0,
	                textHeight = void 0,
	                textWidth = void 0;
	            var backX = void 0,
	                backY = void 0; // background rectangle
	            var text = this.measurement();
	
	            context.font = "12pt Arial";
	
	            textHeight = 12; /* font size*/
	            textWidth = context.measureText(text).width;
	
	            // Rectangle to the right of current point, text aligned left
	            if (Math.abs(stage.W2C_X(this.endX) - pllX) <= 2) {
	                context.textAlign = "left";
	                textX = pllX + 3;
	                backX = pllX;
	            }
	            // Rectangle to the left of current point, text aligned right
	            else {
	                    context.textAlign = "right";
	                    textX = pllX + width - 3;
	                    backX = textX - textWidth - 3;
	                }
	
	            if (Math.abs(stage.W2C_Y(this.endY) - pllY) <= 2) {
	                textY = pllY - 3;
	            } else {
	                textY = pllY + height + textHeight + 3;
	            }
	            backY = textY - textHeight - 3;
	
	            context.fillStyle = 'white';
	            context.globalAlpha = 0.4;
	            context.fillRect(backX, backY, textWidth + 6, textHeight + 6);
	
	            context.fillStyle = "black";
	            context.globalAlpha = 1;
	            context.fillText(this.measurement(), textX, textY);
	        }
	    }, {
	        key: 'measurement',
	        value: function measurement() {
	            var dx = this.endX - this.startX;
	            var dy = this.endY - this.startY;
	            var dist = Math.sqrt(dx * dx + dy * dy);
	            var message = "DX=" + this.format(dx) + ",DY=" + this.format(dy) + ",D=" + this.format(dist);
	            return message;
	        }
	    }, {
	        key: 'format',
	        value: function format(num) {
	            return (num / this.props.divisor).toFixed(this.props.decimals);
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            // this.dispatch = this.props.store.dispatch;
	            // this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var canvas = this.refs.measureCanvas;
	            canvas.addEventListener("mousedown", this.handleMouseDown);
	            canvas.addEventListener("mousemove", this.handleMouseMove);
	            canvas.addEventListener("mouseup", this.handleMouseUp);
	
	            canvas.addEventListener("mousewheel", this.handleMouseWheel);
	            canvas.addEventListener("DOMMouseScroll", this.handleMouseWheelFox);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.measureStarted) {
	                this.draw();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            var canvas = this.refs.measureCanvas;
	            canvas.width = canvas.width;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var mainCanvas = this.props.stage.canvas;
	            var width = mainCanvas.width;
	            var height = mainCanvas.height;
	            var top = mainCanvas.offsetTop;
	            var left = mainCanvas.offsetLeft;
	            return _react2.default.createElement('canvas', { tabIndex: '1', ref: 'measureCanvas', id: 'measurePoints',
	                width: width,
	                height: height,
	                style: { position: 'absolute', top: top, left: left }
	            });
	        }
	    }]);

	    return MeasurePointsTool;
	}(_react.Component);

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.PolygonTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(7);
	
	var _shape = __webpack_require__(16);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 19/06/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	// import Flatten from 'flatten-js';
	
	
	var PolygonTool = exports.PolygonTool = function (_Component) {
	    _inherits(PolygonTool, _Component);
	
	    function PolygonTool(params) {
	        _classCallCheck(this, PolygonTool);
	
	        var _this = _possibleConstructorReturn(this, (PolygonTool.__proto__ || Object.getPrototypeOf(PolygonTool)).call(this));
	
	        _this.vertices = undefined;
	        // this.handleMouseMove = this.handleMouseMove.bind(this);
	        _this.handleMouseOver = _this.handleMouseOver.bind(_this);
	        _this.handleMouseOut = _this.handleMouseOut.bind(_this);
	        return _this;
	    }
	
	    _createClass(PolygonTool, [{
	        key: 'handleMouseOver',
	        value: function handleMouseOver(event) {
	            this.props.onMouseOver(this.props.polygon);
	        }
	    }, {
	        key: 'handleMouseOut',
	        value: function handleMouseOut(event) {
	            this.props.onMouseOut();
	        }
	    }, {
	        key: 'createVertices',
	        value: function createVertices(polygon) {
	            var vertices = [];
	            var parent = polygon.parent;
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = polygon.geom.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var face = _step.value;
	                    var _iteratorNormalCompletion2 = true;
	                    var _didIteratorError2 = false;
	                    var _iteratorError2 = undefined;
	
	                    try {
	                        for (var _iterator2 = face[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                            var edge = _step2.value;
	
	                            var geom = edge.start; // Point
	                            var vertex = new _shape.Shape(geom, parent);
	                            vertices.push(vertex);
	                        }
	                    } catch (err) {
	                        _didIteratorError2 = true;
	                        _iteratorError2 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                _iterator2.return();
	                            }
	                        } finally {
	                            if (_didIteratorError2) {
	                                throw _iteratorError2;
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return vertices;
	        }
	    }, {
	        key: 'redraw',
	        value: function redraw(polygon) {
	            // Draw polygon
	            polygon.redraw({
	                stroke: this.props.color,
	                fill: this.props.widthOn && !this.props.displayVertices ? this.props.color : "white",
	                alpha: this.props.displayed ? 0.6 : 0.0
	            });
	
	            // if (!this.props.displayed)
	            //     return;
	
	            /* Update  vertices */
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = this.vertices[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var vertex = _step3.value;
	
	                    vertex.redraw({
	                        stroke: this.props.color,
	                        fill: this.props.color,
	                        alpha: this.props.displayed && this.props.displayVertices ? 1.0 : 0.0
	                    });
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {}
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.props.polygon.on("mouseover", this.handleMouseOver);
	            this.props.polygon.on("mouseout", this.handleMouseOut);
	            this.vertices = this.createVertices(this.props.polygon);
	            this.redraw(this.props.polygon);
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {}
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            // do not update grpahics if it was not displayed and stay not displayed
	            if (nextProps.polygon.alpha === 0 && !nextProps.displayed) return false;
	            return true; // nextProps.polygon.parent.needToBeUpdated;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.redraw(this.props.polygon);
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            this.vertices = undefined;
	            this.props.polygon.off("mouseover", this.handleMouseOver);
	            this.props.polygon.off("mouseout", this.handleMouseOut);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return PolygonTool;
	}(_react.Component);

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var emptyObject = __webpack_require__(29);
	var _invariant = __webpack_require__(1);
	
	if (false) {
	  var warning = require('fbjs/lib/warning');
	}
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	var ReactPropTypeLocationNames;
	if (false) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	} else {
	  ReactPropTypeLocationNames = {};
	}
	
	function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
	  /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */
	
	  var injectedMixins = [];
	
	  /**
	   * Composite components are higher-level components that compose other composite
	   * or host components.
	   *
	   * To create a new type of `ReactClass`, pass a specification of
	   * your new class to `React.createClass`. The only requirement of your class
	   * specification is that you implement a `render` method.
	   *
	   *   var MyComponent = React.createClass({
	   *     render: function() {
	   *       return <div>Hello World</div>;
	   *     }
	   *   });
	   *
	   * The class specification supports a specific protocol of methods that have
	   * special meaning (e.g. `render`). See `ReactClassInterface` for
	   * more the comprehensive protocol. Any other properties and methods in the
	   * class specification will be available on the prototype.
	   *
	   * @interface ReactClassInterface
	   * @internal
	   */
	  var ReactClassInterface = {
	    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
	    mixins: 'DEFINE_MANY',
	
	    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
	    statics: 'DEFINE_MANY',
	
	    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    propTypes: 'DEFINE_MANY',
	
	    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    contextTypes: 'DEFINE_MANY',
	
	    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
	    childContextTypes: 'DEFINE_MANY',
	
	    // ==== Definition methods ====
	
	    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
	    getDefaultProps: 'DEFINE_MANY_MERGED',
	
	    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
	    getInitialState: 'DEFINE_MANY_MERGED',
	
	    /**
	     * @return {object}
	     * @optional
	     */
	    getChildContext: 'DEFINE_MANY_MERGED',
	
	    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
	    render: 'DEFINE_ONCE',
	
	    // ==== Delegate methods ====
	
	    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
	    componentWillMount: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidMount: 'DEFINE_MANY',
	
	    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
	    componentWillReceiveProps: 'DEFINE_MANY',
	
	    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
	    shouldComponentUpdate: 'DEFINE_ONCE',
	
	    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
	    componentWillUpdate: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidUpdate: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
	    componentWillUnmount: 'DEFINE_MANY',
	
	    // ==== Advanced methods ====
	
	    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
	    updateComponent: 'OVERRIDE_BASE'
	  };
	
	  /**
	   * Mapping from class specification keys to special processing functions.
	   *
	   * Although these are declared like instance properties in the specification
	   * when defining classes using `React.createClass`, they are actually static
	   * and are accessible on the constructor instead of the prototype. Despite
	   * being static, they must be defined outside of the "statics" key under
	   * which all other static methods are defined.
	   */
	  var RESERVED_SPEC_KEYS = {
	    displayName: function(Constructor, displayName) {
	      Constructor.displayName = displayName;
	    },
	    mixins: function(Constructor, mixins) {
	      if (mixins) {
	        for (var i = 0; i < mixins.length; i++) {
	          mixSpecIntoComponent(Constructor, mixins[i]);
	        }
	      }
	    },
	    childContextTypes: function(Constructor, childContextTypes) {
	      if (false) {
	        validateTypeDef(Constructor, childContextTypes, 'childContext');
	      }
	      Constructor.childContextTypes = _assign(
	        {},
	        Constructor.childContextTypes,
	        childContextTypes
	      );
	    },
	    contextTypes: function(Constructor, contextTypes) {
	      if (false) {
	        validateTypeDef(Constructor, contextTypes, 'context');
	      }
	      Constructor.contextTypes = _assign(
	        {},
	        Constructor.contextTypes,
	        contextTypes
	      );
	    },
	    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
	    getDefaultProps: function(Constructor, getDefaultProps) {
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps = createMergedResultFunction(
	          Constructor.getDefaultProps,
	          getDefaultProps
	        );
	      } else {
	        Constructor.getDefaultProps = getDefaultProps;
	      }
	    },
	    propTypes: function(Constructor, propTypes) {
	      if (false) {
	        validateTypeDef(Constructor, propTypes, 'prop');
	      }
	      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	    },
	    statics: function(Constructor, statics) {
	      mixStaticSpecIntoComponent(Constructor, statics);
	    },
	    autobind: function() {}
	  };
	
	  function validateTypeDef(Constructor, typeDef, location) {
	    for (var propName in typeDef) {
	      if (typeDef.hasOwnProperty(propName)) {
	        // use a warning instead of an _invariant so components
	        // don't show up in prod but only in __DEV__
	        if (false) {
	          warning(
	            typeof typeDef[propName] === 'function',
	            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
	              'React.PropTypes.',
	            Constructor.displayName || 'ReactClass',
	            ReactPropTypeLocationNames[location],
	            propName
	          );
	        }
	      }
	    }
	  }
	
	  function validateMethodOverride(isAlreadyDefined, name) {
	    var specPolicy = ReactClassInterface.hasOwnProperty(name)
	      ? ReactClassInterface[name]
	      : null;
	
	    // Disallow overriding of base class methods unless explicitly allowed.
	    if (ReactClassMixin.hasOwnProperty(name)) {
	      _invariant(
	        specPolicy === 'OVERRIDE_BASE',
	        'ReactClassInterface: You are attempting to override ' +
	          '`%s` from your class specification. Ensure that your method names ' +
	          'do not overlap with React methods.',
	        name
	      );
	    }
	
	    // Disallow defining methods more than once unless explicitly allowed.
	    if (isAlreadyDefined) {
	      _invariant(
	        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
	        'ReactClassInterface: You are attempting to define ' +
	          '`%s` on your component more than once. This conflict may be due ' +
	          'to a mixin.',
	        name
	      );
	    }
	  }
	
	  /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
	  function mixSpecIntoComponent(Constructor, spec) {
	    if (!spec) {
	      if (false) {
	        var typeofSpec = typeof spec;
	        var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	        if (process.env.NODE_ENV !== 'production') {
	          warning(
	            isMixinValid,
	            "%s: You're attempting to include a mixin that is either null " +
	              'or not an object. Check the mixins included by the component, ' +
	              'as well as any mixins they include themselves. ' +
	              'Expected object but got %s.',
	            Constructor.displayName || 'ReactClass',
	            spec === null ? null : typeofSpec
	          );
	        }
	      }
	
	      return;
	    }
	
	    _invariant(
	      typeof spec !== 'function',
	      "ReactClass: You're attempting to " +
	        'use a component class or function as a mixin. Instead, just use a ' +
	        'regular object.'
	    );
	    _invariant(
	      !isValidElement(spec),
	      "ReactClass: You're attempting to " +
	        'use a component as a mixin. Instead, just use a regular object.'
	    );
	
	    var proto = Constructor.prototype;
	    var autoBindPairs = proto.__reactAutoBindPairs;
	
	    // By handling mixins before any other properties, we ensure the same
	    // chaining order is applied to methods with DEFINE_MANY policy, whether
	    // mixins are listed before or after these methods in the spec.
	    if (spec.hasOwnProperty(MIXINS_KEY)) {
	      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	    }
	
	    for (var name in spec) {
	      if (!spec.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (name === MIXINS_KEY) {
	        // We have already handled mixins in a special case above.
	        continue;
	      }
	
	      var property = spec[name];
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      validateMethodOverride(isAlreadyDefined, name);
	
	      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	        RESERVED_SPEC_KEYS[name](Constructor, property);
	      } else {
	        // Setup methods on prototype:
	        // The following member methods should not be automatically bound:
	        // 1. Expected ReactClass methods (in the "interface").
	        // 2. Overridden methods (that were mixed in).
	        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	        var isFunction = typeof property === 'function';
	        var shouldAutoBind =
	          isFunction &&
	          !isReactClassMethod &&
	          !isAlreadyDefined &&
	          spec.autobind !== false;
	
	        if (shouldAutoBind) {
	          autoBindPairs.push(name, property);
	          proto[name] = property;
	        } else {
	          if (isAlreadyDefined) {
	            var specPolicy = ReactClassInterface[name];
	
	            // These cases should already be caught by validateMethodOverride.
	            _invariant(
	              isReactClassMethod &&
	                (specPolicy === 'DEFINE_MANY_MERGED' ||
	                  specPolicy === 'DEFINE_MANY'),
	              'ReactClass: Unexpected spec policy %s for key %s ' +
	                'when mixing in component specs.',
	              specPolicy,
	              name
	            );
	
	            // For methods which are defined more than once, call the existing
	            // methods before calling the new property, merging if appropriate.
	            if (specPolicy === 'DEFINE_MANY_MERGED') {
	              proto[name] = createMergedResultFunction(proto[name], property);
	            } else if (specPolicy === 'DEFINE_MANY') {
	              proto[name] = createChainedFunction(proto[name], property);
	            }
	          } else {
	            proto[name] = property;
	            if (false) {
	              // Add verbose displayName to the function, which helps when looking
	              // at profiling tools.
	              if (typeof property === 'function' && spec.displayName) {
	                proto[name].displayName = spec.displayName + '_' + name;
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	
	  function mixStaticSpecIntoComponent(Constructor, statics) {
	    if (!statics) {
	      return;
	    }
	    for (var name in statics) {
	      var property = statics[name];
	      if (!statics.hasOwnProperty(name)) {
	        continue;
	      }
	
	      var isReserved = name in RESERVED_SPEC_KEYS;
	      _invariant(
	        !isReserved,
	        'ReactClass: You are attempting to define a reserved ' +
	          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
	          'as an instance property instead; it will still be accessible on the ' +
	          'constructor.',
	        name
	      );
	
	      var isInherited = name in Constructor;
	      _invariant(
	        !isInherited,
	        'ReactClass: You are attempting to define ' +
	          '`%s` on your component more than once. This conflict may be ' +
	          'due to a mixin.',
	        name
	      );
	      Constructor[name] = property;
	    }
	  }
	
	  /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
	  function mergeIntoWithNoDuplicateKeys(one, two) {
	    _invariant(
	      one && two && typeof one === 'object' && typeof two === 'object',
	      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
	    );
	
	    for (var key in two) {
	      if (two.hasOwnProperty(key)) {
	        _invariant(
	          one[key] === undefined,
	          'mergeIntoWithNoDuplicateKeys(): ' +
	            'Tried to merge two objects with the same key: `%s`. This conflict ' +
	            'may be due to a mixin; in particular, this may be caused by two ' +
	            'getInitialState() or getDefaultProps() methods returning objects ' +
	            'with clashing keys.',
	          key
	        );
	        one[key] = two[key];
	      }
	    }
	    return one;
	  }
	
	  /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createMergedResultFunction(one, two) {
	    return function mergedResult() {
	      var a = one.apply(this, arguments);
	      var b = two.apply(this, arguments);
	      if (a == null) {
	        return b;
	      } else if (b == null) {
	        return a;
	      }
	      var c = {};
	      mergeIntoWithNoDuplicateKeys(c, a);
	      mergeIntoWithNoDuplicateKeys(c, b);
	      return c;
	    };
	  }
	
	  /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createChainedFunction(one, two) {
	    return function chainedFunction() {
	      one.apply(this, arguments);
	      two.apply(this, arguments);
	    };
	  }
	
	  /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
	  function bindAutoBindMethod(component, method) {
	    var boundMethod = method.bind(component);
	    if (false) {
	      boundMethod.__reactBoundContext = component;
	      boundMethod.__reactBoundMethod = method;
	      boundMethod.__reactBoundArguments = null;
	      var componentName = component.constructor.displayName;
	      var _bind = boundMethod.bind;
	      boundMethod.bind = function(newThis) {
	        for (
	          var _len = arguments.length,
	            args = Array(_len > 1 ? _len - 1 : 0),
	            _key = 1;
	          _key < _len;
	          _key++
	        ) {
	          args[_key - 1] = arguments[_key];
	        }
	
	        // User is trying to bind() an autobound method; we effectively will
	        // ignore the value of "this" that the user is trying to use, so
	        // let's warn.
	        if (newThis !== component && newThis !== null) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): React component methods may only be bound to the ' +
	                'component instance. See %s',
	              componentName
	            );
	          }
	        } else if (!args.length) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): You are binding a component method to the component. ' +
	                'React does this for you automatically in a high-performance ' +
	                'way, so you can safely remove this call. See %s',
	              componentName
	            );
	          }
	          return boundMethod;
	        }
	        var reboundMethod = _bind.apply(boundMethod, arguments);
	        reboundMethod.__reactBoundContext = component;
	        reboundMethod.__reactBoundMethod = method;
	        reboundMethod.__reactBoundArguments = args;
	        return reboundMethod;
	      };
	    }
	    return boundMethod;
	  }
	
	  /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
	  function bindAutoBindMethods(component) {
	    var pairs = component.__reactAutoBindPairs;
	    for (var i = 0; i < pairs.length; i += 2) {
	      var autoBindKey = pairs[i];
	      var method = pairs[i + 1];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	
	  var IsMountedPreMixin = {
	    componentDidMount: function() {
	      this.__isMounted = true;
	    }
	  };
	
	  var IsMountedPostMixin = {
	    componentWillUnmount: function() {
	      this.__isMounted = false;
	    }
	  };
	
	  /**
	   * Add more to the ReactClass base class. These are all legacy features and
	   * therefore not already part of the modern ReactComponent.
	   */
	  var ReactClassMixin = {
	    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
	    replaceState: function(newState, callback) {
	      this.updater.enqueueReplaceState(this, newState, callback);
	    },
	
	    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
	    isMounted: function() {
	      if (false) {
	        warning(
	          this.__didWarnIsMounted,
	          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
	            'subscriptions and pending requests in componentWillUnmount to ' +
	            'prevent memory leaks.',
	          (this.constructor && this.constructor.displayName) ||
	            this.name ||
	            'Component'
	        );
	        this.__didWarnIsMounted = true;
	      }
	      return !!this.__isMounted;
	    }
	  };
	
	  var ReactClassComponent = function() {};
	  _assign(
	    ReactClassComponent.prototype,
	    ReactComponent.prototype,
	    ReactClassMixin
	  );
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function(props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (false) {
	        warning(
	          this instanceof Constructor,
	          'Something is calling a React component directly. Use a factory or ' +
	            'JSX instead. See: https://fb.me/react-legacyfactory'
	        );
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (false) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (
	          initialState === undefined &&
	          this.getInitialState._isMockFunction
	        ) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      _invariant(
	        typeof initialState === 'object' && !Array.isArray(initialState),
	        '%s.getInitialState(): must return an object or null',
	        Constructor.displayName || 'ReactCompositeComponent'
	      );
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
	    mixSpecIntoComponent(Constructor, spec);
	    mixSpecIntoComponent(Constructor, IsMountedPostMixin);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (false) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    _invariant(
	      Constructor.prototype.render,
	      'createClass(...): Class specification must implement a `render` method.'
	    );
	
	    if (false) {
	      warning(
	        !Constructor.prototype.componentShouldUpdate,
	        '%s has a method called ' +
	          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
	          'The name is phrased as a question because the function is ' +
	          'expected to return a value.',
	        spec.displayName || 'A component'
	      );
	      warning(
	        !Constructor.prototype.componentWillRecieveProps,
	        '%s has a method called ' +
	          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
	        spec.displayName || 'A component'
	      );
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  }
	
	  return createClass;
	}
	
	module.exports = factory;


/***/ },
/* 114 */
10,
/* 115 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(115);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(125);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  false ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ?  false ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ?  false ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ?  false ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	var createArrayFromMixed = __webpack_require__(118);
	var getMarkupWrap = __webpack_require__(120);
	var invariant = __webpack_require__(1);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ?  false ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ?  false ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ?  false ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;

/***/ },
/* 121 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable.Window && scrollable instanceof scrollable.Window) {
	    return {
	      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
	      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 122 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(122);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(124);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 126 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 4/1/2017.
	 */
	
	let Interval = class Interval {
	    constructor(low, high) {
	        this.low = low;
	        this.high = high;
	    }
	
	    get max() {
	        return this.high;
	    }
	
	    interval(low, high) {
	        return new Interval(low, high);
	    }
	
	    clone() {
	        return new Interval(this.low, this.high);
	    }
	
	    less_than(other_interval) {
	        return this.low < other_interval.low ||
	            this.low == other_interval.low && this.high < other_interval.high;
	    }
	
	    equal_to(other_interval) {
	        return this.low == other_interval.low && this.high == other_interval.high;
	    }
	
	    intersect(other_interval) {
	        return !this.not_intersect(other_interval);
	    }
	
	    not_intersect(other_interval) {
	        return (this.high < other_interval.low || other_interval.high < this.low);
	    }
	
	    output() {
	        return [this.low, this.high];
	    }
	
	    maximal_val(val1, val2) {
	        return Math.max(val1, val2);
	    }
	
	    val_less_than(val1, val2 ) {     // trait to compare max property with item ?
	        return val1 < val2;
	    }
	};
	
	module.exports = Interval;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 4/1/2017.
	 */
	
	'use strict';
	
	// let defaultTraits = require('../utils/numeric_traits');
	let Interval = __webpack_require__(127);
	let {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = __webpack_require__(55);
	
	let Node = class Node {
	    constructor(key = undefined, value = undefined,
	                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
	        this.left = left;                     // reference to left child node
	        this.right = right;                   // reference to right child node
	        this.parent = parent;                 // reference to parent node
	        this.color = color;
	
	        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval
	
	        /* If not, this should by an array of two numbers */
	        this.item.key == undefined;
	        if (key && key instanceof Array && key.length == 2) {
	            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
	                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));
	            }
	        }
	        this.max = this.item.key ? this.item.key.max : undefined;
	    }
	
	    less_than(other_node) {
	        return this.item.key.less_than(other_node.item.key);
	    }
	
	    equal_to(other_node) {
	        let value_equal = true;
	        if (this.item.value && other_node.item.value) {
	            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :
	                this.item.value == other_node.item.value;
	        }
	        return this.item.key.equal_to(other_node.item.key) && value_equal;
	    }
	
	    intersect(other_node) {
	        return this.item.key.intersect(other_node.item.key);
	    }
	
	    copy_data(other_node) {
	        this.item.key = other_node.item.key.clone();
	        this.item.value = other_node.item.value;
	    }
	
	    update_max() {
	        // use key (Interval) max property instead of key.high
	        this.max = this.item.key ? this.item.key.max : undefined;
	        if (this.right && this.right.max) {
	            let maximal_val = this.item.key.maximal_val;
	            this.max = maximal_val(this.max, this.right.max);
	        }
	        if (this.left && this.left.max) {
	            let maximal_val = this.item.key.maximal_val;
	            this.max = maximal_val(this.max, this.left.max);
	        }
	    }
	
	    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
	    not_intersect_left_subtree(search_node) {
	        let val_less_than = this.item.key.val_less_than;
	        let high = this.left.max.high ? this.left.max.high : this.left.max;
	        return val_less_than(high, search_node.item.key.low);
	    }
	
	    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
	    not_intersect_right_subtree(search_node) {
	        let val_less_than = this.item.key.val_less_than;
	        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;
	        return val_less_than(search_node.item.key.high, low);
	    }
	};
	
	module.exports = Node;
	


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 3/31/2017.
	 */
	'use strict';
	
	let Node = __webpack_require__(128);
	let {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = __webpack_require__(55);
	
	let nil_node = new Node();
	
	/**
	 * Implementation of interval binary search tree <br/>
	 * Interval tree may store items which are couples of {key:interval, value: value} <br/>
	 * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />
	 * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,
	 * see documentation {link}
	 * @type {IntervalTree}
	 */
	let IntervalTree = class IntervalTree {
	    /**
	     * Construct new empty instance of IntervalTree
	     */
	    constructor() {
	        this.root = null;
	    }
	
	    /**
	     * Returns number of items stored in the interval tree
	     * @returns {number}
	     */
	    get size() {
	        let count = 0;
	        this.tree_walk(this.root, () => count++);
	        return count;
	    }
	
	    get keys() {
	        let res = [];
	        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));
	        return res;
	    }
	
	    get isEmpty() {
	        return (this.root == null || this.root == nil_node);
	    }
	
	    /**
	     * Insert new item into interval tree
	     * @param key - interval object or array of two numbers [low, high]
	     * @param value - value representing any object (optional)
	     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}
	     */
	    insert(key, value = key) {
	        if (key === undefined) return;
	        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);
	        this.tree_insert(insert_node);
	        this.recalc_max(insert_node);
	        return insert_node;
	    }
	
	    /**
	     * Returns true if item {key,value} exist in the tree
	     * @param key - interval correspondent to keys stored in the tree
	     * @param value - value object to be checked
	     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise
	     */
	    exist(key, value) {
	        let search_node = new Node(key, value);
	        return this.tree_search(this.root, search_node) ? true : false;
	    }
	
	    /**
	     * Remove entry {key, value} from the tree
	     * @param key - interval correspondent to keys stored in the tree
	     * @param value - - value object
	     * @returns {boolean} - true if item {key, value} deleted, false if not found
	     */
	    remove(key, value) {
	        let search_node = new Node(key, value);
	        let delete_node = this.tree_search(this.root, search_node);
	        if (delete_node) {
	            this.tree_delete(delete_node);
	        }
	        return delete_node;
	    }
	
	    /**
	     * Returns array of entry values which keys intersect with given interval <br/>
	     * If no values stored in the tree, returns array of keys which intersect given interval
	     * @param interval - search interval, or array [low, high]
	     * @returns {Array}
	     */
	    search(interval) {
	        let search_node = new Node(interval);
	        let resp_nodes = [];
	        this.tree_search_interval(this.root, search_node, resp_nodes);
	        let resp = [];
	        resp_nodes.forEach((node) => {
	            if (node.item.value) {         // if there are values, return only values
	                resp.push(node.item.value);
	            }
	            else {                         // otherwise, return keys
	                resp.push(node.item.key.output());
	            }
	        }, []);
	        return resp;
	    }
	
	    /**
	     * Tree visitor. For each node implement a callback function. <br/>
	     * Method calls a callback function with two parameters (key, value)
	     * @param visitor(key,value) - function to be called for each tree item
	     */
	    forEach(visitor) {
	        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
	    };
	
	    recalc_max(node) {
	        let node_current = node;
	        while (node_current.parent != null) {
	            node_current.parent.update_max();
	            node_current = node_current.parent;
	        }
	    }
	
	    tree_insert(insert_node) {
	        let current_node = this.root;
	        let parent_node = null;
	
	        if (this.root == null || this.root == nil_node) {
	            this.root = insert_node;
	        }
	        else {
	            while (current_node != nil_node) {
	                parent_node = current_node;
	                if (insert_node.less_than(current_node)) {
	                    current_node = current_node.left;
	                }
	                else {
	                    current_node = current_node.right;
	                }
	            }
	
	            insert_node.parent = parent_node;
	
	            if (insert_node.less_than(parent_node)) {
	                parent_node.left = insert_node;
	            }
	            else {
	                parent_node.right = insert_node;
	            }
	        }
	
	        this.insert_fixup(insert_node);
	    }
	
	// After insertion insert_node may have red-colored parent, and this is a single possible violation
	// Go upwords to the root and re-color until violation will be resolved
	    insert_fixup(insert_node) {
	        let current_node;
	        let uncle_node;
	
	        current_node = insert_node;
	        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {
	            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather
	                uncle_node = current_node.parent.parent.right;              // right brother of parent
	                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red
	                    // re-color father and uncle into black
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    uncle_node.color = RB_TREE_COLOR_BLACK;
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    current_node = current_node.parent.parent;
	                }
	                else {                                                    // Case 2 & 3. Uncle is black
	                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child
	                        // This case is transformed into Case 3.
	                        current_node = current_node.parent;
	                        this.rotate_left(current_node);
	                    }
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.
	                    // Re-color father and grandfather, rotate grandfather right
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    this.rotate_right(current_node.parent.parent);
	                }
	            }
	            else {                                                         // parent is right child of grandfather
	                uncle_node = current_node.parent.parent.left;              // left brother of parent
	                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red
	                    // re-color father and uncle into black
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    uncle_node.color = RB_TREE_COLOR_BLACK;
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    current_node = current_node.parent.parent;
	                }
	                else {
	                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child
	                        // Transform into case 6
	                        current_node = current_node.parent;
	                        this.rotate_right(current_node);
	                    }
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.
	                    // Re-color father and grandfather, rotate grandfather left
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    this.rotate_left(current_node.parent.parent);
	                }
	            }
	        }
	
	        this.root.color = RB_TREE_COLOR_BLACK;
	    }
	
	    tree_delete(delete_node) {
	        let cut_node;   // node to be cut - either delete_node or successor_node  ("y" from 14.4)
	        let fix_node;   // node to fix rb tree property   ("x" from 14.4)
	
	        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children
	            cut_node = delete_node;
	        }
	        else {                                                    // delete_node has 2 children
	            cut_node = this.tree_successor(delete_node);
	        }
	
	        // fix_node if single child of cut_node
	        if (cut_node.left != nil_node) {
	            fix_node = cut_node.left;
	        }
	        else {
	            fix_node = cut_node.right;
	        }
	
	        // remove cut_node from parent
	        if (fix_node != nil_node) {
	            fix_node.parent = cut_node.parent;
	        }
	
	        if (cut_node == this.root) {
	            this.root = fix_node;
	        }
	        else {
	            if (cut_node == cut_node.parent.left) {
	                cut_node.parent.left = fix_node;
	            }
	            else {
	                cut_node.parent.right = fix_node;
	            }
	            cut_node.parent.update_max();        // update max property of the parent
	        }
	
	        this.recalc_max(fix_node);              // update max property upward from fix_node to root
	
	        // COPY DATA !!!
	        // Delete_node becomes cut_node, it means that we cannot hold reference
	        // to node in outer structure and we will have to delete by key, additional search need
	        if (cut_node != delete_node) {
	            delete_node.copy_data(cut_node);
	            delete_node.update_max();           // update max property of the cut node at the new place
	            this.recalc_max(delete_node);       // update max property upward from delete_node to root
	        }
	
	        if (fix_node != nil_node && cut_node.color == RB_TREE_COLOR_BLACK) {
	            this.delete_fixup(fix_node);
	        }
	    }
	
	    delete_fixup(fix_node) {
	        let current_node = fix_node;
	        let brother_node;
	
	        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {
	            if (current_node == current_node.parent.left) {          // fix node is left child
	                brother_node = current_node.parent.right;
	                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red
	                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother
	                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father
	                    this.rotate_left(current_node.parent);
	                    brother_node = current_node.parent.right;                      // update brother
	                }
	                // Derive to cases 2..4: brother is black
	                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&
	                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black
	                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother
	                    current_node = current_node.parent;                  // continue iteration
	                }
	                else {
	                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black
	                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother
	                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew
	                        this.rotate_right(brother_node);
	                        brother_node = current_node.parent.right;                     // update brother
	                        // Derive to case 4: left nephew black, right nephew red
	                    }
	                    // case 4: left nephew black, right nephew red
	                    brother_node.color = current_node.parent.color;
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    brother_node.right.color = RB_TREE_COLOR_BLACK;
	                    this.rotate_left(current_node.parent);
	                    current_node = this.root;                         // exit from loop
	                }
	            }
	            else {                                             // fix node is right child
	                brother_node = current_node.parent.left;
	                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red
	                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother
	                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father
	                    this.rotate_right(current_node.parent);
	                    brother_node = current_node.parent.left;                        // update brother
	                }
	                // Go to cases 2..4
	                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&
	                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2
	                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother
	                    current_node = current_node.parent;                              // continue iteration
	                }
	                else {
	                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black
	                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother
	                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew
	                        this.rotate_left(brother_node);
	                        brother_node = current_node.parent.left;                        // update brother
	                        // Derive to case 4: right nephew black, left nephew red
	                    }
	                    // case 4: right nephew black, left nephew red
	                    brother_node.color = current_node.parent.color;
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    brother_node.left.color = RB_TREE_COLOR_BLACK;
	                    this.rotate_right(current_node.parent);
	                    current_node = this.root;                               // force exit from loop
	                }
	            }
	        }
	
	        current_node.color = RB_TREE_COLOR_BLACK;
	    }
	
	    tree_search(node, search_node) {
	        if (node == null || node == nil_node)
	            return undefined;
	
	        if (search_node.equal_to(node)) {
	            return node;
	        }
	        if (search_node.less_than(node)) {
	            return this.tree_search(node.left, search_node);
	        }
	        else {
	            return this.tree_search(node.right, search_node);
	        }
	    }
	
	    // Original search_interval method; container res support push() insertion
	    // Search all intervals intersecting given one
	    tree_search_interval(node, search_node, res) {
	        if (node != null && node != nil_node) {
	            // if (node->left != nil_node && node->left->max >= low) {
	            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {
	                this.tree_search_interval(node.left, search_node, res);
	            }
	            // if (low <= node->high && node->low <= high) {
	            if (node.intersect(search_node)) {
	                res.push(node);
	            }
	            // if (node->right != nil_node && node->low <= high) {
	            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {
	                this.tree_search_interval(node.right, search_node, res);
	            }
	        }
	    }
	
	    local_minimum(node) {
	        let node_min = node;
	        while (node_min.left != null && node_min.left != nil_node) {
	            node_min = node_min.left;
	        }
	        return node_min;
	    }
	
	    // not in use
	    local_maximum(node) {
	        let node_max = node;
	        while (node_max.right != null && node_max.right != nil_node) {
	            node_max = node_max.right;
	        }
	        return node_max;
	    }
	
	    tree_successor(node) {
	        let node_successor;
	        let current_node;
	        let parent_node;
	
	        if (node.right != nil_node) {
	            node_successor = this.local_minimum(node.right);
	        }
	        else {
	            current_node = node;
	            parent_node = node.parent;
	            while (parent_node != null && parent_node.right == current_node) {
	                current_node = parent_node;
	                parent_node = parent_node.parent;
	            }
	            node_successor = parent_node;
	        }
	        return node_successor;
	    }
	
	    //           |            right-rotate(T,y)       |
	    //           y            ---------------.       x
	    //          / \                                  / \
	    //         x   c          left-rotate(T,x)      a   y
	    //        / \             <---------------         / \
	    //       a   b                                    b   c
	
	    rotate_left(x) {
	        let y = x.right;
	
	        x.right = y.left;           // b goes to x.right
	
	        if (y.left != nil_node) {
	            y.left.parent = x;     // x becomes parent of b
	        }
	        y.parent = x.parent;       // move parent
	
	        if (x == this.root) {
	            this.root = y;           // y becomes root
	        }
	        else {                        // y becomes child of x.parent
	            if (x == x.parent.left) {
	                x.parent.left = y;
	            }
	            else {
	                x.parent.right = y;
	            }
	        }
	        y.left = x;                 // x becomes left child of y
	        x.parent = y;               // and y becomes parent of x
	
	        if (x != null && x != nil_node) {
	            x.update_max();
	        }
	
	        y = x.parent;
	        if (y != null && y != nil_node) {
	            y.update_max();
	        }
	    }
	
	    rotate_right(y) {
	        let x = y.left;
	
	        y.left = x.right;           // b goes to y.left
	
	        if (x.right != nil_node) {
	            x.right.parent = y;        // y becomes parent of b
	        }
	        x.parent = y.parent;          // move parent
	
	        if (y == this.root) {        // x becomes root
	            this.root = x;
	        }
	        else {                        // y becomes child of x.parent
	            if (y == y.parent.left) {
	                y.parent.left = x;
	            }
	            else {
	                y.parent.right = x;
	            }
	        }
	        x.right = y;                 // y becomes right child of x
	        y.parent = x;               // and x becomes parent of y
	
	        if (y != null && y != nil_node) {
	            y.update_max();
	        }
	
	        x = y.parent;
	        if (x != null && x != nil_node) {
	            x.update_max();
	        }
	    }
	
	    tree_walk(node, action) {
	        if (node != null && node != nil_node) {
	            this.tree_walk(node.left, action);
	            // arr.push(node.toArray());
	            action(node);
	            this.tree_walk(node.right, action);
	        }
	    }
	
	    /* Return true if all red nodes have exactly two black child nodes */
	    testRedBlackProperty() {
	        let res = true;
	        this.tree_walk(this.root, function (node) {
	            if (node.color == RB_TREE_COLOR_RED) {
	                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {
	                    res = false;
	                }
	            }
	        });
	        return res;
	    }
	
	    /* Throw error if not every path from root to bottom has same black height */
	    testBlackHeightProperty(node) {
	        let height = 0;
	        let heightLeft = 0;
	        let heightRight = 0;
	        if (node.color == RB_TREE_COLOR_BLACK) {
	            height++;
	        }
	        if (node.left != nil_node) {
	            heightLeft = this.testBlackHeightProperty(node.left);
	        }
	        else {
	            heightLeft = 1;
	        }
	        if (node.right != nil_node) {
	            heightRight = this.testBlackHeightProperty(node.right);
	        }
	        else {
	            heightRight = 1;
	        }
	        if (heightLeft != heightRight) {
	            throw new Error('Red-black height property violated');
	        }
	        height += heightLeft;
	        return height;
	    };
	};
	
	module.exports = IntervalTree;


/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/10/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a circlular arc
	     * @type {Arc}
	     */
	    Flatten.Arc = class Arc {
	        /**
	         *
	         * @param {Point} pc - arc center
	         * @param {number} r - arc radius
	         * @param {number} startAngle - start angle in radians from 0 to 2*PI
	         * @param {number} endAngle - end angle in radians from 0 to 2*PI
	         * @param counterClockwise - arc direction, true - clockwise, false - counter clockwise
	         */
	        constructor(pc=new Flatten.Point(), r=1, startAngle=0, endAngle=2*Math.PI, counterClockwise=true) {
	            this.pc = pc.clone();
	            this.r = r;
	            this.startAngle = startAngle;
	            this.endAngle = endAngle;
	            this.counterClockwise = counterClockwise;
	        }
	
	        /**
	         * Return new instance of arc
	         * @returns {Arc}
	         */
	        clone() {
	            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);
	        }
	
	        /**
	         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI
	         * @returns {number}
	         */
	        get sweep() {
	            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))
	                return 0.0;                    // or Flatten.PIx2 ? - no zero arcs
	            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {
	                return Flatten.PIx2;
	            }
	            let sweep;
	            if (this.counterClockwise) {
	                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?
	                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;
	            } else {
	                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?
	                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;
	            }
	
	            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {
	                sweep -= Flatten.PIx2;
	            }
	            if ( Flatten.Utils.LT(sweep, 0) ) {
	                sweep += Flatten.PIx2;
	            }
	            return sweep;
	        }
	
	        /**
	         * Get start point of arc
	         * @returns {Point}
	         */
	        get start() {
	            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
	            return p0.rotate(this.startAngle, this.pc);
	        }
	
	        /**
	         * Get end point of arc
	         * @returns {Point}
	         */
	        get end() {
	            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
	            return p0.rotate(this.endAngle, this.pc);
	        }
	
	        /**
	         * Get arc length
	         * @returns {number}
	         */
	        get length() {
	            return Math.abs(this.sweep*this.r);
	        }
	
	        /**
	         * Get bounding box of arc
	         * @returns {Box}
	         */
	        get box() {
	            let xs,ys,xe,ye;
	            let dxs,dys,dxe,dye;
	            let xmin,ymin,xmax,ymax;
	            let quads, quade, quad;
	            let xc = this.pc.x;
	            let yc = this.pc.y;
	            let r = this.r;
	
	            let ps = this.start;
	            let pe = this.end;
	
	            let box = new Flatten.Box();
	
	            /* order (xs, xe) and (ys, ye) always clockwise */
	            if(this.counterClockwise){
	                xs = pe.x ; ys = pe.y ;
	                xe = ps.x ; ye = ps.y ;
	            } else {
	                xs = ps.x ; ys =ps.y ;
	                xe = pe.x ; ye = pe.y ;
	            }
	            dxs = xs-xc ; dys = ys-yc ;
	            dxe = xe-xc ; dye = ye-yc ;
	
	            xmin = xc-r ; ymin = yc-r ;
	            xmax = xc+r ; ymax = yc+r ;
	
	            xmin = Math.min(xmin,xs) ; xmin = Math.min(xmin,xe);
	            xmax = Math.max(xmax,xs) ; xmax = Math.max(xmax,xe);
	            ymin = Math.min(ymin,ys) ; ymin = Math.min(ymin,ye);
	            ymax = Math.max(ymax,ys) ; ymax = Math.max(ymax,ye);
	
	            /* Calculate the quadrant for each point */
	            /*
	             *           |
	             *         1 | 0
	             *       ----------
	             *         2 | 3
	             *           |
	             */
	            quads = (dxs >= 0 ? (dys >= 0 ? 0 : 3) : (dys >= 0 ? 1 : 2));
	            quade = (dxe >= 0 ? (dye >= 0 ? 0 : 3) : (dye >= 0 ? 1 : 2));
	
	            /* There are 16 combinations of start-end configurations */
	            /* The more complex ones are when both points are in the
	             * same quadrant (They require additional conditions).
	             * Remember that we converted everything to clockwise !
	             */
	
	            quad = (quads << 2) + quade ;
	
	            switch(quad){
	                case 0 :
	                    /* From quadrant 0 to 0 */
	                    if(xs < xe || ys > ye){
	                        box.set(xs,ye,xe,ys);
	                    } else {
	                        box.set(xmin,ymin,xmax,ymax);
	                    }
	                    break ;
	                case 1 :
	                    /* From quadrant 0 to 1 */
	                    box.set(xmin,ymin,xmax,Math.max(ys,ye));
	                    break ;
	                case 2 :
	                    /* From quadrant 0 to 2 */
	                    box.set(xe,ymin,xmax,ys);
	                    break ;
	                case 3 :
	                    /* From quadrant 0 to 3 */
	                    box.set(Math.min(xs,xe),ye,xmax,ys);
	                    break ;
	                case 4 :
	                    /* From quadrant 1 to 0 */
	                    box.set(xs,Math.min(ys,ye),xe,ymax);
	                    break ;
	                case 5 :
	                    /* From quadrant 1 to 1 */
	                    if(xs < xe || ys < ye){
	                        box.set(xs,ys,xe,ye);
	                    } else {
	                        box.set(xmin,ymin,xmax,ymax);
	                    }
	                    break ;
	                case 6 :
	                    /* From quadrant 1 to 2 */
	                    box.set(Math.min(xs,xe),ymin,xmax,ymax);
	                    break ;
	                case 7 :
	                    /* From quadrant 1 to 3 */
	                    box.set(xs,ye,xmax,ymax);
	                    break ;
	                case 8 :
	                    /* From quadrant 2 to 0 */
	                    box.set(xmin,ys,xe,ymax);
	                    break ;
	                case 9 :
	                    /* From quadrant 2 to 1 */
	                    box.set(xmin,ys,Math.max(xs,xe),ye);
	                    break ;
	                case 10 :
	                    /* From quadrant 2 to 2 */
	                    if(xs > xe || ys < ye){
	                        box.set(xe,ys,xs,ye);
	                    } else {
	                        box.set(xmin,ymin,xmax,ymax);
	                    }
	                    break ;
	                case 11 :
	                    /* From quadrant 2 to 3 */
	                    box.set(xmin,Math.min(ys,ye),xmax,ymax);
	                    break ;
	                case 12 :
	                    /* From quadrant 3 to 0 */
	                    box.set(xmin,ymin,Math.max(xs,xe),ymax);
	                    break ;
	                case 13 :
	                    /* From quadrant 3 to 1 */
	                    box.set(xmin,ymin,xs,ye);
	                    break ;
	                case 14 :
	                    /* From quadrant 3 to 2 */
	                    box.set(xe,ymin,xs,Math.max(ys,ye));
	                    break ;
	                case 15 :
	                    /* From quadrant 3 to 3 */
	                    if(xs > xe || ys > ye){
	                        box.set(xe,ye,xs,ys);
	                    } else {
	                        box.set(xmin,ymin,xmax,ymax);
	                    }
	                    break ;
	            }
	            return box;
	        }
	
	        /**
	         * Returns true if arc contains point
	         * @param {Point} pt - point to test
	         * @returns {boolean}
	         */
	        contains(pt) {
	            // first check if  point on circle (pc,r)
	            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt), this.r))
	                return false;
	
	            // point on circle
	
	            if (pt.equalTo(this.start))
	                return true;
	
	            let angle = new Flatten.Vector(this.pc, pt).slope;
	            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);
	            return Flatten.Utils.LE(test_arc.length, this.length);
	        }
	
	        /**
	         * Returns array of intersection points between arc and other shape
	         * @param shape
	         * @returns {*}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return shape.intersect(this);
	            }
	            if (shape instanceof Flatten.Circle) {
	                return Arc.intersectArc2Circle(this, shape);
	            }
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	            if (shape instanceof Flatten.Arc) {
	                return Arc.intersectArc2Arc(this, shape);
	            }
	        }
	
	        distanceToPoint(pt) {
	            let circle = new Flatten.Circle(this.pc, this.r);
	            let distToCircle = pt.distanceTo(circle);
	            let distToStart = pt.distanceTo(this.start);
	            let distToEnd = pt.distanceTo(this.end);
	            return Math.min(distToCircle, Math.min(distToStart, distToEnd));
	        }
	
	        /**
	         * Returns array of sub-arcs broken in extreme point 0, pi/2, pi, 3*pi/2
	         * @returns {Array}
	         */
	        breakToFunctional() {
	            let func_arcs_array = [];
	            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];
	            let pts = [
	                this.pc.translate(this.r,0),
	                this.pc.translate(0,this.r),
	                this.pc.translate(-this.r,0),
	                this.pc.translate(0,-this.r)
	            ];
	
	            // If arc contains extreme point,
	            // create test arc started at start point and ended at this extreme point
	            let test_arcs = [];
	            for (let i=0; i < 4; i++) {
	                if (pts[i].on(this)) {
	                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));
	                }
	            }
	
	            if (test_arcs.length == 0) {                  // arc does contain any extreme point
	                func_arcs_array.push(this.clone());
	            }
	            else {                                        // arc passes extreme point
	                // sort these arcs by length
	                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);
	
	                for (let i = 0; i < test_arcs.length; i++) {
	                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
	                    let new_arc;
	                    if (prev_arc) {
	                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);
	                    }
	                    else {
	                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);
	                    }
	                    if (!Flatten.Utils.EQ_0(new_arc.length)) {
	                        func_arcs_array.push(new_arc.clone());
	                    }
	                }
	
	                // add last sub arc
	                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
	                let new_arc;
	                if (prev_arc) {
	                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);
	                }
	                else {
	                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);
	                }
	                if (!Flatten.Utils.EQ_0(new_arc.length)) {
	                    func_arcs_array.push(new_arc.clone());
	                }
	            }
	            return func_arcs_array;
	        }
	
	        static intersectArc2Arc(arc1, arc2) {
	            var ip = [];
	
	            if (arc1.box.notIntersect(arc2.box)) {
	                return ip;
	            }
	
	            // Special case: overlapping arcs
	            // May return up to 4 intersection points
	            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {
	                let pt;
	
	                pt = arc1.start;
	                if (pt.on(arc2))
	                    ip.push(pt);
	
	                pt = arc1.end;
	                if (pt.on(arc2))
	                    ip.push(pt);
	
	                pt = arc2.start;
	                if (pt.on(arc1)) ip.push(pt);
	
	                pt = arc2.end;
	                if (pt.on(arc1)) ip.push(pt);
	
	                return ip;
	            }
	
	            // Common case
	            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);
	            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
	            let ip_tmp =  circle1.intersect(circle2);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc1) && pt.on(arc2)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	        }
	
	        static intersectArc2Circle(arc, circle) {
	            let ip = [];
	
	            if (arc.box.notIntersect(circle.box)) {
	                return ip;
	            }
	
	            // Case when arc center incident to circle center
	            // Return arc's end points as 2 intersection points
	            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {
	                ip.push(arc.start);
	                ip.push(arc.end);
	                return ip;
	            }
	
	            // Common case
	            let circle1 = circle;
	            let circle2 = new Flatten.Circle(arc.pc, arc.r);
	            let ip_tmp = circle1.intersect(circle2);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	        }
	
	        definiteIntegral(ymin=0) {
	            let f_arcs = this.breakToFunctional();
	            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );
	            return area;
	        }
	
	        circularSegmentDefiniteIntegral(ymin) {
	            let line = new Flatten.Line(this.start, this.end);
	            let onLeftSide = this.pc.leftTo(line);
	            let segment = new Flatten.Segment(this.start, this.end);
	            let areaTrapez = segment.definiteIntegral(ymin);
	            let areaCircularSegment = this.circularSegmentArea();
	            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;
	            return area;
	        }
	
	        circularSegmentArea() {
	            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))
	        }
	
	        /**
	         * Return string to draw arc in svg
	         * @param attrs - json structure with any attributes allowed to svg path element,
	         * like "stroke", "strokeWidth", "fill"
	         * Defaults are stroke:"black", strokeWidth:"3", fill:"none"
	         * @returns {string}
	         */
	        svg(attrs = {stroke:"black", strokeWidth:"3", fill:"none"}) {
	            let largeArcFlag = this.sweep <= Math.PI ? "0" : "1";
	            let sweepFlag = this.counterClockwise ? "1" : "0";
	            let {stroke, strokeWidth, fill} = attrs;
	
	            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {
	                let circle = new Flatten.Circle(this.pc, this.r);
	                return circle.svg(attrs);
	            }
	            else {
	                return `\n<path d="M${this.start.x},${this.start.y}
	                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}"
	                    stroke="${stroke}" stroke-width="${strokeWidth}" fill="${fill}"/>`
	            }
	        }
	    };
	
	    /**
	     * Function to create arc equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.arc = (...args) => new Flatten.Arc(...args);
	};

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/7/2017.
	 */
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class Box represent bounding box of the shape
	     * @type {Box}
	     */
	    Flatten.Box = class Box {
	        /**
	         *
	         * @param {number} xmin - minimal x coordinate
	         * @param {number} ymin - minimal y coordinate
	         * @param {number} xmax - maximal x coordinate
	         * @param {number} ymax - maximal y coordinate
	         */
	        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {
	            /**
	             * Minimal x coordinate
	             * @type {number}
	             */
	            this.xmin = xmin;
	            /**
	             * Minimal y coordinate
	             * @type {number}
	             */
	            this.ymin = ymin;
	            /**
	             * Maximal x coordinate
	             * @type {number}
	             */
	            this.xmax = xmax;
	            /**
	             * Maximal y coordinate
	             * @type {number}
	             */
	            this.ymax = ymax;
	        }
	
	        /**
	         * Clones and returns new instance of box
	         * @returns {Box}
	         */
	        clone() {
	            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);
	        }
	
	        /**
	         * Property low need for interval tree interface
	         * @returns {Point}
	         */
	        get low() {
	            return new Flatten.Point(this.xmin, this.ymin);
	        }
	
	        /**
	         * Property high need for interval tree interface
	         * @returns {Point}
	         */
	        get high() {
	            return new Flatten.Point(this.xmax, this.ymax);
	        }
	
	        /**
	         * Property max returns the box itself !
	         * @returns {Box}
	         */
	        get max() {
	            return this.clone();
	        }
	
	        /**
	         * Returns true if not intersected with other box
	         * @param {Box} other_box - other box to test
	         * @returns {boolean}
	         */
	        notIntersect(other_box) {
	            return (
	                this.xmax < other_box.xmin ||
	                this.xmin > other_box.xmax ||
	                this.ymax < other_box.ymin ||
	                this.ymin > other_box.ymax
	            );
	        }
	
	        /**
	         * Returns true if intersected with other box
	         * @param {Box} other_box - other box to test
	         * @returns {boolean}
	         */
	        intersect(other_box) {
	            return !this.notIntersect(other_box);
	        }
	
	        /**
	         * Returns new box merged with other box
	         * @param {Box} other_box - other box to merge with
	         * @returns {Box}
	         */
	        merge(other_box) {
	            return new Box(
	                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),
	                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),
	                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),
	                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)
	            );
	        }
	
	        /**
	         * Defines predicate "less than" between two boxes. Need for interval index
	         * @param other_box - other box
	         * @returns {boolean} - true if this box less than other box, false otherwise
	         */
	        less_than(other_box) {
	            if (this.low.lessThan(other_box.low))
	                return true;
	            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))
	                return true;
	            return false;
	        }
	
	        /**
	         * Returns true if this box equal to other box
	         * @param other_box - other box
	         * @returns {boolean} - true if equal, false otherwise
	         */
	        equal_to(other_box) {
	            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));
	        }
	
	        output() {
	            return this.clone();
	        }
	
	        maximal_val(box1, box2) {
	            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();
	            return box1.merge(box2);
	        }
	
	        val_less_than(pt1, pt2) {
	            return pt1.lessThan(pt2);
	        }
	
	        set(xmin, ymin, xmax, ymax) {
	            this.xmin = xmin;
	            this.ymin = ymin;
	            this.xmax = xmax;
	            this.ymax = ymax;
	        }
	    };
	};

/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/6/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Arc} = Flatten;
	    /**
	     * Class representing a circle
	     * @type {Circle}
	     */
	    Flatten.Circle = class Circle {
	        /**
	         *
	         * @param {Point} pc - circle center point
	         * @param {number} r - circle radius
	         */
	        constructor(pc, r) {
	            /**
	             * Circle center
	             * @type {Point}
	             */
	            this.pc = pc;
	            /**
	             * Circle radius
	             * @type {number}
	             */
	            this.r = r;
	        }
	
	        /**
	         * Method clone returns new instance of a Circle
	         * @returns {Circle}
	         */
	        clone() {
	            return new Flatten.Circle(this.pc.clone(), this.r);
	        }
	
	        /**
	         * Circle center
	         * @returns {Point}
	         */
	        get center() {
	            return this.pc;
	        }
	
	        /**
	         * Circle bounding box
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(
	                this.pc.x - this.r,
	                this.pc.y - this.r,
	                this.pc.x + this.r,
	                this.pc.y + this.r
	            );
	        }
	
	        /**
	         * Return true if circle contains point
	         * @param {Point} pt - test point
	         * @returns {boolean}
	         */
	        contains(pt) {
	            return Flatten.Utils.LE(pt.distanceTo(this.center), this.r);
	        }
	
	        /**
	         * Transform circle to closed arc
	         * @param {boolean} counterclockwise
	         * @returns {Arc}
	         */
	        toArc(counterclockwise=true) {
	            return new Flatten.Arc(this.center, this.r, Math.PI, 3*Math.PI, counterclockwise);
	        }
	
	        /**
	         * Returns array of intersection points between circle and other shape
	         * @param shape
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Circle.intersectCirle2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return shape.intersect(this);
	            }
	        }
	
	        static intersectCirle2Circle(circle1, circle2) {
	            let ip = [];
	
	            if (circle1.box.notIntersect(circle2.box)) {
	                return ip;
	            }
	
	            let vec = new Flatten.Vector(circle1.pc, circle2.pc);
	
	            let r1 = circle1.r;
	            let r2 = circle2.r;
	
	            // Degenerated circle
	            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))
	                return ip;
	
	            // In case of equal circles return one most left intersection points
	            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {
	                ip.push(new Flatten.Point(circle1.x - r1, circle1.y));
	                return ip;
	            }
	
	            let dist = circle1.pc.distanceTo(circle2.pc);
	
	            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections
	                return ip;
	
	            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections
	                return ip;
	
	            // Normalize vector.
	            vec.x /= dist;
	            vec.y /= dist;
	
	            let pt;
	
	            // Case of touching from outside or from inside - single intersection point
	            // TODO: check this specifically not sure if correct
	            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {
	                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);
	                ip.push(pt);
	                return ip;
	            }
	
	            // Case of two intersection points
	
	            // Distance from first center to center of common chord:
	            //   a = (r1^2 - r2^2 + d^2) / 2d
	            // Separate for better accuracy
	            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;
	
	            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);
	            let h = Math.sqrt(r1*r1 - a*a);
	            // let norm;
	
	            // norm = vec.rotate90CCW().multiply(h);
	            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));
	            ip.push(pt);
	
	            // norm = vec.rotate90CW();
	            pt = mid_pt.translate(vec.rotate90CW().multiply(h));
	            ip.push(pt);
	
	            return ip;
	        }
	
	        /**
	         * Return string to draw circle in svg
	         * @param attrs - json structure with any attributes allowed to svg circle element,
	         * like "stroke", "strokeWidth", "fill"
	         * Defaults are stroke:"black", strokeWidth:"3", fill:"none"
	         * @returns {string}
	         */
	        svg(attrs = {stroke:"black",strokeWidth:"3",fill:"none"}) {
	            let {stroke, strokeWidth, fill} = attrs;
	            return `\n<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}" stroke="${stroke}" stroke-width="${strokeWidth}" fill="${fill}" />`;
	        }
	    };
	
	    /**
	     * Function to create circle equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.circle = (...args) => new Flatten.Circle(...args);
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/17/2017.
	 */
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing an edge of polygon. Edge shape may be Segment or Arc
	     * Each edge points to the next and previous edges in the face (loop)
	     *
	     * @type {Edge}
	     */
	    Flatten.Edge = class Edge {
	        constructor(shape) {
	            /**
	             * Shape of the edge: Segment or Arc
	             */
	            this.shape = shape;
	            /**
	             * Pointer to the next edge in the face
	             */
	            this.next;
	            /**
	             * Pointer to the previous edge in the face
	             */
	            this.prev;
	        }
	
	        /**
	         * Get edge start point
	         */
	        get start() {
	            return this.shape.start;
	        }
	
	        /**
	         * Get edge end point
	         */
	        get end() {
	            return this.shape.end;
	        }
	
	        /**
	         * Get edge length
	         */
	        get length() {
	            return this.shape.length;
	        }
	
	        /**
	         * Get bounding box of the edge
	         * @returns {*|Box}
	         */
	        get box() {
	            return this.shape.box;
	        }
	
	        /**
	         * Returns true if point lays on the edge, false otherwise
	         * @param pt - test point
	         */
	        contains(pt) {
	            return this.shape.contains(pt);
	        }
	
	        svg() {
	            if (this.shape instanceof Flatten.Segment) {
	                return ` L${this.shape.end.x},${this.shape.end.y}`;
	            }
	            else if (this.shape instanceof  Flatten.Arc) {
	                let arc = this.shape;
	                let largeArcFlag;
	                let sweepFlag = arc.counterClockwise ? "1" : "0";
	
	                // Draw full circe arc as special case: split it into two half-circles
	                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {
	                    let sign = arc.counterClockwise ? 1 : -1;
	                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);
	                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);
	
	                    largeArcFlag = "0";
	
	                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}
	                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`
	                }
	                else {
	                    largeArcFlag = arc.sweep <= Math.PI ? "0" : "1";
	
	                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;
	                }
	            }
	        }
	    };
	};

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/17/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Point, Segment, Arc, Box, Edge} = Flatten;
	    /**
	     * Class representing a face (closed loop) of polygon.
	     * New face object should not be created directly, use polygon.addFace() method instead.
	     * Face implemented as a circular bidirectional linked list of edges.
	     * @type {Face}
	     */
	    Flatten.Face = class Face {
	        constructor(polygon, ...args) {
	            /**
	             * Reference to the first edge in face
	             */
	            this.first;
	            /**
	             * Reference to the last edge in face
	             */
	            this.last;
	            /**
	             * Face orientation: clockwise, counterclockwise or not-orientable
	             * @type {Flatten.ORIENTATION}
	             */
	            this.orientation = undefined;
	            /**
	             * Bounding box of the face
	             */
	            this.box = new Box();
	
	            if (args.length == 0) {
	                return;
	            }
	
	            /* If passed an array it supposed to be:
	             1) array of shapes that performs close loop or
	             2) array of points that performs set of vertices
	             */
	            if (args.length == 1 && args[0] instanceof Array) {
	                let shapes = args[0][0];
	                if (shapes.length == 0)
	                    return;
	
	                if (shapes.every((shape) => {
	                        return shape instanceof Point
	                    })) {
	                    let segments = Face.points2segments(shapes);
	                    this.shapes2face(polygon.edges, segments);
	                }
	                else if (shapes.every((shape) => {
	                        return (shape instanceof Segment || shape instanceof Arc)
	                    })) {
	                    this.shapes2face(polygon.edges, shapes);
	                }
	            }
	
	            /* If passed two edges, consider them as start and end of the face loop */
	            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */
	            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {
	                this.first = args[0];                          // first edge in face or undefined
	                this.last = args[1];                           // last edge in face or undefined
	                this.last.next = this.first;
	                this.first.prev = this.last;
	                this.box = this.getBox();
	                this.orientation = this.getOrientation();      // face direction cw or ccw
	            }
	        }
	
	        [Symbol.iterator]() {
	            let edge = undefined;
	            return {
	                next: () => {
	                    let value = edge ? edge : this.first;
	                    let done = edge ? edge === this.first : false;
	                    edge = value.next;
	                    return {value: value, done: done};
	                }
	            };
	        };
	
	        /**
	         * Return array of edges of the given face in the order from first to last
	         * @returns {Array} - Array of edges
	         */
	        get edges() {
	            let face_edges = [];
	            for (let edge of this) {
	                face_edges.push(edge);
	            }
	            return face_edges;
	        }
	
	        /**
	         * Return number of edges in the face
	         * @returns {number} - number of edges
	         */
	        get size() {
	            let counter = 0;
	            for (let edge of this) {
	                counter++;
	            }
	            return counter;
	        }
	
	        static points2segments(points) {
	            let segments = [];
	            for (let i = 0; i < points.length; i++) {
	                segments.push(new Segment(points[i], points[(i + 1) % points.length]));
	            }
	            return segments;
	        }
	
	        append(edge) {
	            if (this.first === undefined) {
	                edge.prev = edge;
	                edge.next = edge;
	                this.first = edge;
	                this.last = edge;
	            }
	            else {
	                // append to end
	                edge.prev = this.last;
	                this.last.next = edge;
	
	                // update edge to be last
	                this.last = edge;
	
	                // restore circlar links
	                this.last.next = this.first;
	                this.first.prev = this.last;
	            }
	        }
	
	        shapes2face(edges, shapes) {
	            for (let shape of shapes) {
	                let edge = new Edge(shape);
	                this.append(edge);
	                this.box = this.box.merge(shape.box);
	                edges.add(edge);
	            }
	            this.orientation = this.getOrientation();              // face direction cw or ccw
	        }
	
	        /**
	         * Return the area of the polygon
	         * @returns {number}
	         */
	        area() {
	            return Math.abs(this.signedArea());
	        }
	
	        signedArea() {
	            let sArea = 0;
	            for (let edge of this) {
	                sArea += edge.shape.definiteIntegral(this.box.ymin);
	            }
	            return sArea;
	        }
	
	        /* According to Green theorem the area of a closed curve may be calculated as double integral,
	        and the sign of the integral will be defined by the direction of the curve.
	        When the integral ("signed area") will be negative, direction is counter clockwise,
	        when positive - clockwise and when it is zero, polygon is not orientable.
	        See http://mathinsight.org/greens_theorem_find_area
	         */
	        getOrientation() {
	            let area = this.signedArea();
	            if (Flatten.Utils.EQ_0(area)) {
	                return Flatten.ORIENTATION.NOT_ORIENTABLE;
	            }
	            if (Flatten.Utils.LT(area, 0)) {
	                return Flatten.ORIENTATION.CCW;
	            }
	            else {
	                return Flatten.ORIENTATION.CW;
	            }
	        }
	
	        /**
	         * Return bounding box of the face
	         * @returns {Box}
	         */
	        getBox() {
	            let box = new Flatten.Box();
	            for (let edge of this) {
	                box = box.merge(edge.box);
	            }
	            return box;
	        }
	
	        svg() {
	            let svgStr = `\nM${this.first.start.x},${this.first.start.y}`;
	
	            for (let edge of this) {
	                svgStr += edge.svg();
	            }
	
	            svgStr += ` z`;
	            return svgStr;
	        }
	    };
	};

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/20/2017.
	 */
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a line
	     * @type {Line}
	     */
	    Flatten.Line = class Line {
	        /**
	         * Line may be constructed by point and normal vector or by two points that a line passes through
	         * @param {Point} pt - point that a line passes through
	         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through
	         */
	        constructor(...args) {
	            /**
	             * Point a line passes through
	             * @type {Point}
	             */
	            this.pt = new Flatten.Point();
	            /**
	             * Normal unit vector to a line
	             * @type {Vector}
	             */
	            this.norm = new Flatten.Vector(0,1);
	
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 2) {
	                let a1 = args[0];
	                let a2 = args[1];
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
	                    this.pt = a1;
	                    this.norm = Line.points2norm(a1, a2);
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {
	                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {
	                        throw Flatten.Errors.ILLEGAL_PARAMETERS;
	                    }
	                    this.pt = a1.clone();
	                    this.norm = a2.clone();
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {
	                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {
	                        throw Flatten.Errors.ILLEGAL_PARAMETERS;
	                    }
	                    this.pt = a2.clone();
	                    this.norm = a1.clone();
	                    return;
	                }
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Method clone returns new instance of Line
	         * @returns {Line}
	         */
	        clone() {
	            return new Flatten.Line(this.pt, this.norm);
	        }
	
	        /**
	         * Slope of the line - angle in radians between line and axe x from 0 to 2PI
	         * @returns {number} - slope of the line
	         */
	        get slope() {
	            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);
	            return vec.slope;
	        }
	
	        /**
	         * Standard line equation in the form Ax + By = C, get coefficients using es6 destructuring assignment:
	         * @code [A, B, C] = line.standard
	         * @returns {number[]} - array of coefficients
	         */
	        get standard() {
	            let A = this.norm.x;
	            let B = this.norm.y;
	            let C = this.norm.dot(this.pt);
	
	            return [A,B,C];
	        }
	
	        /**
	         * Return true if parallel or incident to other line
	         * @param {Line} other_line - line to check
	         * @returns {boolean}
	         */
	        parallelTo(other_line) {
	            return this.norm.equalTo(other_line.norm);
	        }
	
	        /**
	         * Returns true if incident to other line
	         * @param {Line} other_line - line to check
	         * @returns {boolean}
	         */
	        incidentTo(other_line) {
	            return ( (this.norm.equalTo(other_line.norm) || this.norm.equalTo(other_line.norm.invert())) &&
	                this.pt.on(other_line));
	        }
	
	        /**
	         * Returns true if point belongs to line
	         * @param {Point} pt
	         * @returns {boolean}
	         */
	        contains(pt) {
	            if (this.pt.equalTo(pt)) {
	                return true;
	            }
	            /* Line contains point if vector to point is orthogonal to the line normal vector */
	            let vec = new Flatten.Vector(this.pt, pt);
	            return Flatten.Utils.EQ_0(this.norm.dot(vec));
	        }
	
	        /**
	         * Returns array of intersection points if intersection exists or zero-length array otherwise
	         * @param {Shape} shape - shape to intersect with
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return Line.intersectLine2Line(this, shape);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Line.intersectLine2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return Line.intersectLine2Arc(this, shape);
	            }
	        }
	
	        static points2norm(pt1, pt2) {
	            if (pt1.equalTo(pt2)) {
	                throw Flatten.Errors.ILLEGAL_PARAMETERS;
	            }
	            let vec = new Flatten.Vector(pt1, pt2);
	            let unit = vec.normalize();
	            return unit.rotate90CCW();
	        }
	
	        static intersectLine2Line(line1, line2) {
	            let ip = [];
	
	            let [A1, B1, C1] = line1.standard;
	            let [A2, B2, C2] = line2.standard;
	
	            /* Cramer's rule */
	            let det = A1*B2 - B1*A2;
	            let detX = C1*B2 - B1*C2;
	            let detY = A1*C2 - C1*A2;
	
	            if (!Flatten.Utils.EQ_0(det)) {
	                let new_ip = new Flatten.Point( detX/det, detY/det );
	                ip.push(new_ip);
	            }
	            return ip;
	        }
	
	        static intersectLine2Circle(line, circle) {
	            let ip = [];
	            let prj = circle.pc.projectionOn(line);            // projection of circle center on line
	            let dist = circle.pc.distanceTo(prj);              // distance from circle center to projection
	
	            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point
	                ip.push(prj);
	            }
	            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points
	                var delta = Math.sqrt(circle.r*circle.r - dist*dist);
	                var v_trans, pt;
	
	                v_trans = line.norm.rotate90CCW().multiply(delta);
	                pt = prj.translate(v_trans);
	                ip.push(pt);
	
	                v_trans = line.norm.rotate90CW().multiply(delta);
	                pt = prj.translate(v_trans);
	                ip.push(pt);
	            }
	            return ip;
	        }
	
	        static intersectLine2Box(line, box) {
	            let pts = [
	                new Flatten.Point(box.xmin, box.ymin),
	                new Flatten.Point(box.xmax, box.ymin),
	                new Flatten.Point(box.xmax, box.ymax),
	                new Flatten.Point(box.xmin, box.ymax)
	            ];
	            let segs = [
	                new Flatten.Segment(pts[0], pts[1]),
	                new Flatten.Segment(pts[1], pts[2]),
	                new Flatten.Segment(pts[2], pts[3]),
	                new Flatten.Segment(pts[3], pts[0])
	            ];
	
	            let ips =  [];
	
	            for(let seg of segs) {
	                let ips_tmp = seg.intersect(line);
	                for (let ip of ips_tmp) {
	                    ips.push(ip);
	                }
	            };
	            return ips;
	        }
	
	        static intersectLine2Arc(line, arc) {
	            let ip = [];
	
	            if (line.box.notIntersect(arc.box)) {
	                return ip;
	            }
	
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	            let ip_tmp = line.intersect(circle);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	
	            return ip;
	        }
	    };
	
	    /**
	     * Function to create line equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.line = (...args) => new Flatten.Line(...args);
	};


/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	
	/**
	 *
	 * @param Flatten
	 */
	module.exports = function(Flatten) {
	    /**
	     *
	     * Class representing a point
	     * @type {Point}
	     */
	    Flatten.Point = class Point {
	        /**
	         *
	         * @param {number} x - x-coordinate (float number)
	         * @param {number} y - y-coordinate (float number)
	         */
	        constructor(x = 0, y = 0) {
	            /**
	             * x-coordinate (float number)
	             * @type {number}
	             */
	            this.x = Number.isNaN(x) ? 0 : x;
	            /**
	             * y-coordinate (float number)
	             * @type {number}
	             */
	            this.y = Number.isNaN(y) ? 0: y;
	        }
	
	        /**
	         * Returns bounding box of a point
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(this.x, this.y, this.x, this.y);
	        }
	
	        /**
	         * Method clone returns new instance of Point
	         * @returns {Point}
	         */
	        clone() {
	            return new Flatten.Point(this.x, this.y);
	        }
	
	        /**
	         * Returns true if points are equal up to DP_TOL tolerance
	         * @param {Point} pt
	         * @returns {boolean}
	         */
	        equalTo(pt) {
	            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);
	        }
	
	        /**
	         * Defines predicate "less than" between points. Need for spatial index
	         * @param pt - other point
	         * @returns {boolean} - true if this point less than other points, false otherwise
	         */
	        lessThan(pt) {
	            if (Flatten.Utils.LT(this.y, pt.y))
	                return true;
	            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))
	                return true;
	            return false;
	        }
	
	        /**
	         * Returns new point rotated by given angle around given center point.
	         * If center point is omitted, rotates around zero point (0,0).
	         * @param {number} angle - angle in radians, positive value defines rotation
	         * in counter clockwise direction, negative - clockwise
	         * @param {Point} [center=(0,0)] center
	         * @returns {Point}
	         */
	        rotate(angle, center = {x:0, y:0}) {
	            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);
	            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);
	
	            return new Flatten.Point(x_rot, y_rot);
	        }
	
	        /**
	         * Returns new point translated by given vector.
	         * Translation vector may by also defined by a pair of numbers dx, dy
	         * @param {Vector} vector - translation vector
	         * @returns {Point}
	         */
	        translate(...args) {
	            if (args.length == 0) {
	                return this.clone();
	            }
	
	            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {
	                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);
	            }
	
	            if (args.length == 2 && typeof(args[0]) == "number" && typeof(args[1]) == "number") {
	                return new Flatten.Point(this.x + args[0], this.y + args[1]);
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Returns projection point on given line
	         * @param {Line} line - line this point be projected on
	         * @returns {Point}
	         */
	        projectionOn(line) {
	            if (this.equalTo(line.pt))                   // this point equal to line anchor point
	                return this.clone();
	
	            let vec = new Flatten.Vector(this, line.pt);
	            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector
	                return this.clone();
	
	            let dist = vec.dot(line.norm);             // signed distance
	            let proj_vec = line.norm.multiply(dist);
	            return this.translate(proj_vec);
	        }
	
	        /**
	         * Returns true if point is on "left" semi plane. Left semi plane is where line normal vector points to
	         * @param line
	         * @returns {boolean}
	         */
	        leftTo(line) {
	            let vec = new Flatten.Vector(line.pt, this);
	            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);
	            return onLeftSemiPlane;
	        }
	
	        /**
	         * Returns distance between point and other shape
	         * @param {Shape} shape
	         * @returns {number}
	         */
	        distanceTo(shape) {
	            if (shape instanceof Point) {
	                let vec = new Flatten.Vector(this, shape);
	                return vec.length;
	            }
	
	            if (shape instanceof Flatten.Line) {
	                let vec = new Flatten.Vector(this, this.projectionOn(shape));
	                return vec.length;
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                let dist2pc = this.distanceTo(shape.pc);
	                return Math.abs(dist2pc - shape.r);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return shape.distanceToPoint(this);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return shape.distanceToPoint(this);
	            }
	        }
	
	        /**
	         * Returns true if point is on shape
	         * @param {Shape} shape
	         * @returns {boolean}
	         */
	        on(shape) {
	            if (shape instanceof Flatten.Point) {
	                return this.equalTo(shape);
	            }
	
	            if (shape instanceof Flatten.Line) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof  Flatten.Segment) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return shape.contains(this);
	            }
	        }
	
	        /**
	         * Return string to draw point in svg as circle with radius "r", default is r:"5"
	         * @param attrs - json structure with any attributes allowed to svg circle element,
	         * like "r", "stroke", "strokeWidth", "fill"
	         * Defaults are r:"5", stroke:"black", strokeWidth:"1", fill:"red"
	         * @returns {string}
	         */
	        svg(attrs = {r:"5",stroke:"black",strokeWidth:"1",fill:"red"}) {
	            let {r, stroke, strokeWidth, fill} = attrs;
	            return `\n<circle cx="${this.x}" cy="${this.y}" r="${r}" stroke="${stroke}" stroke-width="${strokeWidth}" fill="${fill}" />`;
	        }
	
	    };
	
	    /**
	     * Function to create point equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.point = (...args) => new Flatten.Point(...args);
	};


/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/15/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Edge, Face, PlanarSet, Box} = Flatten;
	    /**
	     * Class representing a polygon.<br/>
	     * Polygon in FlattenJS is a multipolygon comprised from a set of faces<br/>
	     * Face, in turn, is a closed loop of edges, which can be a segment or a circular arc<br/>
	     * @type {Polygon}
	     */
	    Flatten.Polygon = class Polygon {
	        /**
	         * Constructor creates new instance of polygon.<br/>
	         * New polygon is empty. Add new face to the polygon using method <br/>
	         * <code>
	         *     polygon.addFace(Points|Segments|Arcs[])
	         * </code>
	         */
	        constructor() {
	            /**
	             * Set of faces (closed loops), may be empty
	             * @type {PlanarSet}
	             */
	            this.faces = new PlanarSet();
	            /**
	             * Set of edges. Usually is not used directly. Better access edges via faces
	             * @type {PlanarSet}
	             */
	            this.edges = new PlanarSet();
	        }
	
	        /**
	         * Get bounding box of the polygon
	         * @returns {Box}
	         */
	        get box() {
	            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );
	        }
	
	        /**
	         * Return array of vertices
	         * @returns {Array}
	         */
	        get vertices() {
	            return [...this.edges].map( edge => edge.start);
	        }
	
	        /**
	         * Add new face to polygon
	         * @param {Points[]|Segments|Arcs[]} args - list of points or list of shapes (segments and arcs)
	         * which comprise a closed loop
	         * @returns {Face}
	         */
	        addFace(...args) {
	            let face = new Face(this, args);
	            this.faces.add(face);
	            return face;
	        }
	
	        /**
	         * Delete existing face from polygon
	         * @param {Face}
	         * @returns {boolean|*}
	         */
	        deleteFace(face) {
	            for (let edge of face) {
	                let deleted = this.edges.delete(edge);
	            }
	            let deleted = this.faces.delete(face);
	            return deleted;
	        }
	
	        /**
	         * Create new copied instance of the polygon
	         * @returns {Polygon}
	         */
	        clone() {
	            let polygon = new Polygon();
	            for (let face of this.faces) {
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape.clone());
	                }
	                polygon.addFace(shapes);
	            }
	            return polygon;
	        }
	
	        /**
	         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted
	         * @returns {number}
	         */
	        area() {
	            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);
	            return Math.abs(signedArea);
	        }
	
	        /**
	         * Return string to draw polygon in svg
	         * @param attrs  - json structure with any attributes allowed to svg path element,
	         * like "stroke", "strokeWidth", "fill", "fillRule"
	         * Defaults are stroke:"black", strokeWidth:"3", fill:"lightcyan", fillRule:"evenodd"
	         * @returns {string}
	         */
	        svg(attrs = {stroke:"black", strokeWidth:"3", fill:"lightcyan", fillRule:"evenodd"}) {
	            let {stroke, strokeWidth, fill, fillRule} = attrs;
	            let svgStr = `\n<path stroke="${stroke}" stroke-width="${strokeWidth}" fill="${fill}" fill-rule="${fillRule}" d="`;
	            for (let face of this.faces) {
	                svgStr += face.svg();
	            }
	            svgStr += `">\n</path>`;
	
	            return svgStr;
	        }
	    }
	};

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/10/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a segment
	     * @type {Segment}
	     */
	    Flatten.Segment = class Segment {
	        /**
	         *
	         * @param {Point} ps - start point
	         * @param {Point} pe - end point
	         */
	        constructor(...args) {
	            /**
	             * Start point
	             * @type {Point}
	             */
	            this.ps = new Flatten.Point();
	            /**
	             * End Point
	             * @type {Point}
	             */
	            this.pe = new Flatten.Point();
	
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {
	                let coords = args[0];
	                this.ps = new Flatten.Point(coords[0], coords[1]);
	                this.pe = new Flatten.Point(coords[2], coords[3]);
	                return;
	            }
	
	            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {
	                this.ps = args[0].clone();
	                this.pe = args[1].clone();
	                return;
	            }
	
	            if (args.length == 4) {
	                this.ps = new Flatten.Point(args[0], args[1]);
	                this.pe = new Flatten.Point(args[2], args[3]);
	                return;
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Method clone returns new instance of a Segment
	         * @returns {Segment}
	         */
	        clone() {
	            return new Flatten.Segment(this.start, this.end);
	        }
	
	        /**
	         * Start point
	         * @returns {Point}
	         */
	        get start() {
	            return this.ps;
	        }
	
	        /**
	         * Set start point
	         * @param {Point} pt
	         */
	        set start(pt) {
	            this.ps = pt;
	        }
	
	        /**
	         * End point
	         * @returns {Point}
	         */
	        get end() {
	            return this.pe;
	        }
	
	        /**
	         * Set end point
	         * @param {Point} pt
	         */
	        set end(pt) {
	            this.pe = pt;
	        }
	
	        /**
	         * Length of a segment
	         * @returns {number}
	         */
	        get length() {
	            return this.start.distanceTo(this.end);
	        }
	
	        /**
	         * Slope of the line - angle to axe x in radians from 0 to 2PI
	         * @returns {number}
	         */
	        get slope() {
	            let vec = new Flatten.Vector(this.start, this.end);
	            return vec.slope;
	        }
	
	        /**
	         * Bounding box
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(
	                Math.min(this.start.x, this.end.x),
	                Math.min(this.start.y, this.end.y),
	                Math.max(this.start.x, this.end.x),
	                Math.max(this.start.y, this.end.y)
	            )
	        }
	
	        /**
	         * Function contains returns true if point belongs to segment
	         * @param {Point} pt
	         * @returns {boolean}
	         */
	        contains(pt) {
	            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));
	        }
	
	        /**
	         * Returns array of intersection points between segment and other shape
	         * @param shape - shape to intersect with
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return Segment.intersectSegment2Line(this, shape);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return Segment.intersectSegment2Segment(this, shape);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Segment.intersectSegment2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return Segment.intersectSegment2Arc(this, shape);
	            }
	        }
	
	        distanceToPoint(pt) {
	            /* Degenerated case of zero-length segment */
	            if (this.start.equalTo(this.end)) {
	                return pt.distanceTo(this.start);
	            }
	
	            let v_seg = new Flatten.Vector(this.start, this.end);
	            let v_ps2pt = new Flatten.Vector(this.start, pt);
	            let v_pe2pt = new Flatten.Vector(this.end, pt);
	            let start_sp = v_seg.dot(v_ps2pt);    /* dot product v_seg * v_ps2pt */
	            let end_sp = -v_seg.dot(v_pe2pt);     /* minus dot product v_seg * v_pe2pt */
	
	            let dist;
	            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */
	                let v_unit = new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);
	                /* unit vector ||v_unit|| = 1 */
	                dist = Math.abs(v_unit.cross(v_ps2pt));
	                /* dist = abs(v_unit x v_ps2pt) */
	            }
	            else if (start_sp < 0) {                             /* point is out of scope closer to ps */
	                dist = pt.distanceTo(this.start);
	            }
	            else {                                               /* point is out of scope closer to pe */
	                dist = pt.distanceTo(this.end);
	            }
	            return dist;
	        };
	
	        definiteIntegral(ymin=0.0) {
	            let dx = this.end.x - this.start.x;
	            let dy1 = this.start.y - ymin;
	            let dy2 = this.end.y - ymin;
	            return ( dx*(dy1 + dy2)/2 );
	        }
	        
	        static intersectSegment2Line(seg, line) {
	            let ip = [];
	            let zero_segment = Flatten.Utils.EQ_0(seg.length);
	
	            // Boundary cases
	            if (seg.ps.on(line)) {
	                ip.push(seg.ps);
	            }
	            // If both ends lay on line, return two intersection points
	            if (seg.pe.on(line) && !zero_segment) {
	                ip.push(seg.pe);
	            }
	
	            if (ip.length > 0) {
	                return ip;          // done, intersection found
	            }
	
	            // Not a boundary case, check if both points are on the same side and
	            // hence there is no intersection
	            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||
	                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {
	                return ip;
	            }
	
	            // Calculate intersection between lines
	            let line1 = new Flatten.Line(seg.ps, seg.pe);
	            return line1.intersect(line);
	        }
	
	        static intersectSegment2Segment(seg1, seg2) {
	            let ip = [];
	
	            // quick reject
	            if (seg1.box.notIntersect(seg2.box)) {
	                return ip;
	            }
	
	            let line1 = new Flatten.Line(seg1.ps, seg1.pe);
	            let line2 = new Flatten.Line(seg2.ps, seg2.pe);
	
	            // Check overlapping between segments in case of incidence
	            // If segments touching, add one point. If overlapping, add two points
	            if (line1.incidentTo(line2)) {
	                if (seg1.ps.on(seg2)) {
	                    ip.push(seg1.ps);
	                }
	                if (seg1.pe.on(seg2)) {
	                    ip.push(seg1.pe);
	                }
	                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {
	                    ip.push(seg2.ps);
	                }
	                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {
	                    ip.push(seg2.pe);
	                }
	            }
	            else {                /* not incident - parallel or intersect */
	                // Calculate intersection between lines
	                let new_ip = line1.intersect(line2);
	                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {
	                    ip.push(new_ip[0]);
	                }
	            }
	
	            return ip;
	        }
	
	        static intersectSegment2Circle(segment, circle) {
	            let ips = [];
	
	            if (segment.box.notIntersect(circle.box)) {
	                return ips;
	            }
	
	            let line = new Flatten.Line(segment.ps, segment.pe);
	
	            let ips_tmp = line.intersect(circle);
	
	            for (let ip of ips_tmp) {
	                if (ip.on(segment)) {
	                    ips.push(ip);
	                }
	            }
	
	            return ips;
	        }
	
	        static intersectSegment2Arc(segment, arc) {
	            let ip = [];
	
	            if (segment.box.notIntersect(arc.box)) {
	                return ip;
	            }
	
	            let line = new Flatten.Line(segment.ps, segment.pe);
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	
	            let ip_tmp = line.intersect(circle);
	
	            for (let pt of ip_tmp) {
	                if (pt.on(segment) && pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	
	        }
	
	        /**
	         * Return string to draw segment in svg
	         * @param attrs - json structure with any attributes allowed to svg path element,
	         * like "stroke", "strokeWidth"
	         * Defaults are stroke:"black", strokeWidth:"3"
	         * @returns {string}
	         */
	        svg(attrs = {stroke:"black",strokeWidth:"3"}) {
	            let {stroke, strokeWidth} = attrs;
	            return `\n<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" stroke="${stroke}" stroke-width="${strokeWidth}" />`;
	        }
	    };
	
	    Flatten.segment = (...args) => new Flatten.Segment(...args);
	};

/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/19/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a vector
	     * @type {Vector}
	     */
	    Flatten.Vector = class Vector {
	        /**
	         * Vector may be constructed by two points, or by two float numbers
	         * @param {Point} ps - start point
	         * @param {Point} pe - end point
	         */
	        constructor(...args) {
	            /**
	             * x-coordinate of a vector (float number)
	             * @type {number}
	             */
	            this.x = 0;
	            /**
	             * y-coordinate of a vector (float number)
	             * @type {number}
	             */
	            this.y = 0;
	
	            /* return zero vector */
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 2) {
	                let a1 = args[0];
	                let a2 = args[1];
	
	                if (typeof(a1) == "number" && typeof(a2) == "number") {
	                    this.x = a1;
	                    this.y = a2;
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
	                    this.x = a2.x - a1.x;
	                    this.y = a2.y - a1.y;
	                    return;
	                }
	
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Method clone returns new instance of Vector
	         * @returns {Vector}
	         */
	        clone() {
	            return new Vector(this.x, this.y);
	        }
	
	        /**
	         * Slope of the vector in radians from 0 to 2PI
	         * @returns {number}
	         */
	        get slope() {
	            let angle = Math.atan2(this.y, this.x);
	            if (angle<0) angle = 2*Math.PI + angle;
	            return angle;
	        }
	
	        /**
	         * Length of vector
	         * @returns {number}
	         */
	        get length() {
	            return Math.sqrt(this.dot(this));
	        }
	
	        /**
	         * Returns true if vectors are equal up to DP_TOL tolerance
	         * @param {Vector} v
	         * @returns {boolean}
	         */
	        equalTo(v) {
	            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);
	        }
	
	        /**
	         * Returns new vector multiplied by scalar
	         * @param {number} scalar
	         * @returns {Vector}
	         */
	        multiply(scalar) {
	            return ( new Vector(scalar * this.x, scalar * this.y) );
	        }
	
	        /**
	         * Returns scalar product between two vectors
	         * @param {Vector} v
	         * @returns {number}
	         */
	        dot(v) {
	            return ( this.x * v.x + this.y * v.y );
	        }
	
	        /**
	         * Returns vector product (magnitude) between two vectors
	         * @param {Vector} v
	         * @returns {number}
	         */
	        cross(v) {
	            return ( this.x * v.y - this.y * v.x );
	        }
	
	        /**
	         * Returns unit vector.<br/>
	         * Throw error if given vector has zero length
	         * @returns {Vector}
	         */
	        normalize() {
	            if (!Flatten.Utils.EQ_0(this.length)) {
	                return ( new Vector(this.x / this.length, this.y / this.length) );
	            }
	            throw Flatten.Errors.ZERO_DIVISION;
	        }
	
	        /**
	         * Returns new vector rotated by given angle, positive angle defines rotation in counter clockwise direction
	         * @param {number} angle - angle in radians
	         * @returns {Vector}
	         */
	        rotate(angle) {
	            let point = new Flatten.Point(this.x, this.y);
	            let rpoint = point.rotate(angle);
	            return new Flatten.Vector(rpoint.x, rpoint.y);
	        }
	
	        /**
	         * Special fast version of rotate. Returns vector rotated 90 degrees counter clockwise
	         * @returns {Vector}
	         */
	        rotate90CCW() {
	            return new Flatten.Vector(-this.y, this.x);
	        };
	
	        /**
	         * Special fast version of rotate. Returns vector rotated 90 degrees clockwise
	         * @returns {Vector}
	         */
	        rotate90CW() {
	            return new Flatten.Vector(this.y, -this.x);
	        };
	
	        /**
	         * Return inverted vector
	         * @returns {Vector}
	         */
	        invert() {
	            return new Flatten.Vector(-this.x, -this.y);
	        }
	    };
	
	    /**
	     * Function to create vector equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.vector = (...args) => new Flatten.Vector(...args);
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 3/12/2017.
	 */
	
	"use strict";
	
	// require("babel-polyfill");
	
	let IntervalTree = __webpack_require__(129);
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and
	     * perform spatial queries. Planar set is an extension of Set container, so it is possible to call directly
	     * Set properties and methods
	     */
	     Flatten.PlanarSet = class PlanarSet extends Set {
	        /**
	         * Create new empty instance of PlanarSet
	         */
	        constructor() {
	            super();
	            this.index = new IntervalTree();
	        }
	
	        /**
	         * Add new shape to planar set and to its spatial index.<br/>
	         * If shape already exist, it will not be added again.
	         * This happens with no error, it is possible to use <i>size</i> property to check if
	         * a shape was actually added.<br/>
	         * @param shape - shape to be added, should have valid <i>box</i> property
	         * @returns {PlanarSet} - planar set update, so may be chained
	         */
	        add(shape) {
	            let size = this.size;
	            super.add(shape);
	            // size not changed - item not added, probably trying to add same item twice
	            if (this.size > size) {
	                let node = this.index.insert(shape.box, shape);
	            }
	            return this;         // in accordance to Set.add interface
	        }
	
	        /**
	         * Delete shape from planar set.
	         * @param shape - shape to be deleted
	         * @returns {boolean} - returns true if shape was actually deleted, false otherwise
	         */
	        delete(shape) {
	            let deleted = super.delete(shape);
	            if (deleted) {
	                this.index.remove(shape.box, shape);
	            }
	            return deleted;
	        }
	
	        clear() {
	
	        }
	
	        /**
	         * 2d range search in planar set.<br/>
	         * Returns array of all shapes in planar set which bounding box is intersected with query box
	         * @param box - query box
	         * @returns {Array} - array of shapes
	         */
	        search(box) {
	            let resp = this.index.search(box);
	            return resp;
	        }
	
	        /**
	         * Point location test. Returns array of shapes which contains given point
	         * @param point - query point
	         * @returns {Array} - array of shapes which contains given point
	         */
	        hit(point) {
	            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);
	            let resp = this.index.search(box);
	            return resp.filter((shape) => point.on(shape));
	        }
	
	        /**
	         * Returns svg string to draw all shapes in planar set
	         * @returns {String}
	         */
	        svg() {
	            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), "");
	            return svgcontent;
	        }
	    }
	};
	


/***/ },
/* 141 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/19/2017.
	 */
	module.exports = {
	    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),
	    ZERO_DIVISION: new Error('Zero division')
	};
	


/***/ },
/* 142 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	
	const DP_TOL = 0.000001;
	const DECIMALS = 3;
	
	module.exports = {
	    DP_TOL: DP_TOL,
	    /**
	     * @return {boolean}
	     */
	    EQ_0: function(x) {
	        return ( (x) < DP_TOL && (x) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    EQ: function(x,y) {
	        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    GT: (x,y) => {
	        return ( (x)-(y) >  DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    GE: (x,y) => {
	        return ( (x)-(y) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    LT: (x,y) => {
	        return ( (x)-(y) < -DP_TOL )
	    },
	    /**
	     * @return {boolean}
	     */
	    LE: (x,y) => {
	        return ( (x)-(y) <  DP_TOL );
	    }
	};


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(56),
	    getRawTag = __webpack_require__(146),
	    objectToString = __webpack_require__(147);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 144 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(148);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(56);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 147 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 148 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(144);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//This file contains the ES6 extensions to the core Promises/A+ API
	
	var Promise = __webpack_require__(59);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');
	
	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;
	
	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;
	
	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};
	
	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);
	
	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};
	
	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};
	
	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};
	
	/* Prototype Methods */
	
	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(59);
	
	var DEFAULT_WHITELIST = [
	  ReferenceError,
	  TypeError,
	  RangeError
	];
	
	var enabled = false;
	exports.disable = disable;
	function disable() {
	  enabled = false;
	  Promise._10 = null;
	  Promise._97 = null;
	}
	
	exports.enable = enable;
	function enable(options) {
	  options = options || {};
	  if (enabled) disable();
	  enabled = true;
	  var id = 0;
	  var displayId = 0;
	  var rejections = {};
	  Promise._10 = function (promise) {
	    if (
	      promise._81 === 2 && // IS REJECTED
	      rejections[promise._72]
	    ) {
	      if (rejections[promise._72].logged) {
	        onHandled(promise._72);
	      } else {
	        clearTimeout(rejections[promise._72].timeout);
	      }
	      delete rejections[promise._72];
	    }
	  };
	  Promise._97 = function (promise, err) {
	    if (promise._45 === 0) { // not yet handled
	      promise._72 = id++;
	      rejections[promise._72] = {
	        displayId: null,
	        error: err,
	        timeout: setTimeout(
	          onUnhandled.bind(null, promise._72),
	          // For reference errors and type errors, this almost always
	          // means the programmer made a mistake, so log them after just
	          // 100ms
	          // otherwise, wait 2 seconds to see if they get handled
	          matchWhitelist(err, DEFAULT_WHITELIST)
	            ? 100
	            : 2000
	        ),
	        logged: false
	      };
	    }
	  };
	  function onUnhandled(id) {
	    if (
	      options.allRejections ||
	      matchWhitelist(
	        rejections[id].error,
	        options.whitelist || DEFAULT_WHITELIST
	      )
	    ) {
	      rejections[id].displayId = displayId++;
	      if (options.onUnhandled) {
	        rejections[id].logged = true;
	        options.onUnhandled(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      } else {
	        rejections[id].logged = true;
	        logError(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      }
	    }
	  }
	  function onHandled(id) {
	    if (rejections[id].logged) {
	      if (options.onHandled) {
	        options.onHandled(rejections[id].displayId, rejections[id].error);
	      } else if (!rejections[id].onUnhandled) {
	        console.warn(
	          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'
	        );
	        console.warn(
	          '  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' +
	          rejections[id].displayId + '.'
	        );
	      }
	    }
	  }
	}
	
	function logError(id, error) {
	  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
	  var errStr = (error && (error.stack || error)) + '';
	  errStr.split('\n').forEach(function (line) {
	    console.warn('  ' + line);
	  });
	}
	
	function matchWhitelist(error, list) {
	  return list.some(function (cls) {
	    return error instanceof cls;
	  });
	}

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	if (false) {
	  var invariant = require('fbjs/lib/invariant');
	  var warning = require('fbjs/lib/warning');
	  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
	  var loggedTypeFailures = {};
	}
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (false) {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var stack = getStack ? getStack() : '';
	
	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}
	
	module.exports = checkPropTypes;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(8);
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	var ReactPropTypesSecret = __webpack_require__(155);
	var checkPropTypes = __webpack_require__(153);
	
	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */
	
	  var ANONYMOUS = '<<anonymous>>';
	
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker
	  };
	
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/
	
	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	
	  function createChainableTypeChecker(validate) {
	    if (false) {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (false) {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	
	    return chainedCheckType;
	  }
	
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }
	
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	       false ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	
	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	       false ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }
	
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	
	        return true;
	      default:
	        return false;
	    }
	  }
	
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }
	
	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }
	
	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	
	    return false;
	  }
	
	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }
	
	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }
	
	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }
	
	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(170);


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var focusNode = __webpack_require__(53);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(6);
	var FallbackCompositionState = __webpack_require__(165);
	var SyntheticCompositionEvent = __webpack_require__(202);
	var SyntheticInputEvent = __webpack_require__(205);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(61);
	var ExecutionEnvironment = __webpack_require__(6);
	var ReactInstrumentation = __webpack_require__(9);
	
	var camelizeStyleName = __webpack_require__(116);
	var dangerousStyleValue = __webpack_require__(211);
	var hyphenateStyleName = __webpack_require__(123);
	var memoizeStringOnly = __webpack_require__(126);
	var warning = __webpack_require__(2);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (false) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      var styleValue = styles[styleName];
	      if (false) {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styleValue, component);
	        }
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (false) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      if (false) {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styles[styleName], component);
	        }
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (isCustomProperty) {
	        style.setProperty(styleName, styleValue);
	      } else if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	};
	
	module.exports = CSSPropertyOperations;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(6);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(11);
	var SyntheticEvent = __webpack_require__(12);
	
	var inputValueTracking = __webpack_require__(77);
	var getEventTarget = __webpack_require__(48);
	var isEventSupported = __webpack_require__(49);
	var isTextInputElement = __webpack_require__(79);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
	  event.type = 'change';
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getInstIfValueChanged(targetInst, nativeEvent) {
	  var updated = inputValueTracking.updateValueIfChanged(targetInst);
	  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;
	
	  if (updated || simulated) {
	    return targetInst;
	  }
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For IE <=9) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For IE <=9) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementInst = null;
	}
	
	/**
	 * (For IE <=9) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
	    manualDispatchChangeEvent(nativeEvent);
	  }
	}
	
	function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    return getInstIfValueChanged(activeElementInst, nativeEvent);
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topClick') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}
	
	function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}
	
	function handleControlledInputBlur(inst, node) {
	  // TODO: In IE, inst is occasionally null. Why?
	  if (inst == null) {
	    return;
	  }
	
	  // Fiber and ReactDOM keep wrapper state in separate places
	  var state = inst._wrapperState || node._wrapperState;
	
	  if (!state || !state.controlled || node.type !== 'number') {
	    return;
	  }
	
	  // If controlled, assign the value attribute to the current value on blur
	  var value = '' + node.value;
	  if (node.getAttribute('value') !== value) {
	    node.setAttribute('value', value);
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	  eventTypes: eventTypes,
	
	  _allowSimulatedPassThrough: true,
	  _isInputEventSupported: isInputEventSupported,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventPolyfill;
	        handleEventFunc = handleEventsForInputEventPolyfill;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
	      if (inst) {
	        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	
	    // When blurring, set the value attribute for number inputs
	    if (topLevelType === 'topBlur') {
	      handleControlledInputBlur(targetInst, targetNode);
	    }
	  }
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMLazyTree = __webpack_require__(18);
	var ExecutionEnvironment = __webpack_require__(6);
	
	var createNodesFromMarkup = __webpack_require__(119);
	var emptyFunction = __webpack_require__(8);
	var invariant = __webpack_require__(1);
	
	var Danger = {
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	};
	
	module.exports = Danger;

/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(5);
	var SyntheticMouseEvent = __webpack_require__(31);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(14);
	
	var getTextContentAccessor = __webpack_require__(76);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(19);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {},
	  DOMMutationMethods: {
	    value: function (node, value) {
	      if (value == null) {
	        return node.removeAttribute('value');
	      }
	
	      // Number inputs get special treatment due to some edge cases in
	      // Chrome. Let everything else assign the value attribute as normal.
	      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
	      if (node.type !== 'number' || node.hasAttribute('value') === false) {
	        node.setAttribute('value', '' + value);
	      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
	        // Don't assign an attribute if validation reports bad
	        // input. Chrome will clear the value. Additionally, don't
	        // operate on inputs that have focus, otherwise Chrome might
	        // strip off trailing decimal places and cause the user's
	        // cursor position to jump to the beginning of the input.
	        //
	        // In ReactDOMInput, we have an onBlur event that will trigger
	        // this function again when focus is lost.
	        node.setAttribute('value', '' + value);
	      }
	    }
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(20);
	
	var instantiateReactComponent = __webpack_require__(78);
	var KeyEscapeUtils = __webpack_require__(40);
	var shouldUpdateReactComponent = __webpack_require__(50);
	var traverseAllChildren = __webpack_require__(81);
	var warning = __webpack_require__(2);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && ({"NODE_ENV":"production","PUBLIC_URL":"/debug-viewer"}) && ("production") === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(83);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (false) {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
	  {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (false) {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
	  {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(58)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(36);
	var ReactDOMIDOperations = __webpack_require__(175);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var React = __webpack_require__(21);
	var ReactComponentEnvironment = __webpack_require__(42);
	var ReactCurrentOwner = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(43);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactNodeTypes = __webpack_require__(71);
	var ReactReconciler = __webpack_require__(20);
	
	if (false) {
	  var checkReactTypeSpec = require('./checkReactTypeSpec');
	}
	
	var emptyObject = __webpack_require__(29);
	var invariant = __webpack_require__(1);
	var shallowEqual = __webpack_require__(35);
	var shouldUpdateReactComponent = __webpack_require__(50);
	var warning = __webpack_require__(2);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (false) {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ?  false ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (false) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (false) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (false) {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (false) {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (false) {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (false) {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (false) {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (false) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (false) {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (false) {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (false) {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ?  false ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (false) {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ?  false ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (false) {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ?  false ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (false) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (false) {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (false) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (false) {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (false) {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (false) {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (false) {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (false) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (("production") !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ?  false ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ?  false ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (false) {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	};
	
	module.exports = ReactCompositeComponent;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDefaultInjection = __webpack_require__(183);
	var ReactMount = __webpack_require__(70);
	var ReactReconciler = __webpack_require__(20);
	var ReactUpdates = __webpack_require__(11);
	var ReactVersion = __webpack_require__(196);
	
	var findDOMNode = __webpack_require__(212);
	var getHostComponentFromComposite = __webpack_require__(75);
	var renderSubtreeIntoContainer = __webpack_require__(219);
	var warning = __webpack_require__(2);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	  /* eslint-enable camelcase */
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (false) {
	  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (false) {
	  var ReactInstrumentation = require('./ReactInstrumentation');
	  var ReactDOMUnknownPropertyHook = require('./ReactDOMUnknownPropertyHook');
	  var ReactDOMNullInputValuePropHook = require('./ReactDOMNullInputValuePropHook');
	  var ReactDOMInvalidARIAHook = require('./ReactDOMInvalidARIAHook');
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var AutoFocusUtils = __webpack_require__(158);
	var CSSPropertyOperations = __webpack_require__(160);
	var DOMLazyTree = __webpack_require__(18);
	var DOMNamespaces = __webpack_require__(37);
	var DOMProperty = __webpack_require__(19);
	var DOMPropertyOperations = __webpack_require__(63);
	var EventPluginHub = __webpack_require__(24);
	var EventPluginRegistry = __webpack_require__(38);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactDOMComponentFlags = __webpack_require__(64);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMInput = __webpack_require__(176);
	var ReactDOMOption = __webpack_require__(177);
	var ReactDOMSelect = __webpack_require__(65);
	var ReactDOMTextarea = __webpack_require__(180);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactMultiChild = __webpack_require__(189);
	var ReactServerRenderingTransaction = __webpack_require__(194);
	
	var emptyFunction = __webpack_require__(8);
	var escapeTextContentForBrowser = __webpack_require__(33);
	var invariant = __webpack_require__(1);
	var isEventSupported = __webpack_require__(49);
	var shallowEqual = __webpack_require__(35);
	var inputValueTracking = __webpack_require__(77);
	var validateDOMNesting = __webpack_require__(51);
	var warning = __webpack_require__(2);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { string: true, number: true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	   false ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ?  false ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ?  false ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ?  false ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ?  false ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (false) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (false) {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trackInputValue() {
	  inputValueTracking.track(this);
	}
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ?  false ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ?  false ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  area: true,
	  base: true,
	  br: true,
	  col: true,
	  embed: true,
	  hr: true,
	  img: true,
	  input: true,
	  keygen: true,
	  link: true,
	  meta: true,
	  param: true,
	  source: true,
	  track: true,
	  wbr: true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};
	
	var newlineEatingTags = {
	  listing: true,
	  pre: true,
	  textarea: true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  menuitem: true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ?  false ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (false) {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (false) {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (false) {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (false) {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      // TODO: Validate that text is allowed as a child of this node
	      if (contentToUse != null) {
	        // Avoid setting textContent when the text is empty. In IE11 setting
	        // textContent on a text area will cause the placeholder to not
	        // show within the textarea until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        if (contentToUse !== '') {
	          if (false) {
	            setAndValidateContentChildDev.call(this, contentToUse);
	          }
	          DOMLazyTree.queueText(lazyTree, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (false) {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (false) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (false) {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (false) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (false) {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	      case 'textarea':
	        inputValueTracking.stopTracking(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ?  false ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (false) {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(51);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (false) {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 174 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(36);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var DOMPropertyOperations = __webpack_require__(63);
	var LinkedValueUtils = __webpack_require__(41);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(11);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      controlled: isControlled(props)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (false) {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      if (value === 0 && node.value === '') {
	        node.value = '0';
	        // Note: IE9 reports a number inputs as 'text', so check props instead.
	      } else if (props.type === 'number') {
	        // Simulate `input.valueAsNumber`. IE9 does not support it
	        var valueAsNumber = parseFloat(node.value, 10) || 0;
	
	        if (
	        // eslint-disable-next-line
	        value != valueAsNumber ||
	        // eslint-disable-next-line
	        value == valueAsNumber && node.value != value) {
	          // Cast `value` to a string to ensure the value is set correctly. While
	          // browsers typically do this as necessary, jsdom doesn't.
	          node.value = '' + value;
	        }
	      } else if (node.value !== '' + value) {
	        // Cast `value` to a string to ensure the value is set correctly. While
	        // browsers typically do this as necessary, jsdom doesn't.
	        node.value = '' + value;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        // In Chrome, assigning defaultValue to certain input types triggers input validation.
	        // For number inputs, the display value loses trailing decimal points. For email inputs,
	        // Chrome raises "The specified value <x> is not a valid email address".
	        //
	        // Here we check to see if the defaultValue has actually changed, avoiding these problems
	        // when the user is inputting text
	        //
	        // https://github.com/facebook/react/issues/7253
	        if (node.defaultValue !== '' + props.defaultValue) {
	          node.defaultValue = '' + props.defaultValue;
	        }
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ?  false ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var React = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMSelect = __webpack_require__(65);
	
	var warning = __webpack_require__(2);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	       false ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = ReactDOMOption;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	var getNodeForCharacterOffset = __webpack_require__(216);
	var getTextContentAccessor = __webpack_require__(76);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var DOMChildrenOperations = __webpack_require__(36);
	var DOMLazyTree = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var escapeTextContentForBrowser = __webpack_require__(33);
	var invariant = __webpack_require__(1);
	var validateDOMNesting = __webpack_require__(51);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (false) {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ?  false ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMTextComponent;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(4);
	
	var LinkedValueUtils = __webpack_require__(41);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(11);
	
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ?  false ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ?  false ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ?  false ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var textContent = node.textContent;
	
	    // Only set node.value if textContent is equal to the expected
	    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	    // will populate textContent as well.
	    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	    if (textContent === inst._wrapperState.initialValue) {
	      node.value = textContent;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ?  false ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ?  false ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ?  false ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ?  false ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ?  false ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactUpdates = __webpack_require__(11);
	var Transaction = __webpack_require__(32);
	
	var emptyFunction = __webpack_require__(8);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(157);
	var BeforeInputEventPlugin = __webpack_require__(159);
	var ChangeEventPlugin = __webpack_require__(161);
	var DefaultEventPluginOrder = __webpack_require__(163);
	var EnterLeaveEventPlugin = __webpack_require__(164);
	var HTMLDOMPropertyConfig = __webpack_require__(166);
	var ReactComponentBrowserEnvironment = __webpack_require__(168);
	var ReactDOMComponent = __webpack_require__(171);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMEmptyComponent = __webpack_require__(173);
	var ReactDOMTreeTraversal = __webpack_require__(181);
	var ReactDOMTextComponent = __webpack_require__(179);
	var ReactDefaultBatchingStrategy = __webpack_require__(182);
	var ReactEventListener = __webpack_require__(186);
	var ReactInjection = __webpack_require__(187);
	var ReactReconcileTransaction = __webpack_require__(192);
	var SVGDOMPropertyConfig = __webpack_require__(197);
	var SelectEventPlugin = __webpack_require__(198);
	var SimpleEventPlugin = __webpack_require__(199);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 184 */
84,
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventListener = __webpack_require__(52);
	var ExecutionEnvironment = __webpack_require__(6);
	var PooledClass = __webpack_require__(14);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(11);
	
	var getEventTarget = __webpack_require__(48);
	var getUnboundedScrollPosition = __webpack_require__(121);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(19);
	var EventPluginHub = __webpack_require__(24);
	var EventPluginUtils = __webpack_require__(39);
	var ReactComponentEnvironment = __webpack_require__(42);
	var ReactEmptyComponent = __webpack_require__(66);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactHostComponent = __webpack_require__(68);
	var ReactUpdates = __webpack_require__(11);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(210);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactComponentEnvironment = __webpack_require__(42);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	
	var ReactCurrentOwner = __webpack_require__(13);
	var ReactReconciler = __webpack_require__(20);
	var ReactChildReconciler = __webpack_require__(167);
	
	var emptyFunction = __webpack_require__(8);
	var flattenChildren = __webpack_require__(213);
	var invariant = __webpack_require__(1);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (false) {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (false) {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (false) {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (false) {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (false) {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ?  false ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ?  false ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (false) {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	  }
	};
	
	module.exports = ReactMultiChild;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ?  false ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ?  false ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	};
	
	module.exports = ReactOwner;

/***/ },
/* 191 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(14);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactInputSelection = __webpack_require__(69);
	var ReactInstrumentation = __webpack_require__(9);
	var Transaction = __webpack_require__(32);
	var ReactUpdateQueue = __webpack_require__(44);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (false) {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(190);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(14);
	var Transaction = __webpack_require__(32);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactServerUpdateQueue = __webpack_require__(195);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (false) {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(44);
	
	var warning = __webpack_require__(2);
	
	function warnNoop(publicInstance, callerName) {
	  if (false) {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;

/***/ },
/* 196 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.6.1';

/***/ },
/* 197 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(6);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInputSelection = __webpack_require__(69);
	var SyntheticEvent = __webpack_require__(12);
	
	var getActiveElement = __webpack_require__(54);
	var isTextInputElement = __webpack_require__(79);
	var shallowEqual = __webpack_require__(35);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var EventListener = __webpack_require__(52);
	var EventPropagators = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(5);
	var SyntheticAnimationEvent = __webpack_require__(200);
	var SyntheticClipboardEvent = __webpack_require__(201);
	var SyntheticEvent = __webpack_require__(12);
	var SyntheticFocusEvent = __webpack_require__(204);
	var SyntheticKeyboardEvent = __webpack_require__(206);
	var SyntheticMouseEvent = __webpack_require__(31);
	var SyntheticDragEvent = __webpack_require__(203);
	var SyntheticTouchEvent = __webpack_require__(207);
	var SyntheticTransitionEvent = __webpack_require__(208);
	var SyntheticUIEvent = __webpack_require__(27);
	var SyntheticWheelEvent = __webpack_require__(209);
	
	var emptyFunction = __webpack_require__(8);
	var getEventCharCode = __webpack_require__(46);
	var invariant = __webpack_require__(1);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	var SimpleEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ?  false ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	};
	
	module.exports = SimpleEventPlugin;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(31);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	var getEventCharCode = __webpack_require__(46);
	var getEventKey = __webpack_require__(214);
	var getEventModifierState = __webpack_require__(47);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	var getEventModifierState = __webpack_require__(47);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(12);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(31);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 210 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(61);
	var warning = __webpack_require__(2);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component, isCustomProperty) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (false) {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(13);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstanceMap = __webpack_require__(26);
	
	var getHostComponentFromComposite = __webpack_require__(75);
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(2);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (false) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ?  false ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ?  false ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(40);
	var traverseAllChildren = __webpack_require__(81);
	var warning = __webpack_require__(2);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && ({"NODE_ENV":"production","PUBLIC_URL":"/debug-viewer"}) && ("production") === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(83);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (false) {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (false) {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(58)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(46);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  Esc: 'Escape',
	  Spacebar: ' ',
	  Left: 'ArrowLeft',
	  Up: 'ArrowUp',
	  Right: 'ArrowRight',
	  Down: 'ArrowDown',
	  Del: 'Delete',
	  Win: 'OS',
	  Menu: 'ContextMenu',
	  Apps: 'ContextMenu',
	  Scroll: 'ScrollLock',
	  MozPrintableKey: 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1',
	  113: 'F2',
	  114: 'F3',
	  115: 'F4',
	  116: 'F5',
	  117: 'F6',
	  118: 'F7',
	  119: 'F8',
	  120: 'F9',
	  121: 'F10',
	  122: 'F11',
	  123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 215 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 216 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(6);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(33);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(70);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	// @remove-on-eject-begin
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	// @remove-on-eject-end
	'use strict';
	
	if (typeof Promise === 'undefined') {
	  // Rejection tracking prevents a common issue where React gets into an
	  // inconsistent state due to an error, but it gets swallowed by a Promise,
	  // and the user has no idea what causes React's erratic future behavior.
	  __webpack_require__(152).enable();
	  window.Promise = __webpack_require__(151);
	}
	
	// fetch() polyfill for making API calls.
	__webpack_require__(221);
	
	// Object.assign() is commonly used with React.
	// It will use the native implementation if it's present and isn't buggy.
	Object.assign = __webpack_require__(4);


/***/ },
/* 221 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 222 */
40,
/* 223 */
[249, 28],
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(223);
	var ReactElement = __webpack_require__(22);
	
	var emptyFunction = __webpack_require__(8);
	var traverseAllChildren = __webpack_require__(233);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(22);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (false) {
	  var ReactElementValidator = require('./ReactElementValidator');
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _require = __webpack_require__(22),
	    isValidElement = _require.isValidElement;
	
	var factory = __webpack_require__(60);
	
	module.exports = factory(isValidElement);

/***/ },
/* 227 */
196,
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _require = __webpack_require__(82),
	    Component = _require.Component;
	
	var _require2 = __webpack_require__(22),
	    isValidElement = _require2.isValidElement;
	
	var ReactNoopUpdateQueue = __webpack_require__(85);
	var factory = __webpack_require__(113);
	
	module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ },
/* 229 */
215,
/* 230 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var lowPriorityWarning = function () {};
	
	if (false) {
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	
	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }
	
	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}
	
	module.exports = lowPriorityWarning;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(28);
	
	var ReactElement = __webpack_require__(22);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ?  false ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(28);
	
	var ReactCurrentOwner = __webpack_require__(13);
	var REACT_ELEMENT_TYPE = __webpack_require__(84);
	
	var getIteratorFn = __webpack_require__(229);
	var invariant = __webpack_require__(1);
	var KeyEscapeUtils = __webpack_require__(222);
	var warning = __webpack_require__(2);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (false) {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (false) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  false ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = applyMiddleware;
	
	var _compose = __webpack_require__(87);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 235 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineReducers;
	
	var _createStore = __webpack_require__(88);
	
	var _isPlainObject = __webpack_require__(57);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(90);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	
	    if (false) {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }
	
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var unexpectedKeyCache = void 0;
	  if (false) {
	    unexpectedKeyCache = {};
	  }
	
	  var shapeAssertionError = void 0;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	
	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }
	
	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(238);


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ponyfill = __webpack_require__(239);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var root; /* global window */
	
	
	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (true) {
	  root = module;
	} else {
	  root = Function('return this')();
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(248)(module)))

/***/ },
/* 239 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 240 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAiVJREFUeNrUljFrU1EUxxNTO1lQHGrTgPDA0ZYQSqGkk6XtUDSxRL9Bi5MW0SxxKChNkEJph1K/QGkkaB0yGbuEQguhoKPQyVq7NEUEwYivvwNHeL7cd5MMGbzw4yTv5f3/955z37kJu64b6ua4EOry6LHdTGbmZQK3IAVxiMFF+Aq7sA0fqq83/gRphINShPgk4SWcwFs4gC/QgCiMwR24Ck8wqbRlgHCYsARP4a6K28YsFOGZPIeR26oGBeiDyybxzwd7WXAhL98RLBGuwyDkrEVm9jIbB7LwPWDGWY2JvxcwkdQ9h0U0ZowG3OglrMA6/LCk5L3GV96LmBwTRHwNrR7TLroPO1CxJfxGfPRe0D1Myojva+2K/hSlWhVU838KRcvP3kDatIIReBQkTMh7LtUtBrKCF6Yix3Sf+8WlmHVSI9v3UC8fWgykFgOmFYiAa8h5jVDD6IruMG+hg7rDb9MKjnQvB405jTU1DRpRbSVNBjXv3jaMRBuzlzEEH00G/1TfVwdJT8YzEdtIq1aTwRZMwbjhoQnvi4aho6b+PiadNwmlJgNekp+Ex/DAYOB4do98zlCHuk88os8uoPXL2Iu4sUk4k9cdLhn2veTfQbzgE5fVrMoW1eZnbdcRbdeO9qVKi5xPQ1mfyfnbte3Akc66DHvaQj7BNz1w+jXXt2EYHiL8rqMTzdNhU8pNuKZHppxyVRDRMuKNjo/M/+ZfxbkAAwATycED9MFlsAAAAABJRU5ErkJggg=="

/***/ },
/* 241 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3MEYwOEQ4MDMwMzJFNDExOUZGN0MyRjAwQkZFNDkwMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1ODBBQzAzRTM4MEUxMUU0OERBNjkxMTQ1MjEwNzNEQSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1ODBBQzAzRDM4MEUxMUU0OERBNjkxMTQ1MjEwNzNEQSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJCREE5NUFCNkMzN0U0MTFBNjMyRUJBMjBBMTYyMTlBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwRjA4RDgwMzAzMkU0MTE5RkY3QzJGMDBCRkU0OTAxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xPle8wAAAgZJREFUeNpi/P//PwMtAQshBclVXbikcoHYCIh1gfgSEJ8D4ikkW4ADTAdiKyS+MRRrAXEWpRbkgwwXFRJgSAr2ZFCSlWK4+/gZw7w12xjevP9oDZTLBuKpMMVMZFgAChaGlFBvBjVFWQYWFmYGdSCdCLQMWZ4SC/RAhJKsJIqggrQEjKlFqQUXQMSdh09RBO89fg5jXqbUAlBqYZgLDPOb9x8zgJI5yLKF63cwAoVFgfgKpZE8GYg1gBFq0zV7ObK4GBCLA7EfEM8B4m8gQUZYRgOmd3w5Lg6IF6OJ5UAjFIQvAvE1IA4CYjMg3gu16BuxPsjCYsEULOpmAPEuIHYG4rVA7EVsHFgA8X88GAY+ArEbEB+FBtN/FhoUPyBLbGEWM1HJUJBhj9H42FORkZYaQ1q4D2np9tothlkrt5yY21ZGuDSVkxJj+PHrF0kW3HrwBEQdxyaHkUwzIv0YPn/5xrB08x5yg2sN0CehOH3AwcbGsHjPLoa82CBwYUa0L4C5etLidW+gpSn2IJIUE2bYdvAEg7m+Fpj9+es3oi3Yd/I8iMoE4lfIlRSKBWysLAyMTEwMpnoaDJdv3Wc4cvYyw6NnL0kJntVQ+iAQNwDxARQLnr96y2Ciq8GweMMuhmev3pAT/nCDsfrg1+8/DMfOXSHH4FtAnI5sMEYqohVgYqAxAAgwAOHVpZUAeOcGAAAAAElFTkSuQmCC"

/***/ },
/* 242 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhQTFRF9PX1mqiyoq+47e/wZHqK7O3ua4CP19zfgZOgbIKR8/Pzj5+qlKSut8HIYnmJmKexg5Wh1drexMvRu8TKm6qziJmlvcXMnau10NbaZ32N8fLy2N3gZXyMkaGsx87TaX+OgJKfztTZipumpLG6n6y27/DxprK79vb2fJPf2AAAACh0Uk5T////////////////////////////////////////////////////AL6qLhgAAADTSURBVHjajFLZEoIwDGyhHBWRS0VEDrXt/v8fWorYzigOeegk2clujhKsGLGuOBzEF+ADlxNwuhjXAipUKPfAvjTuB1CJpCL3AC8XVCZqAQIugbSYwiIFJA8+FdTthyqrUVc2fz4uGqTt40gziGEQmjOK+3bKgrCx8wyDlIbT60am0/BDU7q77d6PttB3ADbVMwcgLK6fOsjU9aqyiaqODRVIVM3iTTOLVxFZ2j2ef7WrB8zcAbMtK1lZoka4XTtX7qF08f0xHyrYdtq/n2Ej8BJgAJLkSJodRgvoAAAAAElFTkSuQmCC"

/***/ },
/* 243 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3MEYwOEQ4MDMwMzJFNDExOUZGN0MyRjAwQkZFNDkwMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NkNFODE2MzMyM0QxMUU0OTc2NkEyNzVGRDRDQUREMiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NkNFODE2MjMyM0QxMUU0OTc2NkEyNzVGRDRDQUREMiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM3Q0UwRDg3MzgzMkU0MTE5RkY3QzJGMDBCRkU0OTAxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwRjA4RDgwMzAzMkU0MTE5RkY3QzJGMDBCRkU0OTAxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+nXk3UAAAAjtJREFUeNrU1ktIVFEcx/FRhExEei0kULQkiijMKduo0RNCEHuQRohgggsVJbRSNy2qRSK4qIjohRARk5YgGvmoVSEWRe9EzHJVkFZEoInT9w+/gXGasjngwgMf7uDcOeee/+Nco/x+v2cuR7RnjkdM4MPh+jOBj+moxVYsxnvcQhO+Bf/48umjEe+gAHcxgM1YgkNIxGOsjHQHUYEcsIP1XHqQg7dIk36Mo8JugxfTf5swdFfBO6jDSU1+CvdRrRDdwFn8wB7XJG9XrFejCOvQhgnkoxE+3ee0gMX7E1bgmfLRgG0qBrvuwiKnKmJ8xCol0ybLxBaUoBcH8QqjrjvwKZGf8QAJeI0NWsRC9Ut/b3SpIgvRUyX6Es4rD7sxhevqgyOqtj71yz+rKThEY9iJOziAVtX9S31vE5ZhEjvwSCU9gi8K4+3QEg5ttEFYP1zBRnzVwtYHVZp8IZoRiyTE4Y2+f4KU2c6iKdV9qXaSgYfoVPwvahEr57VYjmTtxh6sW/fNzEGYM2lGrnAOWYjHGizFBZWuR6EtxFV8IAcnIjlN7SnKdbXfLECL+sXK+Ttytah1/D6X49omH1a8LVzZCmUHjqt/NuEdUl3fB2MKxXMtaP1ioWhXTuwBlqk4nBawA3CvwnVPlWRHygtcUxXuV8n+0Qf/M27qfCpGnp7WynlIrMRr9LIKX0XhRkhlpakUu1RZg3oh2ZMfQ6UdO4FOdnknDwU1ocX+p15KXh2SvrBn0bz9r+K3AAMAvVSdlmlN6ucAAAAASUVORK5CYII="

/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC42/Ixj3wAAAtxJREFUOE+tlPtOGlEQxn22Nn2Bpn0MY6LRxKa1IEItikJFihgvCCihhUYBtWIil8ol1UhiTb1RIXhFoyZqTLx9nRkLsqj9pz3JxzJnZ35nZnZ2qwD8Vz24Wam+vj7odDoEg0EyH/Yp6sHNcvn9fkxMTGBmZgYDAwOwWCwwGAwYGhqi2/f9721Eo1EJMpu7yUSV1+tDIpFAPp9Hb28vrNYexONxeDweBAIB8SmXwmA5nU5MT09TVpOYmgqhq8sswJ2dHZhMHwhoxcbGBkZHRwVaGa8wWOyUTKawvp6B3W5HfX09ZmdnBcilms1mZLM5+Hxf0NHRSVef7BXj7wFZoVAI29vb+PzZi9q6OoQjERwdHaHHZoONlN/chGt4GA0NDejv75f/7/V6Cn0E6HA4kMn8QjqdRqfRKCWfnp7CQe3gluzu7oKffHV1tfQxkUyisfEVhf4BhsNhjIy4S022Wm1YWEjj8PAQKysr2N/fx+XlJdbW1qgV6yiQ7XS6oNXqMD8/j2gsBpVKfQdsa2uX8szd3XC73dDr26RvnFXlurm5oQMO5IGNjY3h5/KyJOPxfOLbt0C1WkOAuJTGJTU1vaVsgzg4OGCn0mIYZ8r95MwXFxcRi31Da+tt/1jy4/cH0E5P8PvcnJQ1OflVHMuBDLu4uJCsGVgoFATqcg2DE6J1B2RxuVrtOzr1B87Pz6V/fOVVzOzs7Exge3t7MuipVEpeAB52ZrBKQJZK1SzDu7q6KoDiur6+Fvjx8XEJlslkMD4+Tu1RsUuJoQCyDIYOOTGXy+Hq6qpU6snJibRgk2aQYUtLSxgctKOmppbC/gJk8Qjw6ZxReXY8f9lsVnrH77PJZIJG00Ihd7EKULmMRhPN4kKpd9zTra2tUnY8Zi00h5VxCqNcr9804SN9CJLU+DiNUyQSldnj4ffS+6tSN4N9KuMURrksBHv+4iWePH32qDQtWnJVximMfxeqfgOaT96ucQ2K1AAAAABJRU5ErkJggg=="

/***/ },
/* 245 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAFXRFWHRDcmVhdGlvbiBUaW1lAAfRCxQOGStVPgrRAAAAB3RJTUUH0gIRCCggaWerxAAAAAlwSFlzAAAK8AAACvABQqw0mAAAAwBQTFRFAAAAAAEAZ43Nn8P/8fK61NDIz+H/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvjdahwAAAAZ0Uk5T//////8As7+kvwAAAFxJREFUeNqd0FsKwCAMRNHbidX977hqsD5qKTTkIxwSGMK5KT4wj8CMiBObkWRiQVKKpmPCYjHriG5FOzZriltDVw/XUSXqch7v84p5gyeG8B9tgyZRWwOO9fb5C5cVBoCDYMdpAAAAAElFTkSuQmCC"

/***/ },
/* 246 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAACWUExURezp2L3CsAAAAH91jbamy9Sx1NXVxL2u0MvA2yEeEZy460hBJUU/JAC+ACQhE4qi2Zaw5JCp3se72Ap3Hsi82cq+2qK/8XeKtWNfTb+x0nSEsG19pH6QtWFfU8S31nt1Wpax5Xp0WoeeynBrVMm92WhkVsGz02JfU21oU5m06Mq/2se62MS21bmqzsW517ipzbyu0P///wUDcXkAAAAydFJOU/////////////////////////////////////////////////////////////////8ADVCY7wAAAO1JREFUeNpiMMQCAAKIAZsgQABhFQQIIAZDeW5uZTgXwgEIIAZFKX5+aQk2iBiUAxBADDwCClyCfIwQQSgHIICAglxigny8wmAI4TACBBCDhoymkrg6KwMIsEI4jAABxGCoyskpy8gEFmSCcNgAAojBkI2RkZENqhLIMWRkMwQIIKg7YSohACCAoIIwlRAAEEBYVQIEEFaVAAHEwIwJDAECiIGZg4NJSAiE5OSYJCWZWFiYGAECCCgowi6qwi6iza6jxs6uywISBAggoKCoFoeoioiemoE+CxgwMQIEEAMzEwZgBAggBkNGTAAQYABIRSX4H75PxQAAAABJRU5ErkJggg=="

/***/ },
/* 247 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAABOUExURezp2AAAAH91jb3CsE9PT83C3CQhE7amy9Sx1ImFdL2u0AC+AMq+2si82Qp3Hsm92cvA28Gz07ipzcq/2se62LmqzsS21cW517yu0P///44+OfEAAAAadFJOU/////////////////////////////////8AFCIA2gAAAMxJREFUeNpikMQCAAKIAZsgQABhFQQIIAYWFklJTjYoD8oBCCAGIAMuJgnlAAQQUDsLG5JOMAcggBiAykGaoADCAQggBqByDhYWbj4w5GTjAJkLEEAg2xkZEIARpB4ggECCHEiCHCBBgADCqhIggLCqBAggrCoBAgirSoAAYmDCBJIAAcTAxMrKiIy4uBiZAQIIKMjLxcPPxSvCJSbIxSXKzs7OyAwQQAxMAjzCAjz8vOKCEkLsYMDIDBBADEyMGIAZIIAYJJkxAUCAAQCiZRN3sUCgAwAAAABJRU5ErkJggg=="

/***/ },
/* 248 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(__webpack_module_template_argument_0__);
	
	var invariant = __webpack_require__(1);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ?  false ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};
	
	module.exports = PooledClass;

/***/ }
/******/ ])));
//# sourceMappingURL=main.04b8bf74.js.map