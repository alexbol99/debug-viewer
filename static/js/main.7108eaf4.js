/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/debug-viewer/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(113);
	module.exports = __webpack_require__(47);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(115);
	} else {
	  module.exports = require('./cjs/react.development.js');
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	'use strict';
	
	let Utils = __webpack_require__(97);
	let Errors = __webpack_require__(96);
	
	/**
	 * FlattenJS - library for 2d geometry
	 * @type {Flatten}
	 */
	let Flatten = class Flatten {
	    constructor() {
	        this.DP_TOL = Utils.DP_TOL;
	        this.CCW = true;
	        this.CW = false;
	        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};
	        this.PIx2 = 2 * Math.PI;
	        this.PI_2 = 0.5 * Math.PI;
	        this.INSIDE = 1;
	        this.OUTSIDE = 0;
	        this.BOUNDARY = 2;
	        this.CONTAINS = 3;
	        this.INTERLACE = 4;
	        this.CLIP_INSIDE = 1;
	        this.CLIP_OUTSIDE = 0;
	        this.BOOLEAN_UNION = 1;
	        this.BOOLEAN_INTERSECT = 2;
	        this.BOOLEAN_SUBTRACT = 3;
	        this.OVERLAP_SAME = 1;
	        this.OVERLAP_OPPOSITE = 2;
	        this.Utils = Utils;
	        this.Errors = Errors;
	    }
	};
	
	let f = new Flatten();
	
	__webpack_require__(89)(f);
	__webpack_require__(95)(f);
	__webpack_require__(90)(f);
	__webpack_require__(94)(f);
	__webpack_require__(88)(f);
	__webpack_require__(85)(f);
	__webpack_require__(93)(f);
	__webpack_require__(83)(f);
	__webpack_require__(84)(f);
	__webpack_require__(86)(f);
	__webpack_require__(87)(f);
	__webpack_require__(92)(f);
	__webpack_require__(82)(f);
	__webpack_require__(91)(f);
	__webpack_require__(81)(f);
	
	module.exports = f;


/***/ },
/* 3 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	// export const MAIN_CANVAS_MOUNTED = "MAIN_CANVAS_MOUNTED";
	var NEW_STAGE_CREATED = exports.NEW_STAGE_CREATED = "NEW_STAGE_CREATED";
	var STAGE_RESIZED = exports.STAGE_RESIZED = "STAGE_RESIZED";
	var WINDOW_HASH_CHANGED = exports.WINDOW_HASH_CHANGED = "WINDOW_HASH_CHANGED";
	
	var NEW_SHAPE_PASTED = exports.NEW_SHAPE_PASTED = "NEW_SHAPE_PASTED";
	
	var TOGGLE_UNITS_CLICKED = exports.TOGGLE_UNITS_CLICKED = "TOGGLE_UNITS_CLICKED";
	var TOGGLE_WIDTH_MODE_CLICKED = exports.TOGGLE_WIDTH_MODE_CLICKED = "TOGGLE_WIDTH_MODE_CLICKED";
	var TOGGLE_DISPLAY_VERTICES_CLICKED = exports.TOGGLE_DISPLAY_VERTICES_CLICKED = "TOGGLE_DISPLAY_VERTICES_CLICKED";
	var TOGGLE_DISPLAY_LABELS_CLICKED = exports.TOGGLE_DISPLAY_LABELS_CLICKED = "TOGGLE_DISPLAY_LABELS_CLICKED";
	
	var MOUSE_MOVED_ON_STAGE = exports.MOUSE_MOVED_ON_STAGE = "MOUSE_MOVED_ON_STAGE";
	var MOUSE_DOWN_ON_STAGE = exports.MOUSE_DOWN_ON_STAGE = "MOUSE_DOWN_ON_STAGE";
	var MOUSE_UP_ON_STAGE = exports.MOUSE_UP_ON_STAGE = "MOUSE_UP_ON_STAGE";
	var MOUSE_WHEEL_MOVE_ON_STAGE = exports.MOUSE_WHEEL_MOVE_ON_STAGE = "MOUSE_WHEEL_MOVE_ON_STAGE";
	
	var MOUSE_ROLL_OVER_SHAPE = exports.MOUSE_ROLL_OVER_SHAPE = "MOUSE_ROLL_OVER_SHAPE";
	var MOUSE_ROLL_OUT_SHAPE = exports.MOUSE_ROLL_OUT_SHAPE = "MOUSE_ROLL_OUT_SHAPE";
	var MOUSE_CLICKED_ON_SHAPE = exports.MOUSE_CLICKED_ON_SHAPE = "MOUSE_CLICKED_ON_SHAPE";
	
	// export const HOME_BUTTON_CLICKED = "HOME_BUTTON_CLICKED";
	var PAN_TO_COORDINATE = exports.PAN_TO_COORDINATE = "PAN_TO_COORDINATE";
	var PAN_AND_ZOOM_TO_SHAPE = exports.PAN_AND_ZOOM_TO_SHAPE = "PAN_AND_ZOOM_TO_SHAPE";
	
	var LAYER_LIST_PANEL_PRESSED = exports.LAYER_LIST_PANEL_PRESSED = "LAYER_LIST_PANEL_PRESSED";
	var ADD_LAYER_PRESSED = exports.ADD_LAYER_PRESSED = "ADD_LAYER_PRESSED";
	var DELETE_LAYER_BUTTON_PRESSED = exports.DELETE_LAYER_BUTTON_PRESSED = "DELETE_LAYER_BUTTON_PRESSED";
	var SORT_LAYERS_BUTTON_PRESSED = exports.SORT_LAYERS_BUTTON_PRESSED = "SORT_LAYERS_BUTTON_PRESSED";
	
	var TOGGLE_DISPLAY_LAYER_PRESSED = exports.TOGGLE_DISPLAY_LAYER_PRESSED = "TOGGLE_DISPLAY_LAYER_PRESSED";
	var TOGGLE_AFFECTED_LAYER_PRESSED = exports.TOGGLE_AFFECTED_LAYER_PRESSED = "TOGGLE_AFFECTED_LAYER_PRESSED";
	var OPEN_LAYER_EDIT_FORM_PRESSED = exports.OPEN_LAYER_EDIT_FORM_PRESSED = "OPEN_LAYER_EDIT_FORM_PRESSED";
	var SUBMIT_LAYER_EDIT_FORM_PRESSED = exports.SUBMIT_LAYER_EDIT_FORM_PRESSED = "SUBMIT_LAYER_EDIT_FORM_PRESSED";
	var ESCAPE_LAYER_EDIT_FORM_PRESSED = exports.ESCAPE_LAYER_EDIT_FORM_PRESSED = "ESCAPE_LAYER_EDIT_FORM_PRESSED";
	
	var LAYERS_LIST_ARROW_DOWN_PRESSED = exports.LAYERS_LIST_ARROW_DOWN_PRESSED = "LAYERS_LIST_ARROW_DOWN_PRESSED";
	var LAYERS_LIST_ARROW_UP_PRESSED = exports.LAYERS_LIST_ARROW_UP_PRESSED = "LAYERS_LIST_ARROW_UP_PRESSED";
	
	var TOGGLE_WATCH_EXPAND_CLICKED = exports.TOGGLE_WATCH_EXPAND_CLICKED = "TOGGLE_WATCH_EXPAND_CLICKED";
	
	var FILENAME_LIST_SELECTED = exports.FILENAME_LIST_SELECTED = "FILENAME_LIST_SELECTED";
	var INPUT_FILE_LOADED = exports.INPUT_FILE_LOADED = "INPUT_FILE_LOADED";
	var DATA_FROM_BUFFER_PASTED = exports.DATA_FROM_BUFFER_PASTED = "DATA_FROM_BUFFER_PASTED";
	
	/** Toolbar buttons **/
	var PAN_BY_DRAG_BUTTON_CLICKED = exports.PAN_BY_DRAG_BUTTON_CLICKED = "PAN_BY_DRAG_BUTTON_CLICKED";
	var MEASURE_POINTS_BUTTON_PRESSED = exports.MEASURE_POINTS_BUTTON_PRESSED = "MEASURE_POINTS_BUTTON_PRESSED";
	var MEASURE_SHAPES_BUTTON_PRESSED = exports.MEASURE_SHAPES_BUTTON_PRESSED = "MEASURE_SHAPES_BUTTON_PRESSED";
	var SHOW_ABOUT_POPUP_BUTTON_PRESSED = exports.SHOW_ABOUT_POPUP_BUTTON_PRESSED = "SHOW_ABOUT_POPUP_BUTTON_PRESSED";
	
	var CLOSE_ABOUT_POPUP_BUTTON_PRESSED = exports.CLOSE_ABOUT_POPUP_BUTTON_PRESSED = "CLOSE_ABOUT_POPUP_BUTTON_PRESSED";
	
	/** AABB Distance Measurement Demo **/
	var AABB_DEMO_URI = exports.AABB_DEMO_URI = "AABB_DEMO_URI";
	var AABB_DEMO_NEXT_DIST_STEP = exports.AABB_DEMO_NEXT_DIST_STEP = "AABB_DEMO_NEXT_DIST_STEP";
	var AABB_TREE_NEXT_LEVEL = exports.AABB_TREE_NEXT_LEVEL = "AABB_TREE_NEXT_LEVEL";
	
	/** Collision demo **/
	var COLLISION_DEMO_URI = exports.COLLISION_DEMO_URI = "COLLISION_DEMO_URI";
	var COLLISION_DEMO_BUTTON_PRESSED = exports.COLLISION_DEMO_BUTTON_PRESSED = "COLLISION_DEMO_BUTTON_PRESSED";
	
	/** Skeleton recognition demo **/
	var SKELETON_RECOGNITION_URI = exports.SKELETON_RECOGNITION_URI = "SKELETON_RECOGNITION_URI";
	var SKELETON_RECOGNITION_BUTTON_PRESSED = exports.SKELETON_RECOGNITION_BUTTON_PRESSED = "SKELETON_RECOGNITION_BUTTON_PRESSED";

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Layers = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 20/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _layer = __webpack_require__(58);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var colors = ["#FF0303", "#4AA403", "#540080", "#FFFF40", "#FF0080", "#AED424", "#545400", "#FFA980", "#A95480", "#A9A9FF", "#00FF00", "#FFEE76", "#A40576", "#4385C8", "#1CC826", "#BDBD00", "#48316E", "#14616E", "#8040BD", "#DC7676", "#924845", "#A90000", "#FFA900"];
	
	var Layers = exports.Layers = function () {
	    function Layers() {
	        _classCallCheck(this, Layers);
	    }
	
	    _createClass(Layers, null, [{
	        key: "newLayer",
	        value: function newLayer(stage, layers) {
	            var layer = new _layer.Layer(stage);
	            layer.name = Layers.getNewName(layers);
	            if (layers.length === 0) {
	                // first layer
	                // layer.color = Layers.getNextColor(layers);
	                layer.displayed = false;
	                layer.affected = false;
	            }
	            return layer;
	        }
	    }, {
	        key: "getNewName",
	        value: function getNewName(layers) {
	            var name = Layers.defaultName;
	            var inc = 1;
	            var comparator = function comparator(layer) {
	                return layer.name === name;
	            };
	            while (layers.find(comparator)) {
	                name = Layers.defaultName + inc;
	                inc++;
	            }
	            return name;
	        }
	    }, {
	        key: "getAffected",
	        value: function getAffected(layers) {
	            return layers.find(function (lay) {
	                return lay.affected;
	            });
	        }
	    }, {
	        key: "setAffected",
	        value: function setAffected(layers, layer) {
	            var currentAffectedLayer = Layers.getAffected(layers);
	            if (currentAffectedLayer) {
	                currentAffectedLayer.affected = false;
	            }
	            layer.affected = true;
	        }
	    }, {
	        key: "getNextColor",
	        value: function getNextColor(layers) {
	            var color = "";
	
	            var _loop = function _loop(col) {
	                if (!layers.find(function (layer) {
	                    return layer.displayed && layer.color === col;
	                })) {
	                    color = col;
	                    return "break";
	                }
	            };
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var col = _step.value;
	
	                    var _ret = _loop(col);
	
	                    if (_ret === "break") break;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return color;
	        }
	    }, {
	        key: "delete",
	        value: function _delete(layers, layer) {
	            // let index = layers.findIndex((l) => l === layer);
	            var newLayers = layers.filter(function (l) {
	                return l !== layer;
	            });
	            return newLayers;
	        }
	    }, {
	        key: "sort",
	        value: function sort(layers) {
	            var newLayers = layers.slice();
	            newLayers.sort(function (l1, l2) {
	                var name1 = l1.name.toUpperCase();
	                var name2 = l2.name.toUpperCase();
	                if (name1 < name2) {
	                    return -1;
	                }
	                if (name1 > name2) {
	                    return 1;
	                }
	                return 0;
	            });
	            return newLayers;
	        }
	    }, {
	        key: "defaultName",
	        get: function get() {
	            return "layer";
	        }
	    }]);

	    return Layers;
	}();

/***/ },
/* 6 */
/***/ function(module, exports) {

	/*!
	* EaselJS
	* Visit http://createjs.com/ for documentation, updates and examples.
	*
	* Copyright (c) 2010 gskinner.com, inc.
	*
	* Permission is hereby granted, free of charge, to any person
	* obtaining a copy of this software and associated documentation
	* files (the "Software"), to deal in the Software without
	* restriction, including without limitation the rights to use,
	* copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the
	* Software is furnished to do so, subject to the following
	* conditions:
	*
	* The above copyright notice and this permission notice shall be
	* included in all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	* OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	
	//##############################################################################
	// extend.js
	//##############################################################################
	let createjs = {};
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Sets up the prototype chain and constructor property for a new class.
	 *
	 * This should be called right after creating the class constructor.
	 *
	 * 	function MySubClass() {}
	 * 	createjs.extend(MySubClass, MySuperClass);
	 * 	MySubClass.prototype.doSomething = function() { }
	 *
	 * 	var foo = new MySubClass();
	 * 	console.log(foo instanceof MySuperClass); // true
	 * 	console.log(foo.prototype.constructor === MySubClass); // true
	 *
	 * @method extend
	 * @param {Function} subclass The subclass.
	 * @param {Function} superclass The superclass to extend.
	 * @return {Function} Returns the subclass's new prototype.
	 */
	createjs.extend = function(subclass, superclass) {
		"use strict";
	
		function o() { this.constructor = subclass; }
		o.prototype = superclass.prototype;
		return (subclass.prototype = new o());
	};
	
	//##############################################################################
	// promote.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
	 * It is recommended to use the super class's name as the prefix.
	 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
	 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
	 *
	 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
	 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
	 * prototype of `MySubClass` as `MySuperClass_draw`.
	 *
	 * This should be called after the class's prototype is fully defined.
	 *
	 * 	function ClassA(name) {
	 * 		this.name = name;
	 * 	}
	 * 	ClassA.prototype.greet = function() {
	 * 		return "Hello "+this.name;
	 * 	}
	 *
	 * 	function ClassB(name, punctuation) {
	 * 		this.ClassA_constructor(name);
	 * 		this.punctuation = punctuation;
	 * 	}
	 * 	createjs.extend(ClassB, ClassA);
	 * 	ClassB.prototype.greet = function() {
	 * 		return this.ClassA_greet()+this.punctuation;
	 * 	}
	 * 	createjs.promote(ClassB, "ClassA");
	 *
	 * 	var foo = new ClassB("World", "!?!");
	 * 	console.log(foo.greet()); // Hello World!?!
	 *
	 * @method promote
	 * @param {Function} subclass The class to promote super class methods on.
	 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
	 * @return {Function} Returns the subclass.
	 */
	createjs.promote = function(subclass, prefix) {
		"use strict";
	
		var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
		if (supP) {
			subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
			for (var n in supP) {
				if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
			}
		}
		return subclass;
	};
	
	//##############################################################################
	// indexOf.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
	 * that value.  Returns -1 if value is not found.
	 *
	 *      var i = createjs.indexOf(myArray, myElementToFind);
	 *
	 * @method indexOf
	 * @param {Array} array Array to search for searchElement
	 * @param searchElement Element to find in array.
	 * @return {Number} The first index of searchElement in array.
	 */
	createjs.indexOf = function (array, searchElement){
		"use strict";
	
		for (var i = 0,l=array.length; i < l; i++) {
			if (searchElement === array[i]) {
				return i;
			}
		}
		return -1;
	};
	
	//##############################################################################
	// UID.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)
		 * and should not be instantiated.
		 * @class UID
		 * @static
		 **/
		function UID() {
			throw "UID cannot be instantiated";
		}
	
	
	// private static properties:
		/**
		 * @property _nextID
		 * @type Number
		 * @protected
		 **/
		UID._nextID = 0;
	
	
	// public static methods:
		/**
		 * Returns the next unique id.
		 * @method get
		 * @return {Number} The next unique id
		 * @static
		 **/
		UID.get = function() {
			return UID._nextID++;
		};
	
	
		createjs.UID = UID;
	}());
	
	//##############################################################################
	// deprecate.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/**
	 * @class Utility Methods
	 */
	
	/**
	 * Wraps deprecated methods so they still be used, but throw warnings to developers.
	 *
	 *	obj.deprecatedMethod = createjs.deprecate("Old Method Name", obj._fallbackMethod);
	 *
	 * The recommended approach for deprecated properties is:
	 *
	 *	try {
	 *		Obj	ect.defineProperties(object, {
	 *			readyOnlyProp: { get: createjs.deprecate("readOnlyProp", function() { return this.alternateProp; }) },
	 *			readWriteProp: {
	 *				get: createjs.deprecate("readOnlyProp", function() { return this.alternateProp; }),
	 *				set: createjs.deprecate("readOnlyProp", function(val) { this.alternateProp = val; })
	 *		});
	 *	} catch (e) {}
	 *
	 * @method deprecate
	 * @param {Function} [fallbackMethod=null] A method to call when the deprecated method is used. See the example for how
	 * @param {String} [name=null] The name of the method or property to display in the console warning.
	 * to deprecate properties.
	 * @return {Function} If a fallbackMethod is supplied, returns a closure that will call the fallback method after
	 * logging the warning in the console.
	 */
	createjs.deprecate = function(fallbackMethod, name) {
		"use strict";
		return function() {
			var msg = "Deprecated property or method '"+name+"'. See docs for info.";
			console && (console.warn ? console.warn(msg) : console.log(msg));
			return fallbackMethod && fallbackMethod.apply(this, arguments);
		}
	};
	
	//##############################################################################
	// Event.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	// constructor:
		/**
		 * Contains properties and methods shared by all events for use with
		 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
		 * 
		 * Note that Event objects are often reused, so you should never
		 * rely on an event object's state outside of the call stack it was received in.
		 * @class Event
		 * @param {String} type The event type.
		 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
		 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
		 * @constructor
		 **/
		function Event(type, bubbles, cancelable) {
			
		
		// public properties:
			/**
			 * The type of event.
			 * @property type
			 * @type String
			 **/
			this.type = type;
		
			/**
			 * The object that generated an event.
			 * @property target
			 * @type Object
			 * @default null
			 * @readonly
			*/
			this.target = null;
		
			/**
			 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
			 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
			 * is generated from childObj, then a listener on parentObj would receive the event with
			 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
			 * @property currentTarget
			 * @type Object
			 * @default null
			 * @readonly
			*/
			this.currentTarget = null;
		
			/**
			 * For bubbling events, this indicates the current event phase:<OL>
			 * 	<LI> capture phase: starting from the top parent to the target</LI>
			 * 	<LI> at target phase: currently being dispatched from the target</LI>
			 * 	<LI> bubbling phase: from the target to the top parent</LI>
			 * </OL>
			 * @property eventPhase
			 * @type Number
			 * @default 0
			 * @readonly
			*/
			this.eventPhase = 0;
		
			/**
			 * Indicates whether the event will bubble through the display list.
			 * @property bubbles
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.bubbles = !!bubbles;
		
			/**
			 * Indicates whether the default behaviour of this event can be cancelled via
			 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
			 * @property cancelable
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.cancelable = !!cancelable;
		
			/**
			 * The epoch time at which this event was created.
			 * @property timeStamp
			 * @type Number
			 * @default 0
			 * @readonly
			*/
			this.timeStamp = (new Date()).getTime();
		
			/**
			 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
			 * on this event.
			 * @property defaultPrevented
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.defaultPrevented = false;
		
			/**
			 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
			 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
			 * @property propagationStopped
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.propagationStopped = false;
		
			/**
			 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
			 * on this event.
			 * @property immediatePropagationStopped
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.immediatePropagationStopped = false;
			
			/**
			 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
			 * @property removed
			 * @type Boolean
			 * @default false
			 * @readonly
			*/
			this.removed = false;
		}
		var p = Event.prototype;
	
	// public methods:
		/**
		 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
		 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
		 * cancel the default behaviour associated with the event.
		 * @method preventDefault
		 **/
		p.preventDefault = function() {
			this.defaultPrevented = this.cancelable&&true;
		};
	
		/**
		 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
		 * Mirrors the DOM event standard.
		 * @method stopPropagation
		 **/
		p.stopPropagation = function() {
			this.propagationStopped = true;
		};
	
		/**
		 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
		 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
		 * Mirrors the DOM event standard.
		 * @method stopImmediatePropagation
		 **/
		p.stopImmediatePropagation = function() {
			this.immediatePropagationStopped = this.propagationStopped = true;
		};
		
		/**
		 * Causes the active listener to be removed via removeEventListener();
		 * 
		 * 		myBtn.addEventListener("click", function(evt) {
		 * 			// do stuff...
		 * 			evt.remove(); // removes this listener.
		 * 		});
		 * 
		 * @method remove
		 **/
		p.remove = function() {
			this.removed = true;
		};
		
		/**
		 * Returns a clone of the Event instance.
		 * @method clone
		 * @return {Event} a clone of the Event instance.
		 **/
		p.clone = function() {
			return new Event(this.type, this.bubbles, this.cancelable);
		};
		
		/**
		 * Provides a chainable shortcut method for setting a number of properties on the instance.
		 *
		 * @method set
		 * @param {Object} props A generic object containing properties to copy to the instance.
		 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
		 * @chainable
		*/
		p.set = function(props) {
			for (var n in props) { this[n] = props[n]; }
			return this;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Event (type="+this.type+")]";
		};
	
		createjs.Event = Event;
	}());
	
	//##############################################################################
	// EventDispatcher.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
		 *
		 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
		 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
		 * 
		 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
		 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
		 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
		 * 
		 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
		 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
		 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
		 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
		 * 
		 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
		 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
		 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
		 *
		 * <h4>Example</h4>
		 * Add EventDispatcher capabilities to the "MyClass" class.
		 *
		 *      EventDispatcher.initialize(MyClass.prototype);
		 *
		 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
		 *
		 *      instance.addEventListener("eventName", handlerMethod);
		 *      function handlerMethod(event) {
		 *          console.log(event.target + " Was Clicked");
		 *      }
		 *
		 * <b>Maintaining proper scope</b><br />
		 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
		 * method to subscribe to events simplifies this.
		 *
		 *      instance.addEventListener("click", function(event) {
		 *          console.log(instance == this); // false, scope is ambiguous.
		 *      });
		 *      
		 *      instance.on("click", function(event) {
		 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
		 *      });
		 * 
		 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage
		 * scope.
		 *
		 * <b>Browser support</b>
		 * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model
		 * requires modern browsers (IE9+).
		 *      
		 *
		 * @class EventDispatcher
		 * @constructor
		 **/
		function EventDispatcher() {
		
		
		// private properties:
			/**
			 * @protected
			 * @property _listeners
			 * @type Object
			 **/
			this._listeners = null;
			
			/**
			 * @protected
			 * @property _captureListeners
			 * @type Object
			 **/
			this._captureListeners = null;
		}
		var p = EventDispatcher.prototype;
	
	// static public methods:
		/**
		 * Static initializer to mix EventDispatcher methods into a target object or prototype.
		 * 
		 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
		 * 		EventDispatcher.initialize(myObject); // add to a specific instance
		 * 
		 * @method initialize
		 * @static
		 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
		 * prototype.
		 **/
		EventDispatcher.initialize = function(target) {
			target.addEventListener = p.addEventListener;
			target.on = p.on;
			target.removeEventListener = target.off =  p.removeEventListener;
			target.removeAllEventListeners = p.removeAllEventListeners;
			target.hasEventListener = p.hasEventListener;
			target.dispatchEvent = p.dispatchEvent;
			target._dispatchEvent = p._dispatchEvent;
			target.willTrigger = p.willTrigger;
		};
		
	
	// public methods:
		/**
		 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
		 * multiple callbacks getting fired.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.addEventListener("click", handleClick);
		 *      function handleClick(event) {
		 *         // Click happened.
		 *      }
		 *
		 * @method addEventListener
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
		 * the event is dispatched.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 * @return {Function | Object} Returns the listener for chaining or assignment.
		 **/
		p.addEventListener = function(type, listener, useCapture) {
			var listeners;
			if (useCapture) {
				listeners = this._captureListeners = this._captureListeners||{};
			} else {
				listeners = this._listeners = this._listeners||{};
			}
			var arr = listeners[type];
			if (arr) { this.removeEventListener(type, listener, useCapture); }
			arr = listeners[type]; // remove may have deleted the array
			if (!arr) { listeners[type] = [listener];  }
			else { arr.push(listener); }
			return listener;
		};
		
		/**
		 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
		 * only run once, associate arbitrary data with the listener, and remove the listener.
		 * 
		 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
		 * The wrapper function is returned for use with `removeEventListener` (or `off`).
		 * 
		 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
		 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
		 * to `on` with the same params will create multiple listeners.
		 * 
		 * <h4>Example</h4>
		 * 
		 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
		 * 		function handleClick(evt, data) {
		 * 			data.count -= 1;
		 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
		 * 			if (data.count == 0) {
		 * 				alert("clicked 3 times!");
		 * 				myBtn.off("click", listener);
		 * 				// alternately: evt.remove();
		 * 			}
		 * 		}
		 * 
		 * @method on
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
		 * the event is dispatched.
		 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
		 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
		 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
		 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
		 **/
		p.on = function(type, listener, scope, once, data, useCapture) {
			if (listener.handleEvent) {
				scope = scope||listener;
				listener = listener.handleEvent;
			}
			scope = scope||this;
			return this.addEventListener(type, function(evt) {
					listener.call(scope, evt, data);
					once&&evt.remove();
				}, useCapture);
		};
	
		/**
		 * Removes the specified event listener.
		 *
		 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
		 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
		 * closure will not work.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.removeEventListener("click", handleClick);
		 *
		 * @method removeEventListener
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener The listener function or object.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 **/
		p.removeEventListener = function(type, listener, useCapture) {
			var listeners = useCapture ? this._captureListeners : this._listeners;
			if (!listeners) { return; }
			var arr = listeners[type];
			if (!arr) { return; }
			for (var i=0,l=arr.length; i<l; i++) {
				if (arr[i] == listener) {
					if (l==1) { delete(listeners[type]); } // allows for faster checks.
					else { arr.splice(i,1); }
					break;
				}
			}
		};
		
		/**
		 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
		 * .on method.
		 * 
		 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
		 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
		 *
		 * @method off
		 * @param {String} type The string type of the event.
		 * @param {Function | Object} listener The listener function or object.
		 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
		 **/
		p.off = p.removeEventListener;
	
		/**
		 * Removes all listeners for the specified type, or all listeners of all types.
		 *
		 * <h4>Example</h4>
		 *
		 *      // Remove all listeners
		 *      displayObject.removeAllEventListeners();
		 *
		 *      // Remove all click listeners
		 *      displayObject.removeAllEventListeners("click");
		 *
		 * @method removeAllEventListeners
		 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
		 **/
		p.removeAllEventListeners = function(type) {
			if (!type) { this._listeners = this._captureListeners = null; }
			else {
				if (this._listeners) { delete(this._listeners[type]); }
				if (this._captureListeners) { delete(this._captureListeners[type]); }
			}
		};
	
		/**
		 * Dispatches the specified event to all listeners.
		 *
		 * <h4>Example</h4>
		 *
		 *      // Use a string event
		 *      this.dispatchEvent("complete");
		 *
		 *      // Use an Event instance
		 *      var event = new createjs.Event("progress");
		 *      this.dispatchEvent(event);
		 *
		 * @method dispatchEvent
		 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
		 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
		 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
		 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
		 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
		 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
		 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
		 **/
		p.dispatchEvent = function(eventObj, bubbles, cancelable) {
			if (typeof eventObj == "string") {
				// skip everything if there's no listeners and it doesn't bubble:
				var listeners = this._listeners;
				if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
				eventObj = new createjs.Event(eventObj, bubbles, cancelable);
			} else if (eventObj.target && eventObj.clone) {
				// redispatching an active event object, so clone it:
				eventObj = eventObj.clone();
			}
			
			// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
			try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events
	
			if (!eventObj.bubbles || !this.parent) {
				this._dispatchEvent(eventObj, 2);
			} else {
				var top=this, list=[top];
				while (top.parent) { list.push(top = top.parent); }
				var i, l=list.length;
	
				// capture & atTarget
				for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
					list[i]._dispatchEvent(eventObj, 1+(i==0));
				}
				// bubbling
				for (i=1; i<l && !eventObj.propagationStopped; i++) {
					list[i]._dispatchEvent(eventObj, 3);
				}
			}
			return !eventObj.defaultPrevented;
		};
	
		/**
		 * Indicates whether there is at least one listener for the specified event type.
		 * @method hasEventListener
		 * @param {String} type The string type of the event.
		 * @return {Boolean} Returns true if there is at least one listener for the specified event.
		 **/
		p.hasEventListener = function(type) {
			var listeners = this._listeners, captureListeners = this._captureListeners;
			return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
		};
		
		/**
		 * Indicates whether there is at least one listener for the specified event type on this object or any of its
		 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
		 * specified type is dispatched from this object, it will trigger at least one listener.
		 * 
		 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
		 * event flow for a listener, not just this object.
		 * @method willTrigger
		 * @param {String} type The string type of the event.
		 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
		 **/
		p.willTrigger = function(type) {
			var o = this;
			while (o) {
				if (o.hasEventListener(type)) { return true; }
				o = o.parent;
			}
			return false;
		};
	
		/**
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[EventDispatcher]";
		};
	
	
	// private methods:
		/**
		 * @method _dispatchEvent
		 * @param {Object | Event} eventObj
		 * @param {Object} eventPhase
		 * @protected
		 **/
		p._dispatchEvent = function(eventObj, eventPhase) {
			var l, arr, listeners = (eventPhase <= 2) ? this._captureListeners : this._listeners;
			if (eventObj && listeners && (arr = listeners[eventObj.type]) && (l=arr.length)) {
				try { eventObj.currentTarget = this; } catch (e) {}
				try { eventObj.eventPhase = eventPhase|0; } catch (e) {}
				eventObj.removed = false;
				
				arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
				for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
					var o = arr[i];
					if (o.handleEvent) { o.handleEvent(eventObj); }
					else { o(eventObj); }
					if (eventObj.removed) {
						this.off(eventObj.type, o, eventPhase==1);
						eventObj.removed = false;
					}
				}
			}
			if (eventPhase === 2) { this._dispatchEvent(eventObj, 2.1); }
		};
	
	
		createjs.EventDispatcher = EventDispatcher;
	}());
	
	//##############################################################################
	// Ticker.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
		 * event to be notified when a set time interval has elapsed.
		 *
		 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
		 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
		 * can not be instantiated.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          // Actions carried out each tick (aka frame)
		 *          if (!event.paused) {
		 *              // Actions carried out when the Ticker is not paused.
		 *          }
		 *      }
		 *
		 * @class Ticker
		 * @uses EventDispatcher
		 * @static
		 **/
		function Ticker() {
			throw "Ticker cannot be instantiated.";
		}
	
	
	// constants:
		/**
		 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
		 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
		 * dispatches the tick when the time is within a certain threshold.
		 *
		 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
		 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
		 * gaining the benefits of that API (screen synch, background throttling).
		 *
		 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
		 * framerates of 10, 12, 15, 20, and 30 work well.
		 *
		 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
		 * supported.
		 * @property RAF_SYNCHED
		 * @static
		 * @type {String}
		 * @default "synched"
		 * @readonly
		 **/
		Ticker.RAF_SYNCHED = "synched";
	
		/**
		 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
		 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
		 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event object's "delta" properties to make this easier.
		 *
		 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
		 * supported.
		 * @property RAF
		 * @static
		 * @type {String}
		 * @default "raf"
		 * @readonly
		 **/
		Ticker.RAF = "raf";
	
		/**
		 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
		 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
		 * @property TIMEOUT
		 * @static
		 * @type {String}
		 * @default "timeout"
		 * @readonly
		 **/
		Ticker.TIMEOUT = "timeout";
	
	
	// static events:
		/**
		 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
		 * {{#crossLink "Ticker/paused:property"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          console.log("Paused:", event.paused, event.delta);
		 *      }
		 *
		 * @event tick
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Boolean} paused Indicates whether the ticker is currently paused.
		 * @param {Number} delta The time elapsed in ms since the last tick.
		 * @param {Number} time The total time in ms since Ticker was initialized.
		 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
		 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
		 * @since 0.6.0
		 */
	
	
	// public static properties:
		/**
		 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
		 * {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}}, {{#crossLink "Ticker/RAF:property"}}{{/crossLink}}, and
		 * {{#crossLink "Ticker/RAF_SYNCHED:property"}}{{/crossLink}} for mode details.
		 * @property timingMode
		 * @static
		 * @type {String}
		 * @default Ticker.TIMEOUT
		 **/
		Ticker.timingMode = null;
	
		/**
		 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
		 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
		 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
		 * (ex. maxDelta=50 when running at 40fps).
		 * 
		 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
		 * when using both delta and other values.
		 * 
		 * If 0, there is no maximum.
		 * @property maxDelta
		 * @static
		 * @type {number}
		 * @default 0
		 */
		Ticker.maxDelta = 0;
		
		/**
		 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
		 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
		 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
		 * info.
		 *
		 * <h4>Example</h4>
		 *
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      createjs.Ticker.paused = true;
		 *      function handleTick(event) {
		 *          console.log(event.paused,
		 *          	createjs.Ticker.getTime(false),
		 *          	createjs.Ticker.getTime(true));
		 *      }
		 *
		 * @property paused
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		Ticker.paused = false;
	
	
	// mix-ins:
		// EventDispatcher methods:
		Ticker.removeEventListener = null;
		Ticker.removeAllEventListeners = null;
		Ticker.dispatchEvent = null;
		Ticker.hasEventListener = null;
		Ticker._listeners = null;
		createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
		Ticker._addEventListener = Ticker.addEventListener;
		Ticker.addEventListener = function() {
			!Ticker._inited&&Ticker.init();
			return Ticker._addEventListener.apply(Ticker, arguments);
		};
	
	
	// private static properties:
		/**
		 * @property _inited
		 * @static
		 * @type {Boolean}
		 * @private
		 **/
		Ticker._inited = false;
	
		/**
		 * @property _startTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._startTime = 0;
	
		/**
		 * @property _pausedTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._pausedTime=0;
	
		/**
		 * The number of ticks that have passed
		 * @property _ticks
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._ticks = 0;
	
		/**
		 * The number of ticks that have passed while Ticker has been paused
		 * @property _pausedTicks
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._pausedTicks = 0;
	
		/**
		 * @property _interval
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._interval = 50;
	
		/**
		 * @property _lastTime
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._lastTime = 0;
	
		/**
		 * @property _times
		 * @static
		 * @type {Array}
		 * @private
		 **/
		Ticker._times = null;
	
		/**
		 * @property _tickTimes
		 * @static
		 * @type {Array}
		 * @private
		 **/
		Ticker._tickTimes = null;
	
		/**
		 * Stores the timeout or requestAnimationFrame id.
		 * @property _timerId
		 * @static
		 * @type {Number}
		 * @private
		 **/
		Ticker._timerId = null;
		
		/**
		 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
		 * if that property changed and a tick hasn't fired.
		 * @property _raf
		 * @static
		 * @type {Boolean}
		 * @private
		 **/
		Ticker._raf = true;
		
	
	// static getter / setters:
		/**
		 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
		 * @method _setInterval
		 * @private
		 * @static
		 * @param {Number} interval
		 **/
		Ticker._setInterval = function(interval) {
			Ticker._interval = interval;
			if (!Ticker._inited) { return; }
			Ticker._setupTick();
		};
		// Ticker.setInterval is @deprecated. Remove for 1.1+
		Ticker.setInterval = createjs.deprecate(Ticker._setInterval, "Ticker.setInterval");
	
		/**
		 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
		 * @method _getInterval
		 * @private
		 * @static
		 * @return {Number}
		 **/
		Ticker._getInterval = function() {
			return Ticker._interval;
		};
		// Ticker.getInterval is @deprecated. Remove for 1.1+
		Ticker.getInterval = createjs.deprecate(Ticker._getInterval, "Ticker.getInterval");
	
		/**
		 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
		 * @method _setFPS
		 * @private
		 * @static
		 * @param {Number} value
		 **/
		Ticker._setFPS = function(value) {
			Ticker._setInterval(1000/value);
		};
		// Ticker.setFPS is @deprecated. Remove for 1.1+
		Ticker.setFPS = createjs.deprecate(Ticker._setFPS, "Ticker.setFPS");
	
		/**
		 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
		 * @method _getFPS
		 * @static
		 * @private
		 * @return {Number}
		 **/
		Ticker._getFPS = function() {
			return 1000/Ticker._interval;
		};
		// Ticker.getFPS is @deprecated. Remove for 1.1+
		Ticker.getFPS = createjs.deprecate(Ticker._getFPS, "Ticker.getFPS");
	
		/**
		 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
		 * Note that actual time between ticks may be more than specified depending on CPU load.
		 * This property is ignored if the ticker is using the `RAF` timing mode.
		 * @property interval
		 * @static
		 * @type {Number}
		 **/
		 
		/**
		 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
		 * `framerate == 1000/interval`.
		 * @property framerate
		 * @static
		 * @type {Number}
		 **/
		try {
			Object.defineProperties(Ticker, {
				interval: { get: Ticker._getInterval, set: Ticker._setInterval },
				framerate: { get: Ticker._getFPS, set: Ticker._setFPS }
			});
		} catch (e) { console.log(e); }
	
	
	// public static methods:
		/**
		 * Starts the tick. This is called automatically when the first listener is added.
		 * @method init
		 * @static
		 **/
		Ticker.init = function() {
			if (Ticker._inited) { return; }
			Ticker._inited = true;
			Ticker._times = [];
			Ticker._tickTimes = [];
			Ticker._startTime = Ticker._getTime();
			Ticker._times.push(Ticker._lastTime = 0);
			Ticker.interval = Ticker._interval;
		};
		
		/**
		 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
		 * @method reset
		 * @static
		 **/
		Ticker.reset = function() {
			if (Ticker._raf) {
				var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
				f&&f(Ticker._timerId);
			} else {
				clearTimeout(Ticker._timerId);
			}
			Ticker.removeAllEventListeners("tick");
			Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
			Ticker._startTime = Ticker._lastTime = Ticker._ticks = Ticker._pausedTime = 0;
			Ticker._inited = false;
		};
	
		/**
		 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
		 * because it only measures the time spent within the tick execution stack. 
		 * 
		 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
		 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
		 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
		 *
		 * Example 2: With a target FPS of 30, {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} returns 10fps, which
		 * indicates an average of 100ms between the end of one tick and the end of the next. However, {{#crossLink "Ticker/getMeasuredTickTime"}}{{/crossLink}}
		 * returns 20ms. This would indicate that something other than the tick is using ~80ms (another script, DOM
		 * rendering, etc).
		 * @method getMeasuredTickTime
		 * @static
		 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
		 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
		 * @return {Number} The average time spent in a tick in milliseconds.
		 **/
		Ticker.getMeasuredTickTime = function(ticks) {
			var ttl=0, times=Ticker._tickTimes;
			if (!times || times.length < 1) { return -1; }
	
			// by default, calculate average for the past ~1 second:
			ticks = Math.min(times.length, ticks||(Ticker._getFPS()|0));
			for (var i=0; i<ticks; i++) { ttl += times[i]; }
			return ttl/ticks;
		};
	
		/**
		 * Returns the actual frames / ticks per second.
		 * @method getMeasuredFPS
		 * @static
		 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
		 * Defaults to the number of ticks per second.
		 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
		 * from the target frames per second.
		 **/
		Ticker.getMeasuredFPS = function(ticks) {
			var times = Ticker._times;
			if (!times || times.length < 2) { return -1; }
	
			// by default, calculate fps for the past ~1 second:
			ticks = Math.min(times.length-1, ticks||(Ticker._getFPS()|0));
			return 1000/((times[0]-times[ticks])/ticks);
		};
	
		/**
		 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
		 * Returns -1 if Ticker has not been initialized. For example, you could use
		 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
		 * @method getTime
		 * @static
		 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
		 * If false, the value returned will be total time elapsed since the first tick event listener was added.
		 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
		 **/
		Ticker.getTime = function(runTime) {
			return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
		};
	
		/**
		 * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event object.
		 * @method getEventTime
		 * @static
		 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
		 * @returns {number} The time or runTime property from the most recent tick event or -1.
		 */
		Ticker.getEventTime = function(runTime) {
			return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
		};
		
		/**
		 * Returns the number of ticks that have been broadcast by Ticker.
		 * @method getTicks
		 * @static
		 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
		 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
		 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
		 * value. The default value is false.
		 * @return {Number} of ticks that have been broadcast.
		 **/
		Ticker.getTicks = function(pauseable) {
			return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
		};
	
	
	// private static methods:
		/**
		 * @method _handleSynch
		 * @static
		 * @private
		 **/
		Ticker._handleSynch = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
	
			// run if enough time has elapsed, with a little bit of flexibility to be early:
			if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
				Ticker._tick();
			}
		};
	
		/**
		 * @method _handleRAF
		 * @static
		 * @private
		 **/
		Ticker._handleRAF = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
			Ticker._tick();
		};
	
		/**
		 * @method _handleTimeout
		 * @static
		 * @private
		 **/
		Ticker._handleTimeout = function() {
			Ticker._timerId = null;
			Ticker._setupTick();
			Ticker._tick();
		};
	
		/**
		 * @method _setupTick
		 * @static
		 * @private
		 **/
		Ticker._setupTick = function() {
			if (Ticker._timerId != null) { return; } // avoid duplicates
	
			var mode = Ticker.timingMode;
			if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
				var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
				if (f) {
					Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
					Ticker._raf = true;
					return;
				}
			}
			Ticker._raf = false;
			Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
		};
	
		/**
		 * @method _tick
		 * @static
		 * @private
		 **/
		Ticker._tick = function() {
			var paused = Ticker.paused;
			var time = Ticker._getTime();
			var elapsedTime = time-Ticker._lastTime;
			Ticker._lastTime = time;
			Ticker._ticks++;
			
			if (paused) {
				Ticker._pausedTicks++;
				Ticker._pausedTime += elapsedTime;
			}
			
			if (Ticker.hasEventListener("tick")) {
				var event = new createjs.Event("tick");
				var maxDelta = Ticker.maxDelta;
				event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
				event.paused = paused;
				event.time = time;
				event.runTime = time-Ticker._pausedTime;
				Ticker.dispatchEvent(event);
			}
			
			Ticker._tickTimes.unshift(Ticker._getTime()-time);
			while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }
	
			Ticker._times.unshift(time);
			while (Ticker._times.length > 100) { Ticker._times.pop(); }
		};
	
		/**
		 * @method _getTime
		 * @static
		 * @private
		 **/
		var w=window, now=w.performance.now || w.performance.mozNow || w.performance.msNow || w.performance.oNow || w.performance.webkitNow;
		Ticker._getTime = function() {
			return ((now&&now.call(w.performance))||(new Date().getTime())) - Ticker._startTime;
		};
	
	
		createjs.Ticker = Ticker;
	}());
	
	//##############################################################################
	// VideoBuffer.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * When an HTML video seeks, including when looping, there is an indeterminate period before a new frame is available.
		 * This can result in the video blinking or flashing when it is drawn to a canvas. The VideoBuffer class resolves
		 * this issue by drawing each frame to an off-screen canvas and preserving the prior frame during a seek.
		 * 
		 * 	var myBuffer = new createjs.VideoBuffer(myVideo);
		 * 	var myBitmap = new Bitmap(myBuffer);
		 * 
		 * @class VideoBuffer
		 * @param {HTMLVideoElement} video The HTML video element to buffer.
		 * @constructor
		 **/
		function VideoBuffer(video) {
			
		// private properties:
			/**
			 * Used by Bitmap to determine when the video buffer is ready to be drawn. Not intended for general use.
			 * @property readyState
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.readyState = video.readyState;
			
			/**
			 * @property _video
			 * @protected
			 * @type {HTMLVideoElement}
			 * @default 0
			 **/
			this._video = video;
			
			/**
			 * @property _canvas
			 * @protected
			 * @type {HTMLCanvasElement}
			 * @default 0
			 **/
			this._canvas = null;
			
			/**
			 * @property _lastTime
			 * @protected
			 * @type {Number}
			 * @default -1
			 **/
			this._lastTime = -1;
			
			if (this.readyState < 2) { video.addEventListener("canplaythrough", this._videoReady.bind(this)); } //once:true isn't supported everywhere, but its a non-critical optimization here.
		}
		var p = VideoBuffer.prototype;
		
		
	// public methods:
		/**
		 * Gets an HTML canvas element showing the current video frame, or the previous frame if in a seek / loop.
		 * Primarily for use by {{#crossLink "Bitmap"}}{{/crossLink}}.
		 * @method getImage
		 **/
		p.getImage = function() {
			if (this.readyState < 2) { return; }
			var canvas=this._canvas, video = this._video;
			if (!canvas) {
				canvas = this._canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
			}
			if (video.readyState >= 2 && video.currentTime !== this._lastTime) {
				var ctx = canvas.getContext("2d");
				ctx.clearRect(0,0,canvas.width,canvas.height);
				ctx.drawImage(video,0,0,canvas.width,canvas.height);
				this._lastTime = video.currentTime;
			}
			return canvas;
		};
		
	// private methods:
		/**
		 * @method _videoReady
		 * @protected
		 **/
		p._videoReady = function() {
			this.readyState = 2;
		};
	
	
		createjs.VideoBuffer = VideoBuffer;
	}());
	
	//##############################################################################
	// MouseEvent.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
		 * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.
		 * @class MouseEvent
		 * @param {String} type The event type.
		 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
		 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
		 * @param {Number} stageX The normalized x position relative to the stage.
		 * @param {Number} stageY The normalized y position relative to the stage.
		 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
		 * @param {Number} pointerID The unique id for the pointer.
		 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
		 * @param {Number} rawX The raw x position relative to the stage.
		 * @param {Number} rawY The raw y position relative to the stage.
		 * @param {DisplayObject} relatedTarget The secondary target for the event.
		 * @extends Event
		 * @constructor
		 **/
		function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
			this.Event_constructor(type, bubbles, cancelable);
			
			
		// public properties:
			/**
			 * The normalized x position on the stage. This will always be within the range 0 to stage width.
			 * @property stageX
			 * @type Number
			*/
			this.stageX = stageX;
		
			/**
			 * The normalized y position on the stage. This will always be within the range 0 to stage height.
			 * @property stageY
			 * @type Number
			 **/
			this.stageY = stageY;
		
			/**
			 * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
			 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
			 * @property rawX
			 * @type Number
			*/
			this.rawX = (rawX==null)?stageX:rawX;
		
			/**
			 * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
			 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
			 * @property rawY
			 * @type Number
			*/
			this.rawY = (rawY==null)?stageY:rawY;
		
			/**
			 * The native MouseEvent generated by the browser. The properties and API for this
			 * event may differ between browsers. This property will be null if the
			 * EaselJS property was not directly generated from a native MouseEvent.
			 * @property nativeEvent
			 * @type HtmlMouseEvent
			 * @default null
			 **/
			this.nativeEvent = nativeEvent;
		
			/**
			 * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
			 * supplied id value.
			 * @property pointerID
			 * @type {Number}
			 */
			this.pointerID = pointerID;
		
			/**
			 * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
			 * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
			 * @property primary
			 * @type {Boolean}
			 */
			this.primary = !!primary;
			
			/**
			 * The secondary target for the event, if applicable. This is used for mouseout/rollout
			 * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
			 * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
			 * 
			 * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
			 * @property relatedTarget
			 * @type {DisplayObject}
			 */
			this.relatedTarget = relatedTarget;
		}
		var p = createjs.extend(MouseEvent, createjs.Event);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
		
		
	// getter / setters:
		/**
		 * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
		 * @property localX
		 * @type {Number}
		 * @readonly
		 */
		p._get_localX = function() {
			return this.currentTarget.globalToLocal(this.rawX, this.rawY).x;
		};
		
		/**
		 * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
		 * @property localY
		 * @type {Number}
		 * @readonly
		 */
		p._get_localY = function() {
			return this.currentTarget.globalToLocal(this.rawX, this.rawY).y;
		};
		
		/**
		 * Indicates whether the event was generated by a touch input (versus a mouse input).
		 * @property isTouch
		 * @type {Boolean}
		 * @readonly
		 */
		p._get_isTouch = function() {
			return this.pointerID !== -1;
		};
		
		
		try {
			Object.defineProperties(p, {
				localX: { get: p._get_localX },
				localY: { get: p._get_localY },
				isTouch: { get: p._get_isTouch }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Returns a clone of the MouseEvent instance.
		 * @method clone
		 * @return {MouseEvent} a clone of the MouseEvent instance.
		 **/
		p.clone = function() {
			return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";
		};
	
	
		createjs.MouseEvent = createjs.promote(MouseEvent, "Event");
	}());
	
	//##############################################################################
	// Matrix2D.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
		 *
		 * This matrix can be visualized as:
		 *
		 * 	[ a  c  tx
		 * 	  b  d  ty
		 * 	  0  0  1  ]
		 *
		 * Note the locations of b and c.
		 *
		 * @class Matrix2D
		 * @param {Number} [a=1] Specifies the a property for the new matrix.
		 * @param {Number} [b=0] Specifies the b property for the new matrix.
		 * @param {Number} [c=0] Specifies the c property for the new matrix.
		 * @param {Number} [d=1] Specifies the d property for the new matrix.
		 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
		 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
		 * @constructor
		 **/
		function Matrix2D(a, b, c, d, tx, ty) {
			this.setValues(a,b,c,d,tx,ty);
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * Position (0, 0) in a 3x3 affine transformation matrix.
			 * @property a
			 * @type Number
			 **/
		
			/**
			 * Position (0, 1) in a 3x3 affine transformation matrix.
			 * @property b
			 * @type Number
			 **/
		
			/**
			 * Position (1, 0) in a 3x3 affine transformation matrix.
			 * @property c
			 * @type Number
			 **/
		
			/**
			 * Position (1, 1) in a 3x3 affine transformation matrix.
			 * @property d
			 * @type Number
			 **/
		
			/**
			 * Position (2, 0) in a 3x3 affine transformation matrix.
			 * @property tx
			 * @type Number
			 **/
		
			/**
			 * Position (2, 1) in a 3x3 affine transformation matrix.
			 * @property ty
			 * @type Number
			 **/
		}
		var p = Matrix2D.prototype;
	
	// constants:
		/**
		 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
		 * @property DEG_TO_RAD
		 * @static
		 * @final
		 * @type Number
		 * @readonly
		 **/
		Matrix2D.DEG_TO_RAD = Math.PI/180;
	
	
	// static public properties:
		/**
		 * An identity matrix, representing a null transformation.
		 * @property identity
		 * @static
		 * @type Matrix2D
		 * @readonly
		 **/
		Matrix2D.identity = null; // set at bottom of class definition.
		
	
	// public methods:
		/**
		 * Sets the specified values on this instance. 
		 * @method setValues
		 * @param {Number} [a=1] Specifies the a property for the new matrix.
		 * @param {Number} [b=0] Specifies the b property for the new matrix.
		 * @param {Number} [c=0] Specifies the c property for the new matrix.
		 * @param {Number} [d=1] Specifies the d property for the new matrix.
		 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
		 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
		 * @return {Matrix2D} This instance. Useful for chaining method calls.
		*/
		p.setValues = function(a, b, c, d, tx, ty) {
			// don't forget to update docs in the constructor if these change:
			this.a = (a == null) ? 1 : a;
			this.b = b || 0;
			this.c = c || 0;
			this.d = (d == null) ? 1 : d;
			this.tx = tx || 0;
			this.ty = ty || 0;
			return this;
		};
	
		/**
		 * Appends the specified matrix properties to this matrix. All parameters are required.
		 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
		 * @method append
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.append = function(a, b, c, d, tx, ty) {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			if (a != 1 || b != 0 || c != 0 || d != 1) {
				this.a  = a1*a+c1*b;
				this.b  = b1*a+d1*b;
				this.c  = a1*c+c1*d;
				this.d  = b1*c+d1*d;
			}
			this.tx = a1*tx+c1*ty+this.tx;
			this.ty = b1*tx+d1*ty+this.ty;
			return this;
		};
	
		/**
		 * Prepends the specified matrix properties to this matrix.
		 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
		 * All parameters are required.
		 * @method prepend
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prepend = function(a, b, c, d, tx, ty) {
			var a1 = this.a;
			var c1 = this.c;
			var tx1 = this.tx;
	
			this.a  = a*a1+c*this.b;
			this.b  = b*a1+d*this.b;
			this.c  = a*c1+c*this.d;
			this.d  = b*c1+d*this.d;
			this.tx = a*tx1+c*this.ty+tx;
			this.ty = b*tx1+d*this.ty+ty;
			return this;
		};
	
		/**
		 * Appends the specified matrix to this matrix.
		 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
		 * @method appendMatrix
		 * @param {Matrix2D} matrix
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.appendMatrix = function(matrix) {
			return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Prepends the specified matrix to this matrix.
		 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
		 * For example, you could calculate the combined transformation for a child object using:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var mtx = o.getMatrix();
		 * 	while (o = o.parent) {
		 * 		// prepend each parent's transformation in turn:
		 * 		o.prependMatrix(o.getMatrix());
		 * 	}
		 * @method prependMatrix
		 * @param {Matrix2D} matrix
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prependMatrix = function(matrix) {
			return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
		 * For example, you can use this to generate a matrix representing the transformations of a display object:
		 * 
		 * 	var mtx = new createjs.Matrix2D();
		 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}
	
			if (skewX || skewY) {
				// TODO: can this be combined into a single append operation?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			
			if (regX || regY) {
				// append the registration offset:
				this.tx -= regX*this.a+regY*this.c; 
				this.ty -= regX*this.b+regY*this.d;
			}
			return this;
		};
	
		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
		 * For example, you could calculate the combined transformation for a child object using:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var mtx = new createjs.Matrix2D();
		 * 	do  {
		 * 		// prepend each parent's transformation in turn:
		 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
		 * 	} while (o = o.parent);
		 * 	
		 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
		 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}
	
			if (regX || regY) {
				// prepend the registration offset:
				this.tx -= regX; this.ty -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			return this;
		};
	
		/**
		 * Applies a clockwise rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.rotate = function(angle) {
			angle = angle*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
	
			var a1 = this.a;
			var b1 = this.b;
	
			this.a = a1*cos+this.c*sin;
			this.b = b1*cos+this.d*sin;
			this.c = -a1*sin+this.c*cos;
			this.d = -b1*sin+this.d*cos;
			return this;
		};
	
		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		*/
		p.skew = function(skewX, skewY) {
			skewX = skewX*Matrix2D.DEG_TO_RAD;
			skewY = skewY*Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
			return this;
		};
	
		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
		 * @param {Number} y The amount to scale vertically.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.scale = function(x, y) {
			this.a *= x;
			this.b *= x;
			this.c *= y;
			this.d *= y;
			//this.tx *= x;
			//this.ty *= y;
			return this;
		};
	
		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.translate = function(x, y) {
			this.tx += this.a*x + this.c*y;
			this.ty += this.b*x + this.d*y;
			return this;
		};
	
		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.identity = function() {
			this.a = this.d = 1;
			this.b = this.c = this.tx = this.ty = 0;
			return this;
		};
	
		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		 **/
		p.invert = function() {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var n = a1*d1-b1*c1;
	
			this.a = d1/n;
			this.b = -b1/n;
			this.c = -c1/n;
			this.d = a1/n;
			this.tx = (c1*this.ty-d1*tx1)/n;
			this.ty = -(a1*this.ty-b1*tx1)/n;
			return this;
		};
	
		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @return {Boolean}
		 **/
		p.isIdentity = function() {
			return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
		};
		
		/**
		 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
		 * @method equals
		 * @param {Matrix2D} matrix The matrix to compare.
		 * @return {Boolean}
		 **/
		p.equals = function(matrix) {
			return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
		};
	
		/**
		 * Transforms a point according to this matrix.
		 * @method transformPoint
		 * @param {Number} x The x component of the point to transform.
		 * @param {Number} y The y component of the point to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
		 * @return {Point} This matrix. Useful for chaining method calls.
		 **/
		p.transformPoint = function(x, y, pt) {
			pt = pt||{};
			pt.x = x*this.a+y*this.c+this.tx;
			pt.y = x*this.b+y*this.d+this.ty;
			return pt;
		};
	
		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 * @return {Object} The target, or a new generic object with the transform properties applied.
		*/
		p.decompose = function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.tx;
			target.y = this.ty;
			target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
			target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
	
			var skewX = Math.atan2(-this.c, this.d);
			var skewY = Math.atan2(this.b, this.a);
	
			var delta = Math.abs(1-skewX/skewY);
			if (delta < 0.00001) { // effectively identical, can use rotation:
				target.rotation = skewY/Matrix2D.DEG_TO_RAD;
				if (this.a < 0 && this.d >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/Matrix2D.DEG_TO_RAD;
				target.skewY = skewY/Matrix2D.DEG_TO_RAD;
			}
			return target;
		};
		
		/**
		 * Copies all properties from the specified matrix to this matrix.
		 * @method copy
		 * @param {Matrix2D} matrix The matrix to copy properties from.
		 * @return {Matrix2D} This matrix. Useful for chaining method calls.
		*/
		p.copy = function(matrix) {
			return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		};
	
		/**
		 * Returns a clone of the Matrix2D instance.
		 * @method clone
		 * @return {Matrix2D} a clone of the Matrix2D instance.
		 **/
		p.clone = function() {
			return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
		};
	
		// this has to be populated after the class is defined:
		Matrix2D.identity = new Matrix2D();
	
	
		createjs.Matrix2D = Matrix2D;
	}());
	
	//##############################################################################
	// DisplayProps.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
		/**
		 * Used for calculating and encapsulating display related properties.
		 * @class DisplayProps
		 * @param {Number} [visible=true] Visible value.
		 * @param {Number} [alpha=1] Alpha value.
		 * @param {Number} [shadow=null] A Shadow instance or null.
		 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
		 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
		 * @constructor
		 **/
		function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
			this.setValues(visible, alpha, shadow, compositeOperation, matrix);
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * Property representing the alpha that will be applied to a display object.
			 * @property alpha
			 * @type Number
			 **/
		
			/**
			 * Property representing the shadow that will be applied to a display object.
			 * @property shadow
			 * @type Shadow
			 **/
		
			/**
			 * Property representing the compositeOperation that will be applied to a display object.
			 * You can find a list of valid composite operations at:
			 * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing</a>
			 * @property compositeOperation
			 * @type String
			 **/
			
			/**
			 * Property representing the value for visible that will be applied to a display object.
			 * @property visible
			 * @type Boolean
			 **/
			
			/**
			 * The transformation matrix that will be applied to a display object.
			 * @property matrix
			 * @type Matrix2D
			 **/
		}
		var p = DisplayProps.prototype;
	
	// initialization:
		/**
		 * Reinitializes the instance with the specified values.
		 * @method setValues
		 * @param {Number} [visible=true] Visible value.
		 * @param {Number} [alpha=1] Alpha value.
		 * @param {Number} [shadow=null] A Shadow instance or null.
		 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
		 * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
			this.visible = visible == null ? true : !!visible;
			this.alpha = alpha == null ? 1 : alpha;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			this.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();
			return this;
		};
	
	// public methods:
		/**
		 * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
		 * @method append
		 * @param {Boolean} visible desired visible value
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @param {Matrix2D} [matrix] a Matrix2D instance
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.append = function(visible, alpha, shadow, compositeOperation, matrix) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
			this.visible = this.visible && visible;
			matrix&&this.matrix.appendMatrix(matrix);
			return this;
		};
		
		/**
		 * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
		 * For example, to get the combined display properties that would be applied to a child, you could use:
		 * 
		 * 	var o = myDisplayObject;
		 * 	var props = new createjs.DisplayProps();
		 * 	do {
		 * 		// prepend each parent's props in turn:
		 * 		props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
		 * 	} while (o = o.parent);
		 * 	
		 * @method prepend
		 * @param {Boolean} visible desired visible value
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @param {Matrix2D} [matrix] a Matrix2D instance
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
			this.visible = this.visible && visible;
			matrix&&this.matrix.prependMatrix(matrix);
			return this;
		};
		
		/**
		 * Resets this instance and its matrix to default values.
		 * @method identity
		 * @return {DisplayProps} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.identity = function() {
			this.visible = true;
			this.alpha = 1;
			this.shadow = this.compositeOperation = null;
			this.matrix.identity();
			return this;
		};
		
		/**
		 * Returns a clone of the DisplayProps instance. Clones the associated matrix.
		 * @method clone
		 * @return {DisplayProps} a clone of the DisplayProps instance.
		 **/
		p.clone = function() {
			return new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());
		};
	
	// private methods:
	
		createjs.DisplayProps = DisplayProps;
	})();
	
	//##############################################################################
	// Point.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents a point on a 2 dimensional x / y coordinate system.
		 *
		 * <h4>Example</h4>
		 * 
		 *      var point = new createjs.Point(0, 100);
		 * 
		 * @class Point
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @constructor
		 **/
		function Point(x, y) {
		 	this.setValues(x, y);
		 	
		 	
		// public properties:
			// assigned in the setValues method.
			/**
			 * X position.
			 * @property x
			 * @type Number
			 **/
		
			/**
			 * Y position.
			 * @property y
			 * @type Number
			 **/
		}
		var p = Point.prototype;
		
	// public methods:
		/** 
		 * Sets the specified values on this instance.
		 * @method setValues
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @return {Point} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function(x, y) {
			this.x = x||0;
			this.y = y||0;
			return this;
		};
		
		/**
		 * Copies all properties from the specified point to this point.
		 * @method copy
		 * @param {Point} point The point to copy properties from.
		 * @return {Point} This point. Useful for chaining method calls.
		 * @chainable
		*/
		p.copy = function(point) {
			this.x = point.x;
			this.y = point.y;
			return this;
		};
		
		/**
		 * Returns a clone of the Point instance.
		 * @method clone
		 * @return {Point} a clone of the Point instance.
		 **/
		p.clone = function() {
			return new Point(this.x, this.y);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Point (x="+this.x+" y="+this.y+")]";
		};
		
		
		createjs.Point = Point;
	}());
	
	//##############################################################################
	// Rectangle.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).
		 *
		 * <h4>Example</h4>
		 *
		 *      var rect = new createjs.Rectangle(0, 0, 100, 100);
		 *
		 * @class Rectangle
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @param {Number} [width=0] The width of the Rectangle.
		 * @param {Number} [height=0] The height of the Rectangle.
		 * @constructor
		 **/
		function Rectangle(x, y, width, height) {
			this.setValues(x, y, width, height);
			
			
		// public properties:
			// assigned in the setValues method.
			/**
			 * X position.
			 * @property x
			 * @type Number
			 **/
		
			/**
			 * Y position.
			 * @property y
			 * @type Number
			 **/
		
			/**
			 * Width.
			 * @property width
			 * @type Number
			 **/
		
			/**
			 * Height.
			 * @property height
			 * @type Number
			 **/
		}
		var p = Rectangle.prototype;
	
	// public methods:
		/** 
		 * Sets the specified values on this instance.
		 * @method setValues
		 * @param {Number} [x=0] X position.
		 * @param {Number} [y=0] Y position.
		 * @param {Number} [width=0] The width of the Rectangle.
		 * @param {Number} [height=0] The height of the Rectangle.
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.setValues = function(x, y, width, height) {
			// don't forget to update docs in the constructor if these change:
			this.x = x||0;
			this.y = y||0;
			this.width = width||0;
			this.height = height||0;
			return this;
		};
		
		/** 
		 * Extends the rectangle's bounds to include the described point or rectangle.
		 * @method extend
		 * @param {Number} x X position of the point or rectangle.
		 * @param {Number} y Y position of the point or rectangle.
		 * @param {Number} [width=0] The width of the rectangle.
		 * @param {Number} [height=0] The height of the rectangle.
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.extend = function(x, y, width, height) {
			width = width||0;
			height = height||0;
			if (x+width > this.x+this.width) { this.width = x+width-this.x; }
			if (y+height > this.y+this.height) { this.height = y+height-this.y; }
			if (x < this.x) { this.width += this.x-x; this.x = x; }
			if (y < this.y) { this.height += this.y-y; this.y = y; }
			return this;
		};
		
		/** 
		 * Adds the specified padding to the rectangle's bounds.
		 * @method pad
		 * @param {Number} top
		 * @param {Number} left
		 * @param {Number} bottom
		 * @param {Number} right
		 * @return {Rectangle} This instance. Useful for chaining method calls.
		 * @chainable
		*/
		p.pad = function(top, left, bottom, right) {
			this.x -= left;
			this.y -= top;
			this.width += left+right;
			this.height += top+bottom;
			return this;
		};
		
		/**
		 * Copies all properties from the specified rectangle to this rectangle.
		 * @method copy
		 * @param {Rectangle} rectangle The rectangle to copy properties from.
		 * @return {Rectangle} This rectangle. Useful for chaining method calls.
		 * @chainable
		*/
		p.copy = function(rectangle) {
			return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
		};
		
		/** 
		 * Returns true if this rectangle fully encloses the described point or rectangle.
		 * @method contains
		 * @param {Number} x X position of the point or rectangle.
		 * @param {Number} y Y position of the point or rectangle.
		 * @param {Number} [width=0] The width of the rectangle.
		 * @param {Number} [height=0] The height of the rectangle.
		 * @return {Boolean} True if the described point or rectangle is contained within this rectangle.
		*/
		p.contains = function(x, y, width, height) {
			width = width||0;
			height = height||0;
			return (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);
		};
		
		/** 
		 * Returns a new rectangle which contains this rectangle and the specified rectangle.
		 * @method union
		 * @param {Rectangle} rect The rectangle to calculate a union with.
		 * @return {Rectangle} A new rectangle describing the union.
		*/
		p.union = function(rect) {
			return this.clone().extend(rect.x, rect.y, rect.width, rect.height);
		};
		
		/** 
		 * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,
		 * or null if they do not intersect.
		 * @method intersection
		 * @param {Rectangle} rect The rectangle to calculate an intersection with.
		 * @return {Rectangle} A new rectangle describing the intersection or null.
		*/
		p.intersection = function(rect) {
			var x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;
			if (this.x > x1) { x1 = this.x; }
			if (this.y > y1) { y1 = this.y; }
			if (this.x + this.width < x2) { x2 = this.x + this.width; }
			if (this.y + this.height < y2) { y2 = this.y + this.height; }
			return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);
		};
		
		/** 
		 * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.
		 * @method intersects
		 * @param {Rectangle} rect The rectangle to compare.
		 * @return {Boolean} True if the rectangles intersect.
		*/
		p.intersects = function(rect) {
			return (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);
		};
		
		/** 
		 * Returns true if the width or height are equal or less than 0.
		 * @method isEmpty
		 * @return {Boolean} True if the rectangle is empty.
		*/
		p.isEmpty = function() {
			return this.width <= 0 || this.height <= 0;
		};
		
		/**
		 * Returns a clone of the Rectangle instance.
		 * @method clone
		 * @return {Rectangle} a clone of the Rectangle instance.
		 **/
		p.clone = function() {
			return new Rectangle(this.x, this.y, this.width, this.height);
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";
		};
		
		
		createjs.Rectangle = Rectangle;
	}());
	
	//##############################################################################
	// ButtonHelper.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or
		 * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and
		 * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},
		 * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.
		 *
		 * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent
		 * garbage collection.
		 * 
		 * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 *
		 *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");
		 *      myInstance.addEventListener("click", handleClick);
		 *      function handleClick(event) {
		 *          // Click Happened.
		 *      }
		 *
		 * @class ButtonHelper
		 * @param {Sprite|MovieClip} target The instance to manage.
		 * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.
		 * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.
		 * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.
		 * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing
		 * states.
		 * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,
		 * then the button's visible states will be used instead. Note that the same instance as the "target" argument can be
		 * used for the hitState.
		 * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is
		 * null, then the default state of the hitArea will be used. *
		 * @constructor
		 */
		function ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {
			if (!target.addEventListener) { return; }
		
		
		// public properties:
			/**
			 * The target for this button helper.
			 * @property target
			 * @type MovieClip | Sprite
			 * @readonly
			 **/
			this.target = target;
		
			/**
			 * The label name or frame number to display when the user mouses out of the target. Defaults to "over".
			 * @property overLabel
			 * @type String | Number
			 **/
			this.overLabel = overLabel == null ? "over" : overLabel;
		
			/**
			 * The label name or frame number to display when the user mouses over the target. Defaults to "out".
			 * @property outLabel
			 * @type String | Number
			 **/
			this.outLabel = outLabel == null ? "out" : outLabel;
		
			/**
			 * The label name or frame number to display when the user presses on the target. Defaults to "down".
			 * @property downLabel
			 * @type String | Number
			 **/
			this.downLabel = downLabel == null ? "down" : downLabel;
		
			/**
			 * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.
			 * @property play
			 * @default false
			 * @type Boolean
			 **/
			this.play = play;
			
			
		//  private properties
			/**
			 * @property _isPressed
			 * @type Boolean
			 * @protected
			 **/
			this._isPressed = false;
		
			/**
			 * @property _isOver
			 * @type Boolean
			 * @protected
			 **/
			this._isOver = false;
		
			/**
			 * @property _enabled
			 * @type Boolean
			 * @protected
			 **/
			this._enabled = false;
			
		// setup:
			target.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.
			this.enabled = true;
			this.handleEvent({});
			if (hitArea) {
				if (hitLabel) {
					hitArea.actionsEnabled = false;
					hitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);
				}
				target.hitArea = hitArea;
			}
		}
		var p = ButtonHelper.prototype;
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
		 * @method setEnabled
		 * @param {Boolean} value The enabled property to set the instance to.
		 * @[rptected
		 * @protected
		 **/
		p._setEnabled = function(value) {
			if (value == this._enabled) { return; }
			var o = this.target;
			this._enabled = value;
			if (value) {
				o.cursor = "pointer";
				o.addEventListener("rollover", this);
				o.addEventListener("rollout", this);
				o.addEventListener("mousedown", this);
				o.addEventListener("pressup", this);
				if (o._reset) { o.__reset = o._reset; o._reset = this._reset;}
			} else {
				o.cursor = null;
				o.removeEventListener("rollover", this);
				o.removeEventListener("rollout", this);
				o.removeEventListener("mousedown", this);
				o.removeEventListener("pressup", this);
				if (o.__reset) { o._reset = o.__reset; delete(o.__reset); }
			}
		};
		// ButtonHelper.setEnabled is @deprecated. Remove for 1.1+
		p.setEnabled = createjs.deprecate(p._setEnabled, "ButtonHelper.setEnabled");
	
		/**
		 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
		 * @method getEnabled
		 * @protected
		 * @return {Boolean}
		 **/
		p._getEnabled = function() {
			return this._enabled;
		};
		// ButtonHelper.getEnabled is @deprecated. Remove for 1.1+
		p.getEnabled = createjs.deprecate(p._getEnabled, "ButtonHelper.getEnabled");
	
		/**
		 * Enables or disables the button functionality on the target.
		 * @property enabled
		 * @type {Boolean}
		 **/
		try {
			Object.defineProperties(p, {
				enabled: { get: p._getEnabled, set: p._setEnabled }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[ButtonHelper]";
		};
	
	
	// private methods:
		/**
		 * @method handleEvent
		 * @param {Object} evt The mouse event to handle.
		 * @protected
		 **/
		p.handleEvent = function(evt) {
			var label, t = this.target, type = evt.type;
			if (type == "mousedown") {
				this._isPressed = true;
				label = this.downLabel;
			} else if (type == "pressup") {
				this._isPressed = false;
				label = this._isOver ? this.overLabel : this.outLabel;
			} else if (type == "rollover") {
				this._isOver = true;
				label = this._isPressed ? this.downLabel : this.overLabel;
			} else { // rollout and default
				this._isOver = false;
				label = this._isPressed ? this.overLabel : this.outLabel;
			}
			if (this.play) {
				t.gotoAndPlay&&t.gotoAndPlay(label);
			} else {
				t.gotoAndStop&&t.gotoAndStop(label);
			}
		};
		
		/**
		 * Injected into target. Preserves the paused state through a reset.
		 * @method _reset
		 * @protected
		 **/
		p._reset = function() {
			// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.
			var p = this.paused;
			this.__reset();
			this.paused = p;
		};
	
	
		createjs.ButtonHelper = ButtonHelper;
	}());
	
	//##############################################################################
	// Shadow.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}
		 * via its <code>shadow</code> property.
		 *
		 * <h4>Example</h4>
		 *
		 *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
		 *
		 * @class Shadow
		 * @constructor
		 * @param {String} color The color of the shadow. This can be any valid CSS color value.
		 * @param {Number} offsetX The x offset of the shadow in pixels.
		 * @param {Number} offsetY The y offset of the shadow in pixels.
		 * @param {Number} blur The size of the blurring effect.
		 **/
		function Shadow(color, offsetX, offsetY, blur) {
			
			
		// public properties:
			/** 
			 * The color of the shadow. This can be any valid CSS color value.
			 * @property color
			 * @type String
			 * @default null
			 */
			this.color = color||"black";
		
			/** The x offset of the shadow.
			 * @property offsetX
			 * @type Number
			 * @default 0
			 */
			this.offsetX = offsetX||0;
		
			/** The y offset of the shadow.
			 * @property offsetY
			 * @type Number
			 * @default 0
			 */
			this.offsetY = offsetY||0;
		
			/** The blur of the shadow.
			 * @property blur
			 * @type Number
			 * @default 0
			 */
			this.blur = blur||0;
		}
		var p = Shadow.prototype;
	
	// static public properties:
		/**
		 * An identity shadow object (all properties are set to 0).
		 * @property identity
		 * @type Shadow
		 * @static
		 * @final
		 * @readonly
		 **/
		Shadow.identity = new Shadow("transparent", 0, 0, 0);
	
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Shadow]";
		};
	
		/**
		 * Returns a clone of this Shadow instance.
		 * @method clone
		 * @return {Shadow} A clone of the current Shadow instance.
		 **/
		p.clone = function() {
			return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
		};
		
	
		createjs.Shadow = Shadow;
	}());
	
	//##############################################################################
	// SpriteSheet.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually
		 * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100
		 * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).
		 *
		 * The data passed to the SpriteSheet constructor defines:
		 * <ol>
		 * 	<li> The source image or images to use.</li>
		 * 	<li> The positions of individual image frames.</li>
		 * 	<li> Sequences of frames that form named animations. Optional.</li>
		 * 	<li> The target playback framerate. Optional.</li>
		 * </ol>
		 * <h3>SpriteSheet Format</h3>
		 * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties
		 * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.
		 *
		 * <h4>images</h4>
		 * An array of source images. Images can be either an HTMlimage
		 * instance, or a uri to an image. The former is recommended to control preloading.
		 *
		 * 	images: [image1, "path/to/image2.png"],
		 *
		 * <h4>frames</h4>
		 * Defines the individual frames. There are two supported formats for frame data:
		 * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,
		 * and `count` properties.
		 *
		 * <ul>
		 *  <li>`width` & `height` are required and specify the dimensions of the frames</li>
		 *  <li>`regX` & `regY` indicate the registration point or "origin" of the frames</li>
		 *  <li>`spacing` indicate the spacing between frames</li>
		 *  <li>`margin` specify the margin around the image(s)</li>
		 *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will
		 *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned
		 *  indexes based on their position in the source images (left to right, top to bottom).</li>
		 * </ul>
		 *
		 *  	frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
		 *
		 * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array
		 * with 4 required and 3 optional entries, in the order:
		 *
		 * <ul>
		 *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>
		 *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>
		 *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>
		 * </ul>
		 *
		 * 	frames: [
		 * 		// x, y, width, height, imageIndex*, regX*, regY*
		 * 		[64, 0, 96, 64],
		 * 		[0, 0, 64, 64, 1, 32, 32]
		 * 		// etc.
		 * 	]
		 *
		 * <h4>animations</h4>
		 * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an
		 * animation of the same name. Each animation must specify the frames to play, and may
		 * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and
		 * the name of the `next` animation to sequence to after it completes.
		 *
		 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:
		 * <ol>
		 * 	<li>for a single frame animation, you can simply specify the frame index
		 *
		 * 		animations: {
		 * 			sit: 7
		 * 		}
		 *
		 * </li>
		 * <li>
		 *      for an animation of consecutive frames, you can use an array with two required, and two optional entries
		 * 		in the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.
		 *
		 * 		animations: {
		 * 			// start, end, next*, speed*
		 * 			run: [0, 8],
		 * 			jump: [9, 12, "run", 2]
		 * 		}
		 *
		 *  </li>
		 *  <li>
		 *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame
		 *     indexes to play in order. The object can also specify `next` and `speed` properties.
		 *
		 * 		animations: {
		 * 			walk: {
		 * 				frames: [1,2,3,3,2,1]
		 * 			},
		 * 			shoot: {
		 * 				frames: [1,4,5,6],
		 * 				next: "walk",
		 * 				speed: 0.5
		 * 			}
		 * 		}
		 *
		 *  </li>
		 * </ol>
		 * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`
		 * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in
		 * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.
		 *
		 * <h4>framerate</h4>
		 * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See
		 * {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.
		 *
		 * 		framerate: 20
		 *
		 * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
		 * event generated by the {{#crossLink "Ticker"}}{{/crossLink}}.
		 *
		 * 		createjs.Ticker.on("tick", handleTick);
		 * 		function handleTick(event) {
		 *			stage.update(event);
		 *		}
		 *
		 * <h3>Example</h3>
		 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three
		 * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing frame 6-8 and
		 * sequencing back to run.
		 *
		 * 		var data = {
		 * 			images: ["sprites.jpg"],
		 * 			frames: {width:50, height:50},
		 * 			animations: {
		 * 				stand:0,
		 * 				run:[1,5],
		 * 				jump:[6,8,"run"]
		 * 			}
		 * 		};
		 * 		var spriteSheet = new createjs.SpriteSheet(data);
		 * 		var animation = new createjs.Sprite(spriteSheet, "run");
		 *
		 * <h3>Generating SpriteSheet Images</h3>
		 * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or
		 * coordinates manually, however there are a number of tools that facilitate this.
		 * <ul>
		 *     <li>Exporting SpriteSheets or HTML5 content from Adobe Flash/Animate supports the EaselJS SpriteSheet format.</li>
		 *     <li>The popular <a href="https://www.codeandweb.com/texturepacker/easeljs" target="_blank">Texture Packer</a> has
		 *     EaselJS support.
		 *     <li>SWF animations in Adobe Flash/Animate can be exported to SpriteSheets using <a href="http://createjs.com/zoe" target="_blank">Zo&euml;</a></li>
		 * </ul>
		 *
		 * <h3>Cross Origin Issues</h3>
		 * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with
		 * using:
		 * <ul>
		 *     <li>a mouse</li>
		 *     <li>methods such as {{#crossLink "Container/getObjectUnderPoint"}}{{/crossLink}}</li>
		 *     <li>Filters (see {{#crossLink "Filter"}}{{/crossLink}})</li>
		 *     <li>caching (see {{#crossLink "DisplayObject/cache"}}{{/crossLink}})</li>
		 * </ul>
		 * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or
		 * setting the `crossOrigin` property on PreloadJS' LoadQueue or LoadItems.
		 *
		 * 		var image = new Image();
		 * 		img.crossOrigin="Anonymous";
		 * 		img.src = "http://server-with-CORS-support.com/path/to/image.jpg";
		 *
		 * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must
		 * support cross-origin requests, or this will not work. For more information, check out
		 * <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">CORS overview on MDN</a>.
		 *
		 * @class SpriteSheet
		 * @constructor
		 * @param {Object} data An object describing the SpriteSheet data.
		 * @extends EventDispatcher
		 **/
		function SpriteSheet(data) {
			this.EventDispatcher_constructor();
	
	
			// public properties:
			/**
			 * Indicates whether all images are finished loading.
			 * @property complete
			 * @type Boolean
			 * @readonly
			 **/
			this.complete = true;
	
			/**
			 * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class
			 * {{#crossLink "Sprite/framerate:property"}}{{/crossLink}} for more information.
			 * @property framerate
			 * @type Number
			 **/
			this.framerate = 0;
	
	
			// private properties:
			/**
			 * @property _animations
			 * @protected
			 * @type Array
			 **/
			this._animations = null;
	
			/**
			 * @property _frames
			 * @protected
			 * @type Array
			 **/
			this._frames = null;
	
			/**
			 * @property _images
			 * @protected
			 * @type Array
			 **/
			this._images = null;
	
			/**
			 * @property _data
			 * @protected
			 * @type Object
			 **/
			this._data = null;
	
			/**
			 * @property _loadCount
			 * @protected
			 * @type Number
			 **/
			this._loadCount = 0;
	
			// only used for simple frame defs:
			/**
			 * @property _frameHeight
			 * @protected
			 * @type Number
			 **/
			this._frameHeight = 0;
	
			/**
			 * @property _frameWidth
			 * @protected
			 * @type Number
			 **/
			this._frameWidth = 0;
	
			/**
			 * @property _numFrames
			 * @protected
			 * @type Number
			 **/
			this._numFrames = 0;
	
			/**
			 * @property _regX
			 * @protected
			 * @type Number
			 **/
			this._regX = 0;
	
			/**
			 * @property _regY
			 * @protected
			 * @type Number
			 **/
			this._regY = 0;
	
			/**
			 * @property _spacing
			 * @protected
			 * @type Number
			 **/
			this._spacing = 0;
	
			/**
			 * @property _margin
			 * @protected
			 * @type Number
			 **/
			this._margin = 0;
	
			// setup:
			this._parseData(data);
		}
		var p = createjs.extend(SpriteSheet, createjs.EventDispatcher);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// events:
		/**
		 * Dispatched when all images are loaded.  Note that this only fires if the images
		 * were not fully loaded when the sprite sheet was initialized. You should check the complete property
		 * to prior to adding a listener. Ex.
		 *
		 * 	var sheet = new createjs.SpriteSheet(data);
		 * 	if (!sheet.complete) {
		 * 		// not preloaded, listen for the complete event:
		 * 		sheet.addEventListener("complete", handler);
		 * 	}
		 *
		 * @event complete
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}
		 * when doing on-demand rendering.
		 * @event getframe
		 * @param {Number} index The frame index.
		 * @param {Object} frame The frame object that getFrame will return.
		 */
	
		/**
		 * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that
		 * encounters an error, and will still dispatch a {{#crossLink "SpriteSheet/complete:event"}}{{/crossLink}}
		 * event once all images are finished processing, even if an error is encountered.
		 * @event error
		 * @param {String} src The source of the image that failed to load.
		 * @since 0.8.2
		 */
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.
		 * @method _getAnimations
		 * @protected
		 * @return {Array}
		 **/
		p._getAnimations = function() {
			return this._animations.slice();
		};
		// SpriteSheet.getAnimations is @deprecated. Remove for 1.1+
		p.getAnimations = createjs.deprecate(p._getAnimations, "SpriteSheet.getAnimations");
	
		/**
		 * Returns an array of all available animation names available on this sprite sheet as strings.
		 * @property animations
		 * @type {Array}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				animations: { get: p._getAnimations }
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns the total number of frames in the specified animation, or in the whole sprite
		 * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and
		 * the images have not been fully loaded.
		 * @method getNumFrames
		 * @param {String} animation The name of the animation to get a frame count for.
		 * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.
		 */
		p.getNumFrames = function(animation) {
			if (animation == null) {
				return this._frames ? this._frames.length : this._numFrames || 0;
			} else {
				var data = this._data[animation];
				if (data == null) { return 0; }
				else { return data.frames.length; }
			}
		};
	
		/**
		 * Returns an object defining the specified animation. The returned object contains:<UL>
		 * 	<li>frames: an array of the frame ids in the animation</li>
		 * 	<li>speed: the playback speed for this animation</li>
		 * 	<li>name: the name of the animation</li>
		 * 	<li>next: the default animation to play next. If the animation loops, the name and next property will be the
		 * 	same.</li>
		 * </UL>
		 * @method getAnimation
		 * @param {String} name The name of the animation to get.
		 * @return {Object} a generic object with frames, speed, name, and next properties.
		 **/
		p.getAnimation = function(name) {
			return this._data[name];
		};
	
		/**
		 * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>
		 * 	<li>an image property holding a reference to the image object in which the frame is found</li>
		 * 	<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that
		 * 	image.</li>
		 * 	<li> A regX and regY property corresponding to the regX/Y values for the frame.
		 * </UL>
		 * @method getFrame
		 * @param {Number} frameIndex The index of the frame.
		 * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.
		 **/
		p.getFrame = function(frameIndex) {
			var frame;
			if (this._frames && (frame=this._frames[frameIndex])) { return frame; }
			return null;
		};
	
		/**
		 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative
		 * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:
		 *
		 * 	[x=-50, y=-40, width=90, height=70]
		 *
		 * @method getFrameBounds
		 * @param {Number} frameIndex The index of the frame.
		 * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.
		 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.
		 **/
		p.getFrameBounds = function(frameIndex, rectangle) {
			var frame = this.getFrame(frameIndex);
			return frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[SpriteSheet]";
		};
	
		/**
		 * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.
		 * @method clone
		 **/
		p.clone = function() {
			throw("SpriteSheet cannot be cloned.")
		};
	
	// private methods:
		/**
		 * @method _parseData
		 * @param {Object} data An object describing the SpriteSheet data.
		 * @protected
		 **/
		p._parseData = function(data) {
			var i,l,o,a;
			if (data == null) { return; }
	
			this.framerate = data.framerate||0;
	
			// parse images:
			if (data.images && (l=data.images.length) > 0) {
				a = this._images = [];
				for (i=0; i<l; i++) {
					var img = data.images[i];
					if (typeof img == "string") {
						var src = img;
						img = document.createElement("img");
						img.src = src;
					}
					a.push(img);
					if (!img.getContext && !img.naturalWidth) {
						this._loadCount++;
						this.complete = false;
						(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);
						(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);
					}
				}
			}
	
			// parse frames:
			if (data.frames == null) { // nothing
			} else if (Array.isArray(data.frames)) {
				this._frames = [];
				a = data.frames;
				for (i=0,l=a.length;i<l;i++) {
					var arr = a[i];
					this._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });
				}
			} else {
				o = data.frames;
				this._frameWidth = o.width;
				this._frameHeight = o.height;
				this._regX = o.regX||0;
				this._regY = o.regY||0;
				this._spacing = o.spacing||0;
				this._margin = o.margin||0;
				this._numFrames = o.count;
				if (this._loadCount == 0) { this._calculateFrames(); }
			}
	
			// parse animations:
			this._animations = [];
			if ((o=data.animations) != null) {
				this._data = {};
				var name;
				for (name in o) {
					var anim = {name:name};
					var obj = o[name];
					if (typeof obj == "number") { // single frame
						a = anim.frames = [obj];
					} else if (Array.isArray(obj)) { // simple
						if (obj.length == 1) { anim.frames = [obj[0]]; }
						else {
							anim.speed = obj[3];
							anim.next = obj[2];
							a = anim.frames = [];
							for (i=obj[0];i<=obj[1];i++) {
								a.push(i);
							}
						}
					} else { // complex
						anim.speed = obj.speed;
						anim.next = obj.next;
						var frames = obj.frames;
						a = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);
					}
					if (anim.next === true || anim.next === undefined) { anim.next = name; } // loop
					if (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop
					if (!anim.speed) { anim.speed = 1; }
					this._animations.push(name);
					this._data[name] = anim;
				}
			}
		};
	
		/**
		 * @method _handleImageLoad
		 * @protected
		 **/
		p._handleImageLoad = function(src) {
			if (--this._loadCount == 0) {
				this._calculateFrames();
				this.complete = true;
				this.dispatchEvent("complete");
			}
		};
	
		/**
		 * @method _handleImageError
		 * @protected
		 */
		p._handleImageError = function (src) {
			var errorEvent = new createjs.Event("error");
			errorEvent.src = src;
			this.dispatchEvent(errorEvent);
	
			// Complete is still dispatched.
			if (--this._loadCount == 0) {
				this.dispatchEvent("complete");
			}
		};
	
		/**
		 * @method _calculateFrames
		 * @protected
		 **/
		p._calculateFrames = function() {
			if (this._frames || this._frameWidth == 0) { return; }
	
			this._frames = [];
	
			var maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.
			var frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;
			var spacing = this._spacing, margin = this._margin;
			
			imgLoop:
			for (var i=0, imgs=this._images; i<imgs.length; i++) {
				var img = imgs[i], imgW = (img.width||img.naturalWidth), imgH = (img.height||img.naturalHeight);
	
				var y = margin;
				while (y <= imgH-margin-frameHeight) {
					var x = margin;
					while (x <= imgW-margin-frameWidth) {
						if (frameCount >= maxFrames) { break imgLoop; }
						frameCount++;
						this._frames.push({
								image: img,
								rect: new createjs.Rectangle(x, y, frameWidth, frameHeight),
								regX: this._regX,
								regY: this._regY
							});
						x += frameWidth+spacing;
					}
					y += frameHeight+spacing;
				}
			}
			this._numFrames = frameCount;
		};
	
	
		createjs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");
	}());
	
	//##############################################################################
	// Graphics.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
		 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}
		 * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the
		 * context of an EaselJS display list.
		 *
		 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
		 * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.
		 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
		 *
		 *      var g = new createjs.Graphics();
		 *      g.setStrokeStyle(1);
		 *      g.beginStroke("#000000");
		 *      g.beginFill("red");
		 *      g.drawCircle(0,0,30);
		 *
		 * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,
		 * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:
		 *
		 *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
		 *
		 * Each graphics API call generates a command object (see below). The last command to be created can be accessed via
		 * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:
		 *
		 *      var fillCommand = myGraphics.beginFill("red").command;
		 *      // ... later, update the fill style/color:
		 *      fillCommand.style = "blue";
		 *      // or change it to a bitmap fill:
		 *      fillCommand.bitmap(myImage);
		 *
		 * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you
		 * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
		 *
		 *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
		 *      myGraphics.append(createjs.Graphics.beginCmd);
		 *      // we need to define the path before applying the fill:
		 *      var circle = new createjs.Graphics.Circle(0,0,30);
		 *      myGraphics.append(circle);
		 *      // fill the path we just defined:
		 *      var fill = new createjs.Graphics.Fill("red");
		 *      myGraphics.append(fill);
		 *
		 * These approaches can be used together, for example to insert a custom command:
		 *
		 *      myGraphics.beginFill("red");
		 *      var customCommand = new CustomSpiralCommand(etc);
		 *      myGraphics.append(customCommand);
		 *      myGraphics.beginFill("blue");
		 *      myGraphics.drawCircle(0, 0, 30);
		 *
		 * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.
		 *
		 * <h4>Tiny API</h4>
		 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
		 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
		 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
		 * descriptions in the docs.
		 *
		 * <table>
		 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
		 *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>
		 *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>
		 *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>
		 *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>
		 *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>
		 *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>
		 *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>
		 *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>
		 *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>
		 *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>
		 *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>
		 *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>
		 *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>
		 *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>
		 *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>
		 *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>
		 *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>
		 *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>
		 *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>
		 *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>
		 *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>
		 *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>
		 *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>
		 *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>
		 * </table>
		 *
		 * Here is the above example, using the tiny API instead.
		 *
		 *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);
		 *
		 * @class Graphics
		 * @constructor
		 **/
		function Graphics() {
	
	
		// public properties
			/**
			 * Holds a reference to the last command that was created or appended. For example, you could retain a reference
			 * to a Fill command in order to dynamically update the color later by using:
			 *
			 * 		var myFill = myGraphics.beginFill("red").command;
			 * 		// update color later:
			 * 		myFill.style = "yellow";
			 *
			 * @property command
			 * @type Object
			 **/
			this.command = null;
	
	
		// private properties
			/**
			 * @property _stroke
			 * @protected
			 * @type {Stroke}
			 **/
			this._stroke = null;
	
			/**
			 * @property _strokeStyle
			 * @protected
			 * @type {StrokeStyle}
			 **/
			this._strokeStyle = null;
			
			/**
			 * @property _oldStrokeStyle
			 * @protected
			 * @type {StrokeStyle}
			 **/
			this._oldStrokeStyle = null;
			
			/**
			 * @property _strokeDash
			 * @protected
			 * @type {StrokeDash}
			 **/
			this._strokeDash = null;
			
			/**
			 * @property _oldStrokeDash
			 * @protected
			 * @type {StrokeDash}
			 **/
			this._oldStrokeDash = null;
	
			/**
			 * @property _strokeIgnoreScale
			 * @protected
			 * @type Boolean
			 **/
			this._strokeIgnoreScale = false;
	
			/**
			 * @property _fill
			 * @protected
			 * @type {Fill}
			 **/
			this._fill = null;
	
			/**
			 * @property _instructions
			 * @protected
			 * @type {Array}
			 **/
			this._instructions = [];
	
			/**
			 * Indicates the last instruction index that was committed.
			 * @property _commitIndex
			 * @protected
			 * @type {Number}
			 **/
			this._commitIndex = 0;
	
			/**
			 * Uncommitted instructions.
			 * @property _activeInstructions
			 * @protected
			 * @type {Array}
			 **/
			this._activeInstructions = [];
	
			/**
			 * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
			 * @property _dirty
			 * @protected
			 * @type {Boolean}
			 * @default false
			 **/
			this._dirty = false;
	
			/**
			 * Index to draw from if a store operation has happened.
			 * @property _storeIndex
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._storeIndex = 0;
	
		// setup:
			this.clear();
		}
		var p = Graphics.prototype;
		var G = Graphics; // shortcut
	
	// static public methods:
		/**
		 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
		 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,
		 *
		 *      createjs.Graphics.getRGB(50, 100, 150, 0.5);
		 *      // Returns "rgba(50,100,150,0.5)"
		 *
		 * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
		 * param. For example,
		 *
		 *      createjs.Graphics.getRGB(0xFF00FF, 0.2);
		 *      // Returns "rgba(255,0,255,0.2)"
		 *
		 * @method getRGB
		 * @static
		 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
		 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
		 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
		 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
		 * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
		 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
		 **/
		Graphics.getRGB = function(r, g, b, alpha) {
			if (r != null && b == null) {
				alpha = g;
				b = r&0xFF;
				g = r>>8&0xFF;
				r = r>>16&0xFF;
			}
			if (alpha == null) {
				return "rgb("+r+","+g+","+b+")";
			} else {
				return "rgba("+r+","+g+","+b+","+alpha+")";
			}
		};
	
		/**
		 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
		 * or if alpha is null then in the format "hsl(360,100,100)".
		 *
		 *      createjs.Graphics.getHSL(150, 100, 70);
		 *      // Returns "hsl(150,100,70)"
		 *
		 * @method getHSL
		 * @static
		 * @param {Number} hue The hue component for the color, between 0 and 360.
		 * @param {Number} saturation The saturation component for the color, between 0 and 100.
		 * @param {Number} lightness The lightness component for the color, between 0 and 100.
		 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
		 * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
		 * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
		 **/
		Graphics.getHSL = function(hue, saturation, lightness, alpha) {
			if (alpha == null) {
				return "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";
			} else {
				return "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";
			}
		};
	
	
	// static properties:
		/**
		 * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid
		 * unnecessary instantiation.
		 * @property beginCmd
		 * @type {Graphics.BeginPath}
		 * @static
		 **/
		 // defined at the bottom of this file.
	
		/**
		 * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.
		 * @property BASE_64
		 * @static
		 * @final
		 * @readonly
		 * @type {Object}
		 **/
		Graphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};
	
		/**
		 * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
		 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
		 * "butt", 1 to "round", and 2 to "square".
		 * For example, to set the line caps to "square":
		 *
		 *      myGraphics.ss(16, 2);
		 *
		 * @property STROKE_CAPS_MAP
		 * @static
		 * @final
		 * @readonly
		 * @type {Array}
		 **/
		Graphics.STROKE_CAPS_MAP = ["butt", "round", "square"];
	
		/**
		 * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
		 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
		 * "miter", 1 to "round", and 2 to "bevel".
		 * For example, to set the line joints to "bevel":
		 *
		 *      myGraphics.ss(16, 0, 2);
		 *
		 * @property STROKE_JOINTS_MAP
		 * @static
		 * @final
		 * @readonly
		 * @type {Array}
		 **/
		Graphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];
	
		/**
		 * @property _ctx
		 * @static
		 * @protected
		 * @type {CanvasRenderingContext2D}
		 **/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) {
			Graphics._ctx = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.
		 * @method _getInstructions
		 * @protected
		 * @return {Array} The instructions array, useful for chaining
		 **/
		p._getInstructions = function() {
			this._updateInstructions();
			return this._instructions;
		};
		// Graphics.getInstructions is @deprecated. Remove for 1.1+
		p.getInstructions = createjs.deprecate(p._getInstructions, "Graphics.getInstructions");
	
		/**
		 * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
		 * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
		 *
		 * This property is mainly intended for introspection of the instructions (ex. for graphics export).
		 * @property instructions
		 * @type {Array}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				instructions: { get: p._getInstructions }
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns true if this Graphics instance has no drawing commands.
		 * @method isEmpty
		 * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
		 **/
		p.isEmpty = function() {
			return !(this._instructions.length || this._activeInstructions.length);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
		 **/
		p.draw = function(ctx, data) {
			this._updateInstructions();
			var instr = this._instructions;
			for (var i=this._storeIndex, l=instr.length; i<l; i++) {
				instr[i].exec(ctx, data);
			}
		};
	
		/**
		 * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
		 * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method drawAsPath
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 **/
		p.drawAsPath = function(ctx) {
			this._updateInstructions();
			var instr, instrs = this._instructions;
			for (var i=this._storeIndex, l=instrs.length; i<l; i++) {
				// the first command is always a beginPath command.
				if ((instr = instrs[i]).path !== false) { instr.exec(ctx); }
			}
		};
	
	
	// public methods that map directly to context 2D calls:
		/**
		 * Moves the drawing point to the specified position. A tiny API method "mt" also exists.
		 * @method moveTo
		 * @param {Number} x The x coordinate the drawing point should move to.
		 * @param {Number} y The y coordinate the drawing point should move to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
		 * @chainable
		 **/
		p.moveTo = function(x, y) {
			return this.append(new G.MoveTo(x,y), true);
		};
	
		/**
		 * Draws a line from the current drawing point to the specified position, which become the new current drawing
		 * point. Note that you *must* call {{#crossLink "Graphics/moveTo"}}{{/crossLink}} before the first `lineTo()`.
		 * A tiny API method "lt" also exists.
		 *
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">
		 * whatwg spec</a>.
		 * @method lineTo
		 * @param {Number} x The x coordinate the drawing point should draw to.
		 * @param {Number} y The y coordinate the drawing point should draw to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.lineTo = function(x, y) {
			return this.append(new G.LineTo(x,y));
		};
	
		/**
		 * Draws an arc with the specified control points and radius.  For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">
		 * whatwg spec</a>. A tiny API method "at" also exists.
		 * @method arcTo
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.arcTo = function(x1, y1, x2, y2, radius) {
			return this.append(new G.ArcTo(x1, y1, x2, y2, radius));
		};
	
		/**
		 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For
		 * example, to draw a full circle with a radius of 20 centered at (100, 100):
		 *
		 *      arc(100, 100, 20, 0, Math.PI*2);
		 *
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.
		 * A tiny API method "a" also exists.
		 * @method arc
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle Measured in radians.
		 * @param {Number} endAngle Measured in radians.
		 * @param {Boolean} anticlockwise
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
			return this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));
		};
	
		/**
		 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed
		 * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">
		 * whatwg spec</a>. A tiny API method "qt" also exists.
		 * @method quadraticCurveTo
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.quadraticCurveTo = function(cpx, cpy, x, y) {
			return this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));
		};
	
		/**
		 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,
		 * cp2y). For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">
		 * whatwg spec</a>. A tiny API method "bt" also exists.
		 * @method bezierCurveTo
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
			return this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
		};
	
		/**
		 * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
		 * For detailed information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">
		 * whatwg spec</a>. A tiny API method "r" also exists.
		 * @method rect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.rect = function(x, y, w, h) {
			return this.append(new G.Rect(x, y, w, h));
		};
	
		/**
		 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
		 * since the fill or stroke was last set. A tiny API method "cp" also exists.
		 * @method closePath
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.closePath = function() {
			return this._activeInstructions.length ? this.append(new G.ClosePath()) : this;
		};
	
	
	// public methods that roughly map to Adobe Flash/Animate graphics APIs:
		/**
		 * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
		 * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.
		 * @method clear
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.clear = function() {
			this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
			this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
			this._dirty = this._strokeIgnoreScale = false;
			return this;
		};
	
		/**
		 * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.
		 * @method beginFill
		 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no fill.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginFill = function(color) {
			return this._setFill(color ? new G.Fill(color) : null);
		};
	
		/**
		 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
		 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
		 * square to display it:
		 *
		 *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
		 *
		 * A tiny API method "lf" also exists.
		 * @method beginLinearGradientFill
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
		 * drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
		 * the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
			return this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
		};
	
		/**
		 * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to
		 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:
		 *
		 *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
		 *
		 * A tiny API method "rf" also exists.
		 * @method beginRadialGradientFill
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			return this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
		};
	
		/**
		 * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also
		 * exists.
		 * @method beginBitmapFill
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
		 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
		 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
		 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
		 * will be applied relative to the parent transform.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginBitmapFill = function(image, repetition, matrix) {
			return this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));
		};
	
		/**
		 * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.
		 * A tiny API method "ef" also exists.
		 * @method endFill
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.endFill = function() {
			return this.beginFill();
		};
	
		/**
		 * Sets the stroke style. Like all drawing methods, this can be chained, so you can define
		 * the stroke style and color in a single line of code like so:
		 *
		 * 	myGraphics.setStrokeStyle(8,"round").beginStroke("#F00");
		 *
		 * A tiny API method "ss" also exists.
		 * @method setStrokeStyle
		 * @param {Number} thickness The width of the stroke.
		 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
		 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
		 * the tiny API.
		 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
		 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
		 * for use with the tiny API.
		 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
		 * controls at what point a mitered joint will be clipped.
		 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
		 * of active transformations.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {
			this._updateInstructions(true);
			this._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);
	
			// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
			if (this._stroke) { this._stroke.ignoreScale = ignoreScale; }
			this._strokeIgnoreScale = ignoreScale;
			return this;
		};
		
		/**
		 * Sets or clears the stroke dash pattern.
		 *
		 * 	myGraphics.setStrokeDash([20, 10], 0);
		 *
		 * A tiny API method `sd` also exists.
		 * @method setStrokeDash
		 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
		 * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
		 * Passing null or an empty array will clear the existing stroke dash.
		 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.setStrokeDash = function(segments, offset) {
			this._updateInstructions(true);
			this._strokeDash = this.command = new G.StrokeDash(segments, offset);
			return this;
		};
	
		/**
		 * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.
		 * @method beginStroke
		 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no stroke.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginStroke = function(color) {
			return this._setStroke(color ? new G.Stroke(color) : null);
		};
	
		/**
		 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
		 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
		 * square to display it:
		 *
		 *      myGraphics.setStrokeStyle(10).
		 *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
		 *
		 * A tiny API method "ls" also exists.
		 * @method beginLinearGradientStroke
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
			return this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
		};
	
		/**
		 * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to
		 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:
		 *
		 *      myGraphics.setStrokeStyle(10)
		 *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
		 *          .drawRect(50, 90, 150, 110);
		 *
		 * A tiny API method "rs" also exists.
		 * @method beginRadialGradientStroke
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
		 * to 100%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			return this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
		};
	
		/**
		 * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
		 * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"
		 * also exists.
		 * @method beginBitmapStroke
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
		 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.beginBitmapStroke = function(image, repetition) {
			// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
			return this._setStroke(new G.Stroke().bitmap(image, repetition));
		};
	
		/**
		 * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.
		 * A tiny API method "es" also exists.
		 * @method endStroke
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.endStroke = function() {
			return this.beginStroke();
		};
	
		/**
		 * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}
		 * method.
		 * @method curveTo
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.curveTo = p.quadraticCurveTo;
	
		/**
		 *
		 * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}
		 * method.
		 * @method drawRect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRect = p.rect;
	
		/**
		 * Draws a rounded rectangle with all corners with the specified radius.
		 * @method drawRoundRect
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radius Corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRoundRect = function(x, y, w, h, radius) {
			return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
		};
	
		/**
		 * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API
		 * method "rc" also exists.
		 * @method drawRoundRectComplex
		 * @param {Number} x The horizontal coordinate to draw the round rect.
		 * @param {Number} y The vertical coordinate to draw the round rect.
		 * @param {Number} w The width of the round rect.
		 * @param {Number} h The height of the round rect.
		 * @param {Number} radiusTL Top left corner radius.
		 * @param {Number} radiusTR Top right corner radius.
		 * @param {Number} radiusBR Bottom right corner radius.
		 * @param {Number} radiusBL Bottom left corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
			return this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
		};
	
		/**
		 * Draws a circle with the specified radius at (x, y).
		 *
		 *      var g = new createjs.Graphics();
		 *	    g.setStrokeStyle(1);
		 *	    g.beginStroke(createjs.Graphics.getRGB(0,0,0));
		 *	    g.beginFill(createjs.Graphics.getRGB(255,0,0));
		 *	    g.drawCircle(0,0,3);
		 *
		 *	    var s = new createjs.Shape(g);
		 *		s.x = 100;
		 *		s.y = 100;
		 *
		 *	    stage.addChild(s);
		 *	    stage.update();
		 *
		 * A tiny API method "dc" also exists.
		 * @method drawCircle
		 * @param {Number} x x coordinate center point of circle.
		 * @param {Number} y y coordinate center point of circle.
		 * @param {Number} radius Radius of circle.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawCircle = function(x, y, radius) {
			return this.append(new G.Circle(x, y, radius));
		};
	
		/**
		 * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},
		 * except the width and height can be different. A tiny API method "de" also exists.
		 * @method drawEllipse
		 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from center.
		 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from the center.
		 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
		 * number.
		 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawEllipse = function(x, y, w, h) {
			return this.append(new G.Ellipse(x, y, w, h));
		};
	
		/**
		 * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of
		 * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a
		 * radius of 50:
		 *
		 *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
		 *      // Note: -90 makes the first point vertical
		 *
		 * A tiny API method "dp" also exists.
		 *
		 * @method drawPolyStar
		 * @param {Number} x Position of the center of the shape.
		 * @param {Number} y Position of the center of the shape.
		 * @param {Number} radius The outer radius of the shape.
		 * @param {Number} sides The number of points on the star or sides on the polygon.
		 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
		 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
		 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
		 * directly to the right of the center.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
			return this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));
		};
	
		/**
		 * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
		 * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
		 * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.
		 *
		 * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
		 * built-in or custom graphics commands. For example:
		 *
		 * 		// attach data to our shape, so we can access it during the draw:
		 * 		myShape.color = "red";
		 *
		 * 		// append a Circle command object:
		 * 		myShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));
		 *
		 * 		// append a custom command object with an exec method that sets the fill style
		 * 		// based on the shape's data, and then fills the circle.
		 * 		myShape.graphics.append({exec:function(ctx, shape) {
		 * 			ctx.fillStyle = shape.color;
		 * 			ctx.fill();
		 * 		}});
		 *
		 * @method append
		 * @param {Object} command A graphics command object exposing an "exec" method.
		 * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.append = function(command, clean) {
			this._activeInstructions.push(command);
			this.command = command;
			if (!clean) { this._dirty = true; }
			return this;
		};
	
		/**
		 * Decodes a compact encoded path string into a series of draw instructions.
		 * This format is not intended to be human readable, and is meant for use by authoring tools.
		 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
		 * commands.
		 *
		 * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
		 * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
		 * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
		 * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
		 * latter. Bits 5 and 6 are currently unused.
		 *
		 * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
		 * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
		 * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
		 * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
		 * case of move operations which are absolute, this value is a delta from the previous x or y position (as
		 * appropriate).
		 *
		 * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
		 * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
		 * parameter.
		 * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
		 * indicate 1500 tenths of a pixel.
		 * <br />AA - 000000000000. Absolute y position of 0.
		 * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
		 * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
		 * provide an absolute position of +150.0px.
		 * <br />AAA - 000000000000000000. A y delta value of 0.
		 *
		 * A tiny API method "p" also exists.
		 * @method decodePath
		 * @param {String} str The path string to decode.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.decodePath = function(str) {
			var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
			var paramCount = [2, 2, 4, 6, 0];
			var i=0, l=str.length;
			var params = [];
			var x=0, y=0;
			var base64 = Graphics.BASE_64;
	
			while (i<l) {
				var c = str.charAt(i);
				var n = base64[c];
				var fi = n>>3; // highest order bits 1-3 code for operation.
				var f = instructions[fi];
				// check that we have a valid instruction & that the unused bits are empty:
				if (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }
				var pl = paramCount[fi];
				if (!fi) { x=y=0; } // move operations reset the position.
				params.length = 0;
				i++;
				var charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.
				for (var p=0; p<pl; p++) {
					var num = base64[str.charAt(i)];
					var sign = (num>>5) ? -1 : 1;
					num = ((num&31)<<6)|(base64[str.charAt(i+1)]);
					if (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }
					num = sign*num/10;
					if (p%2) { x = (num += x); }
					else { y = (num += y); }
					params[p] = num;
					i += charCount;
				}
				f.apply(this,params);
			}
			return this;
		};
	
		/**
		 * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
		 * the existing store. This also affects `drawAsPath()`.
		 *
		 * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
		 * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
		 * of the vector instructions for later use (ex. scaling, modifying, or exporting).
		 *
		 * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
		 * the fill or stroke.
		 *
		 * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
		 * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},
		 * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.
		 *
		 * 	// set up cache:
		 * 	myShape.cache(0,0,500,500,scale);
		 *
		 * 	// when the user drags, draw a new line:
		 * 	myShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
		 * 	// then draw it into the existing cache:
		 * 	myShape.updateCache("source-over");
		 * 	// store the new line, so it isn't redrawn next time:
		 * 	myShape.store();
		 *
		 * 	// then, when the window resizes, we can re-render at a different scale:
		 * 	// first, unstore all our lines:
		 * 	myShape.unstore();
		 * 	// then cache using the new scale:
		 * 	myShape.cache(0,0,500,500,newScale);
		 * 	// finally, store the existing commands again:
		 * 	myShape.store();
		 *
		 * @method store
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.store = function() {
			this._updateInstructions(true);
			this._storeIndex = this._instructions.length;
			return this;
		};
	
		/**
		 * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}
		 * so that they will be executed in subsequent draw calls.
		 *
		 * @method unstore
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.unstore = function() {
			this._storeIndex = 0;
			return this;
		};
	
		/**
		 * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
		 * @method clone
		 * @return {Graphics} A clone of the current Graphics instance.
		 **/
		p.clone = function() {
			var o = new Graphics();
			o.command = this.command;
			o._stroke = this._stroke;
			o._strokeStyle = this._strokeStyle;
			o._strokeDash = this._strokeDash;
			o._strokeIgnoreScale = this._strokeIgnoreScale;
			o._fill = this._fill;
			o._instructions = this._instructions.slice();
			o._commitIndex = this._commitIndex;
			o._activeInstructions = this._activeInstructions.slice();
			o._dirty = this._dirty;
			o._storeIndex = this._storeIndex;
			return o;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Graphics]";
		};
	
	
	// tiny API:
		/**
		 * Shortcut to moveTo.
		 * @method mt
		 * @param {Number} x The x coordinate the drawing point should move to.
		 * @param {Number} y The y coordinate the drawing point should move to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
		 * @chainable
		 * @protected
		 **/
		p.mt = p.moveTo;
	
		/**
		 * Shortcut to lineTo.
		 * @method lt
		 * @param {Number} x The x coordinate the drawing point should draw to.
		 * @param {Number} y The y coordinate the drawing point should draw to.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.lt = p.lineTo;
	
		/**
		 * Shortcut to arcTo.
		 * @method at
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.at = p.arcTo;
	
		/**
		 * Shortcut to bezierCurveTo.
		 * @method bt
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bt = p.bezierCurveTo;
	
		/**
		 * Shortcut to quadraticCurveTo / curveTo.
		 * @method qt
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 * @chainable
		 **/
		p.qt = p.quadraticCurveTo;
	
		/**
		 * Shortcut to arc.
		 * @method a
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle Measured in radians.
		 * @param {Number} endAngle Measured in radians.
		 * @param {Boolean} anticlockwise
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @protected
		 * @chainable
		 **/
		p.a = p.arc;
	
		/**
		 * Shortcut to rect.
		 * @method r
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.r = p.rect;
	
		/**
		 * Shortcut to closePath.
		 * @method cp
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.cp = p.closePath;
	
		/**
		 * Shortcut to clear.
		 * @method c
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.c = p.clear;
	
		/**
		 * Shortcut to beginFill.
		 * @method f
		 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no fill.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.f = p.beginFill;
	
		/**
		 * Shortcut to beginLinearGradientFill.
		 * @method lf
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
		 * drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
		 * the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.lf = p.beginLinearGradientFill;
	
		/**
		 * Shortcut to beginRadialGradientFill.
		 * @method rf
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rf = p.beginRadialGradientFill;
	
		/**
		 * Shortcut to beginBitmapFill.
		 * @method bf
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern.
		 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
		 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
		 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
		 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
		 * will be applied relative to the parent transform.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bf = p.beginBitmapFill;
	
		/**
		 * Shortcut to endFill.
		 * @method ef
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ef = p.endFill;
	
		/**
		 * Shortcut to setStrokeStyle.
		 * @method ss
		 * @param {Number} thickness The width of the stroke.
		 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
		 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
		 * the tiny API.
		 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
		 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
		 * for use with the tiny API.
		 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
		 * controls at what point a mitered joint will be clipped.
		 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
		 * of active transformations.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ss = p.setStrokeStyle;
		
		/**
		 * Shortcut to setStrokeDash.
		 * @method sd
		 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
		 * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.
		 * Passing null or an empty array will clear any existing dash.
		 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.sd = p.setStrokeDash;
	
		/**
		 * Shortcut to beginStroke.
		 * @method s
		 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
		 * null will result in no stroke.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.s = p.beginStroke;
	
		/**
		 * Shortcut to beginLinearGradientStroke.
		 * @method ls
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
		 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
		 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
		 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.ls = p.beginLinearGradientStroke;
	
		/**
		 * Shortcut to beginRadialGradientStroke.
		 * @method rs
		 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
		 * a gradient drawing from red to blue.
		 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
		 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
		 * to 100%.
		 * @param {Number} x0 Center position of the inner circle that defines the gradient.
		 * @param {Number} y0 Center position of the inner circle that defines the gradient.
		 * @param {Number} r0 Radius of the inner circle that defines the gradient.
		 * @param {Number} x1 Center position of the outer circle that defines the gradient.
		 * @param {Number} y1 Center position of the outer circle that defines the gradient.
		 * @param {Number} r1 Radius of the outer circle that defines the gradient.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rs = p.beginRadialGradientStroke;
	
		/**
		 * Shortcut to beginBitmapStroke.
		 * @method bs
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
		 * as the pattern.
		 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
		 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.bs = p.beginBitmapStroke;
	
		/**
		 * Shortcut to endStroke.
		 * @method es
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.es = p.endStroke;
	
		/**
		 * Shortcut to drawRect.
		 * @method dr
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w Width of the rectangle
		 * @param {Number} h Height of the rectangle
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dr = p.drawRect;
	
		/**
		 * Shortcut to drawRoundRect.
		 * @method rr
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radius Corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rr = p.drawRoundRect;
	
		/**
		 * Shortcut to drawRoundRectComplex.
		 * @method rc
		 * @param {Number} x The horizontal coordinate to draw the round rect.
		 * @param {Number} y The vertical coordinate to draw the round rect.
		 * @param {Number} w The width of the round rect.
		 * @param {Number} h The height of the round rect.
		 * @param {Number} radiusTL Top left corner radius.
		 * @param {Number} radiusTR Top right corner radius.
		 * @param {Number} radiusBR Bottom right corner radius.
		 * @param {Number} radiusBL Bottom left corner radius.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.rc = p.drawRoundRectComplex;
	
		/**
		 * Shortcut to drawCircle.
		 * @method dc
		 * @param {Number} x x coordinate center point of circle.
		 * @param {Number} y y coordinate center point of circle.
		 * @param {Number} radius Radius of circle.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dc = p.drawCircle;
	
		/**
		 * Shortcut to drawEllipse.
		 * @method de
		 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from center.
		 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
		 * which draws from the center.
		 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
		 * number.
		 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.de = p.drawEllipse;
	
		/**
		 * Shortcut to drawPolyStar.
		 * @method dp
		 * @param {Number} x Position of the center of the shape.
		 * @param {Number} y Position of the center of the shape.
		 * @param {Number} radius The outer radius of the shape.
		 * @param {Number} sides The number of points on the star or sides on the polygon.
		 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
		 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
		 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
		 * directly to the right of the center.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.dp = p.drawPolyStar;
	
		/**
		 * Shortcut to decodePath.
		 * @method p
		 * @param {String} str The path string to decode.
		 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
		 * @chainable
		 * @protected
		 **/
		p.p = p.decodePath;
	
	
	// private methods:
		/**
		 * @method _updateInstructions
		 * @param commit
		 * @protected
		 **/
		p._updateInstructions = function(commit) {
			var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;
	
			if (this._dirty && active.length) {
				instr.length = commitIndex; // remove old, uncommitted commands
				instr.push(Graphics.beginCmd);
	
				var l = active.length, ll = instr.length;
				instr.length = ll+l;
				for (var i=0; i<l; i++) { instr[i+ll] = active[i]; }
	
				if (this._fill) { instr.push(this._fill); }
				if (this._stroke) {
					// doesn't need to be re-applied if it hasn't changed.
					if (this._strokeDash !== this._oldStrokeDash) {
						instr.push(this._strokeDash);
					}
					if (this._strokeStyle !== this._oldStrokeStyle) {
						instr.push(this._strokeStyle);
					}
					if (commit) {
						this._oldStrokeStyle = this._strokeStyle;
						this._oldStrokeDash = this._strokeDash;
					}
					instr.push(this._stroke);
				}
	
				this._dirty = false;
			}
	
			if (commit) {
				active.length = 0;
				this._commitIndex = instr.length;
			}
		};
	
		/**
		 * @method _setFill
		 * @param fill
		 * @protected
		 **/
		p._setFill = function(fill) {
			this._updateInstructions(true);
			this.command = this._fill = fill;
			return this;
		};
	
		/**
		 * @method _setStroke
		 * @param stroke
		 * @protected
		 **/
		p._setStroke = function(stroke) {
			this._updateInstructions(true);
			if (this.command = this._stroke = stroke) {
				stroke.ignoreScale = this._strokeIgnoreScale;
			}
			return this;
		};
	
	// Command Objects:
		/**
		 * @namespace Graphics
		 */
		/**
		 * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class LineTo
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.LineTo = function(x, y) {
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class MoveTo
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx
		 */
		(G.MoveTo = function(x, y) {
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };
	
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class ArcTo
		 * @constructor
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} x2
		 * @param {Number} y2
		 * @param {Number} radius
		 **/
		/**
		 * @property x1
		 * @type Number
		 */
		/**
		 * @property y1
		 * @type Number
		 */
		/**
		 * @property x2
		 * @type Number
		 */
		/**
		 * @property y2
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.ArcTo = function(x1, y1, x2, y2, radius) {
			this.x1 = x1; this.y1 = y1;
			this.x2 = x2; this.y2 = y2;
			this.radius = radius;
		}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Arc
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} startAngle
		 * @param {Number} endAngle
		 * @param {Number} anticlockwise
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * @property startAngle
		 * @type Number
		 */
		/**
		 * @property endAngle
		 * @type Number
		 */
		/**
		 * @property anticlockwise
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
			this.x = x; this.y = y;
			this.radius = radius;
			this.startAngle = startAngle; this.endAngle = endAngle;
			this.anticlockwise = !!anticlockwise;
		}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class QuadraticCurveTo
		 * @constructor
		 * @param {Number} cpx
		 * @param {Number} cpy
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property cpx
		 * @type Number
		 */
		/**
		 * @property cpy
		 * @type Number
		 */
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.QuadraticCurveTo = function(cpx, cpy, x, y) {
			this.cpx = cpx; this.cpy = cpy;
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class BezierCurveTo
		 * @constructor
		 * @param {Number} cp1x
		 * @param {Number} cp1y
		 * @param {Number} cp2x
		 * @param {Number} cp2y
		 * @param {Number} x
		 * @param {Number} y
		 **/
		/**
		 * @property cp1x
		 * @type Number
		 */
		/**
		 * @property cp1y
		 * @type Number
		 */
		/**
		 * @property cp2x
		 * @type Number
		 */
		/**
		 * @property cp2y
		 * @type Number
		 */
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
			this.cp1x = cp1x; this.cp1y = cp1y;
			this.cp2x = cp2x; this.cp2y = cp2y;
			this.x = x; this.y = y;
		}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Rect
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Rect = function(x, y, w, h) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
		}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class ClosePath
		 * @constructor
		 **/
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.ClosePath = function() {
		}).prototype.exec = function(ctx) { ctx.closePath(); };
	
		/**
		 * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class BeginPath
		 * @constructor
		 **/
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.BeginPath = function() {
		}).prototype.exec = function(ctx) { ctx.beginPath(); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Fill
		 * @constructor
		 * @param {Object} style A valid Context2D fillStyle.
		 * @param {Matrix2D} matrix
		 **/
		/**
		 * A valid Context2D fillStyle.
		 * @property style
		 * @type Object
		 */
		/**
		 * @property matrix
		 * @type Matrix2D
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.Fill = function(style, matrix) {
			this.style = style;
			this.matrix = matrix;
		}).prototype;
		p.exec = function(ctx) {
			if (!this.style) { return; }
			ctx.fillStyle = this.style;
			var mtx = this.matrix;
			if (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }
			ctx.fill();
			if (mtx) { ctx.restore(); }
		};
		/**
		 * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.
		 * @method linearGradient
		 * @param {Array} colors
		 *
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.linearGradient = function(colors, ratios, x0, y0, x1, y1) {
			var o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
			for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
			o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};
			return this;
		};
		/**
		 * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.
		 * @method radialGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} r0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} r1
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
			var o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
			for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
			o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};
			return this;
		};
		/**
		 * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.
		 * @method bitmap
		 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
		 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
		 * @return {Fill} Returns this Fill object for chaining or assignment.
		 */
		p.bitmap = function(image, repetition) {
			if (image.naturalWidth || image.getContext || image.readyState >= 2) {
				var o = this.style = Graphics._ctx.createPattern(image, repetition || "");
				o.props = {image: image, repetition: repetition, type: "bitmap"};
			}
			return this;
		};
		p.path = false;
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Stroke
		 * @constructor
		 * @param {Object} style A valid Context2D fillStyle.
		 * @param {Boolean} ignoreScale
		 **/
		/**
		 * A valid Context2D strokeStyle.
		 * @property style
		 * @type Object
		 */
		/**
		 * @property ignoreScale
		 * @type Boolean
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.Stroke = function(style, ignoreScale) {
			this.style = style;
			this.ignoreScale = ignoreScale;
		}).prototype;
		p.exec = function(ctx) {
			if (!this.style) { return; }
			ctx.strokeStyle = this.style;
			if (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }
			ctx.stroke();
			if (this.ignoreScale) { ctx.restore(); }
		};
		/**
		 * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.
		 * @method linearGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.linearGradient = G.Fill.prototype.linearGradient;
		/**
		 * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.
		 * @method radialGradient
		 * @param {Array} colors
		 * @param {Array} ratios
		 * @param {Number} x0
		 * @param {Number} y0
		 * @param {Number} r0
		 * @param {Number} x1
		 * @param {Number} y1
		 * @param {Number} r1
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.radialGradient = G.Fill.prototype.radialGradient;
		/**
		 * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
		 * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.
		 * @method bitmap
		 * @param {HTMLImageElement} image
		 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
		 * @return {Fill} Returns this Stroke object for chaining or assignment.
		 */
		p.bitmap = G.Fill.prototype.bitmap;
		p.path = false;
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class StrokeStyle
		 * @constructor
		 * @param {Number} width
		 * @param {String} [caps=butt]
		 * @param {String} [joints=miter]
		 * @param {Number} [miterLimit=10]
		 * @param {Boolean} [ignoreScale=false]
		 **/
		/**
		 * @property width
		 * @type Number
		 */
		/**
		 * One of: butt, round, square
		 * @property caps
		 * @type String
		 */
		/**
		 * One of: round, bevel, miter
		 * @property joints
		 * @type String
		 */
		/**
		 * @property miterLimit
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		p = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {
			this.width = width;
			this.caps = caps;
			this.joints = joints;
			this.miterLimit = miterLimit;
			this.ignoreScale = ignoreScale;
		}).prototype;
		p.exec = function(ctx) {
			ctx.lineWidth = (this.width == null ? "1" : this.width);
			ctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));
			ctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));
			ctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);
			ctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);
		};
		p.path = false;
		
		/**
		 * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class StrokeDash
		 * @constructor
		 * @param {Array} [segments]
		 * @param {Number} [offset=0]
		 **/
		/**
		 * @property segments
		 * @type Array
		 */
		/**
		 * @property offset
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.StrokeDash = function(segments, offset) {
			this.segments = segments;
			this.offset = offset||0;
		}).prototype.exec = function(ctx) {
			if (ctx.setLineDash) { // feature detection.
				ctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.
				ctx.lineDashOffset = this.offset||0;
			}
		};
		/**
		 * The default value for segments (ie. no dash).
		 * @property EMPTY_SEGMENTS
		 * @static
		 * @final
		 * @readonly
		 * @protected
		 * @type {Array}
		 **/
		G.StrokeDash.EMPTY_SEGMENTS = [];
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class RoundRect
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 * @param {Number} radiusTL
		 * @param {Number} radiusTR
		 * @param {Number} radiusBR
		 * @param {Number} radiusBL
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * @property radiusTL
		 * @type Number
		 */
		/**
		 * @property radiusTR
		 * @type Number
		 */
		/**
		 * @property radiusBR
		 * @type Number
		 */
		/**
		 * @property radiusBL
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
			this.radiusTL = radiusTL; this.radiusTR = radiusTR;
			this.radiusBR = radiusBR; this.radiusBL = radiusBL;
		}).prototype.exec = function(ctx) {
			var max = (w<h?w:h)/2;
			var mTL=0, mTR=0, mBR=0, mBL=0;
			var x = this.x, y = this.y, w = this.w, h = this.h;
			var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;
	
			if (rTL < 0) { rTL *= (mTL=-1); }
			if (rTL > max) { rTL = max; }
			if (rTR < 0) { rTR *= (mTR=-1); }
			if (rTR > max) { rTR = max; }
			if (rBR < 0) { rBR *= (mBR=-1); }
			if (rBR > max) { rBR = max; }
			if (rBL < 0) { rBL *= (mBL=-1); }
			if (rBL > max) { rBL = max; }
	
			ctx.moveTo(x+w-rTR, y);
			ctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);
			ctx.lineTo(x+w, y+h-rBR);
			ctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);
			ctx.lineTo(x+rBL, y+h);
			ctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);
			ctx.lineTo(x, y+rTL);
			ctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);
			ctx.closePath();
		};
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Circle
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Circle = function(x, y, radius) {
			this.x = x; this.y = y;
			this.radius = radius;
		}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class Ellipse
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} w
		 * @param {Number} h
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property w
		 * @type Number
		 */
		/**
		 * @property h
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.Ellipse = function(x, y, w, h) {
			this.x = x; this.y = y;
			this.w = w; this.h = h;
		}).prototype.exec = function(ctx) {
			var x = this.x, y = this.y;
			var w = this.w, h = this.h;
	
			var k = 0.5522848;
			var ox = (w / 2) * k;
			var oy = (h / 2) * k;
			var xe = x + w;
			var ye = y + h;
			var xm = x + w / 2;
			var ym = y + h / 2;
	
			ctx.moveTo(x, ym);
			ctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);
			ctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);
			ctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);
			ctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);
		};
	
		/**
		 * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
		 * @class PolyStar
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} radius
		 * @param {Number} sides
		 * @param {Number} pointSize
		 * @param {Number} angle
		 **/
		/**
		 * @property x
		 * @type Number
		 */
		/**
		 * @property y
		 * @type Number
		 */
		/**
		 * @property radius
		 * @type Number
		 */
		/**
		 * @property sides
		 * @type Number
		 */
		/**
		 * @property pointSize
		 * @type Number
		 */
		/**
		 * @property angle
		 * @type Number
		 */
		/**
		 * Execute the Graphics command in the provided Canvas context.
		 * @method exec
		 * @param {CanvasRenderingContext2D} ctx The canvas rendering context
		 */
		(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {
			this.x = x; this.y = y;
			this.radius = radius;
			this.sides = sides;
			this.pointSize = pointSize;
			this.angle = angle;
		}).prototype.exec = function(ctx) {
			var x = this.x, y = this.y;
			var radius = this.radius;
			var angle = (this.angle||0)/180*Math.PI;
			var sides = this.sides;
			var ps = 1-(this.pointSize||0);
			var a = Math.PI/sides;
	
			ctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
			for (var i=0; i<sides; i++) {
				angle += a;
				if (ps != 1) {
					ctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);
				}
				angle += a;
				ctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
			}
			ctx.closePath();
		};
	
		// docced above.
		Graphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.
	
	
		createjs.Graphics = Graphics;
	}());
	
	//##############################################################################
	// DisplayObject.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as
		 * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.
		 * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and
		 * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),
		 * caching, and mouse handlers.
		 * @class DisplayObject
		 * @extends EventDispatcher
		 * @constructor
		 **/
		function DisplayObject() {
			this.EventDispatcher_constructor();
	
	
		// public properties:
			/**
			 * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
			 * @property alpha
			 * @type {Number}
			 * @default 1
			 **/
			this.alpha = 1;
	
			/**
			 * If a cache is active, this returns the canvas that holds the image of this display object. See {{#crossLink "DisplayObject/cache:method"}}{{/crossLink}}
			 * for more information. Use this to display the result of a cache. This will be a HTMLCanvasElement unless special cache rules have been deliberately enabled for this cache.
			 * @property cacheCanvas
			 * @type {HTMLCanvasElement | Object}
			 * @default null
			 * @readonly
			 **/
			this.cacheCanvas = null;
	
			/**
			 * If a cache has been made, this returns the class that is managing the cacheCanvas and its properties. See {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * for more information. Use this to control, inspect, and change the cache. In special circumstances this may be a modified or subclassed BitmapCache.
			 * @property bitmapCache
			 * @type {BitmapCache}
			 * @default null
			 * @readonly
			 **/
			this.bitmapCache = null;
	
			/**
			 * Unique ID for this display object. Makes display objects easier for some uses.
			 * @property id
			 * @type {Number}
			 * @default -1
			 **/
			this.id = createjs.UID.get();
	
			/**
			 * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
			 * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is
			 * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}
			 * method from returning the child.
			 *
			 * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please
			 * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be
			 * provided in the next release of EaselJS.
			 * @property mouseEnabled
			 * @type {Boolean}
			 * @default true
			 **/
			this.mouseEnabled = true;
	
			/**
			 * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
			 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
			 * on some display objects (ex. Sprite & MovieClip frame advancing, and DOMElement display properties).
			 * @property tickEnabled
			 * @type Boolean
			 * @default true
			 **/
			this.tickEnabled = true;
	
			/**
			 * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for
			 * debugging.
			 * @property name
			 * @type {String}
			 * @default null
			 **/
			this.name = null;
	
			/**
			 * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that
			 * contains this display object, or null if it has not been added
			 * to one.
			 * @property parent
			 * @final
			 * @type {Container}
			 * @default null
			 * @readonly
			 **/
			this.parent = null;
	
			/**
			 * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
			 * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.
			 * Cached object's registration points should be set based on pre-cache conditions, not cached size.
			 * @property regX
			 * @type {Number}
			 * @default 0
			 **/
			this.regX = 0;
	
			/**
			 * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
			 * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.
			 * Cached object's registration points should be set based on pre-cache conditions, not cached size.
			 * @property regY
			 * @type {Number}
			 * @default 0
			 **/
			this.regY = 0;
	
			/**
			 * The rotation in degrees for this display object.
			 * @property rotation
			 * @type {Number}
			 * @default 0
			 **/
			this.rotation = 0;
	
			/**
			 * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
			 * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
			 * @property scaleX
			 * @type {Number}
			 * @default 1
			 **/
			this.scaleX = 1;
	
			/**
			 * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
			 * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
			 * @property scaleY
			 * @type {Number}
			 * @default 1
			 **/
			this.scaleY = 1;
	
			/**
			 * The factor to skew this display object horizontally.
			 * @property skewX
			 * @type {Number}
			 * @default 0
			 **/
			this.skewX = 0;
	
			/**
			 * The factor to skew this display object vertically.
			 * @property skewY
			 * @type {Number}
			 * @default 0
			 **/
			this.skewY = 0;
	
			/**
			 * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
			 * null, this property is inherited from the parent container.
			 * @property shadow
			 * @type {Shadow}
			 * @default null
			 **/
			this.shadow = null;
	
			/**
			 * Indicates whether this display object should be rendered to the canvas and included when running the Stage
			 * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.
			 * @property visible
			 * @type {Boolean}
			 * @default true
			 **/
			this.visible = true;
	
			/**
			 * The x (horizontal) position of the display object, relative to its parent.
			 * @property x
			 * @type {Number}
			 * @default 0
			 **/
			this.x = 0;
	
			/** The y (vertical) position of the display object, relative to its parent.
			 * @property y
			 * @type {Number}
			 * @default 0
			 **/
			this.y = 0;
	
			/**
			 * If set, defines the transformation for this display object, overriding all other transformation properties
			 * (x, y, rotation, scale, skew).
			 * @property transformMatrix
			 * @type {Matrix2D}
			 * @default null
			 **/
			this.transformMatrix = null;
	
			/**
			 * The composite operation indicates how the pixels of this display object will be composited with the elements
			 * behind it. If `null`, this property is inherited from the parent container. For more information, read the
			 * <a href="https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation">
			 * whatwg spec on compositing</a>. For a list of supported compositeOperation value, visit
			 * <a href="https://drafts.fxtf.org/compositing/">the W3C draft on Compositing and Blending</a>.
			 * @property compositeOperation
			 * @type {String}
			 * @default null
			 **/
			this.compositeOperation = null;
	
			/**
			 * Indicates whether the display object should be drawn to a whole pixel when
			 * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole
			 * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).
			 * @property snapToPixel
			 * @type {Boolean}
			 * @default true
			 **/
			this.snapToPixel = true;
	
			/**
			 * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}
			 * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is
			 * cached.
			 * @property filters
			 * @type {Array}
			 * @default null
			 **/
			this.filters = null;
	
			/**
			 * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation
			 * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
			 * @property mask
			 * @type {Shape}
			 * @default null
			 */
			this.mask = null;
	
			/**
			 * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.
			 * The hit area will have its transformation applied relative to this display object's coordinate space (as though
			 * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
			 * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
			 * ancestors (parents).
			 * 
			 * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.
			 * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.
			 *
			 * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.
			 * @property hitArea
			 * @type {DisplayObject}
			 * @default null
			 */
			this.hitArea = null;
	
			/**
			 * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
			 * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to
			 * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
			 * @property cursor
			 * @type {String}
			 * @default null
			 */
			this.cursor = null;
	
	
		// private properties:
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheScale
			 * @protected
			 * @type {Number}
			 * @default 1
			 * @deprecated
			 **/
	
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheDataURLID
			 * @protected
			 * @type {Number}
			 * @default 0
			 * @deprecated
			 */
	
			/**
			 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
			 * @property _cacheDataURL
			 * @protected
			 * @type {String}
			 * @default null
			 * @deprecated
			 */
	
			/**
			 * @property _props
			 * @protected
			 * @type {DisplayObject}
			 * @default null
			 **/
			this._props = new createjs.DisplayProps();
	
			/**
			 * @property _rectangle
			 * @protected
			 * @type {Rectangle}
			 * @default null
			 **/
			this._rectangle = new createjs.Rectangle();
	
			/**
			 * @property _bounds
			 * @protected
			 * @type {Rectangle}
			 * @default null
			 **/
			this._bounds = null;
	
			/**
			 * Where StageGL should look for required display properties, matters only for leaf display objects. Containers
			 * or cached objects won't use this property, it's for native display of terminal elements.
			 * @property _webGLRenderStyle
			 * @protected
			 * @type {number}
			 * @default 0
			 */
			this._webGLRenderStyle = DisplayObject._StageGL_NONE;
		}
		var p = createjs.extend(DisplayObject, createjs.EventDispatcher);
	
	// static properties:
		/**
		 * Listing of mouse event names. Used in _hasMouseEventListener.
		 * @property _MOUSE_EVENTS
		 * @protected
		 * @static
		 * @type {Array}
		 **/
		DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];
	
		/**
		 * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}
		 * with cross domain content.
		 * @property suppressCrossDomainErrors
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		DisplayObject.suppressCrossDomainErrors = false;
	
		/**
		 * @property _snapToPixelEnabled
		 * @protected
		 * @static
		 * @type {Boolean}
		 * @default false
		 **/
		DisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_NONE
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_NONE = 0;
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_SPRITE
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_SPRITE = 1;
	
		/**
		 * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
		 * @property _StageGL_BITMAP
		 * @protected
		 * @static
		 * @type {number}
		 */
		DisplayObject._StageGL_BITMAP = 2;
	
		/**
		 * @property _hitTestCanvas
		 * @type {HTMLCanvasElement | Object}
		 * @static
		 * @protected
		 **/
		/**
		 * @property _hitTestContext
		 * @type {CanvasRenderingContext2D}
		 * @static
		 * @protected
		 **/
		var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.
		if (canvas.getContext) {
			DisplayObject._hitTestCanvas = canvas;
			DisplayObject._hitTestContext = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	// events:
		/**
		 * Dispatched when the user presses their left mouse button over the display object. See the 
		 * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mousedown
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user presses their left mouse button and then releases it while over the display object.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event click
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user double clicks their left mouse button over this display object.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event dblclick
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user's mouse enters this display object. This event must be enabled using 
		 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mouseover
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user's mouse leaves this display object. This event must be enabled using 
		 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event mouseout
		 * @since 0.6.0
		 */
	
		/**
		 * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following
		 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
		 * aggregate of their content.
		 * 
		 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
		 * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on
		 * myContainer, two events would be received, each targeting a child element:<OL>
		 * <LI>when the mouse enters shapeA (target=shapeA)</LI>
		 * <LI>when the mouse enters shapeB (target=shapeB)</LI>
		 * </OL>
		 * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
		 * the aggregate myContainer content (target=myContainer).
		 * 
		 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event rollover
		 * @since 0.7.0
		 */
	
		/**
		 * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following
		 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
		 * aggregate of their content.
		 * 
		 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
		 * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}
		 * on myContainer, two events would be received, each targeting a child element:<OL>
		 * <LI>when the mouse leaves shapeA (target=shapeA)</LI>
		 * <LI>when the mouse leaves shapeB (target=shapeB)</LI>
		 * </OL>
		 * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
		 * the aggregate myContainer content (target=myContainer).
		 * 
		 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event rollout
		 * @since 0.7.0
		 */
	
		/**
		 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove
		 * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
		 * useful for dragging and similar operations.
		 *
		 * **Please note** that if the initial mouse target from a `mousedown` event is removed from the stage after being pressed
		 * (e.g. during a `pressmove` event), a `pressmove` event is still generated. However since it is no longer in the
		 * display list, the event can not bubble. This means that previous ancestors (parent containers) will not receive
		 * the event, and therefore can not re-dispatch it. If you intend to listen for `{{#crossLink "DisplayObject/pressup:event"}}{{/crossLink}}`
		 * or `pressmove` on a dynamic object (such as a {{#crossLink "MovieClip"}}{{/crossLink}} or {{#crossLink "Container"}}{{/crossLink}}),
		 * then ensure you set {{#crossLink "Container/mouseChildren:property"}}{{/crossLink}} to `false`.
		 * @event pressmove
		 * @since 0.7.0
		 */
	
		/**
		 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event
		 * will be generated on that object when that mouse press is released. This can be useful for dragging and similar
		 * operations.
		 *
		 * **Please note** that if the initial mouse target from a `mousedown` event is removed from the stage after being pressed
		 * (e.g. during a `pressmove` event), a `pressup` event is still generated. However since it is no longer in the
		 * display list, the event can not bubble. This means that previous ancestors (parent containers) will not receive
		 * the event, and therefore can not re-dispatch it. If you intend to listen for `{{#crossLink "DisplayObject/pressmove:event"}}{{/crossLink}}`
		 * or `pressup` on a dynamic object (such as a {{#crossLink "MovieClip"}}{{/crossLink}} or {{#crossLink "Container"}}{{/crossLink}}),
		 * then ensure you set {{#crossLink "Container/mouseChildren:property"}}{{/crossLink}} to `false`.
		 * @event pressup
		 * @since 0.7.0
		 */
	
		/**
		 * Dispatched when the display object is added to a parent container.
		 * @event added
		 */
	
		/**
		 * Dispatched when the display object is removed from its parent container.
		 * @event removed
		 */
	
		/**
		 * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
		 * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on
		 * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
		 * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being
		 * dispatched on their parent.
		 * @event tick
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For
		 *      example if you called stage.update("hello"), then the params would be ["hello"].
		 * @since 0.6.0
		 */
	
	
	// getter / setters:
		/**
		 * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.
		 * @method _getStage
		 * @protected
		 * @return {Stage}
		 **/
		p._getStage = function() {
			// uses dynamic access to avoid circular dependencies;
			var o = this, _Stage = createjs["Stage"];
			while (o.parent) { o = o.parent; }
			if (o instanceof _Stage) { return o; }
			return null;
		};
		// DisplayObject.getStage is @deprecated. Remove for 1.1+
		p.getStage = createjs.deprecate(p._getStage, "DisplayObject.getStage");
	
		/**
		 * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.
		 * @property stage
		 * @type {Stage}
		 * @readonly
		 **/
	
		/**
		 * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to
		 * determine if the cache has changed since a previous check.
		 * Moved to {{#crossLink "BitmapCache"}}{{/crossLink}}
		 * @property cacheID
		 * @deprecated
		 * @type {Number}
		 * @default 0
		 */
	
		/**
		 * Set both the {{#crossLink "DisplayObject/scaleX:property"}}{{/crossLink}} and the {{#crossLink "DisplayObject/scaleY"}}{{/crossLink}}
		 * property to the same value. Note that when you get the value, if the `scaleX` and `scaleY` are different values,
		 * it will return only the `scaleX`.
		 * @property scaleX
		 * @type {Number}
		 * @default 1
		 */
		try {
			Object.defineProperties(p, {
				stage: { get: p._getStage },
				cacheID: {
					get: function(){ return this.bitmapCache && this.bitmapCache.cacheID },
					set: function(a){ this.bitmapCache && (this.bitmapCache.cacheID = a) }
				},
				scale: {
					get: function() { return this.scaleX; },
					set: function(scale) { this.scaleX = this.scaleY = scale; },
				}
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns <code>true</code> if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
		 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			var cache = this.bitmapCache;
			if(cache && !ignoreCache) {
				return cache.draw(ctx);
			}
			return false;
		};
	
		/**
		 * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow
		 * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.
		 * @method updateContext
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
		 **/
		p.updateContext = function(ctx) {
			var o=this, mask=o.mask, mtx= o._props.matrix;
			
			if (mask && mask.graphics && !mask.graphics.isEmpty()) {
				mask.getMatrix(mtx);
				ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
				
				mask.graphics.drawAsPath(ctx);
				ctx.clip();
				
				mtx.invert();
				ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
			}
			
			this.getMatrix(mtx);
			var tx = mtx.tx, ty = mtx.ty;
			if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
				tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
				ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
			}
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);
			ctx.globalAlpha *= o.alpha;
			if (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }
			if (o.shadow) { this._applyShadow(ctx, o.shadow); }
		};
	
		/**
		 * Draws the display object into a new element, which is then used for subsequent draws. Intended for complex content
		 * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
		 * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
		 * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually
		 * update the cache by calling <code>updateCache()</code> again. You must specify the cached area via the x, y, w,
		 * and h parameters. This defines the rectangle that will be rendered and cached using this display object's coordinates.
		 *
		 * <h4>Example</h4>
		 * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:
		 *
		 *      var shape = new createjs.Shape();
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
		 *      shape.cache(-25, -25, 50, 50);
		 *
		 * Note that filters need to be defined <em>before</em> the cache is applied or you will have to call updateCache after
		 * application. Check out the {{#crossLink "Filter"}}{{/crossLink}} class for more information. Some filters
		 * (ex. BlurFilter) may not work as expected in conjunction with the scale param.
		 * 
		 * Usually, the resulting cacheCanvas will have the dimensions width * scale, height * scale, however some filters (ex. BlurFilter)
		 * will add padding to the canvas dimensions.
		 *
		 * In previous versions caching was handled on DisplayObject but has since been moved to {{#crossLink "BitmapCache"}}{{/crossLink}}.
		 * This allows for easier interaction and alternate cache methods like WebGL with {{#crossLink "StageGL"}}{{/crossLink}}.
		 * For more information on the options object, see the BitmapCache {{#crossLink "BitmapCache/define"}}{{/crossLink}}.
		 *
		 * @method cache
		 * @param {Number} x The x coordinate origin for the cache region.
		 * @param {Number} y The y coordinate origin for the cache region.
		 * @param {Number} width The width of the cache region.
		 * @param {Number} height The height of the cache region.
		 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
		 * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
		 * 	cached elements with greater fidelity. Default is 1.
		 * @param {Object} [options=undefined] Specify additional parameters for the cache logic
		 **/
		p.cache = function(x, y, width, height, scale, options) {
			if(!this.bitmapCache){
				this.bitmapCache = new createjs.BitmapCache();
			}
			this.bitmapCache.define(this, x, y, width, height, scale, options);
		};
	
		/**
		 * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
		 * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object
		 * will be drawn over the existing cache using the specified compositeOperation.
		 *
		 * <h4>Example</h4>
		 * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line
		 * will be drawn on top of the old one.
		 *
		 *      // Not shown: Creating the shape, and caching it.
		 *      shapeInstance.clear();
		 *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
		 *      shapeInstance.updateCache();
		 *
		 * In previous versions caching was handled on DisplayObject but has since been moved to {{#crossLink "BitmapCache"}}{{/crossLink}}.
		 * This allows for easier interaction and alternate cache methods like WebGL and {{#crossLink "StageGL"}}{{/crossLink}}.
		 *
		 * @method updateCache
		 * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.
		 * <a href="https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation">
		 * whatwg spec on compositing</a>.
		 **/
		p.updateCache = function(compositeOperation) {
			if(!this.bitmapCache) {
				throw "cache() must be called before updateCache()";
			}
			this.bitmapCache.update(compositeOperation);
		};
	
		/**
		 * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.
		 * @method uncache
		 **/
		p.uncache = function() {
			if(this.bitmapCache) {
				this.bitmapCache.release();
				this.bitmapCache = undefined;
			}
		};
	
		/**
		 * Returns a data URL for the cache, or null if this display object is not cached.
		 * Only generated if the cache has changed, otherwise returns last result.
		 * @method getCacheDataURL
		 * @return {String} The image data url for the cache.
		 **/
		p.getCacheDataURL = function() {
			return this.bitmapCache?this.bitmapCache.getDataURL():null;
		};
	
		/**
		 * Transforms the specified x and y position from the coordinate space of the display object
		 * to the global (stage) coordinate space. For example, this could be used to position an HTML label
		 * over a specific point on a nested display object. Returns a Point instance with x and y properties
		 * correlating to the transformed coordinates on the stage.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.x = 300;
		 *      displayObject.y = 200;
		 *      stage.addChild(displayObject);
		 *      var point = displayObject.localToGlobal(100, 100);
		 *      // Results in x=400, y=300
		 *
		 * @method localToGlobal
		 * @param {Number} x The x position in the source display object to transform.
		 * @param {Number} y The y position in the source display object to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates
		 * on the stage.
		 **/
		p.localToGlobal = function(x, y, pt) {
			return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());
		};
	
		/**
		 * Transforms the specified x and y position from the global (stage) coordinate space to the
		 * coordinate space of the display object. For example, this could be used to determine
		 * the current mouse position within the display object. Returns a Point instance with x and y properties
		 * correlating to the transformed position in the display object's coordinate space.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.x = 300;
		 *      displayObject.y = 200;
		 *      stage.addChild(displayObject);
		 *      var point = displayObject.globalToLocal(100, 100);
		 *      // Results in x=-200, y=-100
		 *
		 * @method globalToLocal
		 * @param {Number} x The x position on the stage to transform.
		 * @param {Number} y The y position on the stage to transform.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
		 * display object's coordinate space.
		 **/
		p.globalToLocal = function(x, y, pt) {
			return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());
		};
	
		/**
		 * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
		 * space of the target display object. Returns a Point instance with x and y properties correlating to the
		 * transformed position in the target's coordinate space. Effectively the same as using the following code with
		 * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
		 *
		 *      var pt = this.localToGlobal(x, y);
		 *      pt = target.globalToLocal(pt.x, pt.y);
		 *
		 * @method localToLocal
		 * @param {Number} x The x position in the source display object to transform.
		 * @param {Number} y The y position on the source display object to transform.
		 * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
		 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
		 * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
		 * in the target's coordinate space.
		 **/
		p.localToLocal = function(x, y, target, pt) {
			pt = this.localToGlobal(x, y, pt);
			return target.globalToLocal(pt.x, pt.y, pt);
		};
	
		/**
		 * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
		 * Omitted parameters will have the default value set.
		 *
		 * <h4>Example</h4>
		 *
		 *      displayObject.setTransform(100, 100, 2, 2);
		 *
		 * @method setTransform
		 * @param {Number} [x=0] The horizontal translation (x position) in pixels
		 * @param {Number} [y=0] The vertical translation (y position) in pixels
		 * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
		 * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
		 * @param {Number} [rotation=0] The rotation, in degrees
		 * @param {Number} [skewX=0] The horizontal skew factor
		 * @param {Number} [skewY=0] The vertical skew factor
		 * @param {Number} [regX=0] The horizontal registration point in pixels
		 * @param {Number} [regY=0] The vertical registration point in pixels
		 * @return {DisplayObject} Returns this instance. Useful for chaining commands.
		 * @chainable
		*/
		p.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			this.x = x || 0;
			this.y = y || 0;
			this.scaleX = scaleX == null ? 1 : scaleX;
			this.scaleY = scaleY == null ? 1 : scaleY;
			this.rotation = rotation || 0;
			this.skewX = skewX || 0;
			this.skewY = skewY || 0;
			this.regX = regX || 0;
			this.regY = regY || 0;
			return this;
		};
	
		/**
		 * Returns a matrix based on this object's current transform.
		 * @method getMatrix
		 * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new
		 * Matrix object is returned.
		 * @return {Matrix2D} A matrix representing this display object's transform.
		 **/
		p.getMatrix = function(matrix) {
			var o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();
			return o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
		};
	
		/**
		 * Generates a Matrix2D object representing the combined transform of the display object and all of its
		 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can
		 * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
		 * @method getConcatenatedMatrix
		 * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.
		 * If null, a new Matrix2D object is returned.
		 * @return {Matrix2D} The combined matrix.
		 **/
		p.getConcatenatedMatrix = function(matrix) {
			var o = this, mtx = this.getMatrix(matrix);
			while (o = o.parent) {
				mtx.prependMatrix(o.getMatrix(o._props.matrix));
			}
			return mtx;
		};
	
		/**
		 * Generates a DisplayProps object representing the combined display properties of the  object and all of its
		 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).
		 * @method getConcatenatedDisplayProps
		 * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.
		 * If null, a new DisplayProps object is returned.
		 * @return {DisplayProps} The combined display properties.
		 **/
		p.getConcatenatedDisplayProps = function(props) {
			props = props ? props.identity() : new createjs.DisplayProps();
			var o = this, mtx = o.getMatrix(props.matrix); 
			do {
				props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
				
				// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
				// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
				if (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }
			} while (o = o.parent);
			return props;
		};
	
		/**
		 * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
		 * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
		 *
		 * <h4>Example</h4>
		 *
		 *      stage.addEventListener("stagemousedown", handleMouseDown);
		 *      function handleMouseDown(event) {
		 *          var hit = myShape.hitTest(event.stageX, event.stageY);
		 *      }
		 *
		 * Please note that shape-to-shape collision is not currently supported by EaselJS.
		 * @method hitTest
		 * @param {Number} x The x position to check in the display object's local coordinates.
		 * @param {Number} y The y position to check in the display object's local coordinates.
		 * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
		 * local Point.
		*/
		p.hitTest = function(x, y) {
			var ctx = DisplayObject._hitTestContext;
			ctx.setTransform(1, 0, 0, 1, -x, -y);
			this.draw(ctx);
	
			var hit = this._testHit(ctx);
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, 2, 2);
			return hit;
		};
	
		/**
		 * Provides a chainable shortcut method for setting a number of properties on the instance.
		 *
		 * <h4>Example</h4>
		 *
		 *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
		 *      var shape = stage.addChild(new Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});
		 *
		 * @method set
		 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
		 * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
		 * @chainable
		*/
		p.set = function(props) {
			for (var n in props) { this[n] = props[n]; }
			return this;
		};
	
		/**
		 * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
		 * Objects that have been cached will return the bounds of the cache.
		 * 
		 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
		 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
		 * bounds.
		 * 
		 * <table>
		 * 	<tr><td><b>All</b></td><td>
		 * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
		 * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
		 * 		the automatic calculations listed below.
		 * 	</td></tr>
		 * 	<tr><td><b>Bitmap</b></td><td>
		 * 		Returns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).
		 * 	</td></tr>
		 * 	<tr><td><b>Sprite</b></td><td>
		 * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
		 * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
		 * 	</td></tr>
		 * 	<tr><td><b>Container</b></td><td>
		 * 		Returns the aggregate (combined) bounds of all children that return a non-null value from getBounds().
		 * 	</td></tr>
		 * 	<tr><td><b>Shape</b></td><td>
		 * 		Does not currently support automatic bounds calculations. Use setBounds() to manually define bounds.
		 * 	</td></tr>
		 * 	<tr><td><b>Text</b></td><td>
		 * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are
		 * 		not, especially when using textBaseline values other than "top".
		 * 	</td></tr>
		 * 	<tr><td><b>BitmapText</b></td><td>
		 * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
		 * 		to (x=0,y=0).
		 * 	</td></tr>
		* </table>
		 * 
		 * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
		 * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
		 * bounds explicitly:
		 * 
		 * 	var bounds = obj.getBounds();
		 * 	obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
		 * 	// getBounds will now use the set values, instead of recalculating
		 * 
		 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
		 * values if you need to retain it.
		 * 
		 * 	var myBounds = obj.getBounds().clone();
		 * 	// OR:
		 * 	myRect.copy(obj.getBounds());
		 * 
		 * @method getBounds
		 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
		 * object.
		 **/
		p.getBounds = function() {
			if (this._bounds) { return this._rectangle.copy(this._bounds); }
			var cacheCanvas = this.cacheCanvas;
			if (cacheCanvas) {
				var scale = this._cacheScale;
				return this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
			}
			return null;
		};
	
		/**
		 * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
		 * Objects that have been cached will return the transformed bounds of the cache.
		 * 
		 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
		 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
		 * bounds.
		 * 
		 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
		 * values if you need to retain it.
		 * 
		 * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
		 * @method getTransformedBounds
		 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
		 **/
		p.getTransformedBounds = function() {
			return this._getBounds();
		};
	
		/**
		 * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
		 * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
		 * override calculated bounds.
		 * 
		 * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
		 * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
		 * @method setBounds
		 * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
		 * @param {Number} y The y origin of the bounds.
		 * @param {Number} width The width of the bounds.
		 * @param {Number} height The height of the bounds.
		 **/
		p.setBounds = function(x, y, width, height) {
			if (x == null) { this._bounds = x; return; }
			this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
		};
	
		/**
		 * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
		 * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
		 * are copied by reference (masks, individual filter instances, hit area)
		 * @method clone
		 * @return {DisplayObject} A clone of the current DisplayObject instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new DisplayObject());
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[DisplayObject (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * Called before the object gets drawn and is a chance to ensure the display state of the object is correct.
		 * Mostly used by {{#crossLink "MovieClip"}}{{/crossLink}} and {{#crossLink "BitmapText"}}{{/crossLink}} to
		 * correct their internal state and children prior to being drawn.
		 *
		 * Is manually called via draw in a {{#crossLink "Stage"}}{{/crossLink}} but is automatically called when
		 * present in a {{#crossLink "StageGL"}}{{/crossLink}} instance.
		 *
		 * @method _updateState
		 * @default null
		 */
		p._updateState = null;
	
		// separated so it can be used more easily in subclasses:
		/**
		 * @method _cloneProps
		 * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
		 * instance copied into.
		 * @return {DisplayObject} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			o.alpha = this.alpha;
			o.mouseEnabled = this.mouseEnabled;
			o.tickEnabled = this.tickEnabled;
			o.name = this.name;
			o.regX = this.regX;
			o.regY = this.regY;
			o.rotation = this.rotation;
			o.scaleX = this.scaleX;
			o.scaleY = this.scaleY;
			o.shadow = this.shadow;
			o.skewX = this.skewX;
			o.skewY = this.skewY;
			o.visible = this.visible;
			o.x  = this.x;
			o.y = this.y;
			o.compositeOperation = this.compositeOperation;
			o.snapToPixel = this.snapToPixel;
			o.filters = this.filters==null?null:this.filters.slice(0);
			o.mask = this.mask;
			o.hitArea = this.hitArea;
			o.cursor = this.cursor;
			o._bounds = this._bounds;
			return o;
		};
	
		/**
		 * @method _applyShadow
		 * @protected
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {Shadow} shadow
		 **/
		p._applyShadow = function(ctx, shadow) {
			shadow = shadow || Shadow.identity;
			ctx.shadowColor = shadow.color;
			ctx.shadowOffsetX = shadow.offsetX;
			ctx.shadowOffsetY = shadow.offsetY;
			ctx.shadowBlur = shadow.blur;
		};
	
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
			var ls = this._listeners;
			if (ls && ls["tick"]) {
				// reset & reuse the event object to avoid construction / GC costs:
				evtObj.target = null;
				evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
				this.dispatchEvent(evtObj);
			}
		};
	
		/**
		 * @method _testHit
		 * @protected
		 * @param {CanvasRenderingContext2D} ctx
		 * @return {Boolean}
		 **/
		p._testHit = function(ctx) {
			try {
				var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
			} catch (e) {
				if (!DisplayObject.suppressCrossDomainErrors) {
					throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
				}
			}
			return hit;
		};
	
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform){
			return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
		};
	
		/**
		 * @method _transformBounds
		 * @param {Rectangle} bounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform
		 * @return {Rectangle}
		 * @protected
		 **/
		p._transformBounds = function(bounds, matrix, ignoreTransform) {
			if (!bounds) { return bounds; }
			var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
			mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
			
			if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.
			if (matrix) { mtx.prependMatrix(matrix); }
			
			var x_a = width*mtx.a, x_b = width*mtx.b;
			var y_c = height*mtx.c, y_d = height*mtx.d;
			var tx = mtx.tx, ty = mtx.ty;
			
			var minX = tx, maxX = tx, minY = ty, maxY = ty;
	
			if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
	
			if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
	
			return bounds.setValues(minX, minY, maxX-minX, maxY-minY);
		};
	
		/**
		 * Indicates whether the display object has any mouse event listeners or a cursor.
		 * @method _isMouseOpaque
		 * @return {Boolean}
		 * @protected
		 **/
		p._hasMouseEventListener = function() {
			var evts = DisplayObject._MOUSE_EVENTS;
			for (var i= 0, l=evts.length; i<l; i++) {
				if (this.hasEventListener(evts[i])) { return true; }
			}
			return !!this.cursor;
		};
	
		createjs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");
	}());
	
	//##############################################################################
	// Container.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
		
	
	// constructor:
	/**
	 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
	 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
	 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
	 * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent
	 * Container.
	 *
	 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>
	 * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.
	 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
	 *
	 * <h4>Example</h4>
	 *
	 *      var container = new createjs.Container();
	 *      container.addChild(bitmapInstance, shapeInstance);
	 *      container.x = 100;
	 *
	 * @class Container
	 * @extends DisplayObject
	 * @constructor
	 **/
		function Container() {
			this.DisplayObject_constructor();
			
		// public properties:
			/**
			 * The array of children in the display list. You should usually use the child management methods such as
			 * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},
			 * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is
			 * included for advanced uses.
			 * @property children
			 * @type Array
			 * @default null
			 **/
			this.children = [];
			
			/**
			 * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
			 * If false, the children will be aggregated under the container - for example, a click on a child shape would
			 * trigger a click event on the container.
			 * @property mouseChildren
			 * @type Boolean
			 * @default true
			 **/
			this.mouseChildren = true;
			
			/**
			 * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
			 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
			 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
			 * @property tickChildren
			 * @type Boolean
			 * @default true
			 **/
			this.tickChildren = true;
		}
		var p = createjs.extend(Container, createjs.DisplayObject);
		
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.
		 * @method _getNumChildren
		 * @protected
		 * @return {Number}
		 **/
		p._getNumChildren = function() {
			return this.children.length;
		};
		// Container.getNumChildren is @deprecated. Remove for 1.1+
		p.getNumChildren = createjs.deprecate(p._getNumChildren, "Container.getNumChildren");
	
		/**
		 * Returns the number of children in the container.
		 * @property numChildren
		 * @type {Number}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				numChildren: { get: p._getNumChildren }
			});
		} catch (e) {}
		
	
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Container; // TODO: deprecated.
		
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || this.children.length;
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			
			// this ensures we don't have issues with display list changes that occur during a draw:
			var list = this.children.slice();
			for (var i=0,l=list.length; i<l; i++) {
				var child = list[i];
				if (!child.isVisible()) { continue; }
				
				// draw the child:
				ctx.save();
				child.updateContext(ctx);
				child.draw(ctx);
				ctx.restore();
			}
			return true;
		};
		
		/**
		 * Adds a child to the top of the display list.
		 *
		 * <h4>Example</h4>
		 *
		 * 		container.addChild(bitmapInstance);
		 *
		 * You can also add multiple children at once:
		 *
		 * 		container.addChild(bitmapInstance, shapeInstance, textInstance);
		 *
		 * @method addChild
		 * @param {DisplayObject} child The display object to add.
		 * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
		 **/
		p.addChild = function(child) {
			if (child == null) { return child; }
			var l = arguments.length;
			if (l > 1) {
				for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
				return arguments[l-1];
			}
			// Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
			var par=child.parent, silent = par === this;
			par&&par._removeChildAt(createjs.indexOf(par.children, child), silent);
			child.parent = this;
			this.children.push(child);
			if (!silent) { child.dispatchEvent("added"); }
			return child;
		};
	
		/**
		 * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
		 * setting its parent to this Container.
		 *
		 * <h4>Example</h4>
		 *
		 *      addChildAt(child1, index);
		 *
		 * You can also add multiple children, such as:
		 *
		 *      addChildAt(child1, child2, ..., index);
		 *
		 * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
		 * you could use:
		 *
		 *      container.addChildAt(myShape, container.getChildIndex(otherShape));
		 *
		 * This would also bump otherShape's index up by one. Fails silently if the index is out of range.
		 *
		 * @method addChildAt
		 * @param {DisplayObject} child The display object to add.
		 * @param {Number} index The index to add the child at.
		 * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
		 **/
		p.addChildAt = function(child, index) {
			var l = arguments.length;
			var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
			if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
			if (l > 2) {
				for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
				return arguments[l-2];
			}
			var par=child.parent, silent = par === this;
			par&&par._removeChildAt(createjs.indexOf(par.children, child), silent);
			child.parent = this;
			this.children.splice(index, 0, child);
			if (!silent) { child.dispatchEvent("added"); }
			return child;
		};
	
		/**
		 * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
		 * already known.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.removeChild(child);
		 *
		 * You can also remove multiple children:
		 *
		 *      removeChild(child1, child2, ...);
		 *
		 * Returns true if the child (or children) was removed, or false if it was not in the display list.
		 * @method removeChild
		 * @param {DisplayObject} child The child to remove.
		 * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
		 **/
		p.removeChild = function(child) {
			var l = arguments.length;
			if (l > 1) {
				var good = true;
				for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
				return good;
			}
			return this._removeChildAt(createjs.indexOf(this.children, child));
		};
	
		/**
		 * Removes the child at the specified index from the display list, and sets its parent to null.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.removeChildAt(2);
		 *
		 * You can also remove multiple children:
		 *
		 *      container.removeChild(2, 7, ...)
		 *
		 * Returns true if the child (or children) was removed, or false if any index was out of range.
		 * @method removeChildAt
		 * @param {Number} index The index of the child to remove.
		 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
		 **/
		p.removeChildAt = function(index) {
			var l = arguments.length;
			if (l > 1) {
				var a = [];
				for (var i=0; i<l; i++) { a[i] = arguments[i]; }
				a.sort(function(a, b) { return b-a; });
				var good = true;
				for (var i=0; i<l; i++) { good = good && this._removeChildAt(a[i]); }
				return good;
			}
			return this._removeChildAt(index);
		};
	
		/**
		 * Removes all children from the display list.
		 *
		 * <h4>Example</h4>
		 *
		 * 	container.removeAllChildren();
		 *
		 * @method removeAllChildren
		 **/
		p.removeAllChildren = function() {
			var kids = this.children;
			while (kids.length) { this._removeChildAt(0); }
		};
	
		/**
		 * Returns the child at the specified index.
		 *
		 * <h4>Example</h4>
		 *
		 *      container.getChildAt(2);
		 *
		 * @method getChildAt
		 * @param {Number} index The index of the child to return.
		 * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
		 **/
		p.getChildAt = function(index) {
			return this.children[index];
		};
		
		/**
		 * Returns the child with the specified name.
		 * @method getChildByName
		 * @param {String} name The name of the child to return.
		 * @return {DisplayObject} The child with the specified name.
		 **/
		p.getChildByName = function(name) {
			var kids = this.children;
			for (var i=0,l=kids.length;i<l;i++) {
				if(kids[i].name == name) { return kids[i]; }
			}
			return null;
		};
	
		/**
		 * Performs an array sort operation on the child list.
		 *
		 * <h4>Example: Display children with a higher y in front.</h4>
		 * 
		 *      var sortFunction = function(obj1, obj2, options) {
		 *          if (obj1.y > obj2.y) { return 1; }
		 *          if (obj1.y < obj2.y) { return -1; }
		 *          return 0;
		 *      }
		 *      container.sortChildren(sortFunction);
		 *
		 * @method sortChildren
		 * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>
		 * documentation for details.
		 **/
		p.sortChildren = function(sortFunction) {
			this.children.sort(sortFunction);
		};
	
		/**
		 * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
		 *
		 * <h4>Example</h4>
		 *
		 *      var index = container.getChildIndex(child);
		 *
		 * @method getChildIndex
		 * @param {DisplayObject} child The child to return the index of.
		 * @return {Number} The index of the specified child. -1 if the child is not found.
		 **/
		p.getChildIndex = function(child) {
			return createjs.indexOf(this.children, child);
		};
		
		/**
		 * Swaps the children at the specified indexes. Fails silently if either index is out of range.
		 * @method swapChildrenAt
		 * @param {Number} index1
		 * @param {Number} index2
		 **/
		p.swapChildrenAt = function(index1, index2) {
			var kids = this.children;
			var o1 = kids[index1];
			var o2 = kids[index2];
			if (!o1 || !o2) { return; }
			kids[index1] = o2;
			kids[index2] = o1;
		};
		
		/**
		 * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
		 * Container.
		 * @method swapChildren
		 * @param {DisplayObject} child1
		 * @param {DisplayObject} child2
		 **/
		p.swapChildren = function(child1, child2) {
			var kids = this.children;
			var index1,index2;
			for (var i=0,l=kids.length;i<l;i++) {
				if (kids[i] == child1) { index1 = i; }
				if (kids[i] == child2) { index2 = i; }
				if (index1 != null && index2 != null) { break; }
			}
			if (i==l) { return; } // TODO: throw error?
			kids[index1] = child2;
			kids[index2] = child1;
		};
		
		/**
		 * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
		 * @param {DisplayObject} child
		 * @param {Number} index  
		 * @method setChildIndex
		 **/
		p.setChildIndex = function(child, index) {
			var kids = this.children, l=kids.length;
			if (child.parent != this || index < 0 || index >= l) { return; }
			for (var i=0;i<l;i++) {
				if (kids[i] == child) { break; }
			}
			if (i==l || i == index) { return; }
			kids.splice(i,1);
			kids.splice(index,0,child);
		};
	
		/**
		 * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
		 * of this container.
		 * @method contains
		 * @param {DisplayObject} child The DisplayObject to be checked.
		 * @return {Boolean} true if the specified display object either is this container or is a descendent.
		 **/
		p.contains = function(child) {
			while (child) {
				if (child == this) { return true; }
				child = child.parent;
			}
			return false;
		};
	
		/**
		 * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
		 * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
		 * transform properties including regX/Y.
		 * @method hitTest
		 * @param {Number} x The x position to check in the display object's local coordinates.
		 * @param {Number} y The y position to check in the display object's local coordinates.
		 * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
		 * coordinates.
		 **/
		p.hitTest = function(x, y) {
			// TODO: optimize to use the fast cache check where possible.
			return (this.getObjectUnderPoint(x, y) != null);
		};
	
		/**
		 * Returns an array of all display objects under the specified coordinates that are in this container's display
		 * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
		 * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.
		 * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
		 * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),
		 * and only if the mouse's position has changed.
		 * 
		 * <ul>
		 *     <li>By default (mode=0) this method evaluates all display objects.</li>
		 *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
		 * 		and {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>
		 * 	   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
		 * 	   	listeners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects
		 * 	   	that would normally intercept mouse interaction will be included. This can significantly improve performance
		 * 	   	in some cases by reducing the number of display objects that need to be tested.</li>
		 * </li>
		 * 
		 * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.
		 * @method getObjectsUnderPoint
		 * @param {Number} x The x position in the container to test.
		 * @param {Number} y The y position in the container to test.
		 * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
		 * @return {Array} An Array of DisplayObjects under the specified coordinates.
		 **/
		p.getObjectsUnderPoint = function(x, y, mode) {
			var arr = [];
			var pt = this.localToGlobal(x, y);
			this._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);
			return arr;
		};
	
		/**
		 * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display
		 * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive
		 * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.
		 * @method getObjectUnderPoint
		 * @param {Number} x The x position in the container to test.
		 * @param {Number} y The y position in the container to test.
		 * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
		 * @return {DisplayObject} The top-most display object under the specified coordinates.
		 **/
		p.getObjectUnderPoint = function(x, y, mode) {
			var pt = this.localToGlobal(x, y);
			return this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);
		};
		
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			return this._getBounds(null, true);
		};
		
		
		/**
		 * Docced in superclass.
		 */
		p.getTransformedBounds = function() {
			return this._getBounds();
		};
	
		/**
		 * Returns a clone of this Container. Some properties that are specific to this instance's current context are
		 * reverted to their defaults (for example .parent).
		 * @method clone
		 * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
		 * properties of the container will be cloned, but the new instance will not have any children.
		 * @return {Container} A clone of the current Container instance.
		 **/
		p.clone = function(recursive) {
			var o = this._cloneProps(new Container());
			if (recursive) { this._cloneChildren(o); }
			return o;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Container (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			if (this.tickChildren) {
				for (var i=this.children.length-1; i>=0; i--) {
					var child = this.children[i];
					if (child.tickEnabled && child._tick) { child._tick(evtObj); }
				}
			}
			this.DisplayObject__tick(evtObj);
		};
		
		/**
		 * Recursively clones all children of this container, and adds them to the target container.
		 * @method cloneChildren
		 * @protected
		 * @param {Container} o The target container.
		 **/
		p._cloneChildren = function(o) {
			if (o.children.length) { o.removeAllChildren(); }
			var arr = o.children;
			for (var i=0, l=this.children.length; i<l; i++) {
				var clone = this.children[i].clone(true);
				clone.parent = o;
				arr.push(clone);
			}
		};
		
		/**
		 * Removes the child at the specified index from the display list, and sets its parent to null.
		 * Used by `removeChildAt`, `addChild`, and `addChildAt`.
		 * @method removeChildAt
		 * @protected
		 * @param {Number} index The index of the child to remove.
		 * @param {Boolean} [silent] Prevents dispatch of `removed` event if true.
		 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
		 **/
		p._removeChildAt = function(index, silent) {
			if (index < 0 || index > this.children.length-1) { return false; }
			var child = this.children[index];
			if (child) { child.parent = null; }
			this.children.splice(index, 1);
			if (!silent) { child.dispatchEvent("removed"); }
			return true;
		};
	
		/**
		 * @method _getObjectsUnderPoint
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Array} arr
		 * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
		 * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
		 * @param {Number} currentDepth Indicates the current depth of the search.
		 * @return {DisplayObject}
		 * @protected
		 **/
		p._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {
			currentDepth = currentDepth || 0;
			if (!currentDepth && !this._testMask(this, x, y)) { return null; }
			var mtx, ctx = createjs.DisplayObject._hitTestContext;
			activeListener = activeListener || (mouse&&this._hasMouseEventListener());
	
			// draw children one at a time, and check if we get a hit:
			var children = this.children, l = children.length;
			for (var i=l-1; i>=0; i--) {
				var child = children[i];
				var hitArea = child.hitArea;
				if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }
				if (!hitArea && !this._testMask(child, x, y)) { continue; }
				
				// if a child container has a hitArea then we only need to check its hitAre2a, so we can treat it as a normal DO:
				if (!hitArea && child instanceof Container) {
					var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);
					if (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }
				} else {
					if (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }
					
					// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
					var props = child.getConcatenatedDisplayProps(child._props);
					mtx = props.matrix;
					
					if (hitArea) {
						mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
						props.alpha = hitArea.alpha;
					}
					
					ctx.globalAlpha = props.alpha;
					ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
					(hitArea||child).draw(ctx);
					if (!this._testHit(ctx)) { continue; }
					ctx.setTransform(1, 0, 0, 1, 0, 0);
					ctx.clearRect(0, 0, 2, 2);
					if (arr) { arr.push(child); }
					else { return (mouse && !this.mouseChildren) ? this : child; }
				}
			}
			return null;
		};
		
		/**
		 * @method _testMask
		 * @param {DisplayObject} target
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Boolean} Indicates whether the x/y is within the masked region.
		 * @protected
		 **/
		p._testMask = function(target, x, y) {
			var mask = target.mask;
			if (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }
			
			var mtx = this._props.matrix, parent = target.parent;
			mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
			mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
			
			var ctx = createjs.DisplayObject._hitTestContext;
			ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
			
			// draw the mask as a solid fill:
			mask.graphics.drawAsPath(ctx);
			ctx.fillStyle = "#000";
			ctx.fill();
			
			if (!this._testHit(ctx)) { return false; }
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, 2, 2);
			
			return true;
		};
		
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform) {
			var bounds = this.DisplayObject_getBounds();
			if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
			
			var mtx = this._props.matrix;
			mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
			if (matrix) { mtx.prependMatrix(matrix); }
			
			var l = this.children.length, rect=null;
			for (var i=0; i<l; i++) {
				var child = this.children[i];
				if (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }
				if (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }
				else { rect = bounds.clone(); }
			}
			return rect;
		};
	
	
		createjs.Container = createjs.promote(Container, "DisplayObject");
	}());
	
	//##############################################################################
	// Stage.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}
		 * method is called, it will render its display list to its target canvas.
		 *
		 * <h4>Example</h4>
		 * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child
		 * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.
		 *
		 *      var stage = new createjs.Stage("canvasElementId");
		 *      var image = new createjs.Bitmap("imagePath.png");
		 *      stage.addChild(image);
		 *      createjs.Ticker.addEventListener("tick", handleTick);
		 *      function handleTick(event) {
		 *          image.x += 10;
		 *          stage.update();
		 *      }
		 *
		 * @class Stage
		 * @extends Container
		 * @constructor
		 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
		 * of a canvas object in the current document.
		 **/
		function Stage(canvas) {
			this.Container_constructor();
		
		
		// public properties:
			/**
			 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>
			 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
			 * example).
			 *
			 * <h4>Example</h4>
			 *
			 *      var stage = new createjs.Stage("canvasId");
			 *      stage.autoClear = false;
			 *
			 * @property autoClear
			 * @type Boolean
			 * @default true
			 **/
			this.autoClear = true;
		
			/**
			 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
			 * first stage that will be ticked (or they will clear each other's render).
			 *
			 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
			 * new canvas or mouse events will not work as expected. For example:
			 *
			 *      myStage.enableDOMEvents(false);
			 *      myStage.canvas = anotherCanvas;
			 *      myStage.enableDOMEvents(true);
			 *
			 * @property canvas
			 * @type HTMLCanvasElement | Object
			 **/
			this.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;
		
			/**
			 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
			 * position over the canvas, and mouseInBounds will be set to false.
			 * @property mouseX
			 * @type Number
			 * @readonly
			 **/
			this.mouseX = 0;
		
			/**
			 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
			 * position over the canvas, and mouseInBounds will be set to false.
			 * @property mouseY
			 * @type Number
			 * @readonly
			 **/
			this.mouseY = 0;
		
			/**
			 * Specifies the area of the stage to affect when calling update. This can be use to selectively
			 * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
			 * @property drawRect
			 * @type {Rectangle}
			 */
			this.drawRect = null;
		
			/**
			 * Indicates whether display objects should be rendered on whole pixels. You can set the
			 * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of
			 * display objects to false to enable/disable this behaviour on a per instance basis.
			 * @property snapToPixelEnabled
			 * @type Boolean
			 * @default false
			 **/
			this.snapToPixelEnabled = false;
		
			/**
			 * Indicates whether the mouse is currently within the bounds of the canvas.
			 * @property mouseInBounds
			 * @type Boolean
			 * @default false
			 **/
			this.mouseInBounds = false;
		
			/**
			 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
			 * @property tickOnUpdate
			 * @type Boolean
			 * @default true
			 **/
			this.tickOnUpdate = true;
		
			/**
			 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
			 * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}
			 * x/y/rawX/rawY.
			 * @property mouseMoveOutside
			 * @type Boolean
			 * @default false
			 **/
			this.mouseMoveOutside = false;
			
			
			/**
			 * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
			 * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
			 * @property preventSelection
			 * @type Boolean
			 * @default true
			 **/
			this.preventSelection = true;
		
			/**
			 * The hitArea property is not supported for Stage.
			 * @property hitArea
			 * @type {DisplayObject}
			 * @default null
			 */
			 
			 
		// private properties:
			/**
			 * Holds objects with data for each active pointer id. Each object has the following properties:
			 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
			 * @property _pointerData
			 * @type {Object}
			 * @private
			 */
			this._pointerData = {};
		
			/**
			 * Number of active pointers.
			 * @property _pointerCount
			 * @type {Object}
			 * @private
			 */
			this._pointerCount = 0;
		
			/**
			 * The ID of the primary pointer.
			 * @property _primaryPointerID
			 * @type {Object}
			 * @private
			 */
			this._primaryPointerID = null;
		
			/**
			 * @property _mouseOverIntervalID
			 * @protected
			 * @type Number
			 **/
			this._mouseOverIntervalID = null;
			
			/**
			 * @property _nextStage
			 * @protected
			 * @type Stage
			 **/
			this._nextStage = null;
			
			/**
			 * @property _prevStage
			 * @protected
			 * @type Stage
			 **/
			this._prevStage = null;
			
			
		// initialize:
			this.enableDOMEvents(true);
		}
		var p = createjs.extend(Stage, createjs.Container);
	
	// events:
		/**
		 * Dispatched when the user moves the mouse over the canvas.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event stagemousemove
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event stagemousedown
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
		 * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.
		 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
		 * @event stagemouseup
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
		 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event mouseleave
		 * @since 0.7.0
		 */
	
		/**
		 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
		 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * class for a listing of event properties.
		 * @event mouseenter
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately before the tick event is propagated through the display list.
		 * You can call preventDefault on the event object to cancel propagating the tick event.
		 * @event tickstart
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
		 * tickOnUpdate is false. Precedes the "drawstart" event.
		 * @event tickend
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
		 * You can call preventDefault on the event object to cancel the draw.
		 * @event drawstart
		 * @since 0.7.0
		 */
		 
		/**
		 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
		 * @event drawend
		 * @since 0.7.0
		 */
	
		 
	// getter / setters:
		/**
		 * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.
		 * This can be useful in cases where you have multiple layered canvases and want user interactions
		 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
		 *
		 *      topStage.nextStage = bottomStage;
		 *
		 * To disable relaying, set nextStage to null.
		 * 
		 * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
		 * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
		 * Considerations when using roll over in relay targets:<OL>
		 * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>
		 * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>
		 * <LI> All relay targets will share the frequency value of the top-most stage</LI>
		 * </OL>
		 * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing
		 * 30 as it's desired frequency):
		 * 	topStage.nextStage = targetStage;
		 * 	topStage.enableMouseOver(10);
		 * 	targetStage.enableMouseOver(30);
		 * 
		 * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its
		 * DOM events using:
		 * 
		 *	targetStage.enableDOMEvents(false);
		 * 
		 * @property nextStage
		 * @type {Stage}
		 **/
		p._get_nextStage = function() {
			return this._nextStage;
		};
		p._set_nextStage = function(value) {
			if (this._nextStage) { this._nextStage._prevStage = null; }
			if (value) { value._prevStage = this; }
			this._nextStage = value;
		};
		
		try {
			Object.defineProperties(p, {
				nextStage: { get: p._get_nextStage, set: p._set_nextStage }
			});
		} catch (e) {} // TODO: use Log
	
	
	// public methods:
		/**
		 * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}
		 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,
		 * and then render the display list to the canvas.
		 *
		 * @method update
		 * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.
		 **/
		p.update = function(props) {
			if (!this.canvas) { return; }
			if (this.tickOnUpdate) { this.tick(props); }
			if (this.dispatchEvent("drawstart", false, true) === false) { return; }
			createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
			var r = this.drawRect, ctx = this.canvas.getContext("2d");
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			if (this.autoClear) {
				if (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }
				else { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }
			}
			ctx.save();
			if (this.drawRect) {
				ctx.beginPath();
				ctx.rect(r.x, r.y, r.width, r.height);
				ctx.clip();
			}
			this.updateContext(ctx);
			this.draw(ctx, false);
			ctx.restore();
			this.dispatchEvent("drawend");
		};
		
		/**
		 * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}
		 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.
		 *
		 * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
		 * propagated to listeners.
		 *
		 * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that
		 * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be
		 * passed as the `props` parameter to `tick()`. For example:
		 *
		 * 	Ticker.on("tick", handleTick);
		 * 	function handleTick(evtObj) {
		 * 		// clone the event object from Ticker, and add some custom data to it:
		 * 		var evt = evtObj.clone().set({greeting:"hello", name:"world"});
		 * 		
		 * 		// pass it to stage.update():
		 * 		myStage.update(evt); // subsequently calls tick() with the same param
		 * 	}
		 * 	
		 * 	// ...
		 * 	myDisplayObject.on("tick", handleDisplayObjectTick);
		 * 	function handleDisplayObjectTick(evt) {
		 * 		console.log(evt.delta); // the delta property from the Ticker tick event object
		 * 		console.log(evt.greeting, evt.name); // custom data: "hello world"
		 * 	}
		 * 
		 * @method tick
		 * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
		 **/
		p.tick = function(props) {
			if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }
			var evtObj = new createjs.Event("tick");
			if (props) {
				for (var n in props) {
					if (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }
				}
			}
			this._tick(evtObj);
			this.dispatchEvent("tickend");
		};
	
		/**
		 * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}
		 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}
		 * directly, using:
		 *
		 *      Ticker.addEventListener("tick", myStage);
		 *
		 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
		 * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.
		 * @property handleEvent
		 * @type Function
		 **/
		p.handleEvent = function(evt) {
			if (evt.type == "tick") { this.update(evt); }
		};
	
		/**
		 * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.
		 * @method clear
		 **/
		p.clear = function() {
			if (!this.canvas) { return; }
			var ctx = this.canvas.getContext("2d");
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
		};
	
		/**
		 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
		 * be specified as the src value of an image element.
		 * @method toDataURL
		 * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
		 * value is allowed. The default value is a transparent background.
		 * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type
		 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
		 * @return {String} a Base64 encoded image.
		 **/
		p.toDataURL = function(backgroundColor, mimeType) {
			var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;
	
			if (backgroundColor) {
				data = ctx.getImageData(0, 0, w, h);
				var compositeOperation = ctx.globalCompositeOperation;
				ctx.globalCompositeOperation = "destination-over";
				
				ctx.fillStyle = backgroundColor;
				ctx.fillRect(0, 0, w, h);
			}
	
			var dataURL = this.canvas.toDataURL(mimeType||"image/png");
	
			if(backgroundColor) {
				ctx.putImageData(data, 0, 0);
				ctx.globalCompositeOperation = compositeOperation;
			}
	
			return dataURL;
		};
	
		/**
		 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}
		 * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage's display list. These events can
		 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
		 * independently of mouse move events via the optional `frequency` parameter.
		 *
		 * <h4>Example</h4>
		 *
		 *      var stage = new createjs.Stage("canvasId");
		 *      stage.enableMouseOver(10); // 10 updates per second
		 *
		 * @method enableMouseOver
		 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
		 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
		 * responsive, but uses less CPU.
		 **/
		p.enableMouseOver = function(frequency) {
			if (this._mouseOverIntervalID) {
				clearInterval(this._mouseOverIntervalID);
				this._mouseOverIntervalID = null;
				if (frequency == 0) {
					this._testMouseOver(true);
				}
			}
			if (frequency == null) { frequency = 20; }
			else if (frequency <= 0) { return; }
			var o = this;
			this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
		};
	
		/**
		 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
		 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
		 * events from the page.
		 *
		 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
		 * new canvas or mouse events will not work as expected. For example:
		 *
		 *      myStage.enableDOMEvents(false);
		 *      myStage.canvas = anotherCanvas;
		 *      myStage.enableDOMEvents(true);
		 *
		 * @method enableDOMEvents
		 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
		 **/
		p.enableDOMEvents = function(enable) {
			if (enable == null) { enable = true; }
			var n, o, ls = this._eventListeners;
			if (!enable && ls) {
				for (n in ls) {
					o = ls[n];
					o.t.removeEventListener(n, o.f, false);
				}
				this._eventListeners = null;
			} else if (enable && !ls && this.canvas) {
				var t = window.addEventListener ? window : document;
				var _this = this;
				ls = this._eventListeners = {};
				ls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
				ls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
				ls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };
				ls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };
	
				for (n in ls) {
					o = ls[n];
					o.t.addEventListener(n, o.f, false);
				}
			}
		};
	
		/**
		 * Stage instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			throw("Stage cannot be cloned.");
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Stage (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * @method _getElementRect
		 * @protected
		 * @param {HTMLElement} e
		 **/
		p._getElementRect = function(e) {
			var bounds;
			try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
			catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }
	
			var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
			var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);
	
			var styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.
			var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
			var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
			var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
			var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);
	
			// note: in some browsers bounds properties are read only.
			return {
				left: bounds.left+offX+padL,
				right: bounds.right+offX-padR,
				top: bounds.top+offY+padT,
				bottom: bounds.bottom+offY-padB
			}
		};
	
		/**
		 * @method _getPointerData
		 * @protected
		 * @param {Number} id
		 **/
		p._getPointerData = function(id) {
			var data = this._pointerData[id];
			if (!data) { data = this._pointerData[id] = {x:0,y:0}; }
			return data;
		};
	
		/**
		 * @method _handleMouseMove
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseMove = function(e) {
			if(!e){ e = window.event; }
			this._handlePointerMove(-1, e, e.pageX, e.pageY);
		};
	
		/**
		 * @method _handlePointerMove
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerMove = function(id, e, pageX, pageY, owner) {
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			if (!this.canvas) { return; }
			var nextStage=this._nextStage, o=this._getPointerData(id);
	
			var inBounds = o.inBounds;
			this._updatePointerPosition(id, e, pageX, pageY);
			if (inBounds || o.inBounds || this.mouseMoveOutside) {
				if (id === -1 && o.inBounds == !inBounds) {
					this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
				}
				
				this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
				this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
			}
			
			nextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);
		};
	
		/**
		 * @method _updatePointerPosition
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 **/
		p._updatePointerPosition = function(id, e, pageX, pageY) {
			var rect = this._getElementRect(this.canvas);
			pageX -= rect.left;
			pageY -= rect.top;
	
			var w = this.canvas.width;
			var h = this.canvas.height;
			pageX /= (rect.right-rect.left)/w;
			pageY /= (rect.bottom-rect.top)/h;
			var o = this._getPointerData(id);
			if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {
				o.x = pageX;
				o.y = pageY;
			} else if (this.mouseMoveOutside) {
				o.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);
				o.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);
			}
	
			o.posEvtObj = e;
			o.rawX = pageX;
			o.rawY = pageY;
	
			if (id === this._primaryPointerID || id === -1) {
				this.mouseX = o.x;
				this.mouseY = o.y;
				this.mouseInBounds = o.inBounds;
			}
		};
	
		/**
		 * @method _handleMouseUp
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseUp = function(e) {
			this._handlePointerUp(-1, e, false);
		};
	
		/**
		 * @method _handlePointerUp
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Boolean} clear
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerUp = function(id, e, clear, owner) {
			var nextStage = this._nextStage, o = this._getPointerData(id);
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			
			var target=null, oTarget = o.target;
			if (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
			
			if (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }
			
			if (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }
			this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
			
			if (clear) {
				if (id==this._primaryPointerID) { this._primaryPointerID = null; }
				delete(this._pointerData[id]);
			} else { o.target = null; }
			
			nextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);
		};
	
		/**
		 * @method _handleMouseDown
		 * @protected
		 * @param {MouseEvent} e
		 **/
		p._handleMouseDown = function(e) {
			this._handlePointerDown(-1, e, e.pageX, e.pageY);
		};
	
		/**
		 * @method _handlePointerDown
		 * @protected
		 * @param {Number} id
		 * @param {Event} e
		 * @param {Number} pageX
		 * @param {Number} pageY
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handlePointerDown = function(id, e, pageX, pageY, owner) {
			if (this.preventSelection) { e.preventDefault(); }
			if (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.
			
			if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
			var target = null, nextStage = this._nextStage, o = this._getPointerData(id);
			if (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
	
			if (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }
			this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
			
			nextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);
		};
	
		/**
		 * @method _testMouseOver
		 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 * @param {Stage} eventTarget The stage that the cursor is actively over.
		 * @protected
		 **/
		p._testMouseOver = function(clear, owner, eventTarget) {
			if (this._prevStage && owner === undefined) { return; } // redundant listener.
			
			var nextStage = this._nextStage;
			if (!this._mouseOverIntervalID) {
				// not enabled for mouseover, but should still relay the event.
				nextStage&&nextStage._testMouseOver(clear, owner, eventTarget);
				return;
			}
			var o = this._getPointerData(-1);
			// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
			if (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }
			
			var e = o.posEvtObj;
			var isEventTarget = eventTarget || e&&(e.target == this.canvas);
			var target=null, common = -1, cursor="", t, i, l;
			
			if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
				target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
				this._mouseOverX = this.mouseX;
				this._mouseOverY = this.mouseY;
			}
	
			var oldList = this._mouseOverTarget||[];
			var oldTarget = oldList[oldList.length-1];
			var list = this._mouseOverTarget = [];
	
			// generate ancestor list and check for cursor:
			t = target;
			while (t) {
				list.unshift(t);
				if (!cursor) { cursor = t.cursor; }
				t = t.parent;
			}
			this.canvas.style.cursor = cursor;
			if (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }
	
			// find common ancestor:
			for (i=0,l=list.length; i<l; i++) {
				if (list[i] != oldList[i]) { break; }
				common = i;
			}
	
			if (oldTarget != target) {
				this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
			}
	
			for (i=oldList.length-1; i>common; i--) {
				this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
			}
	
			for (i=list.length-1; i>common; i--) {
				this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
			}
	
			if (oldTarget != target) {
				this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
			}
			
			nextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);
		};
	
		/**
		 * @method _handleDoubleClick
		 * @protected
		 * @param {MouseEvent} e
		 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
		 **/
		p._handleDoubleClick = function(e, owner) {
			var target=null, nextStage=this._nextStage, o=this._getPointerData(-1);
			if (!owner) {
				target = this._getObjectsUnderPoint(o.x, o.y, null, true);
				this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
			}
			nextStage&&nextStage._handleDoubleClick(e, owner || target && this);
		};
	
		/**
		 * @method _dispatchMouseEvent
		 * @protected
		 * @param {DisplayObject} target
		 * @param {String} type
		 * @param {Boolean} bubbles
		 * @param {Number} pointerId
		 * @param {Object} o
		 * @param {MouseEvent} [nativeEvent]
		 * @param {DisplayObject} [relatedTarget]
		 **/
		p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
			// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
			if (!target || (!bubbles && !target.hasEventListener(type))) { return; }
			/*
			// TODO: account for stage transformations?
			this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
			var pt = this._mtx.transformPoint(o.x, o.y);
			var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
			*/
			var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
			target.dispatchEvent(evt);
		};
	
	
		createjs.Stage = createjs.promote(Stage, "Container");
	}());
	
	//##############################################################################
	// StageGL.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	/*
	 * README IF EDITING:
	 * Terminology for developers:
	 *
	 * Vertex: a point that help defines a shape, 3 per triangle. Usually has an x,y,z but can have more/less info.
	 * Vertex Property: a piece of information attached to the vertex like a vector3 containing x,y,z
	 * Index/Indices: used in groups of 3 to define a triangle, points to vertices by their index in an array (some render
	 * 		modes do not use these)
	 * Card: a group of 2 triangles used to display a rectangular image
	 * U/V: common names for the [0-1] texture co-ordinates on an image
	 * Batch: a single call to the renderer, best done as little as possible so multiple cards are put into a single batch
	 * Buffer: WebGL array data
	 * Program/Shader: For every vertex we run the Vertex shader. The results are used per pixel by the Fragment shader. When
	 * 		combined and paired these are a shader "program"
	 * Texture: WebGL representation of image data and associated extra information
	 * Slot: A space on the GPU into which textures can be loaded for use in a batch, using "ActiveTexture" switches texture slot.
	 */
	
	(function () {
		"use strict";
	
		/**
		 * A StageGL instance is the root level {{#crossLink "Container"}}{{/crossLink}} for an WebGL-optimized display list,
		 * which is used in place of the usual {{#crossLink "Stage"}}{{/crossLink}}. This class should behave identically to
		 * a {{#crossLink "Stage"}}{{/crossLink}} except for WebGL-specific functionality.
		 *
		 * Each time the {{#crossLink "Stage/tick"}}{{/crossLink}} method is called, the display list is rendered to the
		 * target &lt;canvas/&gt; instance, ignoring non-WebGL-compatible display objects. On devices and browsers that don't
		 * support WebGL, content will automatically be rendered to canvas 2D context instead.
		 *
		 * <h4>Limitations</h4>
		 * - {{#crossLink "Shape"}}{{/crossLink}}, {{#crossLink "Shadow"}}{{/crossLink}}, and {{#crossLink "Text"}}{{/crossLink}}
		 * 	are not rendered when added to the display list.
		 * - To display something StageGL cannot render, {{#crossLink "displayObject/cache"}}{{/crossLink}} the object.
		 *	Caches can be rendered regardless of source.
		 * - Images are wrapped as a webGL "Texture". Each graphics card has a limit to its concurrent Textures, too many 
		 * Textures will noticeably slow performance.
		 * - Each cache counts as an individual Texture. As such {{#crossLink "SpriteSheet"}}{{/crossLink}} and 
		 * {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}} are recommended practices to help keep texture counts low.
		 * - To use any image node (DOM Image/Canvas Element) between multiple StageGL instances it must be a 
		 * {{#crossLink "Bitmap/clone"}}{{/crossLink}}, otherwise the GPU texture loading and tracking will get confused.
		 * - to avoid an up/down scaled render you must call {{#crossLink "StageGL/updateViewport"}}{{/crossLink}} if you
		 * resize your canvas after making a StageGL instance, this will properly size the WebGL context stored in memory.
		 * - Best performance in demanding scenarios will come from manual management of texture memory, but it is handled
		 * automatically by default. See {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}} for details.
		 *
		 * <h4>Example</h4>
		 * This example creates a StageGL instance, adds a child to it, then uses the EaselJS {{#crossLink "Ticker"}}{{/crossLink}}
		 * to update the child and redraw the stage.
		 *
		 *      var stage = new createjs.StageGL("canvasElementId");
		 *
		 *      var image = new createjs.Bitmap("imagePath.png");
		 *      stage.addChild(image);
		 *
		 *      createjs.Ticker.on("tick", handleTick);
		 *
		 *      function handleTick(event) {
		 *          image.x += 10;
		 *          stage.update();
		 *      }
		 *
		 * <h4>Notes</h4>
		 * - StageGL is not currently included in the minified version of EaselJS.
		 * - {{#crossLink "SpriteContainer"}}{{/crossLink}} (the previous approach to WebGL with EaselJS) has been deprecated.
		 * - Earlier versions of WebGL support in EaselJS (SpriteStage and SpriteContainer) had hard limitations on images
		 * 	per container, which have been solved.
		 *
		 * @class StageGL
		 * @extends Stage
		 * @constructor
		 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that StageGL will render to, or the string id
		 *  of a canvas object in the current DOM.
		 * @param {Object} options All the option parameters in a reference object, some are not supported by some browsers.
		 * @param {Boolean} [options.preserveBuffer=false] If `true`, the canvas is NOT auto-cleared by WebGL (the spec
		 *  discourages setting this to `true`). This is useful if you want persistent draw effects.
		 * @param {Boolean} [options.antialias=false] Specifies whether or not the browser's WebGL implementation should try
		 *  to perform anti-aliasing. This will also enable linear pixel sampling on power-of-two textures (smoother images).
		 * @param {Boolean} [options.transparent=false] If `true`, the canvas is transparent. This is <strong>very</strong>
		 * expensive, and should be used with caution.
		 * @param {Boolean} [options.premultiply=false] Alters color handling. If `true`, this assumes the shader must
		 * account for pre-multiplied alpha. This can help avoid visual halo effects with some assets, but may also cause
		 * problems with other assets.
		 * @param {Integer} [options.autoPurge=1200] How often the system should automatically dump unused textures with
		 * `purgeTextures(autoPurge)` every `autoPurge/2` draws. See {{#crossLink "StageGL/purgeTextures"}}{{/crossLink}} for more
		 * information.
		 */
		function StageGL(canvas, options) {
			this.Stage_constructor(canvas);
	
			if (options !== undefined) {
				if (typeof options !== "object"){ throw("Invalid options object"); }
				var premultiply = options.premultiply;
				var transparent = options.transparent;
				var antialias = options.antialias;
				var preserveBuffer = options.preserveBuffer;
				var autoPurge = options.autoPurge;
			}
	
	// public properties:
			/**
			 * Console log potential issues and problems. This is designed to have <em>minimal</em> performance impact, so
			 * if extensive debugging information is required, this may be inadequate. See {{#crossLink "WebGLInspector"}}{{/crossLink}}
			 * @property vocalDebug
			 * @type {Boolean}
			 * @default false
			 */
			this.vocalDebug = false;
	
	// private properties:
			/**
			 * Specifies whether or not the canvas is auto-cleared by WebGL. The WebGL spec discourages `true`.
			 * If true, the canvas is NOT auto-cleared by WebGL. Used when the canvas context is created and requires
			 * context re-creation to update.
			 * @property _preserveBuffer
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._preserveBuffer = preserveBuffer||false;
	
			/**
			 * Specifies whether or not the browser's WebGL implementation should try to perform anti-aliasing.
			 * @property _antialias
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._antialias = antialias||false;
	
			/**
			 * Specifies whether or not the browser's WebGL implementation should be transparent.
			 * @property _transparent
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._transparent = transparent||false;
	
			/**
			 * Specifies whether or not StageGL is handling colours as premultiplied alpha.
			 * @property _premultiply
			 * @protected
			 * @type {Boolean}
			 * @default false
			 */
			this._premultiply = premultiply||false;
	
			/**
			 * Internal value of {{#crossLink "StageGL/autoPurge"}}{{/crossLink}}
			 * @property _autoPurge
			 * @protected
			 * @type {Integer}
			 * @default null
			 */
			this._autoPurge = undefined;
			this.autoPurge = autoPurge;	//getter/setter handles setting the real value and validating
	
			/**
			 * The width in px of the drawing surface saved in memory.
			 * @property _viewportWidth
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._viewportWidth = 0;
	
			/**
			 * The height in px of the drawing surface saved in memory.
			 * @property _viewportHeight
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._viewportHeight = 0;
	
			/**
			 * A 2D projection matrix used to convert WebGL's viewspace into canvas co-ordinates. Regular canvas display
			 * uses Top-Left values of [0,0] where WebGL uses a Center [0,0] Top-Right [1,1] (euclidean) system.
			 * @property _projectionMatrix
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._projectionMatrix = null;
	
			/**
			 * The current WebGL canvas context. Often shorthanded to just "gl" in many parts of the code.
			 * @property _webGLContext
			 * @protected
			 * @type {WebGLRenderingContext}
			 * @default null
			 */
			this._webGLContext = null;
	
			/**
			 * The color to use when the WebGL canvas has been cleared. May appear as a background color. Defaults to grey.
			 * @property _clearColor
			 * @protected
			 * @type {Object}
			 * @default {r: 0.50, g: 0.50, b: 0.50, a: 0.00}
			 */
			this._clearColor = {r: 0.50, g: 0.50, b: 0.50, a: 0.00};
	
			/**
			 * The maximum number of cards (aka a single sprite) that can be drawn in one draw call. Use getter/setters to
			 * modify otherwise internal buffers may be incorrect sizes.
			 * @property _maxCardsPerBatch
			 * @protected
			 * @type {Number}
			 * @default StageGL.DEFAULT_MAX_BATCH_SIZE (10000)
			 */
			this._maxCardsPerBatch = StageGL.DEFAULT_MAX_BATCH_SIZE;														//TODO: write getter/setters for this
	
			/**
			 * The shader program used to draw the current batch.
			 * @property _activeShader
			 * @protected
			 * @type {WebGLProgram}
			 * @default null
			 */
			this._activeShader = null;
	
			/**
			 * The vertex position data for the current draw call.
			 * @property _vertices
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._vertices = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_vertices:property"}}{{/crossLink}}.
			 * @property _vertexPositionBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._vertexPositionBuffer = null;
	
			/**
			 * The vertex U/V data for the current draw call.
			 * @property _uvs
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._uvs = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_uvs:property"}}{{/crossLink}}.
			 * @property _uvPositionBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._uvPositionBuffer = null;
	
			/**
			 * The vertex indices data for the current draw call.
			 * @property _indices
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._indices = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_indices:property"}}{{/crossLink}}.
			 * @property _textureIndexBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._textureIndexBuffer = null;
	
			/**
			 * The vertices data for the current draw call.
			 * @property _alphas
			 * @protected
			 * @type {Float32Array}
			 * @default null
			 */
			this._alphas = null;
	
			/**
			 * The WebGL buffer attached to {{#crossLink "StageGL/_alphas:property"}}{{/crossLink}}.
			 * @property _alphaBuffer
			 * @protected
			 * @type {WebGLBuffer}
			 * @default null
			 */
			this._alphaBuffer = null;
	
			/**
			 * An index based lookup of every WebGL Texture currently in use.
			 * @property _drawTexture
			 * @protected
			 * @type {Array}
			 */
			this._textureDictionary = [];
	
			/**
			 * A string based lookup hash of which index a texture is stored at in the dictionary. The lookup string is
			 * often the src url.
			 * @property _textureIDs
			 * @protected
			 * @type {Object}
			 */
			this._textureIDs = {};
	
			/**
			 * An array of all the textures currently loaded into the GPU. The index in the array matches the GPU index.
			 * @property _batchTextures
			 * @protected
			 * @type {Array}
			 */
			this._batchTextures = [];
	
			/**
			 * An array of all the simple filler textures used to prevent issues with missing textures in a batch.
			 * @property _baseTextures
			 * @protected
			 * @type {Array}
			 */
			this._baseTextures = [];
	
			/**
			 * The number of concurrent textures the GPU can handle. This value is dynamically set from WebGL during initialization
			 * via `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)`. The WebGL spec states that the lowest guaranteed value is 8,
			 * but it could be higher. Do not set this value higher than the value returned by the GPU. Setting it lower will
			 * probably reduce performance, but may be advisable to reserve slots for custom filter work.
			 * NOTE: Can also act as a length for {{#crossLink "StageGL/_batchTextures:property"}}.
			 * @property _batchTextureCount
			 * @protected
			 * @type {Number}
			 * @default 8
			 */
			this._batchTextureCount = 8;
	
			/**
			 * The location at which the last texture was inserted into a GPU slot in {{#crossLink "StageGL/_batchTextures:property"}}{{/crossLink}}.
			 * Manual control of this variable can yield improvements in performance by intelligently replacing textures
			 * inside a batch to reduce texture re-load. It is impossible to write automated general use code, as it requires
			 * display list look ahead inspection and/or render foreknowledge.
			 * @property _lastTextureInsert
			 * @protected
			 * @type {Number}
			 * @default -1
			 */
			this._lastTextureInsert = -1;
	
			/**
			 * The current batch being drawn, A batch consists of a call to `drawElements` on the GPU. Many of these calls
			 * can occur per draw.
			 * @property _batchId
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._batchID = 0;
	
			/**
			 * The current draw being performed, may contain multiple batches. Comparing to {{#crossLink "StageGL/_batchID:property"}}{{/crossLink}}
			 * can reveal batching efficiency.
			 * @property _drawID
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._drawID = 0;
	
			/**
			 * Used to prevent textures in certain GPU slots from being replaced by an insert.
			 * @property _slotBlackList
			 * @protected
			 * @type {Array}
			 */
			this._slotBlacklist = [];
	
			/**
			 * Used to prevent nested draw calls from accidentally overwriting drawing information by tracking depth.
			 * @property _isDrawing
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._isDrawing = 0;
	
			/**
			 * Used to ensure every canvas used as a texture source has a unique ID.
			 * @property _lastTrackedCanvas
			 * @protected
			 * @type {Number}
			 * @default 0
			 */
			this._lastTrackedCanvas = 0;
	
			/**
			 * Controls whether final rendering output of a {{#crossLink "cacheDraw"}}{{/crossLink}} is the canvas or a render
			 * texture. See the {{#crossLink "cache"}}{{/crossLink}} function modifications for full implications and discussion.
			 * @property isCacheControlled
			 * @protected
			 * @type {Boolean}
			 * @default false
			 * @todo LM: is this supposed to be _isCacheControlled since its private?
			 */
			this.isCacheControlled = false;
	
			/**
			 * Used to counter-position the object being cached so it aligns with the cache surface. Additionally ensures
			 * that all rendering starts with a top level container.
			 * @property _cacheContainer
			 * @protected
			 * @type {Container}
			 * @default An instance of an EaselJS Container.
			 */
			this._cacheContainer = new createjs.Container();
	
			// and begin
			this._initializeWebGL();
		}
		var p = createjs.extend(StageGL, createjs.Stage);
	
	// static methods:
		/**
		 * Calculate the U/V co-ordinate based info for sprite frames. Instead of pixel count it uses a 0-1 space. Also includes
		 * the ability to get info back for a specific frame, or only calculate that one frame.
		 *
		 *     //generate UV rects for all entries
		 *     StageGL.buildUVRects( spriteSheetA );
		 *     //generate all, fetch the first
		 *     var firstFrame = StageGL.buildUVRects( spriteSheetB, 0 );
		 *     //generate the rect for just a single frame for performance's sake
		 *     var newFrame = StageGL.buildUVRects( dynamicSpriteSheet, newFrameIndex, true );
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method buildUVRects
		 * @param  {SpriteSheet} spritesheet The spritesheet to find the frames on
		 * @param  {int} [target=-1] The index of the frame to return
		 * @param  {Boolean} [onlyTarget=false] Whether "target" is the only frame that gets calculated
		 * @static
		 * @return {Object} the target frame if supplied and present or a generic frame {t, l, b, r}
		 */
		StageGL.buildUVRects = function (spritesheet, target, onlyTarget) {
			if (!spritesheet || !spritesheet._frames) { return null; }
			if (target === undefined) { target = -1; }
			if (onlyTarget === undefined) { onlyTarget = false; }
	
			var start = (target != -1 && onlyTarget)?(target):(0);
			var end = (target != -1 && onlyTarget)?(target+1):(spritesheet._frames.length);
			for (var i=start; i<end; i++) {
				var f = spritesheet._frames[i];
				if (f.uvRect || f.image.width <= 0 || f.image.height <= 0) { continue; }
	
				var r = f.rect;
				f.uvRect = {
					t: r.y / f.image.height,
					l: r.x / f.image.width,
					b: (r.y + r.height) / f.image.height,
					r: (r.x + r.width) / f.image.width
				};
			}
	
			return spritesheet._frames[(target != -1) ? target : 0].uvRect || {t:0, l:0, b:1, r:1};
		};
	
		/**
		 * Test a context to see if it has WebGL enabled on it.
		 * @method isWebGLActive
		 * @param {CanvasContext} ctx The context to test
		 * @static
		 * @return {Boolean} Whether WebGL is enabled
		 */
		StageGL.isWebGLActive = function (ctx) {
			return ctx &&
				ctx instanceof WebGLRenderingContext &&
				typeof WebGLRenderingContext !== 'undefined';
		};
	
	// static properties:
		/**
		 * The number of properties defined per vertex (x, y, textureU, textureV, textureIndex, alpha)
		 * @property VERTEX_PROPERTY_COUNT
		 * @static
		 * @final
		 * @type {Number}
		 * @default 6
		 * @readonly
		 */
		StageGL.VERTEX_PROPERTY_COUNT = 6;
	
		/**
		 * The number of triangle indices it takes to form a Card. 3 per triangle, 2 triangles.
		 * @property INDICIES_PER_CARD
		 * @static
		 * @final
		 * @type {Number}
		 * @default 6
		 * @readonly
		 */
		StageGL.INDICIES_PER_CARD = 6;
	
		/**
		 * The default value for the maximum number of cards we want to process in a batch. See
		 * {{#crossLink "StageGL/WEBGL_MAX_INDEX_NUM:property"}}{{/crossLink}} for a hard limit.
		 * @property DEFAULT_MAX_BATCH_SIZE
		 * @static
		 * @final
		 * @type {Number}
		 * @default 10000
		 * @readonly
		 */
		StageGL.DEFAULT_MAX_BATCH_SIZE = 10000;
	
		/**
		 * The maximum size WebGL allows for element index numbers. Uses a 16 bit unsigned integer. It takes 6 indices to
		 * make a unique card.
		 * @property WEBGL_MAX_INDEX_NUM
		 * @static
		 * @final
		 * @type {Number}
		 * @default 65536
		 * @readonly
		 */
		StageGL.WEBGL_MAX_INDEX_NUM = Math.pow(2, 16);
	
		/**
		 * Default U/V rect for dealing with full coverage from an image source.
		 * @property UV_RECT
		 * @static
		 * @final
		 * @type {Object}
		 * @default {t:0, l:0, b:1, r:1}
		 * @readonly
		 */
		StageGL.UV_RECT = {t:0, l:0, b:1, r:1};
	
		/**
		 * Vertex positions for a card that covers the entire render. Used with render targets primarily.
		 * @property COVER_VERT
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_VERT = new Float32Array([
			-1,		 1,		//TL
			1,		 1,		//TR
			-1,		-1,		//BL
			1,		 1,		//TR
			1,		-1,		//BR
			-1,		-1		//BL
		]);
	
		/**
		 * U/V for {{#crossLink "StageGL/COVER_VERT:property"}}{{/crossLink}}.
		 * @property COVER_UV
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_UV = new Float32Array([
			 0,		 0,		//TL
			 1,		 0,		//TR
			 0,		 1,		//BL
			 1,		 0,		//TR
			 1,		 1,		//BR
			 0,		 1		//BL
		]);
	
		/**
		 * Flipped U/V for {{#crossLink "StageGL:COVER_VERT:property"}}{{/crossLink}}.
		 * @property COVER_UV_FLIP
		 * @static
		 * @final
		 * @type {Float32Array}
		 * @readonly
		 */
		StageGL.COVER_UV_FLIP = new Float32Array([
			 0,		 1,		//TL
			 1,		 1,		//TR
			 0,		 0,		//BL
			 1,		 1,		//TR
			 1,		 0,		//BR
			 0,		 0		//BL
		]);
	
		/**
		 * Portion of the shader that contains the "varying" properties required in both vertex and fragment shaders. The
		 * regular shader is designed to render all expected objects. Shader code may contain templates that are replaced
		 * pre-compile.
		 * @property REGULAR_VARYING_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VARYING_HEADER = (
			"precision mediump float;" +
			"varying vec2 vTextureCoord;" +
			"varying lowp float indexPicker;" +
			"varying lowp float alphaValue;"
		);
	
		/**
		 * Actual full header for the vertex shader. Includes the varying header. The regular shader is designed to render
		 * all expected objects. Shader code may contain templates that are replaced pre-compile.
		 * @property REGULAR_VERTEX_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VERTEX_HEADER = (
			StageGL.REGULAR_VARYING_HEADER +
			"attribute vec2 vertexPosition;" +
			"attribute vec2 uvPosition;" +
			"attribute lowp float textureIndex;" +
			"attribute lowp float objectAlpha;" +
			"uniform mat4 pMatrix;"
		);
	
		/**
		 * Actual full header for the fragment shader. Includes the varying header. The regular shader is designed to render
		 * all expected objects. Shader code may contain templates that are replaced pre-compile.
		 * @property REGULAR_FRAGMENT_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_FRAGMENT_HEADER = (
			StageGL.REGULAR_VARYING_HEADER +
			"uniform sampler2D uSampler[{{count}}];"
		);
	
		/**
		 * Body of the vertex shader. The regular shader is designed to render all expected objects. Shader code may contain
		 * templates that are replaced pre-compile.
		 * @property REGULAR_VERTEX_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_VERTEX_BODY  = (
			"void main(void) {" +
				//DHG TODO: This doesn't work. Must be something wrong with the hand built matrix see js... bypass for now
				//vertexPosition, round if flag
				//"gl_Position = pMatrix * vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);" +
				"gl_Position = vec4("+
					"(vertexPosition.x * pMatrix[0][0]) + pMatrix[3][0]," +
					"(vertexPosition.y * pMatrix[1][1]) + pMatrix[3][1]," +
					"pMatrix[3][2]," +
					"1.0" +
				");" +
				"alphaValue = objectAlpha;" +
				"indexPicker = textureIndex;" +
				"vTextureCoord = uvPosition;" +
			"}"
		);
	
		/**
		 * Body of the fragment shader. The regular shader is designed to render all expected objects. Shader code may
		 * contain templates that are replaced pre-compile.
		 * @property REGULAR_FRAGMENT_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.REGULAR_FRAGMENT_BODY = (
			"void main(void) {" +
				"vec4 color = vec4(1.0, 0.0, 0.0, 1.0);" +
	
				"if (indexPicker <= 0.5) {" +
					"color = texture2D(uSampler[0], vTextureCoord);" +
					"{{alternates}}" +
				"}" +
	
				"gl_FragColor = vec4(color.rgb{{premultiply}}, color.a * alphaValue);" +
			"}"
		);
	
		//TODO: DHG: a real particle shader
		/**
		 * @property PARTICLE_VERTEX_BODY
		 * @todo
		 * @final
		 * @static
		 * @type {String}
		 * @readonly
		 */
		StageGL.PARTICLE_VERTEX_BODY = (
			StageGL.REGULAR_VERTEX_BODY
		);
		/**
		 * @property PARTICLE_FRAGMENT_BODY
		 * @todo
		 * @final
		 * @static
		 * @type {String}
		 * @readonly
		 */
		StageGL.PARTICLE_FRAGMENT_BODY = (
			StageGL.REGULAR_FRAGMENT_BODY
		);
	
		/**
		 * Portion of the shader that contains the "varying" properties required in both vertex and fragment shaders. The
		 * cover shader is designed to be a simple vertex/uv only texture render that covers the render surface. Shader
		 * code may contain templates that are replaced pre-compile.
		 * @property COVER_VARYING_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VARYING_HEADER = (
			"precision mediump float;" +
	
			"varying highp vec2 vRenderCoord;" +
			"varying highp vec2 vTextureCoord;"
		);
	
		/**
		 * Actual full header for the vertex shader. Includes the varying header. The cover shader is designed to be a
		 * simple vertex/uv only texture render that covers the render surface. Shader code may contain templates that are
		 * replaced pre-compile.
		 * @property COVER_VERTEX_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VERTEX_HEADER = (
			StageGL.COVER_VARYING_HEADER +
			"attribute vec2 vertexPosition;" +
			"attribute vec2 uvPosition;" +
			"uniform float uUpright;"
		);
	
		/**
		 * Actual full header for the fragment shader. Includes the varying header. The cover shader is designed to be a
		 * simple vertex/uv only texture render that covers the render surface. Shader code may contain templates that are
		 * replaced pre-compile.
		 * @property COVER_FRAGMENT_HEADER
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_FRAGMENT_HEADER = (
			StageGL.COVER_VARYING_HEADER +
			"uniform sampler2D uSampler;"
		);
	
		/**
		 * Body of the vertex shader. The cover shader is designed to be a simple vertex/uv only texture render that covers
		 * the render surface. Shader code may contain templates that are replaced pre-compile.
		 * @property COVER_VERTEX_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_VERTEX_BODY  = (
			"void main(void) {" +
				"gl_Position = vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);" +
				"vRenderCoord = uvPosition;" +
				"vTextureCoord = vec2(uvPosition.x, abs(uUpright - uvPosition.y));" +
			"}"
		);
	
		/**
		 * Body of the fragment shader. The cover shader is designed to be a simple vertex/uv only texture render that
		 * covers the render surface. Shader code may contain templates that are replaced pre-compile.
		 * @property COVER_FRAGMENT_BODY
		 * @static
		 * @final
		 * @type {String}
		 * @readonly
		 */
		StageGL.COVER_FRAGMENT_BODY = (
			"void main(void) {" +
				"vec4 color = texture2D(uSampler, vRenderCoord);" +
				"gl_FragColor = color;" +
			"}"
		);
	
	// events:
		/**
		 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it. You can call
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}} on the event to cancel the draw.
		 * @event drawstart
		 */
	
		/**
		 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
		 * @event drawend
		 */
	
	// getter / setters:
		p._get_isWebGL = function () {
			return !!this._webGLContext;
		};
	
		p._set_autoPurge = function (value) {
			value = isNaN(value)?1200:value;
			if (value != -1) {
				value = value<10?10:value;
			}
			this._autoPurge = value;
		};
		p._get_autoPurge = function () {
			return Number(this._autoPurge);
		};
	
		try {
			Object.defineProperties(p, {
				/**
				 * Indicates whether WebGL is being used for rendering. For example, this would be `false` if WebGL is not
				 * supported in the browser.
				 * @property isWebGL
				 * @type {Boolean}
				 * @readonly
				 */
				isWebGL: { get: p._get_isWebGL },
	
				/**
				 * Specifies whether or not StageGL is automatically purging unused textures. Higher numbers purge less
				 * often. Values below 10 are upgraded to 10, and -1 disables this feature.
				 * @property autoPurge
				 * @protected
				 * @type {Integer}
				 * @default 1000
				 */
				autoPurge: { get: p._get_autoPurge, set: p._set_autoPurge }
			});
		} catch (e) {} // TODO: use Log
	
	
	// constructor methods:
		/**
		 * Create and properly initialize the WebGL instance.
		 * @method _initializeWebGL
		 * @protected
		 * @return {WebGLRenderingContext}
		 */
		p._initializeWebGL = function () {
			if (this.canvas) {
				if (!this._webGLContext || this._webGLContext.canvas !== this.canvas) {
					// A context hasn't been defined yet,
					// OR the defined context belongs to a different canvas, so reinitialize.
	
					// defaults and options
					var options = {
						depth: false, // Disable the depth buffer as it isn't used.
						alpha: this._transparent, // Make the canvas background transparent.
						stencil: true,
						antialias: this._antialias,
						premultipliedAlpha: this._premultiply, // Assume the drawing buffer contains colors with premultiplied alpha.
						preserveDrawingBuffer: this._preserveBuffer
					};
	
					var gl = this._webGLContext = this._fetchWebGLContext(this.canvas, options);
					if (!gl) { return null; }
	
					this.updateSimultaneousTextureCount(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
					this._maxTextureSlots = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
					this._createBuffers(gl);
					this._initTextures(gl);
	
					gl.disable(gl.DEPTH_TEST);
					gl.enable(gl.BLEND);
					gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
					gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiply);
					//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
	
					this._webGLContext.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
					this.updateViewport(this._viewportWidth || this.canvas.width, this._viewportHeight || this.canvas.height);
				}
			} else {
				this._webGLContext = null;
			}
			return this._webGLContext;
		};
	
	// public methods:
		/**
		 * Docced in superclass
		 */
		p.update = function (props) {
			if (!this.canvas) { return; }
			if (this.tickOnUpdate) { this.tick(props); }
			this.dispatchEvent("drawstart");
			if (this.autoClear) { this.clear(); }
	
			if (this._webGLContext) {
				// Use WebGL.
				this._batchDraw(this, this._webGLContext);
				if (this._autoPurge != -1 && !(this._drawID%((this._autoPurge/2)|0))) {
					this.purgeTextures(this._autoPurge);
				}
			} else {
				// Use 2D.
				var ctx = this.canvas.getContext("2d");
				ctx.save();
				this.updateContext(ctx);
				this.draw(ctx, false);
				ctx.restore();
			}
			this.dispatchEvent("drawend");
		};
	
		/**
		 * Docced in superclass
		 */
		p.clear = function () {
			if (!this.canvas) { return; }
			if (StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				var cc = this._clearColor;
				var adjust = this._transparent ? cc.a : 1.0;
				// Use WebGL settings; adjust for pre multiplied alpha appropriate to scenario
				this._webGLContext.clearColor(cc.r * adjust, cc.g * adjust, cc.b * adjust, adjust);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._webGLContext.clearColor(cc.r, cc.g, cc.b, cc.a);
			} else {
				// Use 2D.
				this.Stage_clear();
			}
		};
	
		/**
		 * Draws the stage into the supplied context if possible. Many WebGL properties only exist on their context. As such
		 * you cannot share contexts among many StageGLs and each context requires a unique StageGL instance. Contexts that
		 * don't match the context managed by this StageGL will be treated as a 2D context.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D | WebGLRenderingContext} context The context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For
		 *  example, used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean} If the draw was handled by this function
		 */
		p.draw = function (context, ignoreCache) {
			if (context === this._webGLContext && StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				this._batchDraw(this, gl, ignoreCache);
				return true;
			} else {
				return this.Stage_draw(context, ignoreCache);
			}
		};
	
		/**
		 * Draws the target into the correct context, be it a canvas or Render Texture using WebGL.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method cacheDraw
		 * @param {DisplayObject} target The object we're drawing into cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 * @return {Boolean} If the draw was handled by this function
		 */
		p.cacheDraw = function (target, filters, manager) {
			if (StageGL.isWebGLActive(this._webGLContext)) {
				var gl = this._webGLContext;
				this._cacheDraw(gl, target, filters, manager);
				return true;
			} else {
				return false;
			}
		};
	
		/**
		 * Blocks, or frees a texture "slot" on the GPU. Can be useful if you are overflowing textures. When overflowing
		 * textures they are re-uploaded to the GPU every time they're encountered, this can be expensive with large textures.
		 * By blocking the slot you reduce available slots, potentially increasing draw calls, but mostly you prevent a
		 * texture being re-uploaded if it would have moved slots due to overflow.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * For example, block the slot a background image is stored in so there is less re-loading of that image.
		 * @method protectTextureSlot
		 * @param  {Number} id The slot to be affected
		 * @param  {Boolean} [lock=false] Whether this slot is the one being locked.
		 */
		p.protectTextureSlot = function (id, lock) {
			if (id > this._maxTextureSlots || id < 0) {
				throw "Slot outside of acceptable range";
			}
			this._slotBlacklist[id] = !!lock;
		};
	
		/**
		 * Render textures can't draw into themselves so any item being used for renderTextures needs two to alternate between.
		 * This function creates, gets, and toggles the render surface between the two.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method getTargetRenderTexture
		 * @param  {DisplayObject} target The object associated with the render textures, usually a cached object.
		 * @param  {Number} w The width to create the texture at.
		 * @param  {Number} h The height to create the texture at.
		 * @return {Objet}
		 * @todo fill in return type
		 */
		p.getTargetRenderTexture = function (target, w, h) {
			var result, toggle = false;
			var gl = this._webGLContext;
			if (target.__lastRT !== undefined && target.__lastRT === target.__rtA) { toggle = true; }
			if (!toggle) {
				if (target.__rtA === undefined) {
					target.__rtA = this.getRenderBufferTexture(w, h);
				} else {
					if (w != target.__rtA._width || h != target.__rtA._height) {
						this.resizeTexture(target.__rtA, w, h);
					}
					this.setTextureParams(gl);
				}
				result = target.__rtA;
			} else {
				if (target.__rtB === undefined) {
					target.__rtB = this.getRenderBufferTexture(w, h);
				} else {
					if (w != target.__rtB._width || h != target.__rtB._height) {
						this.resizeTexture(target.__rtB, w, h);
					}
					this.setTextureParams(gl);
				}
				result = target.__rtB;
			}
			if (!result) {
				throw "Problems creating render textures, known causes include using too much VRAM by not releasing WebGL texture instances";
			}
			target.__lastRT = result;
			return result;
		};
	
		/**
		 * For every image encountered StageGL registers and tracks it automatically. This tracking can cause memory leaks 
		 * if not purged. StageGL, by default, automatically purges them. This does have a cost and may unfortunately find
		 * false positives. This function is for manual management of this memory instead of the automatic system controlled
		 * by the {{#crossLink "StageGL/autoPurge:property"}}{{/crossLink}} property.
		 *
		 * This function will recursively remove all textures found on the object, its children, cache, etc. It will uncache 
		 * objects and remove any texture it finds REGARDLESS of whether it is currently in use elsewhere. It is up to the
		 * developer to ensure that a texture in use is not removed.
		 *
		 * Textures in use, or to be used again shortly, should not be removed. This is simply for performance reasons.
		 * Removing a texture in use will cause the texture to have to be re-uploaded slowing rendering.
		 * @method releaseTexture
		 * @param  {DisplayObject | Texture | Image | Canvas} item An object that used the texture to be discarded.
		 */
		p.releaseTexture = function (item) {
			var i, l;
			if (!item) { return; }
	
			// this is a container object
			if (item.children) {
				for (i = 0, l = item.children.length; i < l; i++) {
					this.releaseTexture(item.children[i]);
				}
			}
	
			// this has a cache canvas
			if (item.cacheCanvas) {
				item.uncache();
			}
	
			var foundImage = undefined;
			if (item._storeID !== undefined) {
				// this is a texture itself
				if (item === this._textureDictionary[item._storeID]) {
					this._killTextureObject(item);
					item._storeID = undefined;
					return;
				}
	
				// this is an image or canvas
				foundImage = item;
			} else if (item._webGLRenderStyle === 2) {
				// this is a Bitmap class
				foundImage = item.image;
			} else if (item._webGLRenderStyle === 1) {
				// this is a SpriteSheet, we can't tell which image we used from the list easily so remove them all!
				for (i = 0, l = item.spriteSheet._images.length; i < l; i++) {
					this.releaseTexture(item.spriteSheet._images[i]);
				}
				return;
			}
	
			// did we find anything
			if (foundImage === undefined) {
				if (this.vocalDebug) {
					console.log("No associated texture found on release");
				}
				return;
			}
	
			// remove it
			this._killTextureObject(this._textureDictionary[foundImage._storeID]);
			foundImage._storeID = undefined;
		};
	
		/**
		 * Similar to {{#crossLink "releaseTexture"}}{{/crossLink}}, but this function differs by searching for textures to
		 * release. It works by assuming that it can purge any texture which was last used more than "count" draw calls ago.
		 * Because this process is unaware of the objects and whether they may be used on your stage, false positives can
		 * occur. It is recommended to manually manage your memory with {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}},
		 * however, there are many use cases where this is simpler and error-free. This process is also run by default under
		 * the hood to prevent leaks. To disable it see the {{#crossLink "StageGL/autoPurge:property"}}{{/crossLink}} property.
		 * @method purgeTextures
		 * @param {Number} [count=100] How many renders ago the texture was last used
		 */
		p.purgeTextures = function (count) {
			if (count == undefined){ count = 100; }
	
			var dict = this._textureDictionary;
			var l = dict.length;
			for (var i= 0; i<l; i++) {
				var item = dict[i];
				if (!item) { continue; }
				if (item._drawID + count <= this._drawID) {	// use draw not batch as draw is more indicative of time
					this._killTextureObject(item);
				}
			}
		};
	
		/**
		 * Try to set the max textures the system can handle. It should default to the hardware maximum, and lower values
		 * may limit performance. Some devices have been known to mis-report their max textures, or you may need a standard
		 * baseline cross devices for testing. Barring the previous suggestions, there is little need to call this function
		 * as the library will automatically try to find the best value.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method updateSimultaneousTextureCount
		 * @param {Number} [count=1] The number of textures intended for simultaneous loading.
		 */
		p.updateSimultaneousTextureCount = function (count) {
			// TODO: DHG: make sure API works in all instances, may be some issues with buffers etc I haven't foreseen
			var gl = this._webGLContext;
			var success = false;
	
			if (count < 1 || isNaN(count)) { count = 1; }
			this._batchTextureCount = count;
	
			while (!success) {
				try {
					this._activeShader = this._fetchShaderProgram(gl);
					success = true;
				} catch(e) {
					if (this._batchTextureCount == 1) {
						throw "Cannot compile shader " + e;
					}
	
					this._batchTextureCount -= 4;
					if (this._batchTextureCount < 1) { this._batchTextureCount = 1; }
	
					if (this.vocalDebug) {
						console.log("Reducing desired texture count due to errors: " + this._batchTextureCount);
					}
				}
			}
		};
	
		/**
		 * Update the WebGL viewport. Note that this does <strong>not</strong> update the canvas element's width/height, but
		 * the render surface's instead. This is necessary after manually resizing the canvas element on the DOM to avoid a
		 * up/down scaled render.
		 * @method updateViewport
		 * @param {Integer} width The width of the render surface in pixels.
		 * @param {Integer} height The height of the render surface in pixels.
		 */
		p.updateViewport = function (width, height) {
			this._viewportWidth = width|0;
			this._viewportHeight = height|0;
			var gl = this._webGLContext;
	
			if (gl) {
				gl.viewport(0, 0, this._viewportWidth, this._viewportHeight);
	
				// WebGL works with a -1,1 space on its screen. It also follows Y-Up
				// we need to flip the y, scale and then translate the co-ordinates to match this
				// additionally we offset into they Y so the polygons are inside the camera's "clipping" plane
				this._projectionMatrix = new Float32Array([
					2 / this._viewportWidth,	0,								0,							0,
					0,							-2 / this._viewportHeight,		1,							0,
					0,							0,								1,							0,
					-1,							1,								0.1,						0
				]);
				// create the flipped version for use with render texture flipping
				// DHG: this would be a slice/clone but some platforms don't offer them for Float32Array
				this._projectionMatrixFlip = new Float32Array([0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]);
				this._projectionMatrixFlip.set(this._projectionMatrix);
				this._projectionMatrixFlip[5] *= -1;
				this._projectionMatrixFlip[13] *= -1;
			}
		};
	
		/**
		 * Fetches the shader compiled and set up to work with the provided filter/object. The shader is compiled on first
		 * use and returned on subsequent calls.
		 * @method getFilterShader
		 * @param  {Filter|Object} filter The object which will provide the information needed to construct the filter shader.
		 * @return {WebGLProgram}
		 */
		p.getFilterShader = function (filter) {
			if (!filter) { filter = this; }
	
			var gl = this._webGLContext;
			var targetShader = this._activeShader;
	
			if (filter._builtShader) {
				targetShader = filter._builtShader;
				if (filter.shaderParamSetup) {
					gl.useProgram(targetShader);
					filter.shaderParamSetup(gl, this, targetShader);
				}
			} else {
				try {
					targetShader = this._fetchShaderProgram(
						gl, "filter",
						filter.VTX_SHADER_BODY, filter.FRAG_SHADER_BODY,
						filter.shaderParamSetup && filter.shaderParamSetup.bind(filter)
					);
					filter._builtShader = targetShader;
					targetShader._name = filter.toString();
				} catch (e) {
					console && console.log("SHADER SWITCH FAILURE", e);
				}
			}
			return targetShader;
		};
	
		/**
		 * Returns a base texture that has no image or data loaded. Not intended for loading images. It may return `null`
		 * in some error cases, and trying to use a "null" texture can cause renders to fail.
		 * @method getBaseTexture
		 * @param  {uint} [w=1] The width of the texture in pixels, defaults to 1
		 * @param  {uint} [h=1] The height of the texture in pixels, defaults to 1
		 */
		p.getBaseTexture = function (w, h) {
			var width = Math.ceil(w > 0 ? w : 1) || 1;
			var height = Math.ceil(h > 0 ? h : 1) || 1;
	
			var gl = this._webGLContext;
			var texture = gl.createTexture();
			this.resizeTexture(texture, width, height);
			this.setTextureParams(gl, false);
	
			return texture;
		};
	
		/**
		 * Resizes a supplied texture element. May generate invalid textures in some error cases such as; when the texture
		 * is too large, when an out of texture memory error occurs, or other error scenarios. Trying to use an invalid texture
		 * can cause renders to hard stop on some devices. Check the WebGL bound texture after running this function.
		 *
		 * NOTE: The supplied texture must have been made with the WebGL "texImage2D" function, all default APIs in StageGL
		 * use this, so this note only matters for library developers and plugins.
		 *
		 * @protected
		 * @method resizeTexture
		 * @param  {WebGLTexture} texture The GL Texture to be modified.
		 * @param  {uint} [width=1] The width of the texture in pixels, defaults to 1
		 * @param  {uint} [height=1] The height of the texture in pixels, defaults to 1
		 */
		p.resizeTexture = function (texture, width,height) {
			var gl = this._webGLContext;
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(
				gl.TEXTURE_2D,				// target
				0,							// level of detail
				gl.RGBA,					// internal format
				width, height, 0,			// width, height, border (only for array/null sourced textures)
				gl.RGBA,					// format (match internal format)
				gl.UNSIGNED_BYTE,			// type of texture(pixel color depth)
				null						// image data, we can do null because we're doing array data
			);
			texture.width = width;
			texture.height = height;
		};
	
		/**
		 * Returns a base texture (see {{#crossLink "StageGL/getBaseTexture"}}{{/crossLink}}) for details. Also includes an
		 * attached and linked render buffer in `texture._frameBuffer`. RenderTextures can be thought of as an internal
		 * canvas on the GPU that can be drawn to.
		 * @method getRenderBufferTexture
		 * @param  {Number} w The width of the texture in pixels.
		 * @param  {Number} h The height of the texture in pixels.
		 * @return {Texture} the basic texture instance with a render buffer property.
		 */
		p.getRenderBufferTexture = function (w, h) {
			var gl = this._webGLContext;
	
			// get the texture
			var renderTexture = this.getBaseTexture(w, h);
			if (!renderTexture) { return null; }
	
			// get the frame buffer
			var frameBuffer = gl.createFramebuffer();
			if (!frameBuffer) { return null; }
	
			// set its width and height for spoofing as an image
			renderTexture.width = w;
			renderTexture.height = h;
	
			// attach frame buffer to texture and provide cross links to look up each other
			gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
			frameBuffer._renderTexture = renderTexture;
			renderTexture._frameBuffer = frameBuffer;
	
			// these keep track of themselves simply to reduce complexity of some lookup code
			renderTexture._storeID = this._textureDictionary.length;
			this._textureDictionary[renderTexture._storeID] = renderTexture;
	
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			return renderTexture;
		};
	
		/**
		 * Common utility function used to apply the correct texture processing parameters for the bound texture.
		 * @method setTextureParams
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {Boolean} [isPOT=false] Marks whether the texture is "Power of Two", this may allow better quality AA.
		 */
		p.setTextureParams = function (gl, isPOT) {
			if (isPOT && this._antialias) {
				//non POT linear works in some devices, but performance is NOT good, investigate
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			} else {
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			}
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		};
	
		/**
		 * Changes the webGL clear, aka "background" color to the provided value. A transparent clear is recommended, as
		 * non-transparent colours may create undesired boxes around some visuals.
		 *
		 * The clear color will also be used for filters and other "render textures". The stage background will ignore the
		 * transparency value and display a solid color normally. For the stage to recognize and use transparency it must be
		 * created with the transparent flag set to `true` (see {{#crossLink "StageGL/constructor"}}{{/crossLink}})).
		 *
		 * Using "transparent white" to demonstrate, the valid data formats are as follows:
		 * <ul>
		 *     <li>"#FFF"</li>
		 *     <li>"#FFFFFF"</li>
		 *     <li>"#FFFFFF00"</li>
		 *     <li>"rgba(255,255,255,0.0)"</li>
		 * </ul>
		 * @method setClearColor
		 * @param {String|int} [color=0x00000000] The new color to use as the background
		 */
		p.setClearColor = function (color) {
			var r, g, b, a, output;
	
			if (typeof color == "string") {
				if (color.indexOf("#") == 0) {
					if (color.length == 4) {
						color = "#" + color.charAt(1)+color.charAt(1) + color.charAt(2)+color.charAt(2) + color.charAt(3)+color.charAt(3)
					}
					r = Number("0x"+color.slice(1, 3))/255;
					g = Number("0x"+color.slice(3, 5))/255;
					b = Number("0x"+color.slice(5, 7))/255;
					a = Number("0x"+color.slice(7, 9))/255;
				} else if (color.indexOf("rgba(") == 0) {
					output = color.slice(5, -1).split(",");
					r = Number(output[0])/255;
					g = Number(output[1])/255;
					b = Number(output[2])/255;
					a = Number(output[3]);
				}
			} else {	// >>> is an unsigned shift which is what we want as 0x80000000 and up are negative values
				r = ((color & 0xFF000000) >>> 24)/255;
				g = ((color & 0x00FF0000) >>> 16)/255;
				b = ((color & 0x0000FF00) >>> 8)/255;
				a = (color & 0x000000FF)/255;
			}
	
			this._clearColor.r = r || 0;
			this._clearColor.g = g || 0;
			this._clearColor.b = b || 0;
			this._clearColor.a = a || 0;
	
			if (!this._webGLContext) { return; }
			this._webGLContext.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
		};
	
		/**
		 * docced in subclass
		 */
		p.toString = function () {
			return "[StageGL (name="+  this.name +")]";
		};
	
	// private methods:
		/**
		 * Sets up and returns the WebGL context for the canvas. May return undefined in error scenarios. These can include 
		 * situations where the canvas element already has a context, 2D or GL.
		 * @param  {Canvas} canvas The DOM canvas element to attach to
		 * @param  {Object} options The options to be handed into the WebGL object, see WebGL spec
		 * @method _fetchWebGLContext
		 * @protected
		 * @return {WebGLRenderingContext} The WebGL context, may return undefined in error scenarios
		 */
		p._fetchWebGLContext = function (canvas, options) {
			var gl;
	
			try {
				gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
			} catch (e) {
				// don't do anything in catch, null check will handle it
			}
	
			if (!gl) {
				var msg = "Could not initialize WebGL";
				console.error?console.error(msg):console.log(msg);
			} else {
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
	
			return gl;
		};
	
		/**
		 * Create the completed Shader Program from the vertex and fragment shaders. Allows building of custom shaders for
		 * filters. Once compiled, shaders are saved so. If the Shader code requires dynamic alterations re-run this function
		 * to generate a new shader.
		 * @method _fetchShaderProgram
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {String} [shaderName="regular"] Working values: "regular", "override", and "filter". Which type of shader to build.
		 * Filter and override both accept the custom params. Regular and override have all features. Filter is a special case reduced feature shader meant to be over-ridden.
		 * @param  {String} [customVTX] Extra vertex shader information to replace a regular draw, see 
		 * {{#crossLink "StageGL/COVER_VERTEX_BODY"}}{{/crossLink}} for default and {{#crossLink "Filter"}}{{/crossLink}} for examples.
		 * @param  {String} [customFRAG] Extra fragment shader information to replace a regular draw, see 
		 * {{#crossLink "StageGL/COVER_FRAGMENT_BODY"}}{{/crossLink}} for default and {{#crossLink "Filter"}}{{/crossLink}} for examples.
		 * @param  {Function} [shaderParamSetup] Function to run so custom shader parameters can get applied for the render.
		 * @protected
		 * @return {WebGLProgram} The compiled and linked shader
		 */
		p._fetchShaderProgram = function (gl, shaderName, customVTX, customFRAG, shaderParamSetup) {
			gl.useProgram(null);		// safety to avoid collisions
	
			// build the correct shader string out of the right headers and bodies
			var targetFrag, targetVtx;
			switch (shaderName) {
				case "filter":
					targetVtx = StageGL.COVER_VERTEX_HEADER + (customVTX || StageGL.COVER_VERTEX_BODY);
					targetFrag = StageGL.COVER_FRAGMENT_HEADER + (customFRAG || StageGL.COVER_FRAGMENT_BODY);
					break;
				case "particle": //TODO
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + StageGL.PARTICLE_VERTEX_BODY;
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + StageGL.PARTICLE_FRAGMENT_BODY;
					break;
				case "override":
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + (customVTX || StageGL.REGULAR_VERTEX_BODY);
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + (customFRAG || StageGL.REGULAR_FRAGMENT_BODY);
					break;
				case "regular":
				default:
					targetVtx = StageGL.REGULAR_VERTEX_HEADER + StageGL.REGULAR_VERTEX_BODY;
					targetFrag = StageGL.REGULAR_FRAGMENT_HEADER + StageGL.REGULAR_FRAGMENT_BODY;
					break;
			}
	
			// create the separate vars
			var vertexShader = this._createShader(gl, gl.VERTEX_SHADER, targetVtx);
			var fragmentShader = this._createShader(gl, gl.FRAGMENT_SHADER, targetFrag);
	
			// link them together
			var shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);
			shaderProgram._type = shaderName;
	
			// check compile status
			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				gl.useProgram(this._activeShader);
				throw gl.getProgramInfoLog(shaderProgram);
			}
	
			// set up the parameters on the shader
			gl.useProgram(shaderProgram);
			switch (shaderName) {
				case "filter":
					// get the places in memory the shader is stored so we can feed information into them
					// then save it off on the shader because it's so tied to the shader itself
					shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPosition");
					gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	
					shaderProgram.uvPositionAttribute = gl.getAttribLocation(shaderProgram, "uvPosition");
					gl.enableVertexAttribArray(shaderProgram.uvPositionAttribute);
	
					shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
					gl.uniform1i(shaderProgram.samplerUniform, 0);
	
					shaderProgram.uprightUniform = gl.getUniformLocation(shaderProgram, "uUpright");
					gl.uniform1f(shaderProgram.uprightUniform, 0);
	
					// if there's some custom attributes be sure to hook them up
					if (shaderParamSetup) {
						shaderParamSetup(gl, this, shaderProgram);
					}
					break;
				case "override":
				case "particle":
				case "regular":
				default:
					// get the places in memory the shader is stored so we can feed information into them
					// then save it off on the shader because it's so tied to the shader itself
					shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPosition");
					gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	
					shaderProgram.uvPositionAttribute = gl.getAttribLocation(shaderProgram, "uvPosition");
					gl.enableVertexAttribArray(shaderProgram.uvPositionAttribute);
	
					shaderProgram.textureIndexAttribute = gl.getAttribLocation(shaderProgram, "textureIndex");
					gl.enableVertexAttribArray(shaderProgram.textureIndexAttribute);
	
					shaderProgram.alphaAttribute = gl.getAttribLocation(shaderProgram, "objectAlpha");
					gl.enableVertexAttribArray(shaderProgram.alphaAttribute);
	
					var samplers = [];
					for (var i = 0; i < this._batchTextureCount; i++) {
						samplers[i] = i;
					}
	
					shaderProgram.samplerData = samplers;
					shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
					gl.uniform1iv(shaderProgram.samplerUniform, samplers);
	
					shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "pMatrix");
					break;
			}
	
			gl.useProgram(this._activeShader);
			return shaderProgram;
		};
	
		/**
		 * Creates a shader from the specified string replacing templates. Template items are defined via `{{` `key` `}}``.
		 * @method _createShader
		 * @param  {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param  {Number} type The type of shader to create. gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
		 * @param  {String} str The definition for the shader.
		 * @return {WebGLShader}
		 * @protected
		 */
		p._createShader = function (gl, type, str) {
			// inject the static number
			str = str.replace(/{{count}}/g, this._batchTextureCount);
	
			// resolve issue with no dynamic samplers by creating correct samplers in if else chain
			// TODO: WebGL 2.0 does not need this support
			var insert = "";
			for (var i = 1; i<this._batchTextureCount; i++) {
				insert += "} else if (indexPicker <= "+ i +".5) { color = texture2D(uSampler["+ i +"], vTextureCoord);";
			}
			str = str.replace(/{{alternates}}/g, insert);
			str = str.replace(/{{premultiply}}/g, this._premultiply ? "/color.a" : "");
	
			// actually compile the shader
			var shader = gl.createShader(type);
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
	
			// check compile status
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				throw gl.getShaderInfoLog(shader);
			}
	
			return shader;
		};
	
		/**
		 * Sets up the necessary vertex property buffers, including position and U/V.
		 * @method _createBuffers
		 * @param {WebGLRenderingContext} gl
		 * @protected
		 */
		p._createBuffers = function (gl) {
			var groupCount = this._maxCardsPerBatch * StageGL.INDICIES_PER_CARD;
			var groupSize, i, l;
	
			// INFO:
			// all buffers are created using this pattern
			// create a WebGL buffer
			// attach it to context
			// figure out how many parts it has to an entry
			// fill it with empty data to reserve the memory
			// attach the empty data to the GPU
			// track the sizes on the buffer object
	
			// INFO:
			// a single buffer may be optimal in some situations and would be approached like this,
			// currently not implemented due to lack of need and potential complications with drawCover
	
			// var vertexBuffer = this._vertexBuffer = gl.createBuffer();
			// gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			// groupSize = 2 + 2 + 1 + 1; //x/y, u/v, index, alpha
			// var vertexData = this._vertexData = new Float32Array(groupCount * groupSize);
			// for (i=0; i<vertexData.length; i+=groupSize) {
			// 	vertexData[i+0] = vertexData[i+1] = 0;
			// 	vertexData[i+2] = vertexData[i+3] = 0.5;
			// 	vertexData[i+4] = 0;
			// 	vertexData[i+5] = 1;
			// }
			// vertexBuffer.itemSize = groupSize;
			// vertexBuffer.numItems = groupCount;
			// TODO bechmark and test using unified buffer
	
			// the actual position information
			var vertexPositionBuffer = this._vertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			groupSize = 2;
			var vertices = this._vertices = new Float32Array(groupCount * groupSize);
			for (i=0, l=vertices.length; i<l; i+=groupSize) { vertices[i] = vertices[i+1] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
			vertexPositionBuffer.itemSize = groupSize;
			vertexPositionBuffer.numItems = groupCount;
	
			// where on the texture it gets its information
			var uvPositionBuffer = this._uvPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			groupSize = 2;
			var uvs = this._uvs = new Float32Array(groupCount * groupSize);
			for (i=0, l=uvs.length; i<l; i+=groupSize) { uvs[i] = uvs[i+1] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.DYNAMIC_DRAW);
			uvPositionBuffer.itemSize = groupSize;
			uvPositionBuffer.numItems = groupCount;
	
			// what texture it should use
			var textureIndexBuffer = this._textureIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, textureIndexBuffer);
			groupSize = 1;
			var indices = this._indices = new Float32Array(groupCount * groupSize);
			for (i=0, l=indices.length; i<l; i++) { indices[i] = 0; }
			gl.bufferData(gl.ARRAY_BUFFER, indices, gl.DYNAMIC_DRAW);
			textureIndexBuffer.itemSize = groupSize;
			textureIndexBuffer.numItems = groupCount;
	
			// what alpha it should have
			var alphaBuffer = this._alphaBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
			groupSize = 1;
			var alphas = this._alphas = new Float32Array(groupCount * groupSize);
			for (i=0, l=alphas.length; i<l; i++) { alphas[i] = 1; }
			gl.bufferData(gl.ARRAY_BUFFER, alphas, gl.DYNAMIC_DRAW);
			alphaBuffer.itemSize = groupSize;
			alphaBuffer.numItems = groupCount;
		};
	
		/**
		 * Do all the setup steps for textures in the system.
		 * @method _initTextures
		 * @protected
		 */
		p._initTextures = function () {
			//TODO: DHG: add a cleanup routine in here in case this happens mid stream
	
			// reset counters
			this._lastTextureInsert = -1;
	
			// clear containers
			this._textureDictionary = [];
			this._textureIDs = {};
			this._baseTextures = [];
			this._batchTextures = [];
	
			// fill in blanks as it helps the renderer be stable while textures are loading and reduces need for safety code
			for (var i=0; i<this._batchTextureCount;i++) {
				var tex = this.getBaseTexture();
				this._baseTextures[i] = this._batchTextures[i] = tex;
				if (!tex) {
					throw "Problems creating basic textures, known causes include using too much VRAM by not releasing WebGL texture instances";
				}
			}
		};
	
		/**
		 * Load a specific texture, accounting for potential delay, as it might not be preloaded.
		 * @method _loadTextureImage
		 * @param {WebGLRenderingContext} gl
		 * @param {Image} image Actual image to be loaded
		 * @return {WebGLTexture} The resulting Texture object
		 * @protected
		 */
		p._loadTextureImage = function (gl, image) {
			var src = image.src;
	
			if (!src) {
				// one time canvas property setup
				image._isCanvas = true;
				src = image.src = "canvas_" + this._lastTrackedCanvas++;
			}
	
			// put the texture into our storage system
			var storeID = this._textureIDs[src];
			if (storeID === undefined) {
				storeID = this._textureIDs[src] = this._textureDictionary.length;
			}
			if (this._textureDictionary[storeID] === undefined) {
				this._textureDictionary[storeID] = this.getBaseTexture();
			}
	
			var texture = this._textureDictionary[storeID];
	
			if (texture) {
				// get texture params all set up
				texture._batchID = this._batchID;
				texture._storeID = storeID;
				texture._imageData = image;
				this._insertTextureInBatch(gl, texture);
	
				// get the data into the texture or wait for it to load
				image._storeID = storeID;
				if (image.complete || image.naturalWidth || image._isCanvas) {	// is it already loaded
					this._updateTextureImageData(gl, image);
				} else  {
					image.addEventListener("load", this._updateTextureImageData.bind(this, gl, image));
				}
			} else {
				// we really really should have a texture, try to recover the error by using a saved empty texture so we don't crash
				var msg = "Problem creating desired texture, known causes include using too much VRAM by not releasing WebGL texture instances";
				(console.error && console.error(msg)) || console.log(msg);
	
				texture = this._baseTextures[0];
				texture._batchID = this._batchID;
				texture._storeID = -1;
				texture._imageData = texture;
				this._insertTextureInBatch(gl, texture);
			}
	
			return texture;
		};
	
		/**
		 * Necessary to upload the actual image data to the GPU. Without this the texture will be blank. Called automatically
		 * in most cases due to loading and caching APIs. Flagging an image source with `_invalid = true` will trigger this
		 * next time the image is rendered.
		 * @param {WebGLRenderingContext} gl
		 * @param {Image | Canvas} image The image data to be uploaded
		 * @protected
		 */
		p._updateTextureImageData = function (gl, image) {
			// the bitwise & is intentional, cheap exponent 2 check
			var isNPOT = (image.width & image.width-1) || (image.height & image.height-1);
			var texture = this._textureDictionary[image._storeID];
	
			gl.activeTexture(gl.TEXTURE0 + texture._activeIndex);
			gl.bindTexture(gl.TEXTURE_2D, texture);
	
			texture.isPOT = !isNPOT;
			this.setTextureParams(gl, texture.isPOT);
	
			try {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			} catch(e) {
				var errString = "\nAn error has occurred. This is most likely due to security restrictions on WebGL images with local or cross-domain origins";
				if(console.error) {
					//TODO: LM: I recommend putting this into a log function internally, since you do it so often, and each is implemented differently.
					console.error(errString);
					console.error(e);
				} else if (console) {
					console.log(errString);
					console.log(e);
				}
			}
	
			image._invalid = false;
	
			texture._w = image.width;
			texture._h = image.height;
	
			if (this.vocalDebug) {
				if (isNPOT) {
					console.warn("NPOT(Non Power of Two) Texture: "+ image.src);
				}
				if (image.width > gl.MAX_TEXTURE_SIZE || image.height > gl.MAX_TEXTURE_SIZE){
					console && console.error("Oversized Texture: "+ image.width+"x"+image.height +" vs "+ gl.MAX_TEXTURE_SIZE +"max");
				}
			}
		};
	
		/**
		 * Adds the texture to a spot in the current batch, forcing a draw if no spots are free.
		 * @method _insertTextureInBatch
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {WebGLTexture} texture The texture to be inserted.
		 * @protected
		 */
		p._insertTextureInBatch = function (gl, texture) {
			// if it wasn't used last batch
			if (this._batchTextures[texture._activeIndex] !== texture) {
				// we've got to find it a a spot.
				var found = -1;
				var start = (this._lastTextureInsert+1) % this._batchTextureCount;
				var look = start;
				do {
					if (this._batchTextures[look]._batchID != this._batchID && !this._slotBlacklist[look]) {
						found = look;
						break;
					}
					look = (look+1) % this._batchTextureCount;
				} while (look !== start);
	
				// we couldn't find anywhere for it go, meaning we're maxed out
				if (found === -1) {
					this.batchReason = "textureOverflow";
					this._drawBuffers(gl);		// <------------------------------------------------------------------------
					this.batchCardCount = 0;
					found = start;
				}
	
				// lets put it into that spot
				this._batchTextures[found] = texture;
				texture._activeIndex = found;
				var image = texture._imageData;
				if (image && image._invalid && texture._drawID !== undefined) {
					this._updateTextureImageData(gl, image);
				} else {
					gl.activeTexture(gl.TEXTURE0 + found);
					gl.bindTexture(gl.TEXTURE_2D, texture);
					this.setTextureParams(gl);
				}
				this._lastTextureInsert = found;
			} else {
				var image = texture._imageData;
				if (texture._storeID != undefined && image && image._invalid) {
					this._updateTextureImageData(gl, image);
				}
			}
	
			texture._drawID = this._drawID;
			texture._batchID = this._batchID;
		};
	
		/**
		 * Remove and clean the texture, expects a texture and is inflexible. Mostly for internal use, recommended to call 
		 * {{#crossLink "StageGL/releaseTexture"}}{{/crossLink}} instead as it will call this with the correct texture object(s).
		 * Note: Testing shows this may not happen immediately, have to wait frames for WebGL to have actually adjust memory.
		 * @method _killTextureObject
		 * @param {Texture} tex The texture to be cleaned out
		 * @protected
		 */
		p._killTextureObject = function (tex) {
			if (!tex) { return; }
			var gl = this._webGLContext;
	
			// remove linkage
			if (tex._storeID !== undefined && tex._storeID >= 0) {
				this._textureDictionary[tex._storeID] = undefined;
				for (var n in this._textureIDs) {
					if (this._textureIDs[n] == tex._storeID) { delete this._textureIDs[n]; }
				}
				if(tex._imageData) { tex._imageData._storeID = undefined; }
				tex._imageData = tex._storeID = undefined;
			}
	
			// make sure to drop it out of an active slot
			if (tex._activeIndex !== undefined && this._batchTextures[tex._activeIndex] === tex) {
				this._batchTextures[tex._activeIndex] = this._baseTextures[tex._activeIndex];
			}
	
			// remove buffers if present
			try {
				if (tex._frameBuffer) { gl.deleteFramebuffer(tex._frameBuffer); }
				tex._frameBuffer = undefined;
			} catch(e) {
				/* suppress delete errors because it's already gone or didn't need deleting probably */
				if (this.vocalDebug) { console.log(e); }
			}
	
			// remove entry
			try {
				gl.deleteTexture(tex);
			} catch(e) {
				/* suppress delete errors because it's already gone or didn't need deleting probably */
				if (this.vocalDebug) { console.log(e); }
			}
		};
	
		/**
		 * Store or restore current batch textures into a backup array
		 * @method _backupBatchTextures
		 * @param {Boolean} restore Perform a restore instead of a store.
		 * @param {Array} [target=this._backupTextures] Where to perform the backup, defaults to internal backup.
		 * @protected
		 */
		p._backupBatchTextures = function (restore, target) {
			var gl = this._webGLContext;
	
			if (!this._backupTextures) { this._backupTextures = []; }
			if (target === undefined) { target = this._backupTextures; }
	
			for (var i=0; i<this._batchTextureCount; i++) {
				gl.activeTexture(gl.TEXTURE0 + i);
				if (restore) {
					this._batchTextures[i] = target[i];
				} else {
					target[i] = this._batchTextures[i];
					this._batchTextures[i] = this._baseTextures[i];
				}
				gl.bindTexture(gl.TEXTURE_2D, this._batchTextures[i]);
				this.setTextureParams(gl, this._batchTextures[i].isPOT);
			}
	
			if (restore && target === this._backupTextures) { this._backupTextures = []; }
		};
	
		/**
		 * Begin the drawing process for a regular render.
		 * @method _batchDraw
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Stage || Container} sceneGraph {{#crossLink "Container"}}{{/crossLink}} object with all that needs to rendered, preferably a Stage.
		 * @param {Boolean} ignoreCache
		 * @protected
		 */
		p._batchDraw = function (sceneGraph, gl, ignoreCache) {
			if (this._isDrawing > 0) {
				this._drawBuffers(gl);
			}
			this._isDrawing++;
			this._drawID++;
	
			this.batchCardCount = 0;
			this.depth = 0;
	
			this._appendToBatchGroup(sceneGraph, gl, new createjs.Matrix2D(), this.alpha, ignoreCache);
	
			this.batchReason = "drawFinish";
			this._drawBuffers(gl);								// <--------------------------------------------------------
			this._isDrawing--;
		};
	
		/**
		 * Perform the drawing process to fill a specific cache texture, including applying filters.
		 * @method _cacheDraw
		 * @param {DisplayObject} target The object we're drawing into the cache. For example, used for drawing the cache
		 * (to prevent it from simply drawing an existing cache back into itself).
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 * @protected
		 */
		p._cacheDraw = function (gl, target, filters, manager) {
			/*
			Implicitly there are 4 modes to this function: filtered-sameContext, filtered-uniqueContext, sameContext, uniqueContext.
			Each situation must be handled slightly differently as 'sameContext' or 'uniqueContext' define how the output works,
			one drawing directly into the main context and the other drawing into a stored renderTexture respectively.
			When the draw is a 'filtered' draw, the filters are applied sequentially and will draw into saved textures repeatedly.
			Once the final filter is done the final output is treated depending upon whether it is a same or unique context.
			The internal complexity comes from reducing over-draw, shared code, and issues like textures needing to be flipped
			sometimes when written to render textures.
			*/
			var renderTexture;
			var shaderBackup = this._activeShader;
			var blackListBackup = this._slotBlacklist;
			var lastTextureSlot = this._maxTextureSlots-1;
			var wBackup = this._viewportWidth, hBackup = this._viewportHeight;
	
			// protect the last slot so that we have somewhere to bind the renderTextures so it doesn't get upset
			this.protectTextureSlot(lastTextureSlot, true);
	
			// create offset container for drawing item
			var mtx = target.getMatrix();
			mtx = mtx.clone();
			mtx.scale(1/manager.scale, 1/manager.scale);
			mtx = mtx.invert();
			mtx.translate(-manager.offX/manager.scale, -manager.offY/manager.scale);
			var container = this._cacheContainer;
			container.children = [target];
			container.transformMatrix = mtx;
	
			this._backupBatchTextures(false);
	
			var filterCount = filters && filters.length;
			if (filterCount) {
				this._drawFilters(target, filters, manager);
			} else {
				// is this for another stage or mine?
				if (this.isCacheControlled) {
					// draw item to canvas				I -> C
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._batchDraw(container, gl, true);
				} else {
					gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
					target.cacheCanvas = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
					renderTexture = target.cacheCanvas;
	
					// draw item to render texture		I -> T
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
					this.updateViewport(manager._drawWidth, manager._drawHeight);
					this._projectionMatrix = this._projectionMatrixFlip;
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._batchDraw(container, gl, true);
	
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					this.updateViewport(wBackup, hBackup);
				}
			}
	
			this._backupBatchTextures(true);
	
			this.protectTextureSlot(lastTextureSlot, false);
			this._activeShader = shaderBackup;
			this._slotBlacklist = blackListBackup;
		};
	
		/**
		 * Sub portion of _cacheDraw, split off for readability. Do not call independently.
		 * @method _drawFilters
		 * @param {DisplayObject} target The object we're drawing with a filter.
		 * @param {Array} filters The filters we're drawing into cache.
		 * @param {BitmapCache} manager The BitmapCache instance looking after the cache
		 */
		p._drawFilters = function (target, filters, manager) {
			var gl = this._webGLContext;
			var renderTexture;
			var lastTextureSlot = this._maxTextureSlots-1;
			var wBackup = this._viewportWidth, hBackup = this._viewportHeight;
	
			var container = this._cacheContainer;
			var filterCount = filters && filters.length;
	
			// we don't know which texture slot we're dealing with previously and we need one out of the way
			// once we're using that slot activate it so when we make and bind our RenderTexture it's safe there
			gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
			renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
	
			// draw item to render texture		I -> T
			gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
			this.updateViewport(manager._drawWidth, manager._drawHeight);
			gl.clear(gl.COLOR_BUFFER_BIT);
			this._batchDraw(container, gl, true);
	
			// bind the result texture to slot 0 as all filters and cover draws assume original content is in slot 0
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, renderTexture);
			this.setTextureParams(gl);
	
			var flipY = false;
	
			// apply each filter in order, but remember to toggle used texture and render buffer
			for (var i=0; i<filterCount; i++) {
				var filter = filters[i];
	
				// swap to correct shader
				this._activeShader = this.getFilterShader(filter);
				if (!this._activeShader) { continue; }
	
				// now the old result is stored in slot 0, make a new render texture
				gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
				renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
	
				// draw result to render texture	R -> T
				gl.viewport(0, 0, manager._drawWidth, manager._drawHeight);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._drawCover(gl, flipY);
	
				// bind the result texture to slot 0 as all filters and cover draws assume original content is in slot 0
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, renderTexture);
				this.setTextureParams(gl);
	
				// use flipping to keep things upright, things already cancel out on a single filter
				if (filterCount > 1) {
					flipY = !flipY;
				}
			}
	
			// is this for another stage or mine
			if (this.isCacheControlled) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				this.updateViewport(wBackup, hBackup);
	
				// draw result to canvas			R -> C
				this._activeShader = this.getFilterShader(this);
				gl.clear(gl.COLOR_BUFFER_BIT);
				this._drawCover(gl, flipY);
			} else {
				//TODO: DHG: this is less than ideal. A flipped initial render for this circumstance might help. Adjust the perspective matrix?
				if (flipY) {
					gl.activeTexture(gl.TEXTURE0 + lastTextureSlot);
					renderTexture = this.getTargetRenderTexture(target, manager._drawWidth, manager._drawHeight);
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture._frameBuffer);
	
					this._activeShader = this.getFilterShader(this);
					gl.viewport(0, 0, manager._drawWidth, manager._drawHeight);
					gl.clear(gl.COLOR_BUFFER_BIT);
					this._drawCover(gl, !flipY);
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				this.updateViewport(wBackup, hBackup);
	
				// make sure the last texture is the active thing to draw
				target.cacheCanvas = renderTexture;
			}
		};
	
		/**
		 * Add all the contents of a container to the pending buffers, called recursively on each container. This may
		 * trigger a draw if a buffer runs out of space. This is the main workforce of the render loop.
		 * @method _appendToBatchGroup
		 * @param {Container} container The {{#crossLink "Container"}}{{/crossLink}} that contains everything to be drawn.
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Matrix2D} concatMtx The effective (concatenated) transformation matrix when beginning this container
		 * @param {Number} concatAlpha The effective (concatenated) alpha when beginning this container
		 * @param {Boolean} ignoreCache Don't use an element's cache during this draw
		 * @protected
		 */
		p._appendToBatchGroup = function (container, gl, concatMtx, concatAlpha, ignoreCache) {
			// sort out shared properties
			if (!container._glMtx) { container._glMtx = new createjs.Matrix2D(); }
			var cMtx = container._glMtx;
			cMtx.copy(concatMtx);
			if (container.transformMatrix) {
				cMtx.appendMatrix(container.transformMatrix);
			} else {
				cMtx.appendTransform(
					container.x, container.y,
					container.scaleX, container.scaleY,
					container.rotation, container.skewX, container.skewY,
					container.regX, container.regY
				);
			}
	
			// sub components of figuring out the position an object holds
			var subL, subT, subR, subB;
	
			// actually apply its data to the buffers
			var l = container.children.length;
			for (var i = 0; i < l; i++) {
				var item = container.children[i];
	
				if (!(item.visible && concatAlpha)) { continue; }
				if (!item.cacheCanvas || ignoreCache) {
					if (item._updateState){
						item._updateState();
					}
					if (item.children) {
						this._appendToBatchGroup(item, gl, cMtx, item.alpha * concatAlpha);
						continue;
					}
				}
	
				// check for overflowing batch, if yes then force a render
				// TODO: DHG: consider making this polygon count dependant for things like vector draws
				if (this.batchCardCount+1 > this._maxCardsPerBatch) {
					this.batchReason = "vertexOverflow";
					this._drawBuffers(gl);					// <------------------------------------------------------------
					this.batchCardCount = 0;
				}
	
				// keep track of concatenated position
				if (!item._glMtx) { item._glMtx = new createjs.Matrix2D(); }
				var iMtx = item._glMtx;
				iMtx.copy(cMtx);
				if (item.transformMatrix) {
					iMtx.appendMatrix(item.transformMatrix);
				} else {
					iMtx.appendTransform(
						item.x, item.y,
						item.scaleX, item.scaleY,
						item.rotation, item.skewX, item.skewY,
						item.regX, item.regY
					);
				}
	
				var uvRect, texIndex, image, frame, texture, src;
				var useCache = item.cacheCanvas && !ignoreCache;
	
				if (item._webGLRenderStyle === 2 || useCache) {			// BITMAP / Cached Canvas
					image = (ignoreCache?false:item.cacheCanvas) || item.image;
				} else if (item._webGLRenderStyle === 1) {											// SPRITE
					frame = item.spriteSheet.getFrame(item.currentFrame);	//TODO: Faster way?
					if (frame === null) { continue; }
					image = frame.image;
				} else {																			// MISC (DOM objects render themselves later)
					continue;
				}
	
				var uvs = this._uvs;
				var vertices = this._vertices;
				var texI = this._indices;
				var alphas = this._alphas;
	
				// calculate texture
				if (!image) { continue; }
				if (image._storeID === undefined) {
					// this texture is new to us so load it and add it to the batch
					texture = this._loadTextureImage(gl, image);
					this._insertTextureInBatch(gl, texture);
				} else {
					// fetch the texture (render textures know how to look themselves up to simplify this logic)
					texture = this._textureDictionary[image._storeID];
					if (!texture){
						if (this.vocalDebug){ console.log("Texture should not be looked up while not being stored."); }
						continue;
					}
	
					// put it in the batch if needed
					if (texture._batchID !== this._batchID) {
						this._insertTextureInBatch(gl, texture);
					}
				}
				texIndex = texture._activeIndex;
	
				if (item._webGLRenderStyle === 2 || useCache) {			// BITMAP / Cached Canvas
					if (!useCache && item.sourceRect) {
						// calculate uvs
						if (!item._uvRect) { item._uvRect = {}; }
						src = item.sourceRect;
						uvRect = item._uvRect;
						uvRect.t = (src.y)/image.height;
						uvRect.l = (src.x)/image.width;
						uvRect.b = (src.y + src.height)/image.height;
						uvRect.r = (src.x + src.width)/image.width;
	
						// calculate vertices
						subL = 0;							subT = 0;
						subR = src.width+subL;				subB = src.height+subT;
					} else {
						// calculate uvs
						uvRect = StageGL.UV_RECT;
						// calculate vertices
						if (useCache) {
							src = item.bitmapCache;
							subL = src.x+(src._filterOffX/src.scale);	subT = src.y+(src._filterOffY/src.scale);
							subR = (src._drawWidth/src.scale)+subL;		subB = (src._drawHeight/src.scale)+subT;
						} else {
							subL = 0;						subT = 0;
							subR = image.width+subL;		subB = image.height+subT;
						}
					}
				} else if (item._webGLRenderStyle === 1) {											// SPRITE
					var rect = frame.rect;
	
					// calculate uvs
					uvRect = frame.uvRect;
					if (!uvRect) {
						uvRect = StageGL.buildUVRects(item.spriteSheet, item.currentFrame, false);
					}
	
					// calculate vertices
					subL = -frame.regX;								subT = -frame.regY;
					subR = rect.width-frame.regX;					subB = rect.height-frame.regY;
				}
	
				// These must be calculated here else a forced draw might happen after they're set
				var offV1 = this.batchCardCount*StageGL.INDICIES_PER_CARD;		// offset for 1 component vectors
				var offV2 = offV1*2;											// offset for 2 component vectors
	
				//DHG: See Matrix2D.transformPoint for why this math specifically
				// apply vertices
				vertices[offV2] =		subL *iMtx.a + subT *iMtx.c +iMtx.tx;		vertices[offV2+1] =		subL *iMtx.b + subT *iMtx.d +iMtx.ty;
				vertices[offV2+2] =		subL *iMtx.a + subB *iMtx.c +iMtx.tx;		vertices[offV2+3] =		subL *iMtx.b + subB *iMtx.d +iMtx.ty;
				vertices[offV2+4] =		subR *iMtx.a + subT *iMtx.c +iMtx.tx;		vertices[offV2+5] =		subR *iMtx.b + subT *iMtx.d +iMtx.ty;
				vertices[offV2+6] =		vertices[offV2+2];							vertices[offV2+7] =		vertices[offV2+3];
				vertices[offV2+8] =		vertices[offV2+4];							vertices[offV2+9] =		vertices[offV2+5];
				vertices[offV2+10] =	subR *iMtx.a + subB *iMtx.c +iMtx.tx;		vertices[offV2+11] =	subR *iMtx.b + subB *iMtx.d +iMtx.ty;
	
				// apply uvs
				uvs[offV2] =	uvRect.l;			uvs[offV2+1] =	uvRect.t;
				uvs[offV2+2] =	uvRect.l;			uvs[offV2+3] =	uvRect.b;
				uvs[offV2+4] =	uvRect.r;			uvs[offV2+5] =	uvRect.t;
				uvs[offV2+6] =	uvRect.l;			uvs[offV2+7] =	uvRect.b;
				uvs[offV2+8] =	uvRect.r;			uvs[offV2+9] =	uvRect.t;
				uvs[offV2+10] =	uvRect.r;			uvs[offV2+11] =	uvRect.b;
	
				// apply texture
				texI[offV1] = texI[offV1+1] = texI[offV1+2] = texI[offV1+3] = texI[offV1+4] = texI[offV1+5] = texIndex;
	
				// apply alpha
				alphas[offV1] = alphas[offV1+1] = alphas[offV1+2] = alphas[offV1+3] = alphas[offV1+4] = alphas[offV1+5] = item.alpha * concatAlpha;
	
				this.batchCardCount++;
			}
		};
	
		/**
		 * Draws all the currently defined cards in the buffer to the render surface.
		 * @method _drawBuffers
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @protected
		 */
		p._drawBuffers = function (gl) {
			if (this.batchCardCount <= 0) { return; }	// prevents error logs on stages filled with un-renederable content.
	
			if (this.vocalDebug) {
				console.log("Draw["+ this._drawID +":"+ this._batchID +"] : "+ this.batchReason);
			}
			var shaderProgram = this._activeShader;
			var vertexPositionBuffer = this._vertexPositionBuffer;
			var textureIndexBuffer = this._textureIndexBuffer;
			var uvPositionBuffer = this._uvPositionBuffer;
			var alphaBuffer = this._alphaBuffer;
	
			gl.useProgram(shaderProgram);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, textureIndexBuffer);
			gl.vertexAttribPointer(shaderProgram.textureIndexAttribute, textureIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._indices);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.uvPositionAttribute, uvPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._uvs);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
			gl.vertexAttribPointer(shaderProgram.alphaAttribute, alphaBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._alphas);
	
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, gl.FALSE, this._projectionMatrix);
	
			for (var i = 0; i < this._batchTextureCount; i++) {
				var texture = this._batchTextures[i];
				gl.activeTexture(gl.TEXTURE0 + i);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				this.setTextureParams(gl, texture.isPOT);
			}
	
			gl.drawArrays(gl.TRIANGLES, 0, this.batchCardCount*StageGL.INDICIES_PER_CARD);
			this._batchID++;
		};
	
		/**
		 * Draws a card that covers the entire render surface. Mainly used for filters.
		 * @method _drawBuffers
		 * @param {WebGLRenderingContext} gl The canvas WebGL context object to draw into.
		 * @param {Boolean} flipY Covers are used for things like RenderTextures and because of 3D vs Canvas space this can
		 * end up meaning the `y` space sometimes requires flipping in the render.
		 * @protected
		 */
		p._drawCover = function (gl, flipY) {
			if (this._isDrawing > 0) {
				this._drawBuffers(gl);
			}
	
			if (this.vocalDebug) {
				console.log("Draw["+ this._drawID +":"+ this._batchID +"] : "+ "Cover");
			}
			var shaderProgram = this._activeShader;
			var vertexPositionBuffer = this._vertexPositionBuffer;
			var uvPositionBuffer = this._uvPositionBuffer;
	
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.useProgram(shaderProgram);
	
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, StageGL.COVER_VERT);
			gl.bindBuffer(gl.ARRAY_BUFFER, uvPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.uvPositionAttribute, uvPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, flipY?StageGL.COVER_UV_FLIP:StageGL.COVER_UV);
	
			gl.uniform1i(shaderProgram.samplerUniform, 0);
			gl.uniform1f(shaderProgram.uprightUniform, flipY?0:1);
	
			gl.drawArrays(gl.TRIANGLES, 0, StageGL.INDICIES_PER_CARD);
		};
	
		createjs.StageGL = createjs.promote(StageGL, "Stage");
	}());
	
	//##############################################################################
	// Bitmap.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		
		/**
		 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
		 * HTML element, or a string.
		 *
		 * <h4>Example</h4>
		 *
		 * 	var bitmap = new createjs.Bitmap("imagePath.jpg");
		 *
		 * <strong>Notes:</strong>
		 * <ol>
		 * 	<li>When using a video source that may loop or seek, use a {{#crossLink "VideoBuffer"}}{{/crossLink}} object to
		 * 	 prevent blinking / flashing.
		 * 	<li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
		 * 	 will be displayed.</li>
		 * 	<li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
		 * 	the Bitmap can be cached.</li>
		 * 	<li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
		 * 	happens in all browsers except recent Firefox builds.</li>
		 * 	<li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
		 * 	methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
		 * 	`crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
		 * </ol>
		 *
		 * @class Bitmap
		 * @extends DisplayObject
		 * @constructor
		 * @param {CanvasImageSource | String | Object} imageOrUri The source image to display. This can be a CanvasImageSource
		 * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
		 * If the latter, a new Image instance with the URL as its src will be used.
		 **/
		function Bitmap(imageOrUri) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The source image to display. This can be a CanvasImageSource
			 * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
			 * If the latter, a new Image instance with the URL as its src will be used.
			 * @property image
			 * @type CanvasImageSource | Object
			 **/
			if (typeof imageOrUri == "string") {
				this.image = document.createElement("img");
				this.image.src = imageOrUri;
			} else {
				this.image = imageOrUri;
			}
		
			/**
			 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
			 * Notes:
			 * <ul>
			 *     <li>that video sources must have a width / height set to work correctly with `sourceRect`</li>
			 *     <li>Cached objects will ignore the `sourceRect` property</li>
			 * </ul>
			 * @property sourceRect
			 * @type Rectangle
			 * @default null
			 */
			this.sourceRect = null;
	
		// private properties:
			/**
			 * Docced in superclass.
			 */
			this._webGLRenderStyle = createjs.DisplayObject._StageGL_BITMAP;
		}
		var p = createjs.extend(Bitmap, createjs.DisplayObject);
		
		
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Bitmap; // TODO: deprecated.
	
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var image = this.image;
			var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 *
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			var img = this.image, rect = this.sourceRect;
			if (img.getImage) { img = img.getImage(); }
			if (!img) { return true; }
			if (rect) {
				// some browsers choke on out of bound values, so we'll fix them:
				var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;
				if (x1 < 0) { x -= x1; x1 = 0; }
				if (x2 > w) { x2 = w; }
				if (y1 < 0) { y -= y1; y1 = 0; }
				if (y2 > h) { y2 = h; }
				ctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);
			} else {
				ctx.drawImage(img, 0, 0);
			}
			return true;
		};
		
		//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
		//Bitmap. This is why they have no method implementations.
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method cache
		 **/
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method updateCache
		 **/
		
		/**
		 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
		 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
		 *
		 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
		 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method.
		 * @method uncache
		 **/
	
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			var rect = this.DisplayObject_getBounds();
			if (rect) { return rect; }
			var image = this.image, o = this.sourceRect || image;
			var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
			return hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;
		};
		
		/**
		 * Returns a clone of the Bitmap instance.
		 * @method clone
		 * @param {Boolean} node Whether the underlying dom element should be cloned as well.
		 * @return {Bitmap} a clone of the Bitmap instance.
		 **/
		p.clone = function(node) {
			var image = this.image;
			if(image && node){ image = image.cloneNode(); }
			var o = new Bitmap(image);
			if (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }
			this._cloneProps(o);
			return o;
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Bitmap (name="+  this.name +")]";
		};
	
		
		createjs.Bitmap = createjs.promote(Bitmap, "DisplayObject");
	}());
	
	//##############################################################################
	// Sprite.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of
		 * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100
		 * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,
		 * play frames as an animation, and even sequence animations together.
		 *
		 * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.
		 *
		 * <h4>Example</h4>
		 *
		 *      var instance = new createjs.Sprite(spriteSheet);
		 *      instance.gotoAndStop("frameName");
		 *
		 * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,
		 * only the first defined frame defined in the sprite sheet will be displayed.
		 *
		 * @class Sprite
		 * @extends DisplayObject
		 * @constructor
		 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame
		 * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
		 * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.
		 **/
		function Sprite(spriteSheet, frameOrAnimation) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}
			 * definitions, this will advance non-sequentially. This will always be an integer value.
			 * @property currentFrame
			 * @type {Number}
			 * @default 0
			 * @readonly
			 **/
			this.currentFrame = 0;
		
			/**
			 * Returns the name of the currently playing animation.
			 * @property currentAnimation
			 * @type {String}
			 * @final
			 * @readonly
			 **/
			this.currentAnimation = null;
		
			/**
			 * Prevents the animation from advancing each tick automatically. For example, you could create a sprite
			 * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.
			 * @property paused
			 * @type {Boolean}
			 * @default false
			 **/
			this.paused = true;
		
			/**
			 * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame
			 * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
			 * @property spriteSheet
			 * @type {SpriteSheet}
			 * @readonly
			 **/
			this.spriteSheet = spriteSheet;
		
			/**
			 * Specifies the current frame index within the currently playing animation. When playing normally, this will increase
			 * from 0 to n-1, where n is the number of frames in the current animation.
			 *
			 * This could be a non-integer value if
			 * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation's speed is
			 * not an integer.
			 * @property currentAnimationFrame
			 * @type {Number}
			 * @default 0
			 **/
			this.currentAnimationFrame = 0;
		
			/**
			 * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related
			 * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
			 * framerate.
			 *
			 * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will
			 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
			 * vary slightly between frames.
			 *
			 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
			 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
			 * @property framerate
			 * @type {Number}
			 * @default 0
			 **/
			this.framerate = 0;
		
		
		// private properties:
			/**
			 * Current animation object.
			 * @property _animation
			 * @protected
			 * @type {Object}
			 * @default null
			 **/
			this._animation = null;
		
			/**
			 * Current frame index.
			 * @property _currentFrame
			 * @protected
			 * @type {Number}
			 * @default null
			 **/
			this._currentFrame = null;
			
			/**
			 * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame
			 * @property _skipAdvance
			 * @protected
			 * @type {Boolean}
			 * @default false
			 **/
			this._skipAdvance = false;
	
			/**
			 * Docced in superclass.
			 */
			this._webGLRenderStyle = createjs.DisplayObject._StageGL_SPRITE;
	
			if (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }
		}
		var p = createjs.extend(Sprite, createjs.DisplayObject);
	
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = Sprite; // TODO: Deprecated. This is for backwards support of Flash/Animate spritesheet export.
	
	
	// events:
		/**
		 * Dispatched when an animation reaches its ends.
		 * @event animationend
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {String} name The name of the animation that just ended.
		 * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.
		 * @since 0.6.0
		 */
		 
		/**
		 * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,
		 * or calling gotoAndPlay() or gotoAndStop().
		 * @event change
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 */
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || this.spriteSheet.complete;
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this._normalizeFrame();
			var o = this.spriteSheet.getFrame(this._currentFrame|0);
			if (!o) { return false; }
			var rect = o.rect;
			if (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }
			return true;
		};
	
		//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
		//Bitmap. This is why they have no method implementations.
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method cache
		 **/
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method updateCache
		 **/
	
		/**
		 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
		 * You should not cache Sprite instances as it can degrade performance.
		 * @method uncache
		 **/
	
		/**
		 * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}
		 * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain
		 * unchanged.
		 * @method play
		 **/
		p.play = function() {
			this.paused = false;
		};
	
		/**
		 * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}
		 * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}
		 * will resume playback.
		 * @method stop
		 **/
		p.stop = function() {
			this.paused = true;
		};
	
		/**
		 * Sets paused to false and plays the specified animation name, named frame, or frame number.
		 * @method gotoAndPlay
		 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
		 * and begin playing.
		 **/
		p.gotoAndPlay = function(frameOrAnimation) {
			this.paused = false;
			this._skipAdvance = true;
			this._goto(frameOrAnimation);
		};
	
		/**
		 * Sets paused to true and seeks to the specified animation name, named frame, or frame number.
		 * @method gotoAndStop
		 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
		 * and stop.
		 **/
		p.gotoAndStop = function(frameOrAnimation) {
			this.paused = true;
			this._goto(frameOrAnimation);
		};
	
		/**
		 * Advances the playhead. This occurs automatically each tick by default.
		 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite
		 * or its SpriteSheet.
		 * @method advance
		*/
		p.advance = function(time) {
			var fps = this.framerate || this.spriteSheet.framerate;
			var t = (fps && time != null) ? time/(1000/fps) : 1;
			this._normalizeFrame(t);
		};
		
		/**
		 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to
		 * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a
		 * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.
		 *
		 * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.
		 * @method getBounds
		 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully
		 * loaded.
		 **/
		p.getBounds = function() {
			// TODO: should this normalizeFrame?
			return this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);
		};
	
		/**
		 * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned
		 * instances.
		 * @method clone
		 * @return {Sprite} a clone of the Sprite instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new Sprite(this.spriteSheet));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Sprite (name="+  this.name +")]";
		};
	
	// private methods:
		/**
		 * @method _cloneProps
		 * @param {Sprite} o
		 * @return {Sprite} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			this.DisplayObject__cloneProps(o);
			o.currentFrame = this.currentFrame;
			o.currentAnimation = this.currentAnimation;
			o.paused = this.paused;
			o.currentAnimationFrame = this.currentAnimationFrame;
			o.framerate = this.framerate;
			
			o._animation = this._animation;
			o._currentFrame = this._currentFrame;
			o._skipAdvance = this._skipAdvance;
			return o;
		};
		
		/**
		 * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}
		 * ticks.
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * @protected
		 * @method _tick
		 **/
		p._tick = function(evtObj) {
			if (!this.paused) {
				if (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }
				this._skipAdvance = false;
			}
			this.DisplayObject__tick(evtObj);
		};
	
	
		/**
		 * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.
		 * @protected
		 * @method _normalizeFrame
		 **/
		p._normalizeFrame = function(frameDelta) {
			frameDelta = frameDelta || 0;
			var animation = this._animation;
			var paused = this.paused;
			var frame = this._currentFrame;
			var l;
			
			if (animation) {
				var speed = animation.speed || 1;
				var animFrame = this.currentAnimationFrame;
				l = animation.frames.length;
				if (animFrame + frameDelta * speed >= l) {
					var next = animation.next;
					if (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {
						// something changed in the event stack, so we shouldn't make any more changes here.
						return;
					} else if (next) {
						// sequence. Automatically calls _normalizeFrame again with the remaining frames.
						return this._goto(next, frameDelta - (l - animFrame) / speed);
					} else {
						// end.
						this.paused = true;
						animFrame = animation.frames.length - 1;
					}
				} else {
					animFrame += frameDelta * speed;
				}
				this.currentAnimationFrame = animFrame;
				this._currentFrame = animation.frames[animFrame | 0]
			} else {
				frame = (this._currentFrame += frameDelta);
				l = this.spriteSheet.getNumFrames();
				if (frame >= l && l > 0) {
					if (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {
						// looped.
						if ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }
					}
				}
			}
			frame = this._currentFrame | 0;
			if (this.currentFrame != frame) {
				this.currentFrame = frame;
				this.dispatchEvent("change");
			}
		};
	
		/**
		 * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},
		 * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)
		 * @property _dispatchAnimationEnd
		 * @private
		 * @type {Function}
		 **/
		p._dispatchAnimationEnd = function(animation, frame, paused, next, end) {
			var name = animation ? animation.name : null;
			if (this.hasEventListener("animationend")) {
				var evt = new createjs.Event("animationend");
				evt.name = name;
				evt.next = next;
				this.dispatchEvent(evt);
			}
			// did the animation get changed in the event stack?:
			var changed = (this._animation != animation || this._currentFrame != frame);
			// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:
			if (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }
			return changed;
		};
	
		/**
		 * Moves the playhead to the specified frame number or animation.
		 * @method _goto
		 * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.
		 * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.
		 * @protected
		 **/
		p._goto = function(frameOrAnimation, frame) {
			this.currentAnimationFrame = 0;
			if (isNaN(frameOrAnimation)) {
				var data = this.spriteSheet.getAnimation(frameOrAnimation);
				if (data) {
					this._animation = data;
					this.currentAnimation = frameOrAnimation;
					this._normalizeFrame(frame);
				}
			} else {
				this.currentAnimation = this._animation = null;
				this._currentFrame = frameOrAnimation;
				this._normalizeFrame();
			}
		};
	
	
		createjs.Sprite = createjs.promote(Sprite, "DisplayObject");
	}());
	
	//##############################################################################
	// Shape.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}
		 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
		 * instances to display the same vector graphics with different positions or transforms.
		 *
		 * If the vector art will not
		 * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the
		 * rendering cost.
		 *
		 * <h4>Example</h4>
		 *
		 *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
		 *      var shape = new createjs.Shape(graphics);
		 *
		 *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
		 *      var shape = new createjs.Shape();
		 *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
		 *
		 * @class Shape
		 * @extends DisplayObject
		 * @constructor
		 * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.
		 **/
		function Shape(graphics) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The graphics instance to display.
			 * @property graphics
			 * @type Graphics
			 **/
			this.graphics = graphics ? graphics : new createjs.Graphics();
		}
		var p = createjs.extend(Shape, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if
		 * the draw was handled (useful for overriding functionality).
		 *
		 * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
		 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
		 * @return {Boolean}
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this.graphics.draw(ctx, this);
			return true;
		};
	
		/**
		 * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
		 * their defaults (for example .parent).
		 * @method clone
		 * @param {Boolean} recursive If true, this Shape's {{#crossLink "Graphics"}}{{/crossLink}} instance will also be
		 * cloned. If false, the Graphics instance will be shared with the new Shape.
		 **/
		p.clone = function(recursive) {
			var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
			return  this._cloneProps(new Shape(g));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Shape (name="+  this.name +")]";
		};
	
	
		createjs.Shape = createjs.promote(Shape, "DisplayObject");
	}());
	
	//##############################################################################
	// Text.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the
		 * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML
		 * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
		 * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.
		 *
		 * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use
		 * multiple font styles, you will need to create multiple text instances, and position them manually.
		 *
		 * <h4>Example</h4>
		 *
		 *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");
		 *      text.x = 100;
		 *      text.textBaseline = "alphabetic";
		 *
		 * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser
		 * before it can be displayed.
		 *
		 * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all
		 * browsers will render Text exactly the same.
		 * @class Text
		 * @extends DisplayObject
		 * @constructor
		 * @param {String} [text] The text to display.
		 * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold
		 * 36px Arial").
		 * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.
		 * "#F00", "red", or "#FF0000").
		 **/
		function Text(text, font, color) {
			this.DisplayObject_constructor();
			
			
		// public properties:
			/**
			 * The text to display.
			 * @property text
			 * @type String
			 **/
			this.text = text;
		
			/**
			 * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
			 * @property font
			 * @type String
			 **/
			this.font = font;
		
			/**
			 * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
			 * It will also accept valid canvas fillStyle values.
			 * @property color
			 * @type String
			 **/
			this.color = color;
		
			/**
			 * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed
			 * information view the
			 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>. Default is "left".
			 * @property textAlign
			 * @type String
			 **/
			this.textAlign = "left";
		
			/**
			 * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or
			 * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>. Default is "top".
			 * @property textBaseline
			 * @type String
			*/
			this.textBaseline = "top";
		
			/**
			 * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
			 * shrunk to make it fit in this width. For detailed information view the
			 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
			 * whatwg spec</a>.
			 * @property maxWidth
			 * @type Number
			*/
			this.maxWidth = null;
		
			/**
			 * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
			 * @property outline
			 * @type Number
			 **/
			this.outline = 0;
		
			/**
			 * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
			 * the value of getMeasuredLineHeight is used.
			 * @property lineHeight
			 * @type Number
			 **/
			this.lineHeight = 0;
		
			/**
			 * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
			 * the text will not be wrapped.
			 * @property lineWidth
			 * @type Number
			 **/
			this.lineWidth = null;
		}
		var p = createjs.extend(Text, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		
	// static properties:
		/**
		 * @property _workingContext
		 * @type CanvasRenderingContext2D
		 * @private
		 **/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }
		
		
	// constants:
		/**
		 * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.
		 * @property H_OFFSETS
		 * @type Object
		 * @protected
		 * @static
		 **/
		Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};
		
		/**
		 * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.
		 * @property H_OFFSETS
		 * @type Object
		 * @protected
		 * @static
		 **/
		Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
		};
	
		/**
		 * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
	
			var col = this.color || "#000";
			if (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }
			else { ctx.fillStyle = col; }
			
			this._drawText(this._prepContext(ctx));
			return true;
		};
	
		/**
		 * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
		 * @method getMeasuredWidth
		 * @return {Number} The measured, untransformed width of the text.
		 **/
		p.getMeasuredWidth = function() {
			return this._getMeasuredWidth(this.text);
		};
	
		/**
		 * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
		 * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
		 * @method getMeasuredLineHeight
		 * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
		 * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
		 **/
		p.getMeasuredLineHeight = function() {
			return this._getMeasuredWidth("M")*1.2;
		};
	
		/**
		 * Returns the approximate height of multi-line text by multiplying the number of lines against either the
		 * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that
		 * this operation requires the text flowing logic to run, which has an associated CPU cost.
		 * @method getMeasuredHeight
		 * @return {Number} The approximate height of the untransformed multi-line text.
		 **/
		p.getMeasuredHeight = function() {
			return this._drawText(null,{}).height;
		};
	
		/**
		 * Docced in superclass.
		 */
		p.getBounds = function() {
			var rect = this.DisplayObject_getBounds();
			if (rect) { return rect; }
			if (this.text == null || this.text === "") { return null; }
			var o = this._drawText(null, {});
			var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
			var x = w * Text.H_OFFSETS[this.textAlign||"left"];
			var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
			var y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
			return this._rectangle.setValues(x, y, w, o.height);
		};
		
		/**
		 * Returns an object with width, height, and lines properties. The width and height are the visual width and height
		 * of the drawn text. The lines property contains an array of strings, one for
		 * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
		 * whitespace removed.
		 * @method getMetrics
		 * @return {Object} An object with width, height, and lines properties.
		 **/
		p.getMetrics = function() {
			var o = {lines:[]};
			o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
			o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
			return this._drawText(null, o, o.lines);
		};
	
		/**
		 * Returns a clone of the Text instance.
		 * @method clone
		 * @return {Text} a clone of the Text instance.
		 **/
		p.clone = function() {
			return this._cloneProps(new Text(this.text, this.font, this.color));
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";
		};
	
	
	// private methods:
		/**
		 * @method _cloneProps
		 * @param {Text} o
		 * @protected
		 * @return {Text} o
		 **/
		p._cloneProps = function(o) {
			this.DisplayObject__cloneProps(o);
			o.textAlign = this.textAlign;
			o.textBaseline = this.textBaseline;
			o.maxWidth = this.maxWidth;
			o.outline = this.outline;
			o.lineHeight = this.lineHeight;
			o.lineWidth = this.lineWidth;
			return o;
		};
	
		/**
		 * @method _getWorkingContext
		 * @param {CanvasRenderingContext2D} ctx
		 * @return {CanvasRenderingContext2D}
		 * @protected
		 **/
		p._prepContext = function(ctx) {
			ctx.font = this.font||"10px sans-serif";
			ctx.textAlign = this.textAlign||"left";
			ctx.textBaseline = this.textBaseline||"top";
			ctx.lineJoin = "miter";
			ctx.miterLimit = 2.5;
			return ctx;
		};
	
		/**
		 * Draws multiline text.
		 * @method _drawText
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {Object} o
		 * @param {Array} lines
		 * @return {Object}
		 * @protected
		 **/
		p._drawText = function(ctx, o, lines) {
			var paint = !!ctx;
			if (!paint) {
				ctx = Text._workingContext;
				ctx.save();
				this._prepContext(ctx);
			}
			var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
			
			var maxW = 0, count = 0;
			var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
			for (var i=0, l=hardLines.length; i<l; i++) {
				var str = hardLines[i];
				var w = null;
				
				if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
					// text wrapping:
					var words = str.split(/(\s)/);
					str = words[0];
					w = ctx.measureText(str).width;
					
					for (var j=1, jl=words.length; j<jl; j+=2) {
						// Line needs to wrap:
						var wordW = ctx.measureText(words[j] + words[j+1]).width;
						if (w + wordW > this.lineWidth) {
							if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
							if (lines) { lines.push(str); }
							if (w > maxW) { maxW = w; }
							str = words[j+1];
							w = ctx.measureText(str).width;
							count++;
						} else {
							str += words[j] + words[j+1];
							w += wordW;
						}
					}
				}
				
				if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
				if (lines) { lines.push(str); }
				if (o && w == null) { w = ctx.measureText(str).width; }
				if (w > maxW) { maxW = w; }
				count++;
			}
			
			if (o) {
				o.width = maxW;
				o.height = count*lineHeight;
			}
			if (!paint) { ctx.restore(); }
			return o;
		};
	
		/**
		 * @method _drawTextLine
		 * @param {CanvasRenderingContext2D} ctx
		 * @param {String} text
		 * @param {Number} y
		 * @protected
		 **/
		p._drawTextLine = function(ctx, text, y) {
			// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
			if (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }
			else { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }
		};
		
		
		/**
		 * @method _getMeasuredWidth
		 * @param {String} text
		 * @protected
		 **/
		p._getMeasuredWidth = function(text) {
			var ctx = Text._workingContext;
			ctx.save();
			var w = this._prepContext(ctx).measureText(text).width;
			ctx.restore();
			return w;
		};
	
	
		createjs.Text = createjs.promote(Text, "DisplayObject");
	}());
	
	//##############################################################################
	// BitmapText.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
	
	
	// constructor:
		/**
		 * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported using new line characters,
		 * but automatic wrapping is not supported. See the {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}
		 * property for more information on defining glyphs.
		 *
		 * <strong>Important:</strong> While BitmapText extends Container, it is not designed to be used as one.
		 * As such, methods like addChild and removeChild are disabled.
		 *
		 *
		 * @class BitmapText
		 * @extends DisplayObject
		 * @param {String} [text=""] The text to display.
		 * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.
		 * @constructor
		 **/
		function BitmapText(text, spriteSheet) {
			this.Container_constructor();
			
			
		// public properties:
			/**
			 * The text to display.
			 * @property text
			 * @type String
			 * @default ""
			 **/
			this.text = text||"";
			
			/**
			 * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character
			 * should have a single frame animation defined in the sprite sheet named the same as
			 * corresponding character. For example, the following animation definition:
			 *
			 * 		"A": {frames: [0]}
			 *
			 * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form
			 * is also acceptable:
			 * 
			 * 		"A": 0
			 *
			 * Note that if a character in the text is not found in the sprite sheet, it will also
			 * try to use the alternate case (upper or lower).
			 *
			 * See SpriteSheet for more information on defining sprite sheet data.
			 * @property spriteSheet
			 * @type SpriteSheet
			 * @default null
			 **/
			this.spriteSheet = spriteSheet;
		
			/**
			 * The height of each line of text. If 0, then it will use a line height calculated
			 * by checking for the height of the "1", "T", or "L" character (in that order). If
			 * those characters are not defined, it will use the height of the first frame of the
			 * sprite sheet.
			 * @property lineHeight
			 * @type Number
			 * @default 0
			 **/
			this.lineHeight = 0;
		
			/**
			 * This spacing (in pixels) will be added after each character in the output.
			 * @property letterSpacing
			 * @type Number
			 * @default 0
			 **/
			this.letterSpacing = 0;
		
			/**
			 * If a space character is not defined in the sprite sheet, then empty pixels equal to
			 * spaceWidth will be inserted instead. If 0, then it will use a value calculated
			 * by checking for the width of the "1", "l", "E", or "A" character (in that order). If
			 * those characters are not defined, it will use the width of the first frame of the
			 * sprite sheet.
			 * @property spaceWidth
			 * @type Number
			 * @default 0
			 **/
			this.spaceWidth = 0;
			
			
		// private properties:
		 	/**
			 * @property _oldProps
			 * @type Object
			 * @protected
			 **/
			this._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};
	
			/**
			 * Used to track the object which this class attached listeners to, helps optimize listener attachment.
			 * @property _oldStage
			 * @type Stage
			 * @protected
			 */
			this._oldStage = null;
			/**
			 * The event listener proxy triggered drawing draw for special circumstances.
			 * @property _drawAction
			 * @type function
			 * @protected
			 */
			this._drawAction = null;
		}
		var p = createjs.extend(BitmapText, createjs.Container);
	
	// static properties:
		/**
		 * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains
		 * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be
		 * retained, slightly increasing memory use, but reducing instantiation.
		 * @property maxPoolSize
		 * @type Number
		 * @static
		 * @default 100
		 **/
		BitmapText.maxPoolSize = 100;
		
		/**
		 * Sprite object pool.
		 * @type {Array}
		 * @static
		 * @private
		 */
		BitmapText._spritePool = [];
	
		
	// public methods:
		/**
		 * Docced in superclass.
		 **/
		p.draw = function(ctx, ignoreCache) {
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return; }
			this._updateState();
			this.Container_draw(ctx, ignoreCache);
		};
		
		/**
		 * Docced in superclass.
		 **/
		p.getBounds = function() {
			this._updateText();
			return this.Container_getBounds();
		};
		
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			var hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);
			return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
		};
		
		p.clone = function() {
			return this._cloneProps(new BitmapText(this.text, this.spriteSheet));
		};
		
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method addChild
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method addChildAt
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeChild
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeChildAt
		 **/
		/**
		 * <strong>Disabled in BitmapText.</strong>
		 * @method removeAllChildren
		 **/
		p.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};
	
	
	// private methods:
		/**
		 * Docced in superclass.
		 **/
		p._updateState = function() {
			this._updateText();
		};
	
	 	/**
		 * @method _cloneProps
		 * @param {BitmapText} o
		 * @return {BitmapText} o
		 * @protected
		 **/
		p._cloneProps = function(o) {
			this.Container__cloneProps(o);
			o.lineHeight = this.lineHeight;
			o.letterSpacing = this.letterSpacing;
			o.spaceWidth = this.spaceWidth;
			return o;
		};
		
		/**
		 * @method _getFrameIndex
		 * @param {String} character
		 * @param {SpriteSheet} spriteSheet
		 * @return {Number}
		 * @protected
		 **/
		p._getFrameIndex = function(character, spriteSheet) {
			var c, o = spriteSheet.getAnimation(character);
			if (!o) {
				(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);
				if (c) { o = spriteSheet.getAnimation(c); }
			}
			return o && o.frames[0];
		};
		
		/**
		 * @method _getFrame
		 * @param {String} character
		 * @param {SpriteSheet} spriteSheet
		 * @return {Object}
		 * @protected
		 **/
		p._getFrame = function(character, spriteSheet) {
			var index = this._getFrameIndex(character, spriteSheet);
			return index == null ? index : spriteSheet.getFrame(index);
		};
	
		/**
		 * @method _getLineHeight
		 * @param {SpriteSheet} ss
		 * @return {Number}
		 * @protected
		 **/
		p._getLineHeight = function(ss) {
			var frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);
			return frame ? frame.rect.height : 1;
		};
	
		/**
		 * @method _getSpaceWidth
		 * @param {SpriteSheet} ss
		 * @return {Number}
		 * @protected
		 **/
		p._getSpaceWidth = function(ss) {
			var frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);
			return frame ? frame.rect.width : 1;
		};
	
		/**
		 * @method _updateText
		 * @protected
		 **/
		p._updateText = function() {
			var x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;
			var pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;
			
			for (var n in o) {
				if (o[n] != this[n]) {
					o[n] = this[n];
					change = true;
				}
			}
			if (!change) { return; }
			
			var hasSpace = !!this._getFrame(" ", ss);
			if (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }
			if (!lineH) { lineH = this._getLineHeight(ss); }
			
			for(var i=0, l=this.text.length; i<l; i++) {
				var character = this.text.charAt(i);
				if (character == " " && !hasSpace) {
					x += spaceW;
					continue;
				} else if (character=="\n" || character=="\r") {
					if (character=="\r" && this.text.charAt(i+1) == "\n") { i++; } // crlf
					x = 0;
					y += lineH;
					continue;
				}
	
				var index = this._getFrameIndex(character, ss);
				if (index == null) { continue; }
				
				if (childIndex < numKids) {
					sprite = kids[childIndex];
				} else {
					kids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());
					sprite.parent = this;
					numKids++;
				}
				sprite.spriteSheet = ss;
				sprite.gotoAndStop(index);
				sprite.x = x;
				sprite.y = y;
				childIndex++;
				
				x += sprite.getBounds().width + this.letterSpacing;
			}
			while (numKids > childIndex) {
				 // faster than removeChild.
				pool.push(sprite = kids.pop());
				sprite.parent = null;
				numKids--;
			}
			if (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }
		};
	
	
		createjs.BitmapText = createjs.promote(BitmapText, "Container");
	}());
	
	//##############################################################################
	// MovieClip.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink "Container"}}{{/crossLink}}. It allows
		 * you to create objects which encapsulate timeline animations, state changes, and synched actions. The MovieClip
		 * class has been included in the EaselJS minified file since 0.7.0.
		 *
		 * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have
		 * been made to support time-based timelines in the future.
		 *
		 * <h4>Example</h4>
		 * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in
		 * the animation using {{#crossLink "MovieClip/gotoAndPlay"}}{{/crossLink}}.
		 *
		 *      var stage = new createjs.Stage("canvas");
		 *      createjs.Ticker.addEventListener("tick", stage);
		 *
		 *      var mc = new createjs.MovieClip({loop:-1, labels:{myLabel:20}});
		 *      stage.addChild(mc);
		 *
		 *      var child1 = new createjs.Shape(
		 *          new createjs.Graphics().beginFill("#999999")
		 *              .drawCircle(30,30,30));
		 *      var child2 = new createjs.Shape(
		 *          new createjs.Graphics().beginFill("#5a9cfb")
		 *              .drawCircle(30,30,30));
		 *
		 *      mc.timeline.addTween(
		 *          createjs.Tween.get(child1)
		 *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));
		 *      mc.timeline.addTween(
		 *          createjs.Tween.get(child2)
		 *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));
		 *
		 *      mc.gotoAndPlay("start");
		 *
		 * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set
		 * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the
		 * <code>tween.set()</code> method to affect properties will likely not provide the desired result.
		 *
		 * @class MovieClip
		 * @main MovieClip
		 * @param {Object} [props] The configuration properties to apply to this instance (ex. `{mode:MovieClip.SYNCHED}`).
		 * Supported props for the MovieClip are listed below. These props are set on the corresponding instance properties except where
		 * specified.<UL>
		 *    <LI> `mode`</LI>
		 *    <LI> `startPosition`</LI>
		 *    <LI> `frameBounds`</LI>
		 * </UL>
		 * 
		 * This object will also be passed into the Timeline instance associated with this MovieClip. See the documentation
		 * for Timeline for a list of supported props (ex. `paused`, `labels`, `loop`, `reversed`, etc.)
		 * @extends Container
		 * @constructor
		 **/
		function MovieClip(props) {
			this.Container_constructor();
			!MovieClip.inited&&MovieClip.init(); // static init
			
			var mode, startPosition, loop, labels;
			
			// handle old params (mode, startPosition, loop, labels):
			// TODO: deprecated param handling:
			if (props instanceof String || arguments.length > 1) {
				mode = props;
				startPosition = arguments[1];
				loop = arguments[2];
				labels = arguments[3];
				if (loop == null) { loop = -1; }
				props = null;
			} else if (props) {
				mode = props.mode;
				startPosition = props.startPosition;
				loop = props.loop;
				labels = props.labels;
			}
			if (!props) { props = {labels:labels}; }
			
			
		// public properties:
			/**
			 * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).
			 * See each constant for a description of the behaviour.
			 * @property mode
			 * @type String
			 * @default null
			 **/
			this.mode = mode||MovieClip.INDEPENDENT;
		
			/**
			 * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.
			 * @property startPosition
			 * @type Number
			 * @default 0
			 */
			this.startPosition = startPosition||0;
		
			/**
			 * Specifies how many times this MovieClip should loop. A value of -1 indicates it should loop indefinitely. A value of
			 * 1 would cause it to loop once (ie. play a total of twice).
			 * @property loop
			 * @type Number
			 * @default -1
			 */
			this.loop = loop === true ? -1 : (loop || 0);
		
			/**
			 * The current frame of the movieclip.
			 * @property currentFrame
			 * @type Number
			 * @default 0
			 * @readonly
			 */
			this.currentFrame = 0;
		
			/**
			 * If true, the MovieClip's position will not advance when ticked.
			 * @property paused
			 * @type Boolean
			 * @default false
			 */
			this.paused = props.paused||false;
		
			/**
			 * If true, actions in this MovieClip's tweens will be run when the playhead advances.
			 * @property actionsEnabled
			 * @type Boolean
			 * @default true
			 */
			this.actionsEnabled = true;
		
			/**
			 * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds
			 * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.
			 * <br><br>
			 * For example, if you had a character animation with a "body" child MovieClip instance
			 * with different costumes on each frame, you could set body.autoReset = false, so that
			 * you can manually change the frame it is on, without worrying that it will be reset
			 * automatically.
			 * @property autoReset
			 * @type Boolean
			 * @default true
			 */
			this.autoReset = true;
			
			/**
			 * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.
			 * @property frameBounds
			 * @type Array
			 * @default null
			 */
			this.frameBounds = this.frameBounds||props.frameBounds; // frameBounds are set on the prototype in Animate.
			
			/**
			 * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip
			 * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
			 * framerate.
			 *
			 * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will
			 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
			 * vary slightly between frames.
			 *
			 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
			 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
			 * @property framerate
			 * @type {Number}
			 * @default null
			 **/
			this.framerate = null;
			
			// set up the needed props for Timeline:
			props.useTicks = props.paused = true;
			
			/**
			 * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip
			 * instance is initialized. Animations are created by adding <a href="http://tweenjs.com">TweenJS</a> Tween
			 * instances to the timeline.
			 *
			 * <h4>Example</h4>
			 *
			 *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);
			 *      var mc = new createjs.MovieClip();
			 *      mc.timeline.addTween(tween);
			 *
			 * Elements can be added and removed from the timeline by toggling an "_off" property
			 * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to
			 * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for
			 * frame 1. You can use the "visible" property to achieve the same effect.
			 *
			 *      var tween = createjs.Tween.get(target).to({_off:false})
			 *          .wait(1).to({_off:true})
			 *          .wait(1).to({_off:false});
			 *
			 * @property timeline
			 * @type Timeline
			 * @default null
			 */
			this.timeline = new createjs.Timeline(props);
			
			
		// private properties:
			/**
			 * @property _synchOffset
			 * @type Number
			 * @default 0
			 * @private
			 */
			this._synchOffset = 0;
		
			/**
			 * @property _rawPosition
			 * @type Number
			 * @default -1
			 * @private
			 */
			this._rawPosition = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.
			
			/**
			 * @property _bound_resolveState
			 * @type Function
			 * @private
			 */
			this._bound_resolveState = this._resolveState.bind(this);
		
		
			/**
			 * The time remaining from the previous tick, only applicable when .framerate is set.
			 * @property _t
			 * @type Number
			 * @private
			 */
			this._t = 0;
		
			/**
			 * List of display objects that are actively being managed by the MovieClip.
			 * @property _managed
			 * @type Object
			 * @private
			 */
			this._managed = {};
		}
		var p = createjs.extend(MovieClip, createjs.Container);
	
	
	// constants:
		/**
		 * The MovieClip will advance independently of its parent, even if its parent is paused.
		 * This is the default mode.
		 * @property INDEPENDENT
		 * @static
		 * @type String
		 * @default "independent"
		 * @readonly
		 **/
		MovieClip.INDEPENDENT = "independent";
	
		/**
		 * The MovieClip will only display a single frame (as determined by the startPosition property).
		 * @property SINGLE_FRAME
		 * @static
		 * @type String
		 * @default "single"
		 * @readonly
		 **/
		MovieClip.SINGLE_FRAME = "single";
	
		/**
		 * The MovieClip will be advanced only when its parent advances and will be synched to the position of
		 * the parent MovieClip.
		 * @property SYNCHED
		 * @static
		 * @type String
		 * @default "synched"
		 * @readonly
		 **/
		MovieClip.SYNCHED = "synched";
		
		
	// static properties:
		MovieClip.inited = false;
		
		
	// static methods:
		MovieClip.init = function() {
			if (MovieClip.inited) { return; }
			// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.
			MovieClipPlugin.install();
			MovieClip.inited = true;
		};
		
		
	// getter / setters:
		/**
		 * Use the {{#crossLink "MovieClip/labels:property"}}{{/crossLink}} property instead.
		 * @method _getLabels
		 * @protected
		 * @return {Array}
		 **/
		p._getLabels = function() {
			return this.timeline.getLabels();
		};
		// MovieClip.getLabels is @deprecated. Remove for 1.1+
		p.getLabels = createjs.deprecate(p._getLabels, "MovieClip.getLabels");
	
		/**
		 * Use the {{#crossLink "MovieClip/currentLabel:property"}}{{/crossLink}} property instead.
		 * @method _getCurrentLabel
		 * @protected
		 * @return {String}
		 **/
		p._getCurrentLabel = function() {
			return this.timeline.currentLabel;
		};
		// MovieClip.getCurrentLabel is @deprecated. Remove for 1.1+
		p.getCurrentLabel = createjs.deprecate(p._getCurrentLabel, "MovieClip.getCurrentLabel");
	
		/**
		 * Use the {{#crossLink "MovieClip/duration:property"}}{{/crossLink}} property instead.
		 * @method _getDuration
		 * @protected
		 * @return {Number}
		 **/
		p._getDuration = function() {
			return this.timeline.duration;
		};
		// MovieClip.getDuration is @deprecated. Remove for 1.1+
		p.getDuration = createjs.deprecate(p._getDuration, "MovieClip.getDuration");
	
		/**
		 * Returns an array of objects with label and position (aka frame) properties, sorted by position.
		 * @property labels
		 * @type {Array}
		 * @readonly
		 **/
		
		/**
		 * Returns the name of the label on or immediately before the current frame.
		 * @property currentLabel
		 * @type {String}
		 * @readonly
		 **/
		
		/**
		 * Returns the duration of this MovieClip in seconds or ticks.
		 * @property totalFrames
		 * @type {Number}
		 * @readonly
		 **/
		
		/**
		 * Returns the duration of this MovieClip in seconds or ticks.
		 * @property duration
		 * @type {Number}
		 * @readonly
		 **/
		try {
			Object.defineProperties(p, {
				labels: { get: p._getLabels },
				currentLabel: { get: p._getCurrentLabel },
				totalFrames: { get: p._getDuration },
				duration: { get: p._getDuration }
				// TODO: can we just proxy .currentFrame to tl.position as well? Ditto for .loop (or just remove entirely).
			});
		} catch (e) {}
	
	
	// public methods:
		/**
		 * Constructor alias for backwards compatibility. This method will be removed in future versions.
		 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
		 * @method initialize
		 * @deprecated in favour of `createjs.promote()`
		 **/
		p.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of Adobe Flash/Animate
	
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 **/
		p.isVisible = function() {
			// children are placed in draw, so we can't determine if we have content.
			return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 **/
		p.draw = function(ctx, ignoreCache) {
			// draw to cache first:
			if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
			this._updateState();
			this.Container_draw(ctx, ignoreCache);
			return true;
		};
	
		/**
		 * Sets paused to false.
		 * @method play
		 **/
		p.play = function() {
			this.paused = false;
		};
		
		/**
		 * Sets paused to true.
		 * @method stop
		 **/
		p.stop = function() {
			this.paused = true;
		};
		
		/**
		 * Advances this movie clip to the specified position or label and sets paused to false.
		 * @method gotoAndPlay
		 * @param {String|Number} positionOrLabel The animation name or frame number to go to.
		 **/
		p.gotoAndPlay = function(positionOrLabel) {
			this.paused = false;
			this._goto(positionOrLabel);
		};
		
		/**
		 * Advances this movie clip to the specified position or label and sets paused to true.
		 * @method gotoAndStop
		 * @param {String|Number} positionOrLabel The animation or frame name to go to.
		 **/
		p.gotoAndStop = function(positionOrLabel) {
			this.paused = true;
			this._goto(positionOrLabel);
		};
		
		/**
		 * Advances the playhead. This occurs automatically each tick by default.
		 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.
		 * @method advance
		*/
		p.advance = function(time) {
			var independent = MovieClip.INDEPENDENT;
			if (this.mode !== independent) { return; } // update happens in draw for synched clips
			
			// if this MC doesn't have a framerate, hunt ancestors for one:
			var o=this, fps = o.framerate;
			while ((o = o.parent) && fps === null) { if (o.mode === independent) { fps = o._framerate; } }
			this._framerate = fps;
			
			if (this.paused) { return; }
			
			// calculate how many frames to advance:
			var t = (fps !== null && fps !== -1 && time !== null) ? time/(1000/fps) + this._t : 1;
			var frames = t|0;
			this._t = t-frames; // leftover time, save to add to next advance.
			
			while (frames--) { this._updateTimeline(this._rawPosition+1, false); }
		};
		
		/**
		 * MovieClip instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.
			throw("MovieClip cannot be cloned.");
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[MovieClip (name="+  this.name +")]";
		};
	
	
	// private methods:
		/**
		 * Docced in superclass.
		 **/
		p._updateState = function() {
			if (this._rawPosition === -1 || this.mode !== MovieClip.INDEPENDENT) { this._updateTimeline(-1); }
		};
	
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * function.
		 * @protected
		 **/
		p._tick = function(evtObj) {
			this.advance(evtObj&&evtObj.delta);
			this.Container__tick(evtObj);
		};
		
		/**
		 * @method _goto
		 * @param {String|Number} positionOrLabel The animation name or frame number to go to.
		 * @protected
		 **/
		p._goto = function(positionOrLabel) {
			var pos = this.timeline.resolve(positionOrLabel);
			if (pos == null) { return; }
			this._t = 0;
			this._updateTimeline(pos, true);
		};
		
		/**
		 * @method _reset
		 * @private
		 **/
		p._reset = function() {
			this._rawPosition = -1;
			this._t = this.currentFrame = 0;
			this.paused = false;
		};
		
		/**
		 * @method _updateTimeline
		 * @param {Boolean} jump Indicates whether this update is due to jumping (via gotoAndXX) to a new position.
		 * @protected
		 **/
		p._updateTimeline = function(rawPosition, jump) {
			var synced = this.mode !== MovieClip.INDEPENDENT, tl = this.timeline;
			if (synced) { rawPosition = this.startPosition + (this.mode===MovieClip.SINGLE_FRAME?0:this._synchOffset); }
			if (rawPosition < 0) { rawPosition = 0; }
			if (this._rawPosition === rawPosition && !synced) { return; }
			this._rawPosition = rawPosition;
			
			// update timeline position, ignoring actions if this is a graphic.
			tl.loop = this.loop; // TODO: should we maintain this on MovieClip, or just have it on timeline?
			tl.setPosition(rawPosition, synced || !this.actionsEnabled, jump, this._bound_resolveState);
		};
		
		/**
		 * Renders position 0 without running actions or updating _rawPosition.
		 * Primarily used by Animate CC to build out the first frame in the constructor of MC symbols.
		 * NOTE: not tested when run after the MC advances past the first frame.
		 * @method _renderFirstFrame
		 * @protected
		 **/
		p._renderFirstFrame = function() {
			var tl = this.timeline, pos = tl.rawPosition;
			tl.setPosition(0, true, true, this._bound_resolveState);
			tl.rawPosition = pos;
		};
		
		/**
		 * Runs via a callback after timeline property updates and before actions.
		 * @method _resolveState
		 * @protected
		 **/
		p._resolveState = function() {
			var tl = this.timeline;
			this.currentFrame = tl.position;
			
			for (var n in this._managed) { this._managed[n] = 1; }
	
			var tweens = tl.tweens;
			for (var i=0, l=tweens.length; i<l; i++) {
				var tween = tweens[i],  target = tween.target;
				if (target === this || tween.passive) { continue; } // TODO: this assumes the actions tween from Animate has `this` as the target. There's likely a better approach.
				var offset = tween._stepPosition;
	
				if (target instanceof createjs.DisplayObject) {
					// motion tween.
					this._addManagedChild(target, offset);
				} else {
					// state tween.
					this._setState(target.state, offset);
				}
			}
	
			var kids = this.children;
			for (i=kids.length-1; i>=0; i--) {
				var id = kids[i].id;
				if (this._managed[id] === 1) {
					this.removeChildAt(i);
					delete(this._managed[id]);
				}
			}
		};
	
		/**
		 * @method _setState
		 * @param {Array} state
		 * @param {Number} offset
		 * @protected
		 **/
		p._setState = function(state, offset) {
			if (!state) { return; }
			for (var i=state.length-1;i>=0;i--) {
				var o = state[i];
				var target = o.t;
				var props = o.p;
				for (var n in props) { target[n] = props[n]; }
				this._addManagedChild(target, offset);
			}
		};
	
		/**
		 * Adds a child to the timeline, and sets it up as a managed child.
		 * @method _addManagedChild
		 * @param {MovieClip} child The child MovieClip to manage
		 * @param {Number} offset
		 * @private
		 **/
		p._addManagedChild = function(child, offset) {
			if (child._off) { return; }
			this.addChildAt(child,0);
	
			if (child instanceof MovieClip) {
				child._synchOffset = offset;
				// TODO: this does not precisely match Adobe Flash/Animate, which loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.
				// TODO: should also reset when MovieClip loops, though that will be a bit tricky to detect.
				if (child.mode === MovieClip.INDEPENDENT && child.autoReset && (!this._managed[child.id])) { child._reset(); }
			}
			this._managed[child.id] = 2;
		};
		
		/**
		 * @method _getBounds
		 * @param {Matrix2D} matrix
		 * @param {Boolean} ignoreTransform
		 * @return {Rectangle}
		 * @protected
		 **/
		p._getBounds = function(matrix, ignoreTransform) {
			var bounds = this.DisplayObject_getBounds();
			if (!bounds) {
				if (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }
			}
			if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
			return this.Container__getBounds(matrix, ignoreTransform);
		};
	
	
		createjs.MovieClip = createjs.promote(MovieClip, "Container");
	
	
	
	// MovieClipPlugin for TweenJS:
		/**
		 * This plugin works with <a href="http://tweenjs.com" target="_blank">TweenJS</a> to prevent the startPosition
		 * property from tweening.
		 * @private
		 * @class MovieClipPlugin
		 * @constructor
		 **/
		function MovieClipPlugin() {
			throw("MovieClipPlugin cannot be instantiated.")
		}
		
		/**
		 * @property priority
		 * @type {Number}
		 * @static
		 * @readonly
		 **/
		MovieClipPlugin.priority = 100; // very high priority, should run first
		
		/**
		 * @property ID
		 * @type {String}
		 * @static
		 * @readonly
		 **/
		MovieClipPlugin.ID = "MovieClip";
	
		/**
		 * @method install
		 * @static
		 **/
		MovieClipPlugin.install = function() {
			createjs.Tween._installPlugin(MovieClipPlugin);
		};
		
		/**
		 * @method init
		 * @param {Tween} tween
		 * @param {String} prop
		 * @param {*} value
		 * @static
		 **/
		MovieClipPlugin.init = function(tween, prop, value) {
			if (prop === "startPosition" && tween.target instanceof MovieClip) { tween._addPlugin(MovieClipPlugin); }
		};
		
		/**
		 * @method step
		 * @param {Tween} tween
		 * @param {TweenStep} step
		 * @param {Object} props
		 * @static
		 **/
		MovieClipPlugin.step = function(tween, step, props) {};
	
		/**
		 * @method change
		 * @param {Tween} tween
		 * @param {TweenStep} step
		 * @param {*} value
		 * @param {Number} ratio
		 * @param {Object} end
		 * @return {*}
		 * @static
		 */
		MovieClipPlugin.change = function(tween, step, prop, value, ratio, end) {
			if (prop === "startPosition") { return (ratio === 1 ? step.props[prop] : step.prev.props[prop]); }
		};
	
	}());
	
	//##############################################################################
	// SpriteSheetUtils.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
		
		
	// constructor:
		/**
		 * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.
		 * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For
		 * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across
		 * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.
		 * @class SpriteSheetUtils
		 * @static
		 **/
		function SpriteSheetUtils() {
			throw "SpriteSheetUtils cannot be instantiated";
		}
	
	
	// private static properties:
		/**
		 * @property _workingCanvas
		 * @static
		 * @type HTMLCanvasElement | Object
		 * @protected
		*/
		/**
		 * @property _workingContext
		 * @static
		 * @type CanvasRenderingContext2D
		 * @protected
		*/
		var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
		if (canvas.getContext) {
			SpriteSheetUtils._workingCanvas = canvas;
			SpriteSheetUtils._workingContext = canvas.getContext("2d");
			canvas.width = canvas.height = 1;
		}
	
	
	// public static methods:
		/**
		 * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is
		 * to use a spritesheet frame as the source for a bitmap fill.
		 *
		 * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}
		 * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this
		 * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}
		 * property of {{#crossLink "Bitmap"}}{{/crossLink}}.
		 *
		 * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.
		 * @method extractFrame
		 * @static
		 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.
		 * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation
		 * name is specified, only the first frame of the animation will be extracted.
		 * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.
		*/
		SpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {
			if (isNaN(frameOrAnimation)) {
				frameOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];
			}
			var data = spriteSheet.getFrame(frameOrAnimation);
			if (!data) { return null; }
			var r = data.rect;
			var canvas = SpriteSheetUtils._workingCanvas;
			canvas.width = r.width;
			canvas.height = r.height;
			SpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
			var img = document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			return img;
		};
	
		// SpriteSheetUtils.addFlippedFrames is @deprecated. Remove for 1.1+
		SpriteSheetUtils.addFlippedFrames = createjs.deprecate(null, "SpriteSheetUtils.addFlippedFrames");
	
		// SpriteSheetUtils.addFlippedFrames is @deprecated. Remove for 1.1+
		SpriteSheetUtils.mergeAlpha = createjs.deprecate(null, "SpriteSheetUtils.mergeAlpha");
	
		
	// private static methods:
		SpriteSheetUtils._flip = function(spriteSheet, count, h, v) {
			var imgs = spriteSheet._images;
			var canvas = SpriteSheetUtils._workingCanvas;
			var ctx = SpriteSheetUtils._workingContext;
			var il = imgs.length/count;
			for (var i=0;i<il;i++) {
				var src = imgs[i];
				src.__tmp = i; // a bit hacky, but faster than doing indexOf below.
				ctx.setTransform(1,0,0,1,0,0);
				ctx.clearRect(0,0,canvas.width+1,canvas.height+1);
				canvas.width = src.width;
				canvas.height = src.height;
				ctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);
				ctx.drawImage(src,0,0);
				var img = document.createElement("img");
				img.src = canvas.toDataURL("image/png");
				// work around a strange bug in Safari:
				img.width = (src.width||src.naturalWidth);
				img.height = (src.height||src.naturalHeight);
				imgs.push(img);
			}
	
			var frames = spriteSheet._frames;
			var fl = frames.length/count;
			for (i=0;i<fl;i++) {
				src = frames[i];
				var rect = src.rect.clone();
				img = imgs[src.image.__tmp+il*count];
	
				var frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};
				if (h) {
					rect.x = (img.width||img.naturalWidth)-rect.x-rect.width; // update rect
					frame.regX = rect.width-src.regX; // update registration point
				}
				if (v) {
					rect.y = (img.height||img.naturalHeight)-rect.y-rect.height;  // update rect
					frame.regY = rect.height-src.regY; // update registration point
				}
				frames.push(frame);
			}
	
			var sfx = "_"+(h?"h":"")+(v?"v":"");
			var names = spriteSheet._animations;
			var data = spriteSheet._data;
			var al = names.length/count;
			for (i=0;i<al;i++) {
				var name = names[i];
				src = data[name];
				var anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};
				if (src.next) { anim.next += sfx; }
				frames = src.frames;
				for (var j=0,l=frames.length;j<l;j++) {
					anim.frames.push(frames[j]+fl*count);
				}
				data[anim.name] = anim;
				names.push(anim.name);
			}
		};
	
	
		createjs.SpriteSheetUtils = SpriteSheetUtils;
	}());
	
	//##############################################################################
	// SpriteSheetBuilder.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The SpriteSheetBuilder allows you to generate {{#crossLink "SpriteSheet"}}{{/crossLink}} instances at run time
		 * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and
		 * render them at run time as SpriteSheets for better performance.
		 *
		 * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated
		 * without locking the UI.
		 *
		 * Note that the "images" used in the generated SpriteSheet are actually canvas elements, and that they will be
		 * sized to the nearest power of 2 up to the value of {{#crossLink "SpriteSheetBuilder/maxWidth:property"}}{{/crossLink}}
		 * or {{#crossLink "SpriteSheetBuilder/maxHeight:property"}}{{/crossLink}}.
		 * @class SpriteSheetBuilder
		 * @param {Number} [framerate=0] The {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} of
		 * {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are created.
		 * @extends EventDispatcher
		 * @constructor
		 **/
		function SpriteSheetBuilder(framerate) {
			this.EventDispatcher_constructor();
			
		// public properties:
			/**
			 * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to
			 * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max
			 * dimensions, then additional images will be created as needed.
			 * @property maxWidth
			 * @type Number
			 * @default 2048
			*/
			this.maxWidth = 2048;
		
			/**
			 * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to
			 * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max
			 * dimensions, then additional images will be created as needed.
			 * @property maxHeight
			 * @type Number
			 * @default 2048
			 **/
			this.maxHeight = 2048;
		
			/**
			 * The SpriteSheet that was generated. This will be null before a build is completed successfully.
			 * @property spriteSheet
			 * @type SpriteSheet
			 **/
			this.spriteSheet = null;
		
			/**
			 * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified
			 * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored
			 * to the a specific device resolution (ex. tablet vs mobile).
			 * @property scale
			 * @type Number
			 * @default 1
			 **/
			this.scale = 1;
		
			/**
			* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
			* @property padding
			* @type Number
			* @default 1
			**/
			this.padding = 1;
		
			/**
			 * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
			 * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
			 * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
			 * Defaults to 0.3.
			 * @property timeSlice
			 * @type Number
			 * @default 0.3
			 **/
			this.timeSlice = 0.3;
		
			/**
			 * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
			 * been initiated.
			 * @property progress
			 * @type Number
			 * @default -1
			 * @readonly
			 */
			this.progress = -1;
	
			/**
			 * A {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} value that will be passed to new {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are
			 * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink "Ticker"}}{{/crossLink}}
			 * framerate.
			 * @property framerate
			 * @type Number
			 * @default 0
			 */
			this.framerate = framerate || 0;
		
		
		// private properties:
			/**
			 * @property _frames
			 * @protected
			 * @type Array
			 **/
			this._frames = [];
		
			/**
			 * @property _animations
			 * @protected
			 * @type Array
			 **/
			this._animations = {};
		
			/**
			 * @property _data
			 * @protected
			 * @type Array
			 **/
			this._data = null;
		
			/**
			 * @property _nextFrameIndex
			 * @protected
			 * @type Number
			 **/
			this._nextFrameIndex = 0;
		
			/**
			 * @property _index
			 * @protected
			 * @type Number
			 **/
			this._index = 0;
		
			/**
			 * @property _timerID
			 * @protected
			 * @type Number
			 **/
			this._timerID = null;
		
			/**
			 * @property _scale
			 * @protected
			 * @type Number
			 **/
			this._scale = 1;
		}
		var p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);
	
	// constants:
		SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";
		SpriteSheetBuilder.ERR_RUNNING = "a build is already running";
	
	// events:
		/**
		 * Dispatched when a build completes.
		 * @event complete
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.6.0
		 */
	
		/**
		 * Dispatched when an asynchronous build has progress.
		 * @event progress
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @param {Number} progress The current progress value (0-1).
		 * @since 0.6.0
		 */
	
	
	// public methods:
		/**
		 * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you
		 * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have
		 * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
		 * times, but manipulate it or its children to change it to generate different frames.
		 *
		 * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply
		 * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}
		 * and pass in the Container as the source.
		 * @method addFrame
		 * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.
		 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the
		 * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or
		 * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.
		 * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
		 * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.
		 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
		 * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
		 **/
		p.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			var rect = sourceRect||source.bounds||source.nominalBounds;
			if (!rect&&source.getBounds) { rect = source.getBounds(); }
			if (!rect) { return null; }
			scale = scale||1;
			return this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;
		};
	
		/**
		 * Adds an animation that will be included in the created {{#crossLink "SpriteSheet"}}{{/crossLink}}.
		 * @method addAnimation
		 * @param {String} name The name for the animation.
		 * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
		 * that played frame indexes 3, 6, and 5 in that order.
		 * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
		 * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
		 * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would
		 * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had
		 * the opposite effect.
		 **/
		p.addAnimation = function(name, frames, next, speed) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this._animations[name] = {frames:frames, next:next, speed:speed};
		};
	
		/**
		 * This will take a {{#crossLink "MovieClip"}}{{/crossLink}} instance, and add its frames and labels to this
		 * builder. Labels will be added as an animation running from the label index to the next label. For example, if
		 * there is a label named "foo" at frame 0 and a label named "bar" at frame 10, in a MovieClip with 15 frames, it
		 * will add an animation named "foo" that runs from frame index 0 to 9, and an animation named "bar" that runs from
		 * frame index 10 to 14.
		 *
		 * Note that this will iterate through the full MovieClip with {{#crossLink "MovieClip/actionsEnabled:property"}}{{/crossLink}}
		 * set to `false`, ending on the last frame.
		 * @method addMovieClip
		 * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.
		 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to
		 * draw to the frame. If not specified, it will look for a {{#crossLink "DisplayObject/getBounds"}}{{/crossLink}}
		 * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not
		 * found, the MovieClip will be skipped.
		 * @param {Number} [scale=1] The scale to draw the movie clip at.
		 * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called
		 * with three parameters: the source, setupData, and the frame index.
		 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
		 * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four
		 * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)
		 * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.
		 **/
		p.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			var rects = source.frameBounds;
			var rect = sourceRect||source.bounds||source.nominalBounds;
			if (!rect&&source.getBounds) { rect = source.getBounds(); }
			if (!rect && !rects) { return; }
	
			var i, l, baseFrameIndex = this._frames.length;
			var duration = source.timeline.duration;
			for (i=0; i<duration; i++) {
				var r = (rects&&rects[i]) ? rects[i] : rect;
				this.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});
			}
			var labels = source.timeline._labels;
			var lbls = [];
			for (var n in labels) {
				lbls.push({index:labels[n], label:n});
			}
			if (lbls.length) {
				lbls.sort(function(a,b){ return a.index-b.index; });
				for (i=0,l=lbls.length; i<l; i++) {
					var label = lbls[i].label;
					var start = baseFrameIndex+lbls[i].index;
					var end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);
					var frames = [];
					for (var j=start; j<end; j++) { frames.push(j); }
					if (labelFunction) {
						label = labelFunction(label, source, start, end);
						if (!label) { continue; }
					}
					this.addAnimation(label, frames, true); // for now, this loops all animations.
				}
			}
		};
	
		/**
		 * Builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames.
		 * @method build
		 * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error
		 * occurred.
		 **/
		p.build = function() {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this._startBuild();
			while (this._drawNext()) {}
			this._endBuild();
			return this.spriteSheet;
		};
	
		/**
		 * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will
		 * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the
		 * specified callback.
		 * @method buildAsync
		 * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
		 **/
		p.buildAsync = function(timeSlice) {
			if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
			this.timeSlice = timeSlice;
			this._startBuild();
			var _this = this;
			this._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);
		};
	
		/**
		 * Stops the current asynchronous build.
		 * @method stopAsync
		 **/
		p.stopAsync = function() {
			clearTimeout(this._timerID);
			this._data = null;
		};
	
		/**
		 * SpriteSheetBuilder instances cannot be cloned.
		 * @method clone
		 **/
		p.clone = function() {
			throw("SpriteSheetBuilder cannot be cloned.");
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[SpriteSheetBuilder]";
		};
	
	
	// private methods:
		/**
		 * @method _startBuild
		 * @protected
		 **/
		p._startBuild = function() {
			var pad = this.padding||0;
			this.progress = 0;
			this.spriteSheet = null;
			this._index = 0;
			this._scale = this.scale;
			var dataFrames = [];
			this._data = {
				images: [],
				frames: dataFrames,
				framerate: this.framerate,
				animations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?
			};
	
			var frames = this._frames.slice();
			frames.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });
	
			if (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
			var y=0, x=0;
			var img = 0;
			while (frames.length) {
				var o = this._fillRow(frames, y, img, dataFrames, pad);
				if (o.w > x) { x = o.w; }
				y += o.h;
				if (!o.h || !frames.length) {
					var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
					canvas.width = this._getSize(x,this.maxWidth);
					canvas.height = this._getSize(y,this.maxHeight);
					this._data.images[img] = canvas;
					if (!o.h) {
						x=y=0;
						img++;
					}
				}
			}
		};
		
		/**
		 * @method _setupMovieClipFrame
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._setupMovieClipFrame = function(source, data) {
			var ae = source.actionsEnabled;
			source.actionsEnabled = false;
			source.gotoAndStop(data.i);
			source.actionsEnabled = ae;
			data.f&&data.f(source, data.d, data.i);
		};
	
		/**
		 * @method _getSize
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._getSize = function(size,max) {
			var pow = 4;
			while (Math.pow(2,++pow) < size){}
			return Math.min(max,Math.pow(2,pow));
		};
	
		/**
		 * @method _fillRow
		 * @param {Array} frames
		 * @param {Number} y
		 * @param {HTMLImageElement} img
		 * @param {Object} dataFrames
		 * @param {Number} pad
		 * @protected
		 * @return {Number} The width & height of the row.
		 **/
		p._fillRow = function(frames, y, img, dataFrames, pad) {
			var w = this.maxWidth;
			var maxH = this.maxHeight;
			y += pad;
			var h = maxH-y;
			var x = pad;
			var height = 0;
			for (var i=frames.length-1; i>=0; i--) {
				var frame = frames[i];
				var sc = this._scale*frame.scale;
				var rect = frame.sourceRect;
				var source = frame.source;
				var rx = Math.floor(sc*rect.x-pad);
				var ry = Math.floor(sc*rect.y-pad);
				var rh = Math.ceil(sc*rect.height+pad*2);
				var rw = Math.ceil(sc*rect.width+pad*2);
				if (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
				if (rh > h || x+rw > w) { continue; }
				frame.img = img;
				frame.rect = new createjs.Rectangle(x,y,rw,rh);
				height = height || rh;
				frames.splice(i,1);
				dataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];
				x += rw;
			}
			return {w:x, h:height};
		};
	
		/**
		 * @method _endBuild
		 * @protected
		 **/
		p._endBuild = function() {
			this.spriteSheet = new createjs.SpriteSheet(this._data);
			this._data = null;
			this.progress = 1;
			this.dispatchEvent("complete");
		};
	
		/**
		 * @method _run
		 * @protected
		 **/
		p._run = function() {
			var ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;
			var t = (new Date()).getTime()+ts;
			var complete = false;
			while (t > (new Date()).getTime()) {
				if (!this._drawNext()) { complete = true; break; }
			}
			if (complete) {
				this._endBuild();
			} else {
				var _this = this;
				this._timerID = setTimeout(function() { _this._run(); }, 50-ts);
			}
			var p = this.progress = this._index/this._frames.length;
			if (this.hasEventListener("progress")) {
				var evt = new createjs.Event("progress");
				evt.progress = p;
				this.dispatchEvent(evt);
			}
		};
	
		/**
		 * @method _drawNext
		 * @protected
		 * @return Boolean Returns false if this is the last draw.
		 **/
		p._drawNext = function() {
			var frame = this._frames[this._index];
			var sc = frame.scale*this._scale;
			var rect = frame.rect;
			var sourceRect = frame.sourceRect;
			var canvas = this._data.images[frame.img];
			var ctx = canvas.getContext("2d");
			frame.funct&&frame.funct(frame.source, frame.data);
			ctx.save();
			ctx.beginPath();
			ctx.rect(rect.x, rect.y, rect.width, rect.height);
			ctx.clip();
			ctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));
			ctx.scale(sc,sc);
			frame.source.draw(ctx); // display object will draw itself.
			ctx.restore();
			return (++this._index) < this._frames.length;
		};
	
	
		createjs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");
	}());
	
	//##############################################################################
	// DOMElement.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>
		 *
		 * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed
		 * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is
		 * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be
		 * drawn in front of or behind the canvas).
		 *
		 * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that
		 * the DOM Object be added to a div that also contains the canvas so that they share the same position
		 * on the page.
		 *
		 * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements
		 * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML
		 * content.
		 *
		 * <h4>Mouse Interaction</h4>
		 *
		 * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse
		 * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to
		 * the htmlElement (note, this does not support EventDispatcher)
		 *
		 *      var domElement = new createjs.DOMElement(htmlElement);
		 *      domElement.htmlElement.onclick = function() {
		 *          console.log("clicked");
		 *      }
		 *
		 * <strong>Important:</strong> This class needs to be notified it is about to be drawn, this will happen automatically
		 * if you call stage.update, calling stage.draw or disabling tickEnabled will miss important steps and it will render
		 * stale information.
		 *
		 * @class DOMElement
		 * @extends DisplayObject
		 * @constructor
		 * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.
		 */
		function DOMElement(htmlElement) {
			this.DisplayObject_constructor();
			
			if (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }
			this.mouseEnabled = false;
			
			var style = htmlElement.style;
			style.position = "absolute";
			style.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";
			
			
		// public properties:
			/**
			 * The DOM object to manage.
			 * @property htmlElement
			 * @type HTMLElement
			 */
			this.htmlElement = htmlElement;
		
		
		// private properties:
			/**
			 * @property _oldMtx
			 * @type Matrix2D
			 * @protected
			 */
			this._oldProps = null;
	
			/**
			 * Used to track the object which this class attached listeners to, helps optimize listener attachment.
			 * @property _oldStage
			 * @type Stage
			 * @protected
			 */
			this._oldStage = null;
			/**
			 * The event listener proxy triggered drawing draw for special circumstances.
			 * @property _drawAction
			 * @type function
			 * @protected
			 */
			this._drawAction = null;
		}
		var p = createjs.extend(DOMElement, createjs.DisplayObject);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/**
		 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
		 * This does not account for whether it would be visible within the boundaries of the stage.
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method isVisible
		 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
		 */
		p.isVisible = function() {
			return this.htmlElement != null;
		};
	
		/**
		 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
		 * Returns true if the draw was handled (useful for overriding functionality).
		 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
		 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
		 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
		 * into itself).
		 * @return {Boolean}
		 */
		p.draw = function(ctx, ignoreCache) {
			// this relies on the _tick method because draw isn't called if the parent is not visible.
			// the actual update happens in _handleDrawEnd
			return true;
		};
	
		/**
		 * Not applicable to DOMElement.
		 * @method cache
		 */
		p.cache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method uncache
		 */
		p.uncache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method updateCache
		 */
		p.updateCache = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method hitTest
		 */
		p.hitTest = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method localToGlobal
		 */
		p.localToGlobal = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method globalToLocal
		 */
		p.globalToLocal = function() {};
	
		/**
		 * Not applicable to DOMElement.
		 * @method localToLocal
		 */
		p.localToLocal = function() {};
	
		/**
		 * DOMElement cannot be cloned. Throws an error.
		 * @method clone
		 */
		p.clone = function() {
			throw("DOMElement cannot be cloned.")
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 */
		p.toString = function() {
			return "[DOMElement (name="+  this.name +")]";
		};
	
		/**
	     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
		 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		 * @event click
		 */
	
	     /**
	     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		 * @event dblClick
		 */
	
	     /**
	      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 	  * are not full EaselJS display objects and do not participate in EaselJS mouse events.
		  * @event mousedown
		  */
	
	     /**
	      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.
	      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.
	      * @event mouseover
		  */
	
	     /**
	      * Not applicable to DOMElement.
		  * @event tick
		  */
	
	
	// private methods:
		/**
		 * @method _tick
		 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
		 * function.
		 * @protected
		 */
		p._tick = function(evtObj) {
			var stage = this.stage;
			if(stage && stage !== this._oldStage) {
				this._drawAction && stage.off("drawend", this._drawAction);
				this._drawAction = stage.on("drawend", this._handleDrawEnd, this);
				this._oldStage = stage;
			}
			this.DisplayObject__tick(evtObj);
		};
		
		/**
		 * @method _handleDrawEnd
		 * @param {Event} evt
		 * @protected
		 */
		p._handleDrawEnd = function(evt) {
			var o = this.htmlElement;
			if (!o) { return; }
			var style = o.style;
			
			var props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;
			
			var visibility = props.visible ? "visible" : "hidden";
			if (visibility != style.visibility) { style.visibility = visibility; }
			if (!props.visible) { return; }
			
			var oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;
			var n = 10000; // precision
			
			if (!oldMtx || !oldMtx.equals(mtx)) {
				var str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);
				style.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";
				style.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";
				if (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, null); }
				oldProps.matrix.copy(mtx);
			}
			
			if (oldProps.alpha != props.alpha) {
				style.opacity = ""+(props.alpha*n|0)/n;
				oldProps.alpha = props.alpha;
			}
		};
	
	
		createjs.DOMElement = createjs.promote(DOMElement, "DisplayObject");
	}());
	
	//##############################################################################
	// Filter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
		 * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
		 * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.
		 *
		 * <h4>Example</h4>
		 *
		 *      myInstance.filters = [
		 *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
		 *          new createjs.BlurFilter(5, 5, 10)
		 *      ];
		 *      myInstance.cache(0,0, 100, 100);
		 *
		 * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the
		 * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}
		 * will cause an object to feather outwards, resulting in a margin around the shape.
		 *
		 * <h4>EaselJS Filters</h4>
		 * EaselJS comes with a number of pre-built filters:
		 * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
		 *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
		 *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
		 *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
		 *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
		 * </ul>
		 *
		 * @class Filter
		 * @constructor
		 **/
		function Filter() {
			/**
			 * A flag stating that this filter uses a context draw mode and cannot be batched into imageData processing.
			 * @property usesContext
			 * @type {boolean}
			 * @default false
			 */
			this.usesContext = false;
	
			/**
			 * Pre-processed template shader code. It will be parsed before being fed in into the shader compiler.
			 * This should be based upon StageGL.SHADER_VERTEX_BODY_REGULAR
			 * @property VTX_SHADER
			 * @virtual
			 * @type {String}
			 * @readonly
			 */
			this.VTX_SHADER_BODY = null;
	
			/**
			 * Pre-processed template shader code. It will be parsed before being fed in into the shader compiler.
			 * This should be based upon StageGL.SHADER_FRAGMENT_BODY_REGULAR
			 * @property FRAG_SHADER
			 * @virtual
			 * @type {String}
			 * @readonly
			 */
			this.FRAG_SHADER_BODY = null;
		}
		var p = Filter.prototype;
	
	// public methods:
		/**
		 * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
		 * @method getBounds
		 * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
		 * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
		 **/
		p.getBounds = function(rect) {
			return rect;
		};
	
		/**
		 * Assign any unique uniforms or other setup functionality here.
		 * @method shaderParamSetup
		 * @virtual
		 * @param {WebGLContext} gl The context associated with the stage performing the render.
		 * @param {StageGL} stage The stage instance that will be rendering.
		 * @param {ShaderProgram} shaderProgram The compiled shader that is going to be used to perform the render.
		 */
		p.shaderParamSetup = function(gl, stage, shaderProgram) {};
	
		/**
		 * Applies the filter to the specified context.
		 * @method applyFilter
		 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
		 * @param {Number} x The x position to use for the source rect.
		 * @param {Number} y The y position to use for the source rect.
		 * @param {Number} width The width to use for the source rect.
		 * @param {Number} height The height to use for the source rect.
		 * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
		 * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.
		 * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.
		 * @return {Boolean} If the filter was applied successfully.
		 **/
		p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
			// this is the default behaviour because most filters access pixel data. It is overridden when not needed.
			targetCtx = targetCtx || ctx;
			if (targetX == null) { targetX = x; }
			if (targetY == null) { targetY = y; }
			try {
				var imageData = ctx.getImageData(x, y, width, height);
			} catch (e) {
				return false;
			}
			if (this._applyFilter(imageData)) {
				targetCtx.putImageData(imageData, targetX, targetY);
				return true;
			}
			return false;
		};
	
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Filter]";
		};
	
		/**
		 * Returns a clone of this Filter instance.
		 * @method clone
		 * @return {Filter} A clone of the current Filter instance.
		 **/
		p.clone = function() {
			return new Filter();
		};
		
	// private methods:
		/**
		 * @method _applyFilter
		 * @param {ImageData} imageData Target ImageData instance.
		 * @return {Boolean}
		 **/
		p._applyFilter = function(imageData) { return true; };
	
	
		createjs.Filter = Filter;
	}());
	
	//##############################################################################
	// BitmapCache.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * The BitmapCache is an internal representation of all the cache properties and logic required in order to "cache"
		 * an object. This information and functionality used to be located on a {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
		 * method in {{#crossLink "DisplayObject"}}{{/crossLink}}, but was moved to its own class.
		 *
		 * Caching in this context is purely visual, and will render the DisplayObject out into an image to be used instead
		 * of the object. The actual cache itself is still stored on the target with the {{#crossLink "DisplayObject/cacheCanvas:property"}}{{/crossLink}}.
		 * Working with a singular image like a {{#crossLink "Bitmap"}}{{/crossLink}} there is little benefit to performing 
		 * a cache as it is already a single image. Caching is best done on containers containing multiple complex parts that 
		 * do not move often, so that rendering the image instead will improve overall rendering speed. A cached object will 
		 * not visually update until explicitly told to do so with a call to update, much like a Stage. If a cache is being 
		 * updated every frame it is likely not improving rendering performance. Cache are best used when updates will be sparse.
		 *
		 * Caching is also a co-requisite for applying filters to prevent expensive filters running constantly without need, 
		 * and to physically enable some effects. The BitmapCache is also responsible for applying filters to objects and 
		 * reads each {{#crossLink "Filter"}}{{/crossLink}} due to this relationship. Real-time Filters are not recommended 
		 * performance wise when dealing with a Context2D canvas. For best performance and to still allow for some visual 
		 * effects use a compositeOperation when possible.
		 * @class BitmapCache
		 * @constructor
		 **/
		function BitmapCache() {
	
			// public:
			/**
			 * Width of the cache relative to the target object.
			 * @property width
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.width = undefined;
	
			/**
			 * Height of the cache relative to the target object.
			 * @property height
			 * @protected
			 * @type {Number}
			 * @default undefined
			 * @todo Should the width and height be protected?
			 **/
			this.height = undefined;
	
			/**
			 * Horizontal position of the cache relative to the target's origin.
			 * @property x
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.x = undefined;
	
			/**
			 * Vertical position of the cache relative to target's origin.
			 * @property y
			 * @protected
			 * @type {Number}
			 * @default undefined
			 **/
			this.y = undefined;
	
			/**
			 * The internal scale of the cache image, does not affects display size. This is useful to both increase and
			 * decrease render quality. Objects with increased scales are more likely to look good when scaled up or rotated.
			 * Objects with decreased scales can save on rendering performance.
			 * @property scale
			 * @protected
			 * @type {Number}
			 * @default 1
			 **/
			this.scale = 1;
	
			/**
			 * The x offset used for drawing into the cache itself, accounts for both transforms applied.
			 * @property offX
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.offX = 0;
	
			/**
			 * The y offset used for drawing into the cache itself, accounts for both transforms applied.
			 * @property offY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this.offY = 0;
	
			/**
			 * Track how many times the cache has been updated, mostly used for preventing duplicate cacheURLs.
			 * This can be useful to see if a cache has been updated.
			 * @property cacheID
			 * @type {Number}
			 * @default 0
			 **/
			this.cacheID = 0;
	
			// protected:
			/**
			 * The relative offset of the filter's x position, used for drawing the cache onto its container.
			 * Re-calculated every update call before drawing.
			 * @property _filterOffY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._filterOffX = 0;
	
			/**
			 * The relative offset of the filter's y position, used for drawing the cache onto its container.
			 * Re-calculated every update call before drawing.
			 * @property _filterOffY
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._filterOffY = 0;
	
			/**
			 * The cacheID when a DataURL was requested.
			 * @property _cacheDataURLID
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._cacheDataURLID = 0;
	
			/**
			 * The cache's DataURL, generated on-demand using the getter.
			 * @property _cacheDataURL
			 * @protected
			 * @type {String}
			 * @default null
			 **/
			this._cacheDataURL = null;
	
			/**
			 * Internal tracking of final bounding width, approximately width*scale; however, filters can complicate the actual value.
			 * @property _drawWidth
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._drawWidth = 0;
	
			/**
			 * Internal tracking of final bounding height, approximately height*scale; however, filters can complicate the actual value.
			 * @property _drawHeight
			 * @protected
			 * @type {Number}
			 * @default 0
			 **/
			this._drawHeight = 0;
		}
		var p = BitmapCache.prototype;
	
		/**
		 * Returns the bounds that surround all applied filters, relies on each filter to describe how it changes bounds.
		 * @method getFilterBounds
		 * @param {DisplayObject} target The object to check the filter bounds for.
		 * @param {Rectangle} [output=null] Optional parameter, if provided then calculated bounds will be applied to that object.
		 * @return {Rectangle} bounds object representing the bounds with filters.
		 * @static
		 **/
		BitmapCache.getFilterBounds = function(target, output) {
			if(!output){ output = new createjs.Rectangle(); }
			var filters = target.filters;
			var filterCount = filters && filters.length;
			if (!!filterCount <= 0) { return output; }
	
			for(var i=0; i<filterCount; i++) {
				var f = filters[i];
				if(!f || !f.getBounds){ continue; }
				var test = f.getBounds();
				if(!test){ continue; }
				if(i==0) {
					output.setValues(test.x, test.y, test.width, test.height);
				} else {
					output.extend(test.x, test.y, test.width, test.height);
				}
			}
	
			return output;
		};
	
	// public methods:
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[BitmapCache]";
		};
	
		/**
		 * Actually create the correct cache surface and properties associated with it. Caching and it's benefits are discussed
		 * by the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} function and this class description. Here are the detailed
		 * specifics of how to use the options object.
		 *
		 * - If options.useGL is set to "new" a StageGL is created and contained on this for use when rendering the cache.
		 * - If options.useGL is set to "stage" if the current stage is a StageGL it will be used. If not then it will default to "new".
		 * - If options.useGL is a StageGL instance it will not create one but use the one provided.
		 * - If options.useGL is undefined a Context 2D cache will be performed.
		 *
		 * This means you can use any combination of StageGL and 2D with either, neither, or both the stage and cache being
		 * WebGL. Using "new" with a StageGL display list is highly unrecommended, but still an option. It should be avoided
		 * due to negative performance reasons and the Image loading limitation noted in the class complications above.
		 *
		 * When "options.useGL" is set to the parent stage of the target and WebGL, performance is increased by using
		 * "RenderTextures" instead of canvas elements. These are internal Textures on the graphics card stored in the GPU.
		 * Because they are no longer canvases you cannot perform operations you could with a regular canvas. The benefit
		 * is that this avoids the slowdown of copying the texture back and forth from the GPU to a Canvas element.
		 * This means "stage" is the recommended option when available.
		 *
		 * A StageGL cache does not infer the ability to draw objects a StageGL cannot currently draw, i.e. do not use a
		 * WebGL context cache when caching a Shape, Text, etc.
		 * <h4>WebGL cache with a 2D context</h4>
		 *
		 *     var stage = new createjs.Stage();
		 *     var bmp = new createjs.Bitmap(src);
		 *     bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "new"});          // no StageGL to use, so make one
		 *
		 *     var shape = new createjs.Shape();
		 *     shape.graphics.clear().fill("red").drawRect(0,0,20,20);
		 *     shape.cache(0, 0, 20, 20, 1);                             // cannot use WebGL cache
		 *
		 * <h4>WebGL cache with a WebGL context</h4>
		 *
		 *     var stageGL = new createjs.StageGL();
		 *     var bmp = new createjs.Bitmap(src);
		 *     bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "stage"});       // use our StageGL to cache
		 *
		 *     var shape = new createjs.Shape();
		 *     shape.graphics.clear().fill("red").drawRect(0,0,20,20);
		 *     shape.cache(0, 0, 20, 20, 1);                             // cannot use WebGL cache
		 *
		 * You may wish to create your own StageGL instance to control factors like clear color, transparency, AA, and
		 * others. If you do, pass a new instance in instead of "true", the library will automatically set the
		 * {{#crossLink "StageGL/isCacheControlled"}}{{/crossLink}} to true on your instance. This will trigger it to behave
		 * correctly, and not assume your main context is WebGL.
		 *
		 * @public
		 * @method BitmapCache.cache
		 * @param {Number} x The x coordinate origin for the cache region.
		 * @param {Number} y The y coordinate origin for the cache region.
		 * @param {Number} width The width of the cache region.
		 * @param {Number} height The height of the cache region.
		 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape
		 * using myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and
		 * rotate cached elements with greater fidelity. Default is 1.
		 * @param {Object} [options=undefined] Specify additional parameters for the cache logic
		 * @param {undefined|"new"|"stage"|StageGL} [options.useGL=undefined] Select whether to use context 2D, or WebGL rendering, and
		 * whether to make a new stage instance or use an existing one. See above for extensive details on use.
		 * @for BitmapCache
		 */
		 p.define = function(target, x, y, width, height, scale, options) {
			if(!target){ throw "No symbol to cache"; }
			this._options = options;
			this.target = target;
	
			this.width =		width >= 1 ? width : 1;
			this.height =		height >= 1 ? height : 1;
			this.x =			x || 0;
			this.y =			y || 0;
			this.scale =		scale || 1;
	
			this.update();
		};
	
		/**
		 * Directly called via {{#crossLink "DisplayObject/updateCache:method"}}{{/crossLink}}, but also internally. This
		 * has the dual responsibility of making sure the surface is ready to be drawn to, and performing the draw. For
		 * full details of each behaviour, check the protected functions {{#crossLink "BitmapCache/_updateSurface"}}{{/crossLink}}
		 * and {{#crossLink "BitmapCache/_drawToCache"}}{{/crossLink}} respectively.
		 * @method update
		 * @param {String} [compositeOperation=null] The DisplayObject this cache is linked to.
		 **/
		p.update = function(compositeOperation) {
			if(!this.target) { throw "define() must be called before update()"; }
	
			var filterBounds = BitmapCache.getFilterBounds(this.target);
			var surface = this.target.cacheCanvas;
	
			this._drawWidth = Math.ceil(this.width*this.scale) + filterBounds.width;
			this._drawHeight = Math.ceil(this.height*this.scale) + filterBounds.height;
	
			if(!surface || this._drawWidth != surface.width || this._drawHeight != surface.height) {
				this._updateSurface();
			}
	
			this._filterOffX = filterBounds.x;
			this._filterOffY = filterBounds.y;
			this.offX = this.x*this.scale + this._filterOffX;
			this.offY = this.y*this.scale + this._filterOffY;
	
			this._drawToCache(compositeOperation);
	
			this.cacheID = this.cacheID?this.cacheID+1:1;
		};
	
		/**
		 * Reset and release all the properties and memory associated with this cache.
		 * @method release
		 **/
		p.release = function() {
			if (this._webGLCache) {
				// if it isn't cache controlled clean up after yourself
				if (!this._webGLCache.isCacheControlled) {
					if (this.__lastRT){ this.__lastRT = undefined; }
					if (this.__rtA){ this._webGLCache._killTextureObject(this.__rtA); }
					if (this.__rtB){ this._webGLCache._killTextureObject(this.__rtB); }
					if (this.target && this.target.cacheCanvas){ this._webGLCache._killTextureObject(this.target.cacheCanvas); }
				}
				// set the context to none and let the garbage collector get the rest when the canvas itself gets removed
				this._webGLCache = false;
			} else {
				var stage = this.target.stage;
				if (stage instanceof createjs.StageGL){
					stage.releaseTexture(this.target.cacheCanvas);
				}
			}
	
			this.target = this.target.cacheCanvas = null;
			this.cacheID = this._cacheDataURLID = this._cacheDataURL = undefined;
			this.width = this.height = this.x = this.y = this.offX = this.offY = 0;
			this.scale = 1;
		};
	
		/**
		 * Returns a data URL for the cache, or `null` if this display object is not cached.
		 * Uses {{#crossLink "BitmapCache/cacheID:property"}}{{/crossLink}} to ensure a new data URL is not generated if the
		 * cache has not changed.
		 * @method getCacheDataURL
		 * @return {String} The image data url for the cache.
		 **/
		p.getCacheDataURL = function() {
			var cacheCanvas = this.target && this.target.cacheCanvas;
			if (!cacheCanvas) { return null; }
			if (this.cacheID != this._cacheDataURLID) {
				this._cacheDataURLID = this.cacheID;
				this._cacheDataURL = cacheCanvas.toDataURL?cacheCanvas.toDataURL():null;	// incase function is
			}
			return this._cacheDataURL;
		};
	
		/**
		 * Use context2D drawing commands to display the cache canvas being used.
		 * @method draw
		 * @param {CanvasRenderingContext2D} ctx The context to draw into.
		 * @return {Boolean} Whether the draw was handled successfully.
		 **/
		p.draw = function(ctx) {
			if(!this.target) { return false; }
			ctx.drawImage(this.target.cacheCanvas,
				this.x + (this._filterOffX/this.scale),		this.y + (this._filterOffY/this.scale),
				this._drawWidth/this.scale,					this._drawHeight/this.scale
			);
			return true;
		};
	
	// private methods:
		/**
		 * Create or resize the invisible canvas/surface that is needed for the display object(s) to draw to,
		 * and in turn be used in their stead when drawing. The surface is resized to the size defined
		 * by the width and height, factoring in scaling and filters. Adjust them to adjust the output size.
		 * @method _updateSurface
		 * @protected
		 **/
		p._updateSurface = function() {
			if (!this._options || !this._options.useGL) {
				var surface = this.target.cacheCanvas;
	
				// create it if it's missing
				if(!surface) {
					surface = this.target.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				}
	
				// now size it
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
				return;
			}
	
			// create it if it's missing
			if (!this._webGLCache) {
				if (this._options.useGL === "stage") {
					if(!(this.target.stage && this.target.stage.isWebGL)){
						var error = "Cannot use 'stage' for cache because the object's parent stage is ";
						error += this.target.stage ? "non WebGL." : "not set, please addChild to the correct stage.";
						throw error;
					}
					this.target.cacheCanvas = true; // will be replaced with RenderTexture, temporary positive value for old "isCached" checks
					this._webGLCache = this.target.stage;
	
				} else if(this._options.useGL === "new") {
					this.target.cacheCanvas = document.createElement("canvas"); // we can turn off autopurge because we wont be making textures here
					this._webGLCache = new createjs.StageGL(this.target.cacheCanvas, {antialias: true, transparent: true, autoPurge: -1});
					this._webGLCache.isCacheControlled = true;	// use this flag to control stage sizing and final output
	
				} else if(this._options.useGL instanceof createjs.StageGL) {
					this.target.cacheCanvas = true; // will be replaced with RenderTexture, temporary positive value for old "isCached" checks
					this._webGLCache = this._options.useGL;
					this._webGLCache.isCacheControlled = true;	// use this flag to control stage sizing and final output
	
				} else {
					throw "Invalid option provided to useGL, expected ['stage', 'new', StageGL, undefined], got "+ this._options.useGL;
				}
			}
	
			// now size render surfaces
			var surface = this.target.cacheCanvas;
			var stageGL = this._webGLCache;
	
			// if we have a dedicated stage we've gotta size it
			if (stageGL.isCacheControlled) {
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
				stageGL.updateViewport(this._drawWidth, this._drawHeight);
			}
			if (this.target.filters) {
				// with filters we can't tell how many we'll need but the most we'll ever need is two, so make them now
				stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
				stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
			} else {
				// without filters then we only need one RenderTexture, and that's only if its not a dedicated stage
				if (!stageGL.isCacheControlled) {
					stageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);
				}
			}
		};
	
		/**
		 * Perform the cache draw out for context 2D now that the setup properties have been performed.
		 * @method _drawToCache
		 * @protected
		 **/
		p._drawToCache = function(compositeOperation) {
			var surface = this.target.cacheCanvas;
			var target = this.target;
			var webGL = this._webGLCache;
	
			if (webGL){
				//TODO: auto split blur into an x/y pass
				webGL.cacheDraw(target, target.filters, this);
	
				// we may of swapped around which element the surface is, so we re-fetch it
				surface = this.target.cacheCanvas;
	
				surface.width = this._drawWidth;
				surface.height = this._drawHeight;
			} else {
				var ctx = surface.getContext("2d");
	
				if (!compositeOperation) {
					ctx.clearRect(0, 0, this._drawWidth+1, this._drawHeight+1);
				}
	
				ctx.save();
				ctx.globalCompositeOperation = compositeOperation;
				ctx.setTransform(this.scale,0,0,this.scale, -this._filterOffX,-this._filterOffY);
				ctx.translate(-this.x, -this.y);
				target.draw(ctx, true);
				ctx.restore();
	
	
				if (target.filters && target.filters.length) {
					this._applyFilters(ctx);
				}
			}
			surface._invalid = true;
		};
	
		/**
		 * Work through every filter and apply its individual visual transformation.
		 * @method _applyFilters
		 * @protected
		 **/
		p._applyFilters = function(ctx) {
			var filters = this.target.filters;
	
			var w = this._drawWidth;
			var h = this._drawHeight;
	
			var data;
	
			var l = filters.length;
			for (var i=0; i<l; i++) {
				var filter = filters[i];
				if(filter.usesContext){
					if(data) {
						ctx.putImageData(data, 0,0);
						data = null;
					}
					filter.applyFilter(ctx, 0,0, w,h);
				} else {
					if(!data) {
						data = ctx.getImageData(0,0, w,h);
					}
					filter._applyFilter(data);
				}
			}
	
			//done
			if(data) {
				ctx.putImageData(data, 0,0);
			}
		};
	
		createjs.BitmapCache = BitmapCache;
	}());
	
	//##############################################################################
	// BlurFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies a box blur to DisplayObjects in context 2D and a Gaussian blur in webgl. Note that this filter is fairly
		 * intensive, particularly if the quality is set higher than 1.
		 *
		 * <h4>Example</h4>
		 * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}
		 * method to account for the spread that the blur causes.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      var blurFilter = new createjs.BlurFilter(5, 5, 1);
		 *      shape.filters = [blurFilter];
		 *      var bounds = blurFilter.getBounds();
		 *
		 *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class BlurFilter
		 * @extends Filter
		 * @constructor
		 * @param {Number} [blurX=0] The horizontal blur radius in pixels.
		 * @param {Number} [blurY=0] The vertical blur radius in pixels.
		 * @param {Number} [quality=1] The number of blur iterations.
		 **/
		function BlurFilter( blurX, blurY, quality) {
			this.Filter_constructor();
	
			// public properties:
			/**
			 * Horizontal blur radius in pixels
			 * @property blurX
			 * @default 0
			 * @type Number
			 **/
			this._blurX = blurX;
			this._blurXTable = [];
			this._lastBlurX = null;
	
			/**
			 * Vertical blur radius in pixels
			 * @property blurY
			 * @default 0
			 * @type Number
			 **/
			this._blurY = blurY;
			this._blurYTable = [];
			this._lastBlurY = null;
	
			/**
			 * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a
			 * smoother blur, but take twice as long to run.
			 * @property quality
			 * @default 1
			 * @type Number
			 **/
			this._quality;
			this._lastQuality = null;
	
			/**
			 * This is a template to generate the shader for {{#crossLink FRAG_SHADER_BODY}}{{/crossLink}}
			 */
			this.FRAG_SHADER_TEMPLATE = (
				"uniform float xWeight[{{blurX}}];" +
				"uniform float yWeight[{{blurY}}];" +
				"uniform vec2 textureOffset;" +
				"void main(void) {" +
					"vec4 color = vec4(0.0);" +
	
					"float xAdj = ({{blurX}}.0-1.0)/2.0;" +
					"float yAdj = ({{blurY}}.0-1.0)/2.0;" +
					"vec2 sampleOffset;" +
	
					"for(int i=0; i<{{blurX}}; i++) {" +
						"for(int j=0; j<{{blurY}}; j++) {" +
							"sampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));" +
							"color += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);" +
						"}" +
					"}" +
	
					"gl_FragColor = color.rgba;" +
				"}"
			);
	
			// update the filter using the setters
			if(isNaN(quality) || quality < 1){ quality = 1; }
			this.setQuality(quality|0);
		}
		var p = createjs.extend(BlurFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		p.getBlurX = function() { return this._blurX; };
		p.getBlurY = function() { return this._blurY; };
		p.setBlurX = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._blurX = value;
		};
		p.setBlurY = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._blurY = value;
		};
		p.getQuality = function() { return this._quality; };
		p.setQuality = function(value) {
			if(isNaN(value) || value < 0){ value = 0; }
			this._quality = value | 0;
		};
		p._getShader = function() {
			var xChange = this._lastBlurX !== this._blurX;
			var yChange = this._lastBlurY !== this._blurY;
			var qChange = this._lastQuality !== this._quality;
			if(xChange || yChange || qChange) {
				if(xChange || qChange) { this._blurXTable = this._getTable(this._blurX * this._quality); }
				if(yChange || qChange) { this._blurYTable = this._getTable(this._blurY * this._quality); }
				this._updateShader();
				this._lastBlurX = this._blurX;
				this._lastBlurY = this._blurY;
				this._lastQuality = this._quality;
				return undefined; // force a rebuild
			}
			return this._compiledShader;
		};
		p._setShader = function() { this._compiledShader; };
	
		try {
			Object.defineProperties(p, {
				blurX: { get: p.getBlurX, set: p.setBlurX },
				blurY: { get: p.getBlurY, set: p.setBlurY },
				quality: { get: p.getQuality, set: p.setQuality },
				_builtShader: { get: p._getShader, set: p._setShader}
			});
		} catch (e) { console.log(e); }
	
		/**
		 * Internal lookup function to create gaussian distribution.
		 * @method _getTable
		 * @param {Number} spread How many steps in the curve.
		 * @return {Array<Number>} An array with Math.ceil(spread*2) entries with appropriately distributed weights.
		 */
		p._getTable = function(spread) {
			var EDGE = 4.2;
			if(spread<=1) { return [1]; }
	
			var result = [];
			var count = Math.ceil(spread*2);
			count += (count%2)?0:1;
			var adjust = (count/2)|0;
			for(var i = -adjust; i<=adjust; i++) {
				var x = (i/adjust)*EDGE;
				result.push(1/Math.sqrt(2*Math.PI) * Math.pow(Math.E, -(Math.pow(x,2)/4)));
			}
			var factor = result.reduce(function(a, b) { return a + b; });
			return result.map(function(currentValue, index, array) { return currentValue/factor; });
		};
	
		/**
		 * Internal update function to create shader properties.
		 * @method _updateShader
		 */
		p._updateShader = function() {
			if(this._blurX === undefined || this._blurY === undefined){ return; }
			var result = this.FRAG_SHADER_TEMPLATE;
			result = result.replace(/\{\{blurX\}\}/g, (this._blurXTable.length).toFixed(0));
			result = result.replace(/\{\{blurY\}\}/g, (this._blurYTable.length).toFixed(0));
			this.FRAG_SHADER_BODY = result;
		};
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			// load the normalized gaussian weight tables
			gl.uniform1fv(
				gl.getUniformLocation(shaderProgram, "xWeight"),
				this._blurXTable
			);
			gl.uniform1fv(
				gl.getUniformLocation(shaderProgram, "yWeight"),
				this._blurYTable
			);
	
			// what is the size of a single pixel in -1, 1 (webGL) space
			gl.uniform2f(
				gl.getUniformLocation(shaderProgram, "textureOffset"),
				2/(stage._viewportWidth*this._quality), 2/(stage._viewportHeight*this._quality)
			);
		};
	
	// constants:
		/**
		 * Array of multiply values for blur calculations.
		 * @property MUL_TABLE
		 * @type Array
		 * @protected
		 * @static
		 **/
		BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];
	
		/**
		 * Array of shift values for blur calculations.
		 * @property SHG_TABLE
		 * @type Array
		 * @protected
		 * @static
		 **/
		BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];
	
	// public methods:
		/** docced in super class **/
		p.getBounds = function (rect) {
			var x = this.blurX|0, y = this.blurY| 0;
			if(x <= 0 && y <= 0) { return rect; }
			var q = Math.pow(this.quality, 0.2);
			return (rect || new createjs.Rectangle()).pad(y*q+1,x*q+1,y*q+1,x*q+1);
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new BlurFilter(this.blurX, this.blurY, this.quality);
		};
	
		/** docced in super class **/
		p.toString = function() {
			return "[BlurFilter]";
		};
	
	
	// private methods:
	
		/** docced in super class **/
		p._applyFilter = function (imageData) {
			var radiusX = this._blurX >> 1;
			if (isNaN(radiusX) || radiusX < 0) return false;
			var radiusY = this._blurY >> 1;
			if (isNaN(radiusY) || radiusY < 0) return false;
			if (radiusX == 0 && radiusY == 0) return false;
	
			var iterations = this.quality;
			if (isNaN(iterations) || iterations < 1) iterations = 1;
			iterations |= 0;
			if (iterations > 3) iterations = 3;
			if (iterations < 1) iterations = 1;
	
			var px = imageData.data;
			var x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;
	
			var divx = (radiusX + radiusX + 1) | 0;
			var divy = (radiusY + radiusY + 1) | 0;
			var w = imageData.width | 0;
			var h = imageData.height | 0;
	
			var w1 = (w - 1) | 0;
			var h1 = (h - 1) | 0;
			var rxp1 = (radiusX + 1) | 0;
			var ryp1 = (radiusY + 1) | 0;
	
			var ssx = {r:0,b:0,g:0,a:0};
			var sx = ssx;
			for ( i = 1; i < divx; i++ )
			{
				sx = sx.n = {r:0,b:0,g:0,a:0};
			}
			sx.n = ssx;
	
			var ssy = {r:0,b:0,g:0,a:0};
			var sy = ssy;
			for ( i = 1; i < divy; i++ )
			{
				sy = sy.n = {r:0,b:0,g:0,a:0};
			}
			sy.n = ssy;
	
			var si = null;
	
	
			var mtx = BlurFilter.MUL_TABLE[radiusX] | 0;
			var stx = BlurFilter.SHG_TABLE[radiusX] | 0;
			var mty = BlurFilter.MUL_TABLE[radiusY] | 0;
			var sty = BlurFilter.SHG_TABLE[radiusY] | 0;
	
			while (iterations-- > 0) {
	
				yw = yi = 0;
				var ms = mtx;
				var ss = stx;
				for (y = h; --y > -1;) {
					r = rxp1 * (pr = px[(yi) | 0]);
					g = rxp1 * (pg = px[(yi + 1) | 0]);
					b = rxp1 * (pb = px[(yi + 2) | 0]);
					a = rxp1 * (pa = px[(yi + 3) | 0]);
	
					sx = ssx;
	
					for( i = rxp1; --i > -1; )
					{
						sx.r = pr;
						sx.g = pg;
						sx.b = pb;
						sx.a = pa;
						sx = sx.n;
					}
	
					for( i = 1; i < rxp1; i++ )
					{
						p = (yi + ((w1 < i ? w1 : i) << 2)) | 0;
						r += ( sx.r = px[p]);
						g += ( sx.g = px[p+1]);
						b += ( sx.b = px[p+2]);
						a += ( sx.a = px[p+3]);
	
						sx = sx.n;
					}
	
					si = ssx;
					for ( x = 0; x < w; x++ )
					{
						px[yi++] = (r * ms) >>> ss;
						px[yi++] = (g * ms) >>> ss;
						px[yi++] = (b * ms) >>> ss;
						px[yi++] = (a * ms) >>> ss;
	
						p = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);
	
						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);
	
						si = si.n;
	
					}
					yw += w;
				}
	
				ms = mty;
				ss = sty;
				for (x = 0; x < w; x++) {
					yi = (x << 2) | 0;
	
					r = (ryp1 * (pr = px[yi])) | 0;
					g = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;
					b = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;
					a = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;
	
					sy = ssy;
					for( i = 0; i < ryp1; i++ )
					{
						sy.r = pr;
						sy.g = pg;
						sy.b = pb;
						sy.a = pa;
						sy = sy.n;
					}
	
					yp = w;
	
					for( i = 1; i <= radiusY; i++ )
					{
						yi = ( yp + x ) << 2;
	
						r += ( sy.r = px[yi]);
						g += ( sy.g = px[yi+1]);
						b += ( sy.b = px[yi+2]);
						a += ( sy.a = px[yi+3]);
	
						sy = sy.n;
	
						if( i < h1 )
						{
							yp += w;
						}
					}
	
					yi = x;
					si = ssy;
					if ( iterations > 0 )
					{
						for ( y = 0; y < h; y++ )
						{
							p = yi << 2;
							px[p+3] = pa =(a * ms) >>> ss;
							if ( pa > 0 )
							{
								px[p]   = ((r * ms) >>> ss );
								px[p+1] = ((g * ms) >>> ss );
								px[p+2] = ((b * ms) >>> ss );
							} else {
								px[p] = px[p+1] = px[p+2] = 0
							}
	
							p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;
	
							r -= si.r - ( si.r = px[p]);
							g -= si.g - ( si.g = px[p+1]);
							b -= si.b - ( si.b = px[p+2]);
							a -= si.a - ( si.a = px[p+3]);
	
							si = si.n;
	
							yi += w;
						}
					} else {
						for ( y = 0; y < h; y++ )
						{
							p = yi << 2;
							px[p+3] = pa =(a * ms) >>> ss;
							if ( pa > 0 )
							{
								pa = 255 / pa;
								px[p]   = ((r * ms) >>> ss ) * pa;
								px[p+1] = ((g * ms) >>> ss ) * pa;
								px[p+2] = ((b * ms) >>> ss ) * pa;
							} else {
								px[p] = px[p+1] = px[p+2] = 0
							}
	
							p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;
	
							r -= si.r - ( si.r = px[p]);
							g -= si.g - ( si.g = px[p+1]);
							b -= si.b - ( si.b = px[p+2]);
							a -= si.a - ( si.a = px[p+3]);
	
							si = si.n;
	
							yi += w;
						}
					}
				}
	
			}
			return true;
		};
	
		createjs.BlurFilter = createjs.promote(BlurFilter, "Filter");
	}());
	
	//##############################################################################
	// AlphaMapFilter.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
		
		
	// constructor:
		/**
		 * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will
		 * be copied from the red channel of the map, and the RGB channels will be copied from the target.
		 *
		 * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much
		 * better performance.
		 *
		 * <h4>Example</h4>
		 * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.
		 *
		 *       var box = new createjs.Shape();
		 *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)
		 *       box.graphics.drawRect(0, 0, 100, 100);
		 *       box.cache(0, 0, 100, 100);
		 *
		 *       var bmp = new createjs.Bitmap("path/to/image.jpg");
		 *       bmp.filters = [
		 *           new createjs.AlphaMapFilter(box.cacheCanvas)
		 *       ];
		 *       bmp.cache(0, 0, 100, 100);
		 *       stage.addChild(bmp);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
		 * @class AlphaMapFilter
		 * @extends Filter
		 * @constructor
		 * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the
		 * result. This should be exactly the same dimensions as the target.
		 **/
		function AlphaMapFilter(alphaMap) {
			this.Filter_constructor();
		
		// public properties:
			/**
			 * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same
			 * dimensions as the target.
			 * @property alphaMap
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this.alphaMap = alphaMap;
			
			
		// private properties:
			/**
			 * @property _alphaMap
			 * @protected
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this._alphaMap = null;
			
			/**
			 * @property _mapData
			 * @protected
			 * @type Uint8ClampedArray
			 **/
			this._mapData = null;
			this._mapTexture = null;
	
			this.FRAG_SHADER_BODY = (
				"uniform sampler2D uAlphaSampler;"+
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
					"vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);" +
	
					// some image formats can have transparent white rgba(1,1,1, 0) when put on the GPU, this means we need a slight tweak
					// using ceil ensure that the colour will be used so long as it exists but pure transparency will be treated black
					"gl_FragColor = vec4(color.rgb, color.a * (alphaMap.r * ceil(alphaMap.a)));" +
				"}"
			);
		}
		var p = createjs.extend(AlphaMapFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			if(!this._mapTexture) { this._mapTexture = gl.createTexture(); }
	
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this._mapTexture);
			stage.setTextureParams(gl);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.alphaMap);
	
			gl.uniform1i(
				gl.getUniformLocation(shaderProgram, "uAlphaSampler"),
				1
			);
		};
	
	// public methods:
		/** docced in super class **/
		p.clone = function () {
			var o = new AlphaMapFilter(this.alphaMap);
			o._alphaMap = this._alphaMap;
			o._mapData = this._mapData;
			return o;
		};
	
		/** docced in super class **/
		p.toString = function () {
			return "[AlphaMapFilter]";
		};
	
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function (imageData) {
			if (!this.alphaMap) { return true; }
			if (!this._prepAlphaMap()) { return false; }
			
			// TODO: update to support scenarios where the target has different dimensions.
			var data = imageData.data;
			var map = this._mapData;
			for(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }
			
			return true;
		};
	
		/**
		 * @method _prepAlphaMap
		 * @protected
		 **/
		p._prepAlphaMap = function () {
			if (!this.alphaMap) { return false; }
			if (this.alphaMap == this._alphaMap && this._mapData) { return true; }
	
			this._mapData = null;
			var map = this._alphaMap = this.alphaMap;
			var canvas = map;
			var ctx;
			if (map instanceof HTMLCanvasElement) {
				ctx = canvas.getContext("2d");
			} else {
				canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");
				canvas.width = map.width;
				canvas.height = map.height;
				ctx = canvas.getContext("2d");
				ctx.drawImage(map, 0, 0);
			}
	
			try {
				var imgData = ctx.getImageData(0, 0, map.width, map.height);
			} catch (e) {
				//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
				return false;
			}
			
			this._mapData = imgData.data;
			return true;
		};
	
	
		createjs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");
	}());
	
	//##############################################################################
	// AlphaMaskFilter.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function () {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will
		 * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to
		 * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32
		 * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.
		 *
		 * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>
		 *
		 * <h4>Example</h4>
		 * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.
		 *
		 *      var box = new createjs.Shape();
		 *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)
		 *      box.graphics.drawRect(0, 0, 100, 100);
		 *      box.cache(0, 0, 100, 100);
		 *
		 *      var bmp = new createjs.Bitmap("path/to/image.jpg");
		 *      bmp.filters = [
		 *          new createjs.AlphaMaskFilter(box.cacheCanvas)
		 *      ];
		 *      bmp.cache(0, 0, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
		 * @class AlphaMaskFilter
		 * @extends Filter
		 * @constructor
		 * @param {HTMLImageElement|HTMLCanvasElement} mask
		 **/
		function AlphaMaskFilter(mask) {
			this.Filter_constructor();
		
		// public properties:
			/**
			 * The image (or canvas) to use as the mask.
			 * @property mask
			 * @type HTMLImageElement|HTMLCanvasElement
			 **/
			this.mask = mask;
	
			/** docced in super class **/
			this.usesContext = true;
	
			this.FRAG_SHADER_BODY = (
				"uniform sampler2D uAlphaSampler;"+
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
					"vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);" +
	
					"gl_FragColor = vec4(color.rgb, color.a * alphaMap.a);" +
				"}"
			);
		}
		var p = createjs.extend(AlphaMaskFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			if(!this._mapTexture) { this._mapTexture = gl.createTexture(); }
	
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this._mapTexture);
			stage.setTextureParams(gl);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.mask);
	
			gl.uniform1i(
				gl.getUniformLocation(shaderProgram, "uAlphaSampler"),
				1
			);
		};
	
	// public methods:
		/**
		 * Applies the filter to the specified context.
		 *
		 * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters
		 * correctly.</strong>
		 * @method applyFilter
		 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
		 * @param {Number} x The x position to use for the source rect.
		 * @param {Number} y The y position to use for the source rect.
		 * @param {Number} width The width to use for the source rect.
		 * @param {Number} height The height to use for the source rect.
		 * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.
		 * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.
		 * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.
		 * @return {Boolean} If the filter was applied successfully.
		 **/
		p.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {
			if (!this.mask) { return true; }
			targetCtx = targetCtx || ctx;
			if (targetX == null) { targetX = x; }
			if (targetY == null) { targetY = y; }
	
			targetCtx.save();
			if (ctx != targetCtx) {
				// TODO: support targetCtx and targetX/Y
				// clearRect, then draw the ctx in?
				return false;
			}
	
			targetCtx.globalCompositeOperation = "destination-in";
			targetCtx.drawImage(this.mask, targetX, targetY);
			targetCtx.restore();
			return true;
		};
	
		/** docced in super class **/
		p.clone = function () {
			return new AlphaMaskFilter(this.mask);
		};
	
		/** docced in super class **/
		p.toString = function () {
			return "[AlphaMaskFilter]";
		};
	
	
		createjs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");
	}());
	
	//##############################################################################
	// ColorFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Applies a color transform to DisplayObjects.
		 *
		 * <h4>Example</h4>
		 * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels
		 * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      shape.filters = [
		 *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)
		 *      ];
		 *      shape.cache(-50, -50, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class ColorFilter
		 * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.
		 * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.
		 * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.
		 * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.
		 * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range
		 * between -255 and 255.
		 * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range
		  * between -255 and 255.
		 * @constructor
		 * @extends Filter
		 **/
		function ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
			this.Filter_constructor();
	
		// public properties:
			/**
			 * Red channel multiplier.
			 * @property redMultiplier
			 * @type Number
			 **/
			this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
		
			/**
			 * Green channel multiplier.
			 * @property greenMultiplier
			 * @type Number
			 **/
			this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
		
			/**
			 * Blue channel multiplier.
			 * @property blueMultiplier
			 * @type Number
			 **/
			this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
		
			/**
			 * Alpha channel multiplier.
			 * @property alphaMultiplier
			 * @type Number
			 **/
			this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
		
			/**
			 * Red channel offset (added to value).
			 * @property redOffset
			 * @type Number
			 **/
			this.redOffset = redOffset || 0;
		
			/**
			 * Green channel offset (added to value).
			 * @property greenOffset
			 * @type Number
			 **/
			this.greenOffset = greenOffset || 0;
		
			/**
			 * Blue channel offset (added to value).
			 * @property blueOffset
			 * @type Number
			 **/
			this.blueOffset = blueOffset || 0;
		
			/**
			 * Alpha channel offset (added to value).
			 * @property alphaOffset
			 * @type Number
			 **/
			this.alphaOffset = alphaOffset || 0;
	
			this.FRAG_SHADER_BODY = (
				"uniform vec4 uColorMultiplier;" +
				"uniform vec4 uColorOffset;" +
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
	
					"gl_FragColor = (color * uColorMultiplier) + uColorOffset;" +
				"}"
			);
	
		}
		var p = createjs.extend(ColorFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
	// public methods:
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorMultiplier"),
				this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier
			);
	
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorOffset"),
				this.redOffset/255, this.greenOffset/255, this.blueOffset/255, this.alphaOffset/255
			);
		};
	
		/** docced in super class **/
		p.toString = function() {
			return "[ColorFilter]";
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new ColorFilter(
				this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier,
				this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset
			);
		};
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function(imageData) {
			var data = imageData.data;
			var l = data.length;
			for (var i=0; i<l; i+=4) {
				data[i] = data[i]*this.redMultiplier+this.redOffset;
				data[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;
				data[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;
				data[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;
			}
			return true;
		};
	
	
		createjs.ColorFilter = createjs.promote(ColorFilter, "Filter");
	}());
	
	//##############################################################################
	// ColorMatrix.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.
		 * Most methods return the instance to facilitate chained calls.
		 *
		 * <h4>Example</h4>
		 *
		 *      myColorMatrix.adjustHue(20).adjustBrightness(50);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}
		 * for an example of how to use ColorMatrix to change a DisplayObject's color.
		 * @class ColorMatrix
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @constructor
		 **/
		function ColorMatrix(brightness, contrast, saturation, hue) {
			this.setColor(brightness, contrast, saturation, hue);
		}
		var p = ColorMatrix.prototype;
	
	// constants:
		/**
		 * Array of delta values for contrast calculations.
		 * @property DELTA_INDEX
		 * @type Array
		 * @protected
		 * @static
		 **/
		ColorMatrix.DELTA_INDEX = [
			0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,
			0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
			0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
			0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
			0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
			1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
			1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,
			2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,
			4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,
			7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,
			10.0
		];
	
		/**
		 * Identity matrix values.
		 * @property IDENTITY_MATRIX
		 * @type Array
		 * @protected
		 * @static
		 **/
		ColorMatrix.IDENTITY_MATRIX = [
			1,0,0,0,0,
			0,1,0,0,0,
			0,0,1,0,0,
			0,0,0,1,0,
			0,0,0,0,1
		];
	
		/**
		 * The constant length of a color matrix.
		 * @property LENGTH
		 * @type Number
		 * @protected
		 * @static
		 **/
		ColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;
	
	
	// public methods:
		/**
		 * Resets the instance with the specified values.
		 * @method setColor
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 */
		p.setColor = function(brightness,contrast,saturation,hue) {
			return this.reset().adjustColor(brightness,contrast,saturation,hue);
		};
	
		/**
		 * Resets the matrix to identity values.
		 * @method reset
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 */
		p.reset = function() {
			return this.copy(ColorMatrix.IDENTITY_MATRIX);
		};
	
		/**
		 * Shortcut method to adjust brightness, contrast, saturation and hue.
		 * Equivalent to calling adjustHue(hue), adjustContrast(contrast),
		 * adjustBrightness(brightness), adjustSaturation(saturation), in that order.
		 * @method adjustColor
		 * @param {Number} brightness
		 * @param {Number} contrast
		 * @param {Number} saturation
		 * @param {Number} hue
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustColor = function(brightness,contrast,saturation,hue) {
			this.adjustHue(hue);
			this.adjustContrast(contrast);
			this.adjustBrightness(brightness);
			return this.adjustSaturation(saturation);
		};
	
		/**
		 * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.
		 * Positive values will make the image brighter, negative values will make it darker.
		 * @method adjustBrightness
		 * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustBrightness = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,255);
			this._multiplyMatrix([
				1,0,0,0,value,
				0,1,0,0,value,
				0,0,1,0,value,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Adjusts the contrast of pixel color.
		 * Positive values will increase contrast, negative values will decrease contrast.
		 * @method adjustContrast
		 * @param {Number} value A value between -100 & 100.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustContrast = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,100);
			var x;
			if (value<0) {
				x = 127+value/100*127;
			} else {
				x = value%1;
				if (x == 0) {
					x = ColorMatrix.DELTA_INDEX[value];
				} else {
					x = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.
				}
				x = x*127+127;
			}
			this._multiplyMatrix([
				x/127,0,0,0,0.5*(127-x),
				0,x/127,0,0,0.5*(127-x),
				0,0,x/127,0,0.5*(127-x),
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Adjusts the color saturation of the pixel.
		 * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).
		 * @method adjustSaturation
		 * @param {Number} value A value between -100 & 100.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustSaturation = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,100);
			var x = 1+((value > 0) ? 3*value/100 : value/100);
			var lumR = 0.3086;
			var lumG = 0.6094;
			var lumB = 0.0820;
			this._multiplyMatrix([
				lumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,
				lumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,
				lumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
	
		/**
		 * Adjusts the hue of the pixel color.
		 * @method adjustHue
		 * @param {Number} value A value between -180 & 180.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.adjustHue = function(value) {
			if (value == 0 || isNaN(value)) { return this; }
			value = this._cleanValue(value,180)/180*Math.PI;
			var cosVal = Math.cos(value);
			var sinVal = Math.sin(value);
			var lumR = 0.213;
			var lumG = 0.715;
			var lumB = 0.072;
			this._multiplyMatrix([
				lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
				lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
				lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
				0,0,0,1,0,
				0,0,0,0,1
			]);
			return this;
		};
	
		/**
		 * Concatenates (multiplies) the specified matrix with this one.
		 * @method concat
		 * @param {Array} matrix An array or ColorMatrix instance.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.concat = function(matrix) {
			matrix = this._fixMatrix(matrix);
			if (matrix.length != ColorMatrix.LENGTH) { return this; }
			this._multiplyMatrix(matrix);
			return this;
		};
	
		/**
		 * Returns a clone of this ColorMatrix.
		 * @method clone
		 * @return {ColorMatrix} A clone of this ColorMatrix.
		 **/
		p.clone = function() {
			return (new ColorMatrix()).copy(this);
		};
	
		/**
		 * Return a length 25 (5x5) array instance containing this matrix's values.
		 * @method toArray
		 * @return {Array} An array holding this matrix's values.
		 **/
		p.toArray = function() {
			var arr = [];
			for (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {
				arr[i] = this[i];
			}
			return arr;
		};
	
		/**
		 * Copy the specified matrix's values to this matrix.
		 * @method copy
		 * @param {Array} matrix An array or ColorMatrix instance.
		 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
		 * @chainable
		 **/
		p.copy = function(matrix) {
			var l = ColorMatrix.LENGTH;
			for (var i=0;i<l;i++) {
				this[i] = matrix[i];
			}
			return this;
		};
		
		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[ColorMatrix]";
		};
	
	
	// private methods:
		/**
		 * @method _multiplyMatrix
		 * @param {Array} matrix
		 * @protected
		 **/
		p._multiplyMatrix = function(matrix) {
			var i, j, k, col = [];
	
			for (i=0;i<5;i++) {
				for (j=0;j<5;j++) {
					col[j] = this[j+i*5];
				}
				for (j=0;j<5;j++) {
					var val=0;
					for (k=0;k<5;k++) {
						val += matrix[j+k*5]*col[k];
					}
					this[j+i*5] = val;
				}
			}
		};
	
		/**
		 * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.
		 * @method _cleanValue
		 * @param {Number} value The raw number
		 * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.
		 * @protected
		 **/
		p._cleanValue = function(value, limit) {
			return Math.min(limit,Math.max(-limit,value));
		};
	
		/**
		 * Makes sure matrixes are 5x5 (25 long).
		 * @method _fixMatrix
		 * @param {Array} matrix
		 * @protected
		 **/
		p._fixMatrix = function(matrix) {
			if (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }
			if (matrix.length < ColorMatrix.LENGTH) {
				matrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));
			} else if (matrix.length > ColorMatrix.LENGTH) {
				matrix = matrix.slice(0,ColorMatrix.LENGTH);
			}
			return matrix;
		};
	
	
		createjs.ColorMatrix = ColorMatrix;
	}());
	
	//##############################################################################
	// ColorMatrixFilter.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
		 * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the
		 * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,
		 * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.
		 *
		 * <h4>Example</h4>
		 * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.
		 *
		 *      var shape = new createjs.Shape().set({x:100,y:100});
		 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
		 *
		 *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);
		 *      shape.filters = [
		 *          new createjs.ColorMatrixFilter(matrix)
		 *      ];
		 *
		 *      shape.cache(-50, -50, 100, 100);
		 *
		 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
		 * @class ColorMatrixFilter
		 * @constructor
		 * @extends Filter
		 * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
		 * class.
		 **/
		function ColorMatrixFilter(matrix) {
			this.Filter_constructor();
	
		// public properties:
			/**
			 * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
			 * @property matrix
			 * @type Array | ColorMatrix
			 **/
			this.matrix = matrix;
	
			this.FRAG_SHADER_BODY = (
				"uniform mat4 uColorMatrix;" +
				"uniform vec4 uColorMatrixOffset;" +
	
				"void main(void) {" +
					"vec4 color = texture2D(uSampler, vRenderCoord);" +
	
					"mat4 m = uColorMatrix;" +
					"vec4 newColor = vec4(0,0,0,0);" +
					"newColor.r = color.r*m[0][0] + color.g*m[0][1] + color.b*m[0][2] + color.a*m[0][3];" +
					"newColor.g = color.r*m[1][0] + color.g*m[1][1] + color.b*m[1][2] + color.a*m[1][3];" +
					"newColor.b = color.r*m[2][0] + color.g*m[2][1] + color.b*m[2][2] + color.a*m[2][3];" +
					"newColor.a = color.r*m[3][0] + color.g*m[3][1] + color.b*m[3][2] + color.a*m[3][3];" +
	
					"gl_FragColor = newColor + uColorMatrixOffset;" +
				"}"
			);
		}
		var p = createjs.extend(ColorMatrixFilter, createjs.Filter);
	
		// TODO: deprecated
		// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
		/** docced in super class **/
		p.shaderParamSetup = function(gl, stage, shaderProgram) {
			var mat = this.matrix;
			var colorMatrix = new Float32Array([
				mat[0],mat[1],mat[2],mat[3],
				mat[5],mat[6],mat[7],mat[8],
				mat[10],mat[11],mat[12],mat[13],
				mat[15],mat[16],mat[17],mat[18]
			]);
	
			gl.uniformMatrix4fv(
				gl.getUniformLocation(shaderProgram, "uColorMatrix"),
				false, colorMatrix
			);
			gl.uniform4f(
				gl.getUniformLocation(shaderProgram, "uColorMatrixOffset"),
				mat[4]/255, mat[9]/255, mat[14]/255, mat[19]/255
			);
		};
	
	// public methods:
		/** docced in super class **/
		p.toString = function() {
			return "[ColorMatrixFilter]";
		};
	
		/** docced in super class **/
		p.clone = function() {
			return new ColorMatrixFilter(this.matrix);
		};
	
	// private methods:
		/** docced in super class **/
		p._applyFilter = function(imageData) { 
			var data = imageData.data;
			var l = data.length;
			var r,g,b,a;
			var mtx = this.matrix;
			var m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];
			var m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];
			var m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];
			var m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];
	
			for (var i=0; i<l; i+=4) {
				r = data[i];
				g = data[i+1];
				b = data[i+2];
				a = data[i+3];
				data[i] = r*m0+g*m1+b*m2+a*m3+m4; // red
				data[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green
				data[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue
				data[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha
			}
			return true;
		};
	
		createjs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");
	}());
	
	//##############################################################################
	// Touch.js
	//##############################################################################
	
	this.createjs = this.createjs||{};
	
	(function() {
		"use strict";
	
	
	// constructor:
		/**
	 * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and
	 * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.
	 *
	 * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have
	 * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.
	 *
	 * <h4>Example</h4>
	 *
	 *      var stage = new createjs.Stage("canvasId");
	 *      createjs.Touch.enable(stage);
	 *
	 * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:
	 *
	 *      createjs.Touch.disable(stage);
	 *
	 * @class Touch
	 * @static
	 **/
		function Touch() {
			throw "Touch cannot be instantiated";
		}
	
	
	// public static methods:
		/**
		 * Returns `true` if touch is supported in the current browser.
		 * @method isSupported
		 * @return {Boolean} Indicates whether touch is supported in the current browser.
		 * @static
		 **/
		Touch.isSupported = function() {
			return	!!(('ontouchstart' in window) // iOS & Android
				|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10
				|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+
		};
	
		/**
		 * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS
		 * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and
		 * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for
		 * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}
		 * for more information.
		 * @method enable
		 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.
		 * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.
		 * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be
		 * allowed when the user is interacting with the target canvas.
		 * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.
		 * @static
		 **/
		Touch.enable = function(stage, singleTouch, allowDefault) {
			if (!stage || !stage.canvas || !Touch.isSupported()) { return false; }
			if (stage.__touch) { return true; }
	
			// inject required properties on stage:
			stage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};
	
			// note that in the future we may need to disable the standard mouse event model before adding
			// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.
			if ('ontouchstart' in window) { Touch._IOS_enable(stage); }
			else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }
			return true;
		};
	
		/**
		 * Removes all listeners that were set up when calling `Touch.enable()` on a stage.
		 * @method disable
		 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.
		 * @static
		 **/
		Touch.disable = function(stage) {
			if (!stage) { return; }
			if ('ontouchstart' in window) { Touch._IOS_disable(stage); }
			else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }
			
			delete stage.__touch;
		};
	
	
	// Private static methods:
		/**
		 * @method _IOS_enable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IOS_enable = function(stage) {
			var canvas = stage.canvas;
			var f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };
			canvas.addEventListener("touchstart", f, false);
			canvas.addEventListener("touchmove", f, false);
			canvas.addEventListener("touchend", f, false);
			canvas.addEventListener("touchcancel", f, false);
		};
	
		/**
		 * @method _IOS_disable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IOS_disable = function(stage) {
			var canvas = stage.canvas;
			if (!canvas) { return; }
			var f = stage.__touch.f;
			canvas.removeEventListener("touchstart", f, false);
			canvas.removeEventListener("touchmove", f, false);
			canvas.removeEventListener("touchend", f, false);
			canvas.removeEventListener("touchcancel", f, false);
		};
	
		/**
		 * @method _IOS_handleEvent
		 * @param {Stage} stage
		 * @param {Object} e The event to handle
		 * @protected
		 * @static
		 **/
		Touch._IOS_handleEvent = function(stage, e) {
			if (!stage) { return; }
			if (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }
			var touches = e.changedTouches;
			var type = e.type;
			for (var i= 0,l=touches.length; i<l; i++) {
				var touch = touches[i];
				var id = touch.identifier;
				if (touch.target != stage.canvas) { continue; }
	
				if (type == "touchstart") {
					this._handleStart(stage, id, e, touch.pageX, touch.pageY);
				} else if (type == "touchmove") {
					this._handleMove(stage, id, e, touch.pageX, touch.pageY);
				} else if (type == "touchend" || type == "touchcancel") {
					this._handleEnd(stage, id, e);
				}
			}
		};
	
		/**
		 * @method _IE_enable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IE_enable = function(stage) {
			var canvas = stage.canvas;
			var f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };
	
			if (window.navigator["pointerEnabled"] === undefined) {
				canvas.addEventListener("MSPointerDown", f, false);
				window.addEventListener("MSPointerMove", f, false);
				window.addEventListener("MSPointerUp", f, false);
				window.addEventListener("MSPointerCancel", f, false);
				if (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }
			} else {
				canvas.addEventListener("pointerdown", f, false);
				window.addEventListener("pointermove", f, false);
				window.addEventListener("pointerup", f, false);
				window.addEventListener("pointercancel", f, false);
				if (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }
	
			}
			stage.__touch.activeIDs = {};
		};
	
		/**
		 * @method _IE_disable
		 * @protected
		 * @param {Stage} stage
		 * @static
		 **/
		Touch._IE_disable = function(stage) {
			var f = stage.__touch.f;
	
			if (window.navigator["pointerEnabled"] === undefined) {
				window.removeEventListener("MSPointerMove", f, false);
				window.removeEventListener("MSPointerUp", f, false);
				window.removeEventListener("MSPointerCancel", f, false);
				if (stage.canvas) {
					stage.canvas.removeEventListener("MSPointerDown", f, false);
				}
			} else {
				window.removeEventListener("pointermove", f, false);
				window.removeEventListener("pointerup", f, false);
				window.removeEventListener("pointercancel", f, false);
				if (stage.canvas) {
					stage.canvas.removeEventListener("pointerdown", f, false);
				}
			}
		};
	
		/**
		 * @method _IE_handleEvent
		 * @param {Stage} stage
		 * @param {Object} e The event to handle.
		 * @protected
		 * @static
		 **/
		Touch._IE_handleEvent = function(stage, e) {
			if (!stage) { return; }
			if (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }
			var type = e.type;
			var id = e.pointerId;
			var ids = stage.__touch.activeIDs;
	
			if (type == "MSPointerDown" || type == "pointerdown") {
				if (e.srcElement != stage.canvas) { return; }
				ids[id] = true;
				this._handleStart(stage, id, e, e.pageX, e.pageY);
			} else if (ids[id]) { // it's an id we're watching
				if (type == "MSPointerMove" || type == "pointermove") {
					this._handleMove(stage, id, e, e.pageX, e.pageY);
				} else if (type == "MSPointerUp" || type == "MSPointerCancel"
						|| type == "pointerup" || type == "pointercancel") {
					delete(ids[id]);
					this._handleEnd(stage, id, e);
				}
			}
		};
	
		/**
		 * @method _handleStart
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 **/
		Touch._handleStart = function(stage, id, e, x, y) {
			var props = stage.__touch;
			if (!props.multitouch && props.count) { return; }
			var ids = props.pointers;
			if (ids[id]) { return; }
			ids[id] = true;
			props.count++;
			stage._handlePointerDown(id, e, x, y);
		};
	
		/**
		 * @method _handleMove
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @param {Number} x
		 * @param {Number} y
		 * @protected
		 **/
		Touch._handleMove = function(stage, id, e, x, y) {
			if (!stage.__touch.pointers[id]) { return; }
			stage._handlePointerMove(id, e, x, y);
		};
	
		/**
		 * @method _handleEnd
		 * @param {Stage} stage
		 * @param {String|Number} id
		 * @param {Object} e
		 * @protected
		 **/
		Touch._handleEnd = function(stage, id, e) {
			// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).
			var props = stage.__touch;
			var ids = props.pointers;
			if (!ids[id]) { return; }
			props.count--;
			stage._handlePointerUp(id, e, true);
			delete(ids[id]);
		};
	
	
		createjs.Touch = Touch;
	}());
	
	//##############################################################################
	// version.js
	//##############################################################################
	
	this.createjs = this.createjs || {};
	
	(function() {
		"use strict";
	
		/**
		 * Static class holding library specific information such as the version and buildDate of
		 * the library.
		 * @class EaselJS
		 **/
		var s = createjs.EaselJS = createjs.EaselJS || {};
	
		/**
		 * The version string for this release.
		 * @property version
		 * @type String
		 * @static
		 **/
		s.version = /*=version*/"NEXT"; // injected by build process
	
		/**
		 * The build date for this release in UTC format.
		 * @property buildDate
		 * @type String
		 * @static
		 **/
		s.buildDate = /*=date*/"Tue, 04 Jul 2017 15:42:51 GMT"; // injected by build process
	
	})();
	
	module.exports = createjs;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.graphics = graphics;
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Circle = _flattenJs2.default.Circle,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon,
	    Box = _flattenJs2.default.Box;
	
	/* Provide conversion methods from FlattenJS objects to CreateJS Graphics */
	
	function graphics(shape) {
	    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	    if (shape instanceof Point) {
	        return graphics_point(shape, style);
	    }
	    if (shape instanceof Segment) {
	        return graphics_segment(shape, style);
	    }
	    if (shape instanceof Arc) {
	        return graphics_arc(shape, style);
	    }
	    if (shape instanceof Circle) {
	        return graphics_circle(shape, style);
	    }
	    if (shape instanceof Box) {
	        return graphics_box(shape, style);
	    }
	    if (shape instanceof Polygon) {
	        return graphics_polygon(shape, style);
	    }
	    return null;
	}
	
	// Point.prototype.graphics = function(style) {
	function graphics_point(point, style) {
	    var radius = style && style.radius ? style.radius : 3;
	    var fill = style && style.fill ? style.fill : "#FF0303";
	    var graphics = new createjs.Graphics();
	    graphics.fill = graphics.beginFill(fill).command;
	    graphics.circle = graphics.drawCircle(point.x, point.y, radius).command;
	    return graphics;
	};
	
	// Segment.prototype.graphics = function(style) {
	function graphics_segment(segment, style) {
	    var graphics = new createjs.Graphics();
	    var strokeStyle = style && style.strokeStyle !== undefined ? style.strokeStyle : 2;
	    var ignoreScale = style && style.ignoreScale !== undefined ? style.ignoreScale : true;
	    var stroke = style && style.stroke ? style.stroke : "black";
	    return graphics.setStrokeStyle(strokeStyle, 1, 0, 10, ignoreScale).beginStroke(stroke).moveTo(segment.ps.x, segment.ps.y).lineTo(segment.pe.x, segment.pe.y).endStroke();
	};
	
	// Arc.prototype.graphics = function(style) {
	function graphics_arc(arc, style) {
	    // let startAngle = 2 * Math.PI - this.startAngle;
	    // let endAngle =  2 * Math.PI - this.endAngle;
	    var graphics = new createjs.Graphics();
	    var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 2;
	    var ignoreScale = style && style.ignoreScale !== undefined ? style.ignoreScale : true;
	    var stroke = style && style.stroke ? style.stroke : "black";
	    return graphics.setStrokeStyle(strokeStyle, 1, 0, 10, ignoreScale).beginStroke(stroke).arc(arc.pc.x, arc.pc.y, arc.r, arc.startAngle, arc.endAngle, !arc.counterClockwise).endStroke();
	};
	
	// Circle.prototype.graphics = function(style) {
	function graphics_circle(circle, style) {
	    var graphics = new createjs.Graphics();
	    var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 2;
	    var stroke = style && style.stroke ? style.stroke : "black";
	    // graphics.setStrokeStyle(2).beginStroke("black").beginFill("red").drawCircle(pcx, pcy, r);
	    return graphics.setStrokeStyle(strokeStyle, 0, 0, 10, true).beginStroke(stroke).drawCircle(circle.pc.x, circle.pc.y, circle.r).endStroke();
	};
	
	// Box.prototype.graphics = function(style) {
	function graphics_box(box, style) {
	    var graphics = new createjs.Graphics();
	    var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 1;
	    var stroke = style && style.stroke ? style.stroke : "black";
	    // graphics.setStrokeStyle(2).beginStroke("black").beginFill("red").drawCircle(pcx, pcy, r);
	    return graphics.setStrokeStyle(strokeStyle, 0, 0, 10, true).beginStroke(stroke).drawRect(box.xmin, box.ymin, box.xmax - box.xmin, box.ymax - box.ymin);
	};
	
	function setGraphicsEdgeSegment(graphics, segment) {
	    graphics.lineTo(segment.pe.x, segment.pe.y);
	}
	
	function setGraphicsEdgeArc(graphics, arc) {
	    // let startAngle = 2 * Math.PI - arc.startAngle;
	    // let endAngle = 2 * Math.PI - arc.endAngle;
	    graphics.arc(arc.pc.x, arc.pc.y, arc.r, arc.startAngle, arc.endAngle, !arc.counterClockwise);
	}
	
	function setGraphicsEdge(graphics, edge) {
	    if (edge.shape instanceof Segment) {
	        setGraphicsEdgeSegment(graphics, edge.shape);
	    } else if (edge.shape instanceof Arc) {
	        setGraphicsEdgeArc(graphics, edge.shape);
	    }
	}
	
	function setGraphicsFace(graphics, face) {
	    var ps = face.first.start;
	    graphics.moveTo(ps.x, ps.y);
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = face[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var edge = _step.value;
	
	            setGraphicsEdge(graphics, edge);
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	}
	
	// Polygon.prototype.graphics = function(style) {
	function graphics_polygon(polygon, style) {
	    var graphics = new createjs.Graphics();
	    var strokeStyle = style && style.strokeStyle ? style.strokeStyle : 1;
	    var stroke = style && style.stroke ? style.stroke : "#FF0303";
	    var fill = style && style.fill ? style.fill : "#FF0303";
	    graphics.setStrokeStyle(strokeStyle, 0, 0, 10, true);
	    graphics.stroke = graphics.beginStroke(stroke).command;
	    graphics.fill = graphics.beginFill(fill).command;
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = polygon.faces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var face = _step2.value;
	
	            setGraphicsFace(graphics, face);
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    graphics.endStroke();
	    return graphics;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Job = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Box = _flattenJs2.default.Box;
	
	var Job = exports.Job = function () {
	    function Job() {
	        _classCallCheck(this, Job);
	
	        this.filename = "";
	        this.title = "";
	        this.profiles = []; // array of FlattenJS Polygons
	        this.materials = []; // array of FlattenJS Polygons
	        this.shapes = []; // array of other FlattenJS shapes
	    }
	
	    _createClass(Job, [{
	        key: "box",
	        get: function get() {
	            var b = new Box();
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = this.profiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var shape = _step.value;
	
	                    b.merge(shape.box);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.materials[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var _shape = _step2.value;
	
	                    b.merge(_shape.box);
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = this.shapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var _shape2 = _step3.value;
	
	                    b.merge(_shape2.box);
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            return b;
	        }
	    }]);

	    return Job;
	}();

/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Utils = {
	    is_equal: function is_equal(obj1, obj2) {
	        var equal = true;
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = Object.keys(obj2)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var key = _step.value;
	
	                if (obj2[key] !== obj1[key]) {
	                    equal = false;
	                    break;
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        return equal;
	    }
	};
	
	exports.default = Utils;

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var defaultStyle = {
	    strokeStyle: 1,
	    stroke: "#FF0303",
	    fill: "#FF0303",
	    alpha: 1.0
	};
	
	/* Class Model represents data model that will be added to layer */
	
	var Model = exports.Model = function () {
	    function Model() {
	        var geom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	        var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	        var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
	
	        _classCallCheck(this, Model);
	
	        this.geom = geom;
	        this.style = style || defaultStyle;
	        this.label = label;
	    }
	
	    _createClass(Model, [{
	        key: "clone",
	        value: function clone() {
	            var model = new Model(this.geom, this.style, this.label);
	            return Object.assign(model, this);
	        }
	    }, {
	        key: "box",
	        get: function get() {
	            return this.geom.box;
	        }
	        /*
	            static transformPoint(pt, stage) {
	                return new Flatten.Point(stage.W2C_X(pt.x), stage.W2C_Y(pt.y));
	            }
	        
	            static transformSegment(segment, stage) {
	                return new Flatten.Segment(
	                    Model.transformPoint(segment.ps, stage),
	                    Model.transformPoint(segment.pe, stage)
	                )
	            }
	        
	            static transformArc(arc, stage) {
	                return new Flatten.Arc(
	                    Model.transformPoint(arc.pc, stage),
	                    stage.W2C_Scalar(arc.r),
	                    arc.startAngle,
	                    arc.endAngle,
	                    arc.counterClockwise
	                )
	            }
	        
	            static transformEdge(shape, stage) {
	                if (shape instanceof Flatten.Segment) {
	                    return Model.transformSegment(shape, stage);
	                }
	                else if (shape instanceof Flatten.Arc) {
	                    return Model.transformArc(shape, stage);
	                }
	            }
	        
	            static transformFace(face, stage) {
	                // Get shapes of face as array
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape);
	                }
	        
	                // Transform array of edges
	                return shapes.map(shape => Model.transformEdge(shape, stage));
	            }
	        
	            static transformPolygon(polygon, stage) {
	                let newPolygon = new Flatten.Polygon();
	                let shapes = [];
	                for (let face of polygon.faces) {
	                    shapes = Model.transformFace(face, stage);
	                    newPolygon.addFace(shapes);
	                }
	                return newPolygon;
	            }
	        */

	    }]);

	    return Model;
	}();

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (false) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 3/31/2017.
	 */
	'use strict';
	
	let Node = __webpack_require__(80);
	let {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = __webpack_require__(19);
	
	let nil_node = new Node();
	
	/**
	 * Implementation of interval binary search tree <br/>
	 * Interval tree may store items which are couples of {key:interval, value: value} <br/>
	 * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />
	 * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,
	 * see documentation {link}
	 * @type {IntervalTree}
	 */
	let IntervalTree = class IntervalTree {
	    /**
	     * Construct new empty instance of IntervalTree
	     */
	    constructor() {
	        this.root = null;
	    }
	
	    /**
	     * Returns number of items stored in the interval tree
	     * @returns {number}
	     */
	    get size() {
	        let count = 0;
	        this.tree_walk(this.root, () => count++);
	        return count;
	    }
	
	    get keys() {
	        let res = [];
	        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));
	        return res;
	    }
	
	    get isEmpty() {
	        return (this.root == null || this.root == nil_node);
	    }
	
	    /**
	     * Insert new item into interval tree
	     * @param key - interval object or array of two numbers [low, high]
	     * @param value - value representing any object (optional)
	     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}
	     */
	    insert(key, value = key) {
	        if (key === undefined) return;
	        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);
	        this.tree_insert(insert_node);
	        this.recalc_max(insert_node);
	        return insert_node;
	    }
	
	    /**
	     * Returns true if item {key,value} exist in the tree
	     * @param key - interval correspondent to keys stored in the tree
	     * @param value - value object to be checked
	     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise
	     */
	    exist(key, value) {
	        let search_node = new Node(key, value);
	        return this.tree_search(this.root, search_node) ? true : false;
	    }
	
	    /**
	     * Remove entry {key, value} from the tree
	     * @param key - interval correspondent to keys stored in the tree
	     * @param value - - value object
	     * @returns {boolean} - true if item {key, value} deleted, false if not found
	     */
	    remove(key, value) {
	        let search_node = new Node(key, value);
	        let delete_node = this.tree_search(this.root, search_node);
	        if (delete_node) {
	            this.tree_delete(delete_node);
	        }
	        return delete_node;
	    }
	
	    /**
	     * Returns array of entry values which keys intersect with given interval <br/>
	     * If no values stored in the tree, returns array of keys which intersect given interval
	     * @param interval - search interval, or array [low, high]
	     * @returns {Array}
	     */
	    search(interval) {
	        let search_node = new Node(interval);
	        let resp_nodes = [];
	        this.tree_search_interval(this.root, search_node, resp_nodes);
	        let resp = [];
	        resp_nodes.forEach((node) => {
	            if (node.item.value) {         // if there are values, return only values
	                resp.push(node.item.value);
	            }
	            else {                         // otherwise, return keys
	                resp.push(node.item.key.output());
	            }
	        }, []);
	        return resp;
	    }
	
	    /**
	     * Tree visitor. For each node implement a callback function. <br/>
	     * Method calls a callback function with two parameters (key, value)
	     * @param visitor(key,value) - function to be called for each tree item
	     */
	    forEach(visitor) {
	        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
	    };
	
	    recalc_max(node) {
	        let node_current = node;
	        while (node_current.parent != null) {
	            node_current.parent.update_max();
	            node_current = node_current.parent;
	        }
	    }
	
	    tree_insert(insert_node) {
	        let current_node = this.root;
	        let parent_node = null;
	
	        if (this.root == null || this.root == nil_node) {
	            this.root = insert_node;
	        }
	        else {
	            while (current_node != nil_node) {
	                parent_node = current_node;
	                if (insert_node.less_than(current_node)) {
	                    current_node = current_node.left;
	                }
	                else {
	                    current_node = current_node.right;
	                }
	            }
	
	            insert_node.parent = parent_node;
	
	            if (insert_node.less_than(parent_node)) {
	                parent_node.left = insert_node;
	            }
	            else {
	                parent_node.right = insert_node;
	            }
	        }
	
	        this.insert_fixup(insert_node);
	    }
	
	// After insertion insert_node may have red-colored parent, and this is a single possible violation
	// Go upwords to the root and re-color until violation will be resolved
	    insert_fixup(insert_node) {
	        let current_node;
	        let uncle_node;
	
	        current_node = insert_node;
	        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {
	            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather
	                uncle_node = current_node.parent.parent.right;              // right brother of parent
	                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red
	                    // re-color father and uncle into black
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    uncle_node.color = RB_TREE_COLOR_BLACK;
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    current_node = current_node.parent.parent;
	                }
	                else {                                                    // Case 2 & 3. Uncle is black
	                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child
	                        // This case is transformed into Case 3.
	                        current_node = current_node.parent;
	                        this.rotate_left(current_node);
	                    }
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.
	                    // Re-color father and grandfather, rotate grandfather right
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    this.rotate_right(current_node.parent.parent);
	                }
	            }
	            else {                                                         // parent is right child of grandfather
	                uncle_node = current_node.parent.parent.left;              // left brother of parent
	                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red
	                    // re-color father and uncle into black
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    uncle_node.color = RB_TREE_COLOR_BLACK;
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    current_node = current_node.parent.parent;
	                }
	                else {
	                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child
	                        // Transform into case 6
	                        current_node = current_node.parent;
	                        this.rotate_right(current_node);
	                    }
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.
	                    // Re-color father and grandfather, rotate grandfather left
	                    current_node.parent.parent.color = RB_TREE_COLOR_RED;
	                    this.rotate_left(current_node.parent.parent);
	                }
	            }
	        }
	
	        this.root.color = RB_TREE_COLOR_BLACK;
	    }
	
	    tree_delete(delete_node) {
	        let cut_node;   // node to be cut - either delete_node or successor_node  ("y" from 14.4)
	        let fix_node;   // node to fix rb tree property   ("x" from 14.4)
	
	        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children
	            cut_node = delete_node;
	        }
	        else {                                                    // delete_node has 2 children
	            cut_node = this.tree_successor(delete_node);
	        }
	
	        // fix_node if single child of cut_node
	        if (cut_node.left != nil_node) {
	            fix_node = cut_node.left;
	        }
	        else {
	            fix_node = cut_node.right;
	        }
	
	        // remove cut_node from parent
	        /*if (fix_node != nil_node) {*/
	            fix_node.parent = cut_node.parent;
	        /*}*/
	
	        if (cut_node == this.root) {
	            this.root = fix_node;
	        }
	        else {
	            if (cut_node == cut_node.parent.left) {
	                cut_node.parent.left = fix_node;
	            }
	            else {
	                cut_node.parent.right = fix_node;
	            }
	            cut_node.parent.update_max();        // update max property of the parent
	        }
	
	        this.recalc_max(fix_node);              // update max property upward from fix_node to root
	
	        // COPY DATA !!!
	        // Delete_node becomes cut_node, it means that we cannot hold reference
	        // to node in outer structure and we will have to delete by key, additional search need
	        if (cut_node != delete_node) {
	            delete_node.copy_data(cut_node);
	            delete_node.update_max();           // update max property of the cut node at the new place
	            this.recalc_max(delete_node);       // update max property upward from delete_node to root
	        }
	
	        if (/*fix_node != nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {
	            this.delete_fixup(fix_node);
	        }
	    }
	
	    delete_fixup(fix_node) {
	        let current_node = fix_node;
	        let brother_node;
	
	        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {
	            if (current_node == current_node.parent.left) {          // fix node is left child
	                brother_node = current_node.parent.right;
	                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red
	                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother
	                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father
	                    this.rotate_left(current_node.parent);
	                    brother_node = current_node.parent.right;                      // update brother
	                }
	                // Derive to cases 2..4: brother is black
	                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&
	                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black
	                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother
	                    current_node = current_node.parent;                  // continue iteration
	                }
	                else {
	                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black
	                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother
	                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew
	                        this.rotate_right(brother_node);
	                        brother_node = current_node.parent.right;                     // update brother
	                        // Derive to case 4: left nephew black, right nephew red
	                    }
	                    // case 4: left nephew black, right nephew red
	                    brother_node.color = current_node.parent.color;
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    brother_node.right.color = RB_TREE_COLOR_BLACK;
	                    this.rotate_left(current_node.parent);
	                    current_node = this.root;                         // exit from loop
	                }
	            }
	            else {                                             // fix node is right child
	                brother_node = current_node.parent.left;
	                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red
	                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother
	                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father
	                    this.rotate_right(current_node.parent);
	                    brother_node = current_node.parent.left;                        // update brother
	                }
	                // Go to cases 2..4
	                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&
	                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2
	                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother
	                    current_node = current_node.parent;                              // continue iteration
	                }
	                else {
	                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black
	                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother
	                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew
	                        this.rotate_left(brother_node);
	                        brother_node = current_node.parent.left;                        // update brother
	                        // Derive to case 4: right nephew black, left nephew red
	                    }
	                    // case 4: right nephew black, left nephew red
	                    brother_node.color = current_node.parent.color;
	                    current_node.parent.color = RB_TREE_COLOR_BLACK;
	                    brother_node.left.color = RB_TREE_COLOR_BLACK;
	                    this.rotate_right(current_node.parent);
	                    current_node = this.root;                               // force exit from loop
	                }
	            }
	        }
	
	        current_node.color = RB_TREE_COLOR_BLACK;
	    }
	
	    tree_search(node, search_node) {
	        if (node == null || node == nil_node)
	            return undefined;
	
	        if (search_node.equal_to(node)) {
	            return node;
	        }
	        if (search_node.less_than(node)) {
	            return this.tree_search(node.left, search_node);
	        }
	        else {
	            return this.tree_search(node.right, search_node);
	        }
	    }
	
	    // Original search_interval method; container res support push() insertion
	    // Search all intervals intersecting given one
	    tree_search_interval(node, search_node, res) {
	        if (node != null && node != nil_node) {
	            // if (node->left != nil_node && node->left->max >= low) {
	            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {
	                this.tree_search_interval(node.left, search_node, res);
	            }
	            // if (low <= node->high && node->low <= high) {
	            if (node.intersect(search_node)) {
	                res.push(node);
	            }
	            // if (node->right != nil_node && node->low <= high) {
	            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {
	                this.tree_search_interval(node.right, search_node, res);
	            }
	        }
	    }
	
	    local_minimum(node) {
	        let node_min = node;
	        while (node_min.left != null && node_min.left != nil_node) {
	            node_min = node_min.left;
	        }
	        return node_min;
	    }
	
	    // not in use
	    local_maximum(node) {
	        let node_max = node;
	        while (node_max.right != null && node_max.right != nil_node) {
	            node_max = node_max.right;
	        }
	        return node_max;
	    }
	
	    tree_successor(node) {
	        let node_successor;
	        let current_node;
	        let parent_node;
	
	        if (node.right != nil_node) {
	            node_successor = this.local_minimum(node.right);
	        }
	        else {
	            current_node = node;
	            parent_node = node.parent;
	            while (parent_node != null && parent_node.right == current_node) {
	                current_node = parent_node;
	                parent_node = parent_node.parent;
	            }
	            node_successor = parent_node;
	        }
	        return node_successor;
	    }
	
	    //           |            right-rotate(T,y)       |
	    //           y            ---------------.       x
	    //          / \                                  / \
	    //         x   c          left-rotate(T,x)      a   y
	    //        / \             <---------------         / \
	    //       a   b                                    b   c
	
	    rotate_left(x) {
	        let y = x.right;
	
	        x.right = y.left;           // b goes to x.right
	
	        if (y.left != nil_node) {
	            y.left.parent = x;     // x becomes parent of b
	        }
	        y.parent = x.parent;       // move parent
	
	        if (x == this.root) {
	            this.root = y;           // y becomes root
	        }
	        else {                        // y becomes child of x.parent
	            if (x == x.parent.left) {
	                x.parent.left = y;
	            }
	            else {
	                x.parent.right = y;
	            }
	        }
	        y.left = x;                 // x becomes left child of y
	        x.parent = y;               // and y becomes parent of x
	
	        if (x != null && x != nil_node) {
	            x.update_max();
	        }
	
	        y = x.parent;
	        if (y != null && y != nil_node) {
	            y.update_max();
	        }
	    }
	
	    rotate_right(y) {
	        let x = y.left;
	
	        y.left = x.right;           // b goes to y.left
	
	        if (x.right != nil_node) {
	            x.right.parent = y;        // y becomes parent of b
	        }
	        x.parent = y.parent;          // move parent
	
	        if (y == this.root) {        // x becomes root
	            this.root = x;
	        }
	        else {                        // y becomes child of x.parent
	            if (y == y.parent.left) {
	                y.parent.left = x;
	            }
	            else {
	                y.parent.right = x;
	            }
	        }
	        x.right = y;                 // y becomes right child of x
	        y.parent = x;               // and x becomes parent of y
	
	        if (y != null && y != nil_node) {
	            y.update_max();
	        }
	
	        x = y.parent;
	        if (x != null && x != nil_node) {
	            x.update_max();
	        }
	    }
	
	    tree_walk(node, action) {
	        if (node != null && node != nil_node) {
	            this.tree_walk(node.left, action);
	            // arr.push(node.toArray());
	            action(node);
	            this.tree_walk(node.right, action);
	        }
	    }
	
	    /* Return true if all red nodes have exactly two black child nodes */
	    testRedBlackProperty() {
	        let res = true;
	        this.tree_walk(this.root, function (node) {
	            if (node.color == RB_TREE_COLOR_RED) {
	                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {
	                    res = false;
	                }
	            }
	        });
	        return res;
	    }
	
	    /* Throw error if not every path from root to bottom has same black height */
	    testBlackHeightProperty(node) {
	        let height = 0;
	        let heightLeft = 0;
	        let heightRight = 0;
	        if (node.color == RB_TREE_COLOR_BLACK) {
	            height++;
	        }
	        if (node.left != nil_node) {
	            heightLeft = this.testBlackHeightProperty(node.left);
	        }
	        else {
	            heightLeft = 1;
	        }
	        if (node.right != nil_node) {
	            heightRight = this.testBlackHeightProperty(node.right);
	        }
	        else {
	            heightRight = 1;
	        }
	        if (heightLeft != heightRight) {
	            throw new Error('Red-black height property violated');
	        }
	        height += heightLeft;
	        return height;
	    };
	};
	
	module.exports = IntervalTree;


/***/ },
/* 14 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Modal = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _reactDom = __webpack_require__(23);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var modalRoot = document.getElementById('modal-root');
	
	// A Modal component that is an abstraction around the portal API.
	
	var Modal = exports.Modal = function (_Component) {
	    _inherits(Modal, _Component);
	
	    function Modal(props) {
	        _classCallCheck(this, Modal);
	
	        // Create a div that we'll render the modal into. Because each
	        // Modal component has its own element, we can render multiple
	        // modal components into the modal container.
	        var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));
	
	        _this.el = document.createElement('div');
	        return _this;
	    }
	
	    _createClass(Modal, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            // Append the element into the DOM on mount. We'll render
	            // into the modal container element (see the HTML tab).
	            modalRoot.appendChild(this.el);
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            // Remove the element from the DOM when we unmount
	            modalRoot.removeChild(this.el);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            // Use a portal to render the children into the element
	            return _reactDom2.default.createPortal(
	            // Any valid React child: JSX, strings, arrays, etc.
	            this.props.children,
	            // A DOM element
	            this.el);
	        }
	    }]);

	    return Modal;
	}(_react.Component);

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Parser = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 01/05/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon;
	var vector = _flattenJs2.default.vector;
	
	/*
	let debug_str = `+		[0]	{nrec=27 nalloc=27 h_ind_id=-1 ...} mat_cont_hdr_struc	mat_cont_struc
	    +		[1]	{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc	mat_cont_struc
	+		[2]	{nedge=23 nalloc=25 ntop=2 ...} mat_cont_poly_struc	mat_cont_struc
	+		[3]	{pmin=59146400,5973200 pmax=59606001,6438000} mat_cont_lim_struc	mat_cont_struc
	+		[4]	{ps=59192738,6363124 pe=59216000,6372800 pc=59216000,6340000 cw=1} mat_curve_struc	mat_cont_struc
	+		[5]	{ps=59216000,6372800 pe=59267652,6372800} mat_seg_struc	mat_cont_struc
	+		[6]	{ps=59267652,6372800 pe=59267652,6307200 pc=59360000,6340000 cw=1} mat_curve_struc	mat_cont_struc
	+		[7]	{ps=59267652,6307200 pe=59229586,6307200} mat_seg_struc	mat_cont_struc
	+		[8]	{ps=59229586,6307200 pe=59212000,6289614} mat_seg_struc	mat_cont_struc
	+		[9]	{ps=59212000,6289614 pe=59212000,6056386} mat_seg_struc	mat_cont_struc
	+		[10]	{ps=59212000,6056386 pe=59229586,6038800} mat_seg_struc	mat_cont_struc
	+		[11]	{ps=59229586,6038800 pe=59469614,6038800} mat_seg_struc	mat_cont_struc
	+		[12]	{ps=59469614,6038800 pe=59487200,6056386} mat_seg_struc	mat_cont_struc
	+		[13]	{ps=59487200,6056386 pe=59487200,6100500} mat_seg_struc	mat_cont_struc
	+		[14]	{ps=59487200,6100500 pe=59434000,6180000 pc=59520000,6180000 cw=1} mat_curve_struc	mat_cont_struc
	+		[15]	{ps=59434000,6180000 pe=59552800,6100500 pc=59520000,6180000 cw=1} mat_curve_struc	mat_cont_struc
	+		[16]	{ps=59552800,6100500 pe=59552800,6042800} mat_seg_struc	mat_cont_struc
	+		[17]	{ps=59552800,6042800 pe=59543124,6019538 pc=59520000,6042800 cw=1} mat_curve_struc	mat_cont_struc
	+		[18]	{ps=59543124,6019538 pe=59506462,5982876} mat_seg_struc	mat_cont_struc
	+		[19]	{ps=59506462,5982876 pe=59483200,5973200 pc=59483200,6006000 cw=1} mat_curve_struc	mat_cont_struc
	+		[20]	{ps=59483200,5973200 pe=59216000,5973200} mat_seg_struc	mat_cont_struc
	+		[21]	{ps=59216000,5973200 pe=59192738,5982876 pc=59216000,6006000 cw=1} mat_curve_struc	mat_cont_struc
	+		[22]	{ps=59192738,5982876 pe=59156076,6019538} mat_seg_struc	mat_cont_struc
	+		[23]	{ps=59156076,6019538 pe=59146400,6042800 pc=59179200,6042800 cw=1} mat_curve_struc	mat_cont_struc
	+		[24]	{ps=59146400,6042800 pe=59146400,6303200} mat_seg_struc	mat_cont_struc
	+		[25]	{ps=59146400,6303200 pe=59156076,6326462 pc=59179200,6303200 cw=1} mat_curve_struc	mat_cont_struc
	+		[26]	{ps=59156076,6326462 pe=59192738,6363124} mat_seg_struc	mat_cont_struc
	`;
	*/
	
	var Parser = exports.Parser = function () {
	    function Parser() {
	        _classCallCheck(this, Parser);
	    }
	
	    _createClass(Parser, [{
	        key: 'parseToWatchArray',
	        value: function parseToWatchArray(str) {
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	            var watchArray = [];
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = arrayOfLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var line = _step.value;
	
	                    watchArray.push(line.substring(line.indexOf('{')));
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return watchArray;
	        }
	    }, {
	        key: 'parseToSegment',
	        value: function parseToSegment(line) {
	            var parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	            var termArr = parenth.split(' '); // array of terms "attr=value"
	
	            var psArr = termArr[0].split('=')[1].split(',');
	            var ps = new Point(parseInt(psArr[0], 10), parseInt(psArr[1], 10));
	
	            var peArr = termArr[1].split('=')[1].split(',');
	            var pe = new Point(parseInt(peArr[0], 10), parseInt(peArr[1], 10));
	
	            return new Segment(ps, pe);
	        }
	    }, {
	        key: 'parseToArc',
	        value: function parseToArc(line) {
	            var parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	            var termArr = parenth.split(' '); // array of terms "attr=value"
	
	            var psArr = termArr[0].split('=')[1].split(',');
	            var ps = new Point(parseInt(psArr[0], 10), parseInt(psArr[1], 10));
	
	            var peArr = termArr[1].split('=')[1].split(',');
	            var pe = new Point(parseInt(peArr[0], 10), parseInt(peArr[1], 10));
	
	            var pcArr = termArr[2].split('=')[1].split(',');
	            var pc = new Point(parseInt(pcArr[0], 10), parseInt(pcArr[1], 10));
	
	            var cwStr = termArr[3].split('=')[1];
	            var counterClockwise = cwStr === '0' ? true : false;
	
	            var startAngle = vector(pc, ps).slope;
	            var endAngle = vector(pc, pe).slope;
	
	            if (_flattenJs2.default.Utils.EQ(startAngle, endAngle)) {
	                endAngle += 2 * Math.PI;
	            }
	            var r = vector(pc, ps).length;
	
	            return new Arc(pc, r, startAngle, endAngle, counterClockwise);
	        }
	    }, {
	        key: 'parseToPolygon',
	        value: function parseToPolygon(str) {
	            var polygon = new Polygon();
	            // let mulitystr = debug_str;
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	
	            for (var i = 0; i < arrayOfLines.length; i++) {
	                var line = arrayOfLines[i];
	                if (line.search('mat_cont_poly_struc') >= 0) {
	                    var parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	                    var termArr = parenth.split(' '); // array of terms "attr=value"
	                    var nedgesTerm = termArr[0]; // "nedge=nn"
	                    var nedgesStr = nedgesTerm.split('=')[1];
	                    var nedges = parseInt(nedgesStr, 10);
	
	                    // Create new face from next #nedges of segments and arcs
	                    var edges = [];
	                    for (var j = i + 2; j < i + 2 + nedges; j++) {
	                        line = arrayOfLines[j];
	                        // let parenth = line.match(/\{([^)]+)\}/)[1];   // string inside {..}
	                        // let termArr = parenth.split(' ');             // array of terms "attr=value"
	
	                        if (line.search('mat_seg_struc') >= 0) {
	                            var segment = this.parseToSegment(line);
	                            edges.push(segment);
	
	                            // let psArr = termArr[0].split('=')[1].split(',');
	                            // let ps = new Point(parseInt(psArr[0],10), parseInt(psArr[1],10));
	                            //
	                            // let peArr = termArr[1].split('=')[1].split(',');
	                            // let pe = new Point(parseInt(peArr[0],10), parseInt(peArr[1],10));
	                            //
	                            // edges.push(new Segment(ps, pe));
	                        } else if (line.search('mat_curve_struc') >= 0) {
	                            var arc = this.parseToArc(line);
	                            edges.push(arc);
	
	                            // let psArr = termArr[0].split('=')[1].split(',');
	                            // let ps = new Point(parseInt(psArr[0],10), parseInt(psArr[1],10));
	                            //
	                            // let peArr = termArr[1].split('=')[1].split(',');
	                            // let pe = new Point(parseInt(peArr[0],10), parseInt(peArr[1],10));
	                            //
	                            // let pcArr = termArr[2].split('=')[1].split(',');
	                            // let pc = new Point(parseInt(pcArr[0],10), parseInt(pcArr[1],10));
	                            //
	                            // let cwStr = termArr[3].split('=')[1];
	                            // let counterClockwise = cwStr === '0' ? true : false;
	                            //
	                            // let startAngle = vector(pc,ps).slope;
	                            // let endAngle = vector(pc, pe).slope;
	                            //
	                            // if (Flatten.Utils.EQ(startAngle, endAngle)) {
	                            //     endAngle += 2*Math.PI;
	                            // }
	                            // let r = vector(pc, ps).length;
	                            //
	                            // edges.push(new Arc(pc, r, startAngle, endAngle, counterClockwise));
	                        }
	                    }
	                    polygon.addFace(edges);
	                }
	            }
	            return polygon;
	        }
	    }, {
	        key: 'parseToPoints',
	        value: function parseToPoints(str) {
	            var points = [];
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = arrayOfLines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var line = _step2.value;
	
	                    if (line.search('point_struc') >= 0) {
	                        var parenth = line.match(/\{([^)]+)\}/)[1]; // string inside {..}
	                        var pointArr = parenth.split('=')[1].split(',');
	                        var point = new Point(parseInt(pointArr[0], 10), parseInt(pointArr[1], 10));
	                        point.label = line.split(/\s+/)[1];
	                        points.push(point);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return points;
	        }
	    }, {
	        key: 'parseToSegmentsArcs',
	        value: function parseToSegmentsArcs(str) {
	            var shapes = [];
	            var arrayOfLines = str.match(/[^\r\n]+/g);
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = arrayOfLines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var line = _step3.value;
	
	                    if (line.search('mat_seg_struc') >= 0) {
	                        var segment = this.parseToSegment(line);
	                        shapes.push(segment);
	                    } else if (line.search('mat_curve_struc') >= 0) {
	                        var arc = this.parseToArc(line);
	                        shapes.push(arc);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            return shapes;
	        }
	    }, {
	        key: 'parse',
	        value: function parse(str) {
	            /* try polygon */
	            var polygon = this.parseToPolygon(str);
	            if (polygon.edges.size > 0 && polygon.faces.size > 0) {
	                return [polygon];
	            }
	
	            /* try array of points */
	            var points = this.parseToPoints(str);
	            if (points.length > 0) {
	                return points;
	            }
	
	            /* try array of segments and arcs */
	            var shapes = this.parseToSegmentsArcs(str);
	            if (shapes.length > 0) {
	                return shapes;
	            }
	        }
	    }]);

	    return Parser;
	}();

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseODB = parseODB;
	
	var _job = __webpack_require__(8);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon;
	var vector = _flattenJs2.default.vector;
	
	
	var inch2pixels = 10160000;
	var mils2pixels = 10160;
	function InchToPixels(str) {
	    return Math.round(Number(str) * inch2pixels, 0);
	}
	function MilsToPixels(str) {
	    return Math.round(Number(str) * mils2pixels, 0);
	}
	
	function parsePolygon(lines, start) {
	    var shapes = [];
	    var i = start;
	    var line = lines[i];
	    var terms = line.split(' ');
	    var ps = new Point(InchToPixels(terms[1]), InchToPixels(terms[2]));
	    var pe = void 0;
	    var pc = void 0;
	    var end_of_face = false;
	    while (true) {
	        line = lines[i];
	        terms = line.split(' ');
	        switch (terms[0]) {
	            case 'OS':
	                pe = new Point(InchToPixels(terms[1]), InchToPixels(terms[2]));
	                shapes.push(new Segment(ps, pe));
	
	                ps = pe.clone();
	                break;
	            case 'OC':
	                pe = new Point(InchToPixels(terms[1]), InchToPixels(terms[2]));
	                pc = new Point(InchToPixels(terms[3]), InchToPixels(terms[4]));
	
	                var cwStr = terms[5];
	                var counterClockwise = cwStr === 'Y' ? _flattenJs2.default.CW : _flattenJs2.default.CCW; /* sic ! */
	
	                var startAngle = vector(pc, ps).slope;
	                var endAngle = vector(pc, pe).slope;
	                if (_flattenJs2.default.Utils.EQ(startAngle, endAngle)) {
	                    endAngle += 2 * Math.PI;
	                    counterClockwise = true;
	                }
	                var r = vector(pc, ps).length;
	
	                shapes.push(new Arc(pc, r, startAngle, endAngle, counterClockwise));
	
	                ps = pe.clone();
	                break;
	            case 'OE':
	                end_of_face = true;
	                break;
	            default:
	                break;
	        }
	        if (end_of_face) {
	            break;
	        }
	
	        i++;
	    }
	    return shapes;
	}
	
	function parseLine(str, apertures) {
	    var terms = str.split(' ');
	    var ps = new Point(InchToPixels(terms[1]), InchToPixels(terms[2]));
	    var pe = new Point(InchToPixels(terms[3]), InchToPixels(terms[4]));
	    var segment = new Segment(ps, pe);
	    var ap_key = Number(terms[5]);
	    var ap_value = apertures[ap_key];
	    segment.aperture = ap_value; // augmentation
	    return segment;
	}
	
	function parseArc(str, apertures) {
	    var terms = str.split(' ');
	    var ps = new Point(InchToPixels(terms[1]), InchToPixels(terms[2]));
	    var pe = new Point(InchToPixels(terms[3]), InchToPixels(terms[4]));
	    var pc = new Point(InchToPixels(terms[5]), InchToPixels(terms[6]));
	
	    var cwStr = terms[10];
	    var counterClockwise = cwStr === 'Y' ? _flattenJs2.default.CW : _flattenJs2.default.CCW; /* sic ! */
	
	    var startAngle = vector(pc, ps).slope;
	    var endAngle = vector(pc, pe).slope;
	    if (_flattenJs2.default.Utils.EQ(startAngle, endAngle)) {
	        endAngle += 2 * Math.PI;
	        counterClockwise = true;
	    }
	    var r = vector(pc, ps).length;
	
	    var arc = new Arc(pc, r, startAngle, endAngle, counterClockwise);
	
	    var ap_key = Number(terms[7]);
	    var ap_value = apertures[ap_key];
	    arc.aperture = ap_value; // augmentation
	
	    return arc;
	}
	
	function parseODB(filename, str) {
	    var job = new _job.Job();
	    job.filename = filename;
	
	    var arrayOfLines = str.match(/[^\r\n]+/g);
	    var polygon = void 0;
	
	    var apertures = [];
	
	    for (var i = 0; i < arrayOfLines.length; i++) {
	        var line = arrayOfLines[i];
	        var terms = line.split(' ');
	
	        if (terms[0].substr(0, 1) === '$') {
	            var ap_key = Number(terms[0].substr(1));
	            var ap_value = MilsToPixels(terms[1].substr(1));
	            apertures[ap_key] = ap_value;
	            continue;
	        }
	
	        switch (terms[0]) {
	            case 'S':
	                // surface started
	                polygon = new Polygon();
	                var termArr = line.split(' ');
	                var polarity = termArr[1]; // consider later
	                polygon.polarity = polarity;
	                break;
	            case 'OB':
	                // polygon started
	                var start = i;
	                var shapes = parsePolygon(arrayOfLines, start);
	                polygon.addFace(shapes);
	                i = start + shapes.length + 1;
	                break;
	            case 'SE':
	                // surface ended
	                job.shapes.push(polygon);
	                break;
	            case 'L':
	                // line
	                var odbLine = parseLine(line, apertures);
	                job.shapes.push(odbLine);
	                break;
	            case 'A':
	                // Arc
	                var odbArc = parseArc(line, apertures);
	                job.shapes.push(odbArc);
	                break;
	            default:
	                break;
	        }
	    }
	    return job;
	}

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (false) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/28/2017.
	 */
	
	'use strict';
	
	module.exports = {
	    RB_TREE_COLOR_RED: 0,
	    RB_TREE_COLOR_BLACK: 1
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(104);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(98),
	    getPrototype = __webpack_require__(100),
	    isObjectLike = __webpack_require__(105);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var asap = __webpack_require__(30);
	
	function noop() {}
	
	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable
	
	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.
	
	
	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	module.exports = Promise;
	
	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;
	
	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};
	
	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}
	
	function handleResolved(self, deferred) {
	  asap(function() {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}
	
	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}
	
	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}
	
	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  if (false) {
	    // This branch is unreachable because this function is only called
	    // in production, but the condition is true only in development.
	    // Therefore if the branch is still here, dead code elimination wasn't
	    // properly applied.
	    // Don't change the message. React DevTools relies on it. Also make sure
	    // this message doesn't occur elsewhere in this function, or it will cause
	    // a false positive.
	    throw new Error('^_^');
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}
	
	if (true) {
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  module.exports = __webpack_require__(111);
	} else {
	  module.exports = require('./cjs/react-dom.development.js');
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(109);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _screenReaderStyles = __webpack_require__(112);
	
	var _screenReaderStyles2 = _interopRequireDefault(_screenReaderStyles);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * A React component for the font-awesome icon library.
	 *
	 * @param {String} [ariaLabel] An extra accessibility label to put on the icon
	 * @param {Boolean} [border=false] Whether or not to show a border radius
	 * @param {String} [className] An extra set of CSS classes to add to the component
	 * @param {Object} [cssModule] Option to pass FontAwesome CSS as a module
	 * @param {Boolean} [fixedWidth=false] Make buttons fixed width
	 * @param {String} [flip=false] Flip the icon's orientation.
	 * @param {Boolean} [inverse=false]Inverse the icon's color
	 * @param {String} name Name of the icon to use
	 * @param {Boolean} [pulse=false] Rotate icon with 8 steps, rather than smoothly
	 * @param {Number} [rotate] The degress to rotate the icon by
	 * @param {String} [size] The icon scaling size
	 * @param {Boolean} [spin=false] Spin the icon
	 * @param {String} [stack] Stack an icon on top of another
	 * @param {String} [tag=span] The HTML tag to use as a string, eg 'i' or 'em'
	 * @module FontAwesome
	 * @type {ReactClass}
	 */
	var FontAwesome = function (_React$Component) {
	  _inherits(FontAwesome, _React$Component);
	
	  function FontAwesome() {
	    _classCallCheck(this, FontAwesome);
	
	    var _this = _possibleConstructorReturn(this, (FontAwesome.__proto__ || Object.getPrototypeOf(FontAwesome)).call(this));
	
	    _this.displayName = 'FontAwesome';
	    return _this;
	  }
	
	  _createClass(FontAwesome, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          border = _props.border,
	          cssModule = _props.cssModule,
	          className = _props.className,
	          fixedWidth = _props.fixedWidth,
	          flip = _props.flip,
	          inverse = _props.inverse,
	          name = _props.name,
	          pulse = _props.pulse,
	          rotate = _props.rotate,
	          size = _props.size,
	          spin = _props.spin,
	          stack = _props.stack,
	          _props$tag = _props.tag,
	          tag = _props$tag === undefined ? 'span' : _props$tag,
	          ariaLabel = _props.ariaLabel,
	          props = _objectWithoutProperties(_props, ['border', 'cssModule', 'className', 'fixedWidth', 'flip', 'inverse', 'name', 'pulse', 'rotate', 'size', 'spin', 'stack', 'tag', 'ariaLabel']);
	
	      var classNames = [];
	
	      if (cssModule) {
	        classNames.push(cssModule['fa']);
	        classNames.push(cssModule['fa-' + name]);
	        size && classNames.push(cssModule['fa-' + size]);
	        spin && classNames.push(cssModule['fa-spin']);
	        pulse && classNames.push(cssModule['fa-pulse']);
	        border && classNames.push(cssModule['fa-border']);
	        fixedWidth && classNames.push(cssModule['fa-fw']);
	        inverse && classNames.push(cssModule['fa-inverse']);
	        flip && classNames.push(cssModule['fa-flip-' + flip]);
	        rotate && classNames.push(cssModule['fa-rotate-' + rotate]);
	        stack && classNames.push(cssModule['fa-stack-' + stack]);
	      } else {
	        classNames.push('fa');
	        classNames.push('fa-' + name);
	        size && classNames.push('fa-' + size);
	        spin && classNames.push('fa-spin');
	        pulse && classNames.push('fa-pulse');
	        border && classNames.push('fa-border');
	        fixedWidth && classNames.push('fa-fw');
	        inverse && classNames.push('fa-inverse');
	        flip && classNames.push('fa-flip-' + flip);
	        rotate && classNames.push('fa-rotate-' + rotate);
	        stack && classNames.push('fa-stack-' + stack);
	      }
	
	      // Add any custom class names at the end.
	      className && classNames.push(className);
	      return _react2.default.createElement(tag, _extends({}, props, { 'aria-hidden': true, className: classNames.join(' ') }), ariaLabel ? _react2.default.createElement('span', { style: _screenReaderStyles2.default }, ariaLabel) : null);
	    }
	  }]);
	
	  return FontAwesome;
	}(_react2.default.Component);
	
	FontAwesome.propTypes = {
	  ariaLabel: _propTypes2.default.string,
	  border: _propTypes2.default.bool,
	  className: _propTypes2.default.string,
	  cssModule: _propTypes2.default.object,
	  fixedWidth: _propTypes2.default.bool,
	  flip: _propTypes2.default.oneOf(['horizontal', 'vertical']),
	  inverse: _propTypes2.default.bool,
	  name: _propTypes2.default.string.isRequired,
	  pulse: _propTypes2.default.bool,
	  rotate: _propTypes2.default.oneOf([90, 180, 270]),
	  size: _propTypes2.default.oneOf(['lg', '2x', '3x', '4x', '5x']),
	  spin: _propTypes2.default.bool,
	  stack: _propTypes2.default.oneOf(['1x', '2x']),
	  tag: _propTypes2.default.string
	};
	
	exports.default = FontAwesome;
	module.exports = exports['default'];

/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	
	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(undefined, arguments));
	    };
	  });
	}

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;
	
	var _isPlainObject = __webpack_require__(21);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(119);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	
	  /**
	   * Creates a Redux store that holds the state tree.
	   * The only way to change the data in the store is to call `dispatch()` on it.
	   *
	   * There should only be a single store in your app. To specify how different
	   * parts of the state tree respond to actions, you may combine several reducers
	   * into a single reducer function by using `combineReducers`.
	   *
	   * @param {Function} reducer A function that returns the next state tree, given
	   * the current state tree and the action to handle.
	   *
	   * @param {any} [preloadedState] The initial state. You may optionally specify it
	   * to hydrate the state from the server in universal apps, or to restore a
	   * previously serialized user session.
	   * If you use `combineReducers` to produce the root reducer function, this must be
	   * an object with the same shape as `combineReducers` keys.
	   *
	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	   * to enhance the store with third-party capabilities such as middleware,
	   * time travel, persistence, etc. The only store enhancer that ships with Redux
	   * is `applyMiddleware()`.
	   *
	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
	   * and subscribe to changes.
	   */
	};function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(26);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(118);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(117);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(116);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(25);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(28);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (false) {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	let Flatten = __webpack_require__(2);
	let {Point, Vector, Segment, Arc, Line, Box, Polygon} = Flatten;
	
	class CollisionDistance {
	    static apply(polygon1, polygon2) {
	        let collision_distance = Number.POSITIVE_INFINITY;
	        for (let edge of [...polygon2.edges]) {
	            let distance = CollisionDistance.edge2polygon(edge, polygon1);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static edge2polygon(edge2, polygon1) {
	        let shapeBox = edge2.shape.box;
	        let box = new Box(
	            Number.NEGATIVE_INFINITY,
	            shapeBox.ymin,
	            Number.POSITIVE_INFINITY,
	            shapeBox.ymax
	        );
	        let collision_distance = Number.POSITIVE_INFINITY;
	        let resp_edges =  polygon1.edges.search(box);
	        for (let edge1 of resp_edges) {
	            let distance;
	            if (edge1.shape instanceof Segment && edge2.shape instanceof Segment) {
	                distance = CollisionDistance.segment2segment(edge1.shape, edge2.shape);
	            }
	            else if (edge1.shape instanceof Arc && edge2.shape instanceof Segment) {
	                distance = CollisionDistance.segment2arc(edge2.shape, edge1.shape);
	            }
	            else if (edge1.shape instanceof Segment && edge2.shape instanceof Arc) {
	                distance = CollisionDistance.segment2arc(edge1.shape, edge2.shape);
	            }
	            else if (edge1.shape instanceof Arc && edge2.shape instanceof Arc) {
	                distance = CollisionDistance.arc2arc(edge1.shape, edge2.shape);
	            }
	
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static point2shape(point, shape) {
	        let line = new Line(point, new Vector(0,1));
	        let intersections = line.intersect(shape);          // segment or arc
	        let collision_distance = Number.POSITIVE_INFINITY;
	        for (let ip of intersections) {
	            let [distance, shortest_segment] = point.distanceTo(ip);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static segment2segment(segment1, segment2) {
	        let collision_distance = Number.POSITIVE_INFINITY;
	        for (let point of segment1.vertices) {
	            let distance = CollisionDistance.point2shape(point, segment2);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        for (let point of segment2.vertices) {
	            let distance = CollisionDistance.point2shape(point, segment1);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static segment2arc(segment, arc) {
	        let collision_distance = Number.POSITIVE_INFINITY;
	        let v_s = new Vector(segment.start, segment.end);
	        v_s = v_s.normalize();
	
	        let v_n = [v_s.rotate90CCW().multiply(arc.r), v_s.rotate90CW().multiply(arc.r)];
	        let distance;
	
	        // Distance between tangent point and segment
	        for (let v of v_n) {
	            let tangent_point = arc.center.translate(v);  // tangent point in direction of the normal vector
	            if (tangent_point.on(arc)) {
	                distance = CollisionDistance.point2shape(tangent_point, segment);
	                if (distance < collision_distance) {
	                    collision_distance = distance;
	                }
	            }
	        }
	
	        for (let point of arc.vertices) {
	            let distance = CollisionDistance.point2shape(point, segment);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        for (let point of segment.vertices) {
	            let distance = CollisionDistance.point2shape(point, arc);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static arc2arc(arc1, arc2) {
	        let collision_distance = Number.POSITIVE_INFINITY;
	        let distance;
	
	        // test translation of arc2.center to arc1 enlarged by r2
	        let arc_enlarged = arc1.clone();
	        arc_enlarged.r += arc2.r;
	        distance = CollisionDistance.point2shape(arc2.center, arc_enlarged);
	        if (distance < collision_distance) {
	            // additional check that transformed arc actually touching
	            let [dist_tmp, shortest_segment_tmp] =
	                arc1.distanceTo( CollisionDistance.translateArc(arc2, new Vector(-distance,0)));
	            if (Flatten.Utils.EQ_0(dist_tmp)) {
	                collision_distance = distance;
	            }
	        }
	
	        // test translation of arc2.center to arc1 reduced by r2
	        if (Flatten.Utils.GE(arc1.r, arc2.r)) {
	            let arc_reduced = arc1.clone();
	            arc_reduced.r -= arc2.r;
	            distance = CollisionDistance.point2shape(arc2.center, arc_reduced);
	            if (distance < collision_distance) {
	                // additional check that transformed arc actually touching
	                let [dist_tmp, shortest_segment_tmp] =
	                    arc1.distanceTo( CollisionDistance.translateArc(arc2, new Vector(-distance,0)));
	                if (Flatten.Utils.EQ_0(dist_tmp)) {
	                    collision_distance = distance;
	                }
	            }
	        }
	
	        // test translation of arc1.center to arc2 reduced by r1
	        if (Flatten.Utils.LT(arc1.r, arc2.r)) {
	            let arc_reduced = arc2.clone();
	            arc_reduced.r -= arc1.r;
	            distance = CollisionDistance.point2shape(arc1.center, arc_reduced);
	            if (distance < collision_distance) {
	                // additional check that transformed arc actually touching
	                let [dist_tmp, shortest_segment_tmp] =
	                    arc1.distanceTo( CollisionDistance.translateArc(arc2, new Vector(-distance,0)));
	                if (Flatten.Utils.EQ_0(dist_tmp)) {
	                    collision_distance = distance;
	                }
	            }
	        }
	
	        for (let point of arc1.vertices) {
	            let distance = CollisionDistance.point2shape(point, arc2);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        for (let point of arc2.vertices) {
	            let distance = CollisionDistance.point2shape(point, arc1);
	            if (distance < collision_distance) {
	                collision_distance = distance;
	            }
	        }
	        return collision_distance;
	    }
	
	    static translateArc(arc, vec) {
	        let arc_tmp = arc.clone();
	        arc_tmp.pc = arc_tmp.pc.translate(vec);
	        return arc_tmp;
	    }
	
	    static translate(polygon, vec) {
	        let newPolygon = new Polygon();
	        for (let face of polygon.faces) {
	            let shapes = [];
	            for (let edge of face) {
	                if (edge.shape instanceof Segment) {
	                    shapes.push(
	                        new Segment(edge.shape.ps.translate(vec), edge.shape.pe.translate(vec))
	                    )
	                }
	                else if (edge.shape instanceof  Arc) {
	                    let arc_trans = edge.shape.clone();
	                    arc_trans.pc = edge.shape.pc.translate(vec);
	                    shapes.push(arc_trans);
	                }
	            }
	            newPolygon.addFace(shapes);
	        }
	        return newPolygon;
	    }
	
	};
	
	CollisionDistance.Flatten = Flatten;
	
	module.exports = CollisionDistance;


/***/ },
/* 30 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}
	
	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;
	
	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}
	
	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
	
	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` or `self` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	
	/* globals self */
	var scope = typeof global !== "undefined" ? global : self;
	var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
	
	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);
	
	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.
	
	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396
	
	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}
	
	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;
	
	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}
	
	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html
	
	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.
	
	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }
	
	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.
	
	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }
	
	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.
	
	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.
	
	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);
	
	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}
	
	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
	
	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.App = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _headerComponent = __webpack_require__(34);
	
	var _mainComponent = __webpack_require__(40);
	
	var _layersListComponent = __webpack_require__(39);
	
	var _asideComponent = __webpack_require__(32);
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// import logo from './logo.svg';
	
	
	var App = exports.App = function (_Component) {
	    _inherits(App, _Component);
	
	    function App(props) {
	        _classCallCheck(this, App);
	
	        var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));
	
	        _this.state = _this.props.store.getState();
	        _this.props.store.subscribe(function () {
	            _this.setState(_this.props.store.getState());
	        });
	        _this.handlePaste = _this.handlePaste.bind(_this);
	        _this.handleHashChange = _this.handleHashChange.bind(_this);
	        return _this;
	    }
	
	    _createClass(App, [{
	        key: 'handlePaste',
	        value: function handlePaste(event) {
	            this.props.store.dispatch({
	                type: ActionTypes.DATA_FROM_BUFFER_PASTED,
	                data: event.clipboardData
	            });
	        }
	    }, {
	        key: 'handleHashChange',
	        value: function handleHashChange(event) {
	            this.props.store.dispatch({
	                type: ActionTypes.WINDOW_HASH_CHANGED,
	                stage: this.state.stage
	            });
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            // this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount(e) {
	            window.onhashchange = this.handleHashChange;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'App' },
	                _react2.default.createElement(_headerComponent.HeaderComponent, this.props),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'App-body', onPaste: this.handlePaste },
	                    _react2.default.createElement(_mainComponent.MainComponent, this.props),
	                    _react2.default.createElement(_layersListComponent.LayersListComponent, {
	                        dispatch: this.props.store.dispatch,
	                        stage: this.state.stage,
	                        layers: this.state.layers
	                    }),
	                    _react2.default.createElement(_asideComponent.AsideComponent, this.props)
	                )
	            );
	        }
	    }]);
	
	    return App;
	}(_react.Component);
	
	// export default App;
	
	/*
	 <div className="App">
	 <div className="App-header">
	 <h2>Debug Viewer</h2>
	 </div>
	
	 </div>
	*/
	
	/*
	 <img src={logo} className="App-logo" alt="logo" />
	 */

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AsideComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 06/05/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import {Layers} from '../models/layers';
	// import {Shape} from '../models/shape';
	
	var AsideComponent = exports.AsideComponent = function (_Component) {
	    _inherits(AsideComponent, _Component);
	
	    function AsideComponent() {
	        _classCallCheck(this, AsideComponent);
	
	        var _this = _possibleConstructorReturn(this, (AsideComponent.__proto__ || Object.getPrototypeOf(AsideComponent)).call(this));
	
	        _this.onToggleWatchExpandButtonClicked = _this.onToggleWatchExpandButtonClicked.bind(_this);
	        _this.onSelectShapeClicked = _this.onSelectShapeClicked.bind(_this);
	        // this.addSamplePolygon = this.addSamplePolygon.bind(this);
	        _this.height = 0;
	        return _this;
	    }
	
	    _createClass(AsideComponent, [{
	        key: 'onToggleWatchExpandButtonClicked',
	        value: function onToggleWatchExpandButtonClicked(shape) {
	            if (!shape) return;
	            this.dispatch({
	                type: ActionTypes.TOGGLE_WATCH_EXPAND_CLICKED,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'onSelectShapeClicked',
	        value: function onSelectShapeClicked(shape) {
	            if (!shape) return;
	            this.dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.height = this.refs.aside.clientHeight;
	            // let container = this.refs.watchContainer;
	            // let parentHeight = container.parentElement.clientHeight;
	            // container.style.maxHeight = 0.7*parentHeight;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            // let layer = Layers.getAffected(this.state.layers);
	            // let shapes = layer ? [...layer.shapes] : undefined;
	            // let title = layer ? layer.title : "";
	            // let watchContainerHeight = 0.75*this.height;
	            return _react2.default.createElement(
	                'aside',
	                { className: 'App-aside', ref: 'aside' },
	                _react2.default.createElement(
	                    'h5',
	                    null,
	                    ' '
	                )
	            );
	        }
	    }]);

	    return AsideComponent;
	}(_react.Component);

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CanvasComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _stage = __webpack_require__(63);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	var CanvasComponent = exports.CanvasComponent = function (_Component) {
	    _inherits(CanvasComponent, _Component);
	
	    function CanvasComponent() {
	        _classCallCheck(this, CanvasComponent);
	
	        var _this = _possibleConstructorReturn(this, (CanvasComponent.__proto__ || Object.getPrototypeOf(CanvasComponent)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	        _this.handleMouseLeave = _this.handleMouseLeave.bind(_this);
	        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
	        _this.handleMouseWheelFox = _this.handleMouseWheelFox.bind(_this);
	        return _this;
	    }
	
	    _createClass(CanvasComponent, [{
	        key: 'handleMouseMove',
	        value: function handleMouseMove(event) {
	            this.props.stage.canvas.focus();
	            this.props.onMouseMove(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseDown',
	        value: function handleMouseDown(event) {
	            this.props.onMouseDown(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(event) {
	            event.stopPropagation();
	            event.preventDefault();
	            this.props.onMouseUp(event.stageX, event.stageY);
	        }
	    }, {
	        key: 'handleMouseLeave',
	        value: function handleMouseLeave(event) {
	            // nothing works except click
	            this.props.stage.canvas.blur();
	            document.body.focus();
	        }
	    }, {
	        key: 'handleMouseWheel',
	        value: function handleMouseWheel(event) {
	            event.preventDefault();
	
	            var delta = event.detail || event.wheelDelta;
	            if (delta !== 0) {
	                this.props.onMouseWheelMove(event.offsetX, event.offsetY, delta);
	            }
	        }
	    }, {
	        key: 'handleMouseWheelFox',
	        value: function handleMouseWheelFox(event) {
	            event.preventDefault();
	            if (event.detail !== 0) {
	                this.props.onMouseWheelMove(event.layerX, event.layerY, -event.detail);
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var stage = new _stage.Stage(this.refs.canvas);
	
	            // stage.setClearColor("#FFFFFF");
	            // stage.update();
	
	            stage.on("stagemousemove", this.handleMouseMove);
	            stage.on("stagemousedown", this.handleMouseDown);
	            stage.on("stagemouseup", this.handleMouseUp);
	            stage.on("mouseleave", this.handleMouseLeave);
	            stage.canvas.addEventListener("mousewheel", this.handleMouseWheel);
	            stage.canvas.addEventListener("DOMMouseScroll", this.handleMouseWheelFox);
	
	            this.props.onStageCreated(stage);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('canvas', { tabIndex: '1', ref: 'canvas', id: 'mainCanvas', className: 'App-canvas' });
	        }
	    }]);

	    return CanvasComponent;
	}(_react.Component);

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HeaderComponent = undefined;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	
	var HeaderComponent = exports.HeaderComponent = function HeaderComponent(props) {
	    var state = props.store.getState();
	    return _react2.default.createElement(
	        'header',
	        { className: 'App-header' },
	        _react2.default.createElement(
	            'h2',
	            null,
	            state.app.title
	        )
	    );
	};
	// import logo from './logo.svg';

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ImageComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	__webpack_require__(7);
	
	var _utils = __webpack_require__(9);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 19/06/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var ImageComponent = exports.ImageComponent = function (_Component) {
	    _inherits(ImageComponent, _Component);
	
	    function ImageComponent(params) {
	        _classCallCheck(this, ImageComponent);
	
	        var _this = _possibleConstructorReturn(this, (ImageComponent.__proto__ || Object.getPrototypeOf(ImageComponent)).call(this));
	
	        _this.bitmap = new createjs.Bitmap(params.model.geom.uri);
	        params.stage.addChild(_this.bitmap);
	
	        _this.labelShape = undefined;
	
	        if (params.model.label && params.model.label.trim() !== "") {
	            var html = document.createElement('div');
	            html.innerText = params.model.label;
	            html.style.position = "absolute";
	            html.style.top = 0;
	            html.style.left = 0;
	
	            document.body.appendChild(html);
	
	            _this.labelShape = new createjs.DOMElement(html);
	
	            _this.labelShape.geom = params.model.geom; // augment label Shape with geom struct
	            params.stage.addChild(_this.labelShape);
	        }
	
	        // this.handleMouseMove = this.handleMouseMove.bind(this);
	        _this.handleMouseOver = _this.handleMouseOver.bind(_this);
	        _this.handleMouseOut = _this.handleMouseOut.bind(_this);
	        _this.handleClick = _this.handleClick.bind(_this);
	        return _this;
	    }
	
	    _createClass(ImageComponent, [{
	        key: 'handleMouseOver',
	        value: function handleMouseOver(event) {
	            this.props.onMouseOver(this.props.model);
	        }
	    }, {
	        key: 'handleMouseOut',
	        value: function handleMouseOut(event) {
	            this.props.onMouseOut();
	        }
	    }, {
	        key: 'handleClick',
	        value: function handleClick(event) {
	            this.props.onClick(this.props.model, this.props.layer);
	        }
	    }, {
	        key: 'redrawLabels',
	        value: function redrawLabels(showLabel) {
	            if (!this.labelShape) return;
	
	            var stage = this.props.stage;
	
	            this.labelShape.htmlElement.style.display = showLabel ? "block" : "none";
	
	            var box = this.props.model.geom.box;
	            var point = { x: (box.xmin + box.xmax) / 2, y: (box.ymin + box.ymax) / 2 };
	            var dx = 6. / (stage.zoomFactor * stage.resolution);
	            var dy = 4. / (stage.zoomFactor * stage.resolution);
	
	            this.labelShape.htmlElement.style.font = "16px Arial";
	            var unscale = 1. / (stage.zoomFactor * stage.resolution);
	            var tx = stage.canvas.offsetLeft / (stage.zoomFactor * stage.resolution) + point.x + dx;
	            var ty = -stage.canvas.offsetTop / (stage.zoomFactor * stage.resolution) + point.y + dy;
	            this.labelShape.setTransform(tx, ty, unscale, -unscale);
	        }
	    }, {
	        key: 'redraw',
	        value: function redraw() {
	            // Draw shape
	
	            var alpha = 0.5; // (this.props.hovered || this.props.selected) ? 1.0 : 0.6;
	
	            this.bitmap.alpha = this.props.displayed ? alpha : 0.0;
	
	            var width = this.props.model.geom.width;
	
	            var ratio = this.bitmap.image.naturalWidth / this.bitmap.image.naturalHeight;
	            var scaleX = width / this.bitmap.image.naturalWidth; // 1. / (stage.zoomFactor * stage.resolution);
	            var scaleY = width / (this.bitmap.image.naturalHeight * ratio);
	            var tx = this.props.model.geom.center.x; // stage.canvas.offsetLeft / (stage.zoomFactor * stage.resolution) + point.x + dx;
	            var ty = this.props.model.geom.center.y; // -stage.canvas.offsetTop / (stage.zoomFactor * stage.resolution) + point.y + dy;
	
	            this.bitmap.setTransform(tx, ty, scaleX, -scaleY);
	
	            this.bitmap.regX = this.bitmap.image.naturalWidth / 2;
	            this.bitmap.regY = this.bitmap.image.naturalHeight / 2;
	
	            // let box = this.state.polygon.geom.box;
	            // this.shape.cache(box.xmin, box.ymin, box.xmax - box.xmin, box.ymax - box.ymin);
	
	            // Draw labels
	            var showLabel = this.props.displayed && this.props.displayLabels;
	            this.redrawLabels(showLabel);
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.bitmap.on("mouseover", this.handleMouseOver);
	            this.bitmap.on("mouseout", this.handleMouseOut);
	            this.bitmap.on("click", this.handleClick);
	
	            // this.shape.mouseEnabled = false;
	
	            this.redraw();
	        }
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            if (_utils2.default.is_equal(this.props, nextProps)) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.redraw();
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            this.bitmap.off("mouseover", this.handleMouseOver);
	            this.bitmap.off("mouseout", this.handleMouseOut);
	            this.bitmap.off("click", this.handleClick);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return ImageComponent;
	}(_react.Component);

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayerComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _shapeComponent = __webpack_require__(41);
	
	var _imageComponent = __webpack_require__(35);
	
	var _utils = __webpack_require__(9);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LayerComponent = exports.LayerComponent = function (_Component) {
	    _inherits(LayerComponent, _Component);
	
	    function LayerComponent() {
	        _classCallCheck(this, LayerComponent);
	
	        return _possibleConstructorReturn(this, (LayerComponent.__proto__ || Object.getPrototypeOf(LayerComponent)).apply(this, arguments));
	    }
	
	    _createClass(LayerComponent, [{
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            if (_utils2.default.is_equal(this.props, nextProps)) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            return this.props.layer.shapes.map(function (shape, index) {
	                return shape.geom.uri ? _react2.default.createElement(_imageComponent.ImageComponent, {
	                    key: index,
	                    stage: _this2.props.stage,
	                    layer: _this2.props.layer,
	                    model: shape,
	                    displayed: _this2.props.layer.displayed,
	                    hovered: shape === _this2.props.hoveredShape,
	                    selected: shape === _this2.props.firstMeasuredShape || shape === _this2.props.secondMeasuredShape,
	                    color: _this2.props.layer.color,
	                    widthOn: _this2.props.widthOn,
	                    displayLabels: _this2.props.displayLabels,
	                    zoomFactor: _this2.props.zoomFactor,
	                    onMouseOver: _this2.props.onMouseOver,
	                    onMouseOut: _this2.props.onMouseOut,
	                    onClick: _this2.props.onClick
	                }) : _react2.default.createElement(_shapeComponent.ShapeComponent, {
	                    key: index,
	                    stage: _this2.props.stage,
	                    layer: _this2.props.layer,
	                    model: shape,
	                    displayed: _this2.props.layer.displayed,
	                    hovered: shape === _this2.props.hoveredShape,
	                    selected: shape === _this2.props.firstMeasuredShape || shape === _this2.props.secondMeasuredShape,
	                    color: _this2.props.layer.color,
	                    widthOn: _this2.props.widthOn,
	                    displayVertices: _this2.props.displayVertices,
	                    displayLabels: _this2.props.displayLabels,
	                    zoomFactor: _this2.props.zoomFactor,
	                    onMouseOver: _this2.props.onMouseOver,
	                    onMouseOut: _this2.props.onMouseOut,
	                    onClick: _this2.props.onClick
	                });
	            });
	        }
	    }]);

	    return LayerComponent;
	}(_react.Component);

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayerListElement = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _modalPopupComponent = __webpack_require__(15);
	
	var _layerEditForm = __webpack_require__(46);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var LayerListElement = exports.LayerListElement = function (_Component) {
	    _inherits(LayerListElement, _Component);
	
	    function LayerListElement() {
	        _classCallCheck(this, LayerListElement);
	
	        return _possibleConstructorReturn(this, (LayerListElement.__proto__ || Object.getPrototypeOf(LayerListElement)).apply(this, arguments));
	    }
	
	    _createClass(LayerListElement, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (document.activeElement.nodeName === "CANVAS") return;
	            var elem = this.refs.layerName;
	            if (this.props.layer.affected) {
	                elem.focus();
	            }
	        }
	    }, {
	        key: 'rgba',
	        value: function rgba(hex, opacity) {
	            var r = void 0,
	                g = void 0,
	                b = void 0,
	                percent = void 0;
	            if (hex) {
	                hex = hex.replace('#', '');
	                r = parseInt(hex.substring(0, 2), 16);
	                g = parseInt(hex.substring(2, 4), 16);
	                b = parseInt(hex.substring(4, 6), 16);
	                percent = opacity;
	            } else {
	                r = 147;
	                g = 128;
	                b = 108;
	                percent = 0;
	            }
	            var result = 'rgba(' + r + ',' + g + ',' + b + ',' + percent / 100 + ')';
	
	            return result;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            // let style = this.props.layer.displayed ?
	            //     styleSheet.displayed : styleSheet.undisplayed;
	
	            var displayed = this.props.layer.displayed ? "Layer-displayed" : "Layer-undisplayed";
	            var color = displayed ? this.rgba(this.props.layer.color, 100) : this.rgba();
	            var bgcolor = displayed ? this.rgba(this.props.layer.color, 30) : this.rgba();
	            var alpha = this.props.layer.affected ? 1 : 0;
	            return [_react2.default.createElement(
	                'li',
	                { key: 1,
	                    className: 'Layer ' + displayed,
	                    onClick: this.props.onLayerClicked,
	                    onDoubleClick: this.props.onLayerDoubleClicked },
	                _react2.default.createElement(
	                    'div',
	                    {
	                        style: { flex: 2, marginRight: 3 },
	                        onClick: this.props.onAffectedBoxClicked
	                    },
	                    _react2.default.createElement(
	                        'h4',
	                        { style: { opacity: alpha, color: color,
	                                width: 16, marginLeft: 2, cursor: "default"
	                            } },
	                        '\u2713'
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { style: { flex: 8, cursor: "default", padding: 3,
	                            backgroundColor: bgcolor } },
	                    _react2.default.createElement(
	                        'h4',
	                        { ref: 'layerName',
	                            title: this.props.layer.name,
	                            tabIndex: '1'
	                        },
	                        this.props.layer.name
	                    )
	                )
	            ), this.props.layer.edited ? _react2.default.createElement(
	                _modalPopupComponent.Modal,
	                { key: 2 },
	                _react2.default.createElement(_layerEditForm.LayerEditForm, {
	                    layer: this.props.layer,
	                    onSubmitLayerEditForm: this.props.onSubmitLayerEditForm,
	                    onEscapeLayerEditForm: this.props.onEscapeLayerEditForm
	                })
	            ) : null];
	        }
	    }]);
	
	    return LayerListElement;
	}(_react.Component);
	/*
	this.props.layer.edited ? (

	            <div
	                className={`Layer ${displayed}`}
	                onClick={this.props.onLayerClicked}
	            >
	                <input val={this.props.layer.name}/>
	            </div>
	        ) : (
	 */

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayerListToolbarComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactFontawesome = __webpack_require__(24);
	
	var _reactFontawesome2 = _interopRequireDefault(_reactFontawesome);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import icon_add from '../../public/icons/Add.png';
	// import icon_edit from '../../public/icons/Delete.png';
	// import icon_delete from '../../public/icons/Delete.png';
	// import icon_sort from '../../public/icons/Delete.png';
	
	var LayerListToolbarComponent = exports.LayerListToolbarComponent = function (_Component) {
	    _inherits(LayerListToolbarComponent, _Component);
	
	    function LayerListToolbarComponent() {
	        _classCallCheck(this, LayerListToolbarComponent);
	
	        var _this = _possibleConstructorReturn(this, (LayerListToolbarComponent.__proto__ || Object.getPrototypeOf(LayerListToolbarComponent)).call(this));
	
	        _this.openJobButtonClicked = _this.openJobButtonClicked.bind(_this);
	        _this.notImplemented = _this.notImplemented.bind(_this);
	        return _this;
	    }
	
	    _createClass(LayerListToolbarComponent, [{
	        key: 'openJobButtonClicked',
	        value: function openJobButtonClicked() {
	            document.getElementById("browseFiles").click();
	        }
	    }, {
	        key: 'notImplemented',
	        value: function notImplemented() {
	            alert("Not implemented yet");
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'App-toolbar' },
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Add layer', onClick: this.props.onAddLayerButtonClicked },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'plus',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Edit selected layer\'s name and info', onClick: this.props.onEditLayerButtonClicked },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'pencil',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Delete selected layer', onClick: this.props.onDeleteLayerButtonClicked },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'times',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Sort layer list', onClick: this.props.onSortLayersButtonClicked },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'sort-alpha-asc',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                )
	            );
	        }
	    }]);
	
	    return LayerListToolbarComponent;
	}(_react.Component);
	
	;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayersListComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _layerListToolbarComponent = __webpack_require__(38);
	
	var _layerListElement = __webpack_require__(37);
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var LayersListComponent = exports.LayersListComponent = function (_Component) {
	    _inherits(LayersListComponent, _Component);
	
	    function LayersListComponent(param) {
	        _classCallCheck(this, LayersListComponent);
	
	        var _this = _possibleConstructorReturn(this, (LayersListComponent.__proto__ || Object.getPrototypeOf(LayersListComponent)).call(this));
	
	        _this.onLayerListClicked = _this.onLayerListClicked.bind(_this);
	        _this.onLayerClicked = _this.onLayerClicked.bind(_this);
	        _this.onLayerDoubleClicked = _this.onLayerDoubleClicked.bind(_this);
	        _this.onSubmitLayerEditForm = _this.onSubmitLayerEditForm.bind(_this);
	        _this.onEscapeLayerEditForm = _this.onEscapeLayerEditForm.bind(_this);
	
	        _this.onAddLayerSelected = _this.onAddLayerSelected.bind(_this);
	        _this.onEditLayerSelected = _this.onEditLayerSelected.bind(_this);
	        _this.onDeleteLayerSelected = _this.onDeleteLayerSelected.bind(_this);
	        _this.onSortLayersSelected = _this.onSortLayersSelected.bind(_this);
	
	        _this.onAffectedBoxClicked = _this.onAffectedBoxClicked.bind(_this);
	        _this.handleKeyDown = _this.handleKeyDown.bind(_this);
	        _this.height = 0;
	        _this.dispatch = param.dispatch;
	        return _this;
	    }
	
	    _createClass(LayersListComponent, [{
	        key: 'onLayerListClicked',
	        value: function onLayerListClicked() {
	            this.dispatch({
	                type: ActionTypes.LAYER_LIST_PANEL_PRESSED
	            });
	        }
	    }, {
	        key: 'onLayerClicked',
	        value: function onLayerClicked(layer) {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onLayerDoubleClicked',
	        value: function onLayerDoubleClicked(layer) {
	            // this.dispatch({
	            //     type: ActionTypes.OPEN_LAYER_EDIT_FORM_PRESSED,
	            //     layer: layer
	            // });
	        }
	    }, {
	        key: 'onSubmitLayerEditForm',
	        value: function onSubmitLayerEditForm(layer, newLayer) {
	            this.dispatch({
	                type: ActionTypes.SUBMIT_LAYER_EDIT_FORM_PRESSED,
	                layer: layer,
	                newLayer: newLayer
	            });
	        }
	    }, {
	        key: 'onEscapeLayerEditForm',
	        value: function onEscapeLayerEditForm(layer) {
	            this.dispatch({
	                type: ActionTypes.ESCAPE_LAYER_EDIT_FORM_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onAffectedBoxClicked',
	        value: function onAffectedBoxClicked(layer) {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_AFFECTED_LAYER_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onAddLayerSelected',
	        value: function onAddLayerSelected() {
	            var layer = _layers.Layers.newLayer(this.props.stage, this.props.layers);
	
	            this.dispatch({
	                type: ActionTypes.ADD_LAYER_PRESSED,
	                stage: this.props.stage,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onEditLayerSelected',
	        value: function onEditLayerSelected() {
	            var layer = _layers.Layers.getAffected(this.props.layers);
	            if (!layer) return;
	
	            this.dispatch({
	                type: ActionTypes.OPEN_LAYER_EDIT_FORM_PRESSED,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onDeleteLayerSelected',
	        value: function onDeleteLayerSelected() {
	            var layer = _layers.Layers.getAffected(this.props.layers);
	            if (!layer) return;
	
	            this.dispatch({
	                type: ActionTypes.DELETE_LAYER_BUTTON_PRESSED,
	                layers: this.props.layers,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'onSortLayersSelected',
	        value: function onSortLayersSelected() {
	            this.dispatch({
	                type: ActionTypes.SORT_LAYERS_BUTTON_PRESSED,
	                layers: this.props.layers
	            });
	        }
	    }, {
	        key: 'handleKeyDown',
	        value: function handleKeyDown(e) {
	            // e.stopPropagation();
	            // e.preventDefault();
	
	            if (e.target.parentElement.parentElement.parentElement && e.target.parentElement.parentElement.parentElement.id && e.target.parentElement.parentElement.parentElement.id === "layersList") {
	
	                switch (e.code) {
	                    case "ArrowRight":
	                    case "ArrowDown":
	                        this.dispatch({
	                            type: ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED
	                        });
	                        break;
	                    case "ArrowLeft":
	                    case "ArrowUp":
	                        this.dispatch({
	                            type: ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED
	                        });
	                        break;
	                    /* tab does not work properly
	                    case "Tab":
	                    if (e.shiftKey) {
	                        this.dispatch({
	                            type: ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED
	                        });
	                    }
	                    else {
	                        this.dispatch({
	                            type: ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED
	                        });
	                    }
	                    break;
	                    */
	                    default:
	                        break;
	                }
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            // Keyboard event
	            // var _keydown = _.throttle(this.keydown, 100);
	            document.addEventListener('keydown', this.handleKeyDown);
	            // var _keyup = _.throttle(this.keyup, 500);
	            // document.addEventListener('keyup', this.handleKeyUp);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.height = this.refs.layersComponent.clientHeight;
	            // let container = this.refs.watchContainer;
	            // let parentHeight = container.parentElement.clientHeight;
	            // container.style.maxHeight = 0.7*parentHeight;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            // let addLayer =
	            //     (<div
	            //         style={{padding:4, backgroundColor: "lightgray"}}
	            //         onClick={this.onAddLayerSelected}>
	            //         <h5 style={{margin:0}}>Add layer</h5>
	            //     </div>)
	
	            // let layers = this.props.layers.slice();
	            // layers.sort( function(l1, l2) {
	            //     let name1 = l1.name.toUpperCase();
	            //     let name2 = l2.name.toUpperCase();
	            //     if (name1 < name2) {
	            //         return -1;
	            //     }
	            //     if (name1 > name2) {
	            //         return 1;
	            //     }
	            //     return 0;
	            // });
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'App-layers',
	                    ref: 'layersComponent',
	                    onClick: this.onLayerListClicked
	                },
	                _react2.default.createElement(_layerListToolbarComponent.LayerListToolbarComponent, {
	                    onAddLayerButtonClicked: this.onAddLayerSelected,
	                    onEditLayerButtonClicked: this.onEditLayerSelected,
	                    onDeleteLayerButtonClicked: this.onDeleteLayerSelected,
	                    onSortLayersButtonClicked: this.onSortLayersSelected
	                }),
	                _react2.default.createElement(
	                    'ul',
	                    { id: 'layersList',
	                        style: { maxHeight: 0.82 * (this.height - 40), padding: 0, overflow: 'auto' } },
	                    this.props.layers.map(function (layer) {
	                        return _react2.default.createElement(_layerListElement.LayerListElement, {
	                            onLayerClicked: function onLayerClicked() {
	                                return _this2.onLayerClicked(layer);
	                            },
	                            onLayerDoubleClicked: function onLayerDoubleClicked() {
	                                return _this2.onLayerDoubleClicked(layer);
	                            },
	                            onAffectedBoxClicked: function onAffectedBoxClicked() {
	                                return _this2.onAffectedBoxClicked(layer);
	                            },
	                            onSubmitLayerEditForm: _this2.onSubmitLayerEditForm,
	                            onEscapeLayerEditForm: _this2.onEscapeLayerEditForm,
	                            key: layer.name,
	                            layer: layer
	                        });
	                    })
	                )
	            );
	        }
	    }]);

	    return LayersListComponent;
	}(_react.Component);

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MainComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	var _toolbarComponent = __webpack_require__(44);
	
	var _canvasComponent = __webpack_require__(33);
	
	var _statusComponent = __webpack_require__(43);
	
	var _stageComponent = __webpack_require__(42);
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	var _measurePointsTool = __webpack_require__(68);
	
	var _modalPopupComponent = __webpack_require__(15);
	
	var _aboutPopup = __webpack_require__(45);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	//import {MeasureShapesTool} from "../tools/measureShapesTool";
	// import {DisplayCoordsTool} from "../tools/displayCoordsTool";
	
	var MainComponent = exports.MainComponent = function (_Component) {
	    _inherits(MainComponent, _Component);
	
	    function MainComponent() {
	        _classCallCheck(this, MainComponent);
	
	        var _this = _possibleConstructorReturn(this, (MainComponent.__proto__ || Object.getPrototypeOf(MainComponent)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	        _this.handleMouseWheelMove = _this.handleMouseWheelMove.bind(_this);
	        _this.registerStage = _this.registerStage.bind(_this);
	        _this.toggleUnits = _this.toggleUnits.bind(_this);
	
	        _this.onMouseRollOverShape = _this.onMouseRollOverShape.bind(_this);
	        _this.onMouseRollOutShape = _this.onMouseRollOutShape.bind(_this);
	        _this.onClickOnShape = _this.onClickOnShape.bind(_this);
	
	        _this.resizeStage = _this.resizeStage.bind(_this);
	
	        _this.handleFileSelect = _this.handleFileSelect.bind(_this);
	        _this.setHomeView = _this.setHomeView.bind(_this);
	        _this.toggleWidthMode = _this.toggleWidthMode.bind(_this);
	        _this.toggleDisplayVertices = _this.toggleDisplayVertices.bind(_this);
	        _this.toggleDisplayLabels = _this.toggleDisplayLabels.bind(_this);
	        _this.showAboutPopup = _this.showAboutPopup.bind(_this);
	        _this.closeAboutPopup = _this.closeAboutPopup.bind(_this);
	
	        _this.onMeasurePointsButtonPressed = _this.onMeasurePointsButtonPressed.bind(_this);
	        _this.onMeasureBetweenShapesButtonPressed = _this.onMeasureBetweenShapesButtonPressed.bind(_this);
	        _this.onPanByDragPressed = _this.onPanByDragPressed.bind(_this);
	
	        _this.handleKeyDown = _this.handleKeyDown.bind(_this);
	        _this.handleKeyUp = _this.handleKeyUp.bind(_this);
	
	        _this.aabbToolNext = _this.aabbToolNext.bind(_this);
	        _this.nextAabbDistStep = _this.nextAabbDistStep.bind(_this);
	        _this.onCollisionDemoButtonPressed = _this.onCollisionDemoButtonPressed.bind(_this);
	        _this.onSkeletonRecognitionButtonPressed = _this.onSkeletonRecognitionButtonPressed.bind(_this);
	        return _this;
	    }
	
	    _createClass(MainComponent, [{
	        key: 'registerStage',
	        value: function registerStage(stage) {
	            // let layer = Layers.newLayer(stage, this.state.layers);
	            this.dispatch({
	                type: ActionTypes.NEW_STAGE_CREATED,
	                stage: stage
	            });
	        }
	    }, {
	        key: 'resizeStage',
	        value: function resizeStage() {
	            // alert("resized")
	            this.dispatch({
	                type: ActionTypes.STAGE_RESIZED,
	                stage: this.state.stage
	            });
	        }
	    }, {
	        key: 'toggleUnits',
	        value: function toggleUnits() {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_UNITS_CLICKED
	            });
	        }
	    }, {
	        key: 'handleMouseMove',
	        value: function handleMouseMove(stageX, stageY) {
	            this.dispatch({
	                type: ActionTypes.MOUSE_MOVED_ON_STAGE,
	                stage: this.state.stage,
	                x: stageX,
	                y: stageY,
	                dx: this.state.mouse.startX ? stageX - this.state.mouse.startX : undefined,
	                dy: this.state.mouse.startY ? stageY - this.state.mouse.startY : undefined
	            });
	        }
	    }, {
	        key: 'handleMouseDown',
	        value: function handleMouseDown(stageX, stageY) {
	            // start pan stage
	            this.dispatch({
	                type: ActionTypes.MOUSE_DOWN_ON_STAGE,
	                stage: this.state.stage,
	                x: stageX,
	                y: stageY
	            });
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(stageX, stageY) {
	            // stop pan stage
	            // Patch bug in Firefox when dispatch is not fired
	            this.state.stage.panByMouseStop();
	            this.dispatch({
	                type: ActionTypes.MOUSE_UP_ON_STAGE,
	                state: this.state.stage,
	                x: event.stageX,
	                y: event.stageY
	            });
	        }
	    }, {
	        key: 'handleMouseWheelMove',
	        value: function handleMouseWheelMove(stageX, stageY, delta) {
	            if (delta !== 0) {
	                this.dispatch({
	                    type: ActionTypes.MOUSE_WHEEL_MOVE_ON_STAGE,
	                    stage: this.state.stage,
	                    x: stageX,
	                    y: stageY,
	                    delta: delta
	                });
	            }
	        }
	    }, {
	        key: 'onMouseRollOverShape',
	        value: function onMouseRollOverShape(shape) {
	            this.dispatch({
	                type: ActionTypes.MOUSE_ROLL_OVER_SHAPE,
	                shape: shape
	            });
	        }
	    }, {
	        key: 'onMouseRollOutShape',
	        value: function onMouseRollOutShape() {
	            this.dispatch({
	                type: ActionTypes.MOUSE_ROLL_OUT_SHAPE
	            });
	        }
	    }, {
	        key: 'onClickOnShape',
	        value: function onClickOnShape(shape, layer) {
	            this.dispatch({
	                type: ActionTypes.MOUSE_CLICKED_ON_SHAPE,
	                shape: shape,
	                layer: layer
	            });
	        }
	    }, {
	        key: 'handleFileSelect',
	        value: function handleFileSelect(event) {
	            if (!(File && FileReader && FileList)) return;
	
	            var files = event.target.files; // FileList object
	
	            this.dispatch({
	                type: ActionTypes.FILENAME_LIST_SELECTED,
	                files: files,
	                stage: this.state.stage,
	                layers: this.state.layers
	            });
	        }
	    }, {
	        key: 'setHomeView',
	        value: function setHomeView() {
	            var layer = _layers.Layers.getAffected(this.state.layers);
	            if (!layer) return;
	            // TODO: dispatch PAN_AND_ZOOM instead ?
	            this.dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                stage: this.state.stage,
	                shape: layer
	            });
	        }
	    }, {
	        key: 'onPanByDragPressed',
	        value: function onPanByDragPressed() {
	            this.dispatch({
	                type: ActionTypes.PAN_BY_DRAG_BUTTON_CLICKED
	            });
	        }
	    }, {
	        key: 'toggleWidthMode',
	        value: function toggleWidthMode() {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_WIDTH_MODE_CLICKED,
	                widthOn: this.state.app.widthOn
	            });
	        }
	    }, {
	        key: 'toggleDisplayVertices',
	        value: function toggleDisplayVertices() {
	            // if (this.state.app.widthOn)
	            //     return;
	            this.dispatch({
	                type: ActionTypes.TOGGLE_DISPLAY_VERTICES_CLICKED
	            });
	        }
	    }, {
	        key: 'toggleDisplayLabels',
	        value: function toggleDisplayLabels() {
	            this.dispatch({
	                type: ActionTypes.TOGGLE_DISPLAY_LABELS_CLICKED
	            });
	        }
	    }, {
	        key: 'showAboutPopup',
	        value: function showAboutPopup() {
	            this.dispatch({
	                type: ActionTypes.SHOW_ABOUT_POPUP_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'closeAboutPopup',
	        value: function closeAboutPopup(event) {
	            this.dispatch({
	                type: ActionTypes.CLOSE_ABOUT_POPUP_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'onMeasurePointsButtonPressed',
	        value: function onMeasurePointsButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.MEASURE_POINTS_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'onMeasureBetweenShapesButtonPressed',
	        value: function onMeasureBetweenShapesButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.MEASURE_SHAPES_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'aabbToolNext',
	        value: function aabbToolNext() {
	            this.dispatch({
	                type: ActionTypes.AABB_TREE_NEXT_LEVEL
	            });
	        }
	    }, {
	        key: 'nextAabbDistStep',
	        value: function nextAabbDistStep() {
	            this.dispatch({
	                type: ActionTypes.AABB_DEMO_NEXT_DIST_STEP
	            });
	        }
	    }, {
	        key: 'onCollisionDemoButtonPressed',
	        value: function onCollisionDemoButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.COLLISION_DEMO_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'onSkeletonRecognitionButtonPressed',
	        value: function onSkeletonRecognitionButtonPressed() {
	            this.dispatch({
	                type: ActionTypes.SKELETON_RECOGNITION_BUTTON_PRESSED
	            });
	        }
	    }, {
	        key: 'handleKeyDown',
	        value: function handleKeyDown(e) {
	            // let ctrl = e.ctrlKey;
	            if (e.target.id !== "mainCanvas") return;
	            switch (e.code) {
	                case "KeyH":
	                    this.setHomeView();
	                    break;
	
	                case "KeyW":
	                    this.toggleWidthMode(); // toggle width On/Off in graphics model
	                    break;
	
	                case "KeyE":
	                    this.toggleDisplayVertices(); // toggle vertices On/Off
	                    break;
	
	                case "ArrowRight":
	                    this.nextAabbDistStep();
	                    break;
	
	                case "ArrowLeft":
	                    break;
	                case "ArrowUp":
	                    break;
	                case "ArrowDown":
	                    break;
	                default:
	                    break;
	            }
	        }
	    }, {
	        key: 'handleKeyUp',
	        value: function handleKeyUp(event) {}
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            this.dispatch = this.props.store.dispatch;
	            this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            window.onresize = this.resizeStage;
	            // Keyboard event
	            // var _keydown = _.throttle(this.keydown, 100);
	            document.addEventListener('keydown', this.handleKeyDown);
	            // var _keyup = _.throttle(this.keyup, 500);
	            document.addEventListener('keyup', this.handleKeyUp);
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState(nextProps.store.getState());
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'main',
	                { className: 'App-content' },
	                _react2.default.createElement(_toolbarComponent.ToolbarComponent, {
	                    units: this.state.app.units,
	                    aabbDemoToolActivated: this.state.aabbDemoTool.aabbDemoToolActivated,
	                    showCollisionDemoToolButton: this.state.collisionDistanceDemoTool.showCollisionDemoToolButton,
	                    showSkeletonRecognitionButton: this.state.app.showSkeletonRecognitionButton,
	                    onFileSelected: this.handleFileSelect,
	                    onHomeButtonPressed: this.setHomeView,
	                    onPanByDragPressed: this.onPanByDragPressed,
	                    onMeasurePointsButtonPressed: this.onMeasurePointsButtonPressed,
	                    onMeasureBetweenShapesButtonPressed: this.onMeasureBetweenShapesButtonPressed,
	                    onToggleWidthModePressed: this.toggleWidthMode,
	                    onToggleVerticesPressed: this.toggleDisplayVertices,
	                    onToggleLabelsPressed: this.toggleDisplayLabels,
	                    onShowAboutPopupPressed: this.showAboutPopup,
	                    onAabbToolNext: this.aabbToolNext,
	                    onCollisionDemoButtonPressed: this.onCollisionDemoButtonPressed,
	                    onSkeletonRecognitionButtonPressed: this.onSkeletonRecognitionButtonPressed,
	                    onUnitClicked: this.toggleUnits
	                }),
	                _react2.default.createElement(_canvasComponent.CanvasComponent, {
	                    stage: this.state.stage,
	                    onStageCreated: this.registerStage,
	                    onMouseDown: this.handleMouseDown,
	                    onMouseMove: this.handleMouseMove,
	                    onMouseUp: this.handleMouseUp,
	                    onMouseWheelMove: this.handleMouseWheelMove
	                }),
	                _react2.default.createElement(_stageComponent.StageComponent, {
	                    stage: this.state.stage,
	                    layers: this.state.layers,
	                    displayVertices: this.state.app.displayVertices,
	                    displayLabels: this.state.app.displayLabels,
	                    widthOn: this.state.app.widthOn,
	                    zoomFactor: this.state.app.zoomFactor,
	                    originX: this.state.app.originX,
	                    originY: this.state.app.originY,
	                    hoveredShape: this.state.measureShapesTool.hoveredShape,
	                    firstMeasuredShape: this.state.measureShapesTool.firstMeasuredShape,
	                    secondMeasuredShape: this.state.measureShapesTool.secondMeasuredShape,
	                    firstMeasuredLayer: this.state.measureShapesTool.firstMeasuredLayer,
	                    secondMeasuredLayer: this.state.measureShapesTool.secondMeasuredLayer,
	                    distance: this.state.measureShapesTool.distance,
	                    shortestSegment: this.state.measureShapesTool.shortestSegment,
	                    aabbDemoToolActivated: this.state.aabbDemoTool.aabbDemoToolActivated,
	                    firstMeasuredShapeLevel: this.state.aabbDemoTool.firstMeasuredShapeLevel,
	                    secondMeasuredShapeLevel: this.state.aabbDemoTool.secondMeasuredShapeLevel,
	                    selectedEdgesTree: this.state.aabbDemoTool.tree,
	                    minStop: this.state.aabbDemoTool.min_stop,
	                    collisionDistanceDemoToolActivated: this.state.collisionDistanceDemoTool.collisionDistanceDemoToolActivated,
	                    units: this.state.app.units,
	                    divisor: this.state.app.divisor,
	                    decimals: this.state.app.decimals,
	                    coordX: this.state.mouse.x,
	                    coordY: this.state.mouse.y,
	                    onMouseOver: this.onMouseRollOverShape,
	                    onMouseOut: this.onMouseRollOutShape,
	                    onClick: this.onClickOnShape
	                }),
	                this.state.app.measurePointsActive ? _react2.default.createElement(_measurePointsTool.MeasurePointsTool, {
	                    stage: this.state.stage,
	                    divisor: this.state.app.divisor,
	                    decimals: this.state.app.decimals,
	                    onMouseWheelMove: this.handleMouseWheelMove
	                }) : null,
	                _react2.default.createElement(_statusComponent.StatusComponent, {
	                    stage: this.state.stage,
	                    units: this.state.app.units,
	                    divisor: this.state.app.divisor,
	                    decimals: this.state.app.decimals,
	                    distance: this.state.measureShapesTool.distance,
	                    shortestSegment: this.state.measureShapesTool.shortestSegment,
	                    coordX: this.state.mouse.x,
	                    coordY: this.state.mouse.y,
	                    onUnitClicked: this.toggleUnits
	                }),
	                this.state.app.showAboutPopup ? _react2.default.createElement(
	                    _modalPopupComponent.Modal,
	                    null,
	                    _react2.default.createElement(_aboutPopup.AboutPopup, {
	                        title: this.state.app.title,
	                        version: this.state.app.version,
	                        build: this.state.app.build,
	                        onCloseAboutPopupPressed: this.closeAboutPopup
	                    })
	                ) : null
	            );
	        }
	    }]);

	    return MainComponent;
	}(_react.Component);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ShapeComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _graphics = __webpack_require__(7);
	
	var _utils = __webpack_require__(9);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 19/06/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var ShapeComponent = exports.ShapeComponent = function (_Component) {
	    _inherits(ShapeComponent, _Component);
	
	    function ShapeComponent(params) {
	        _classCallCheck(this, ShapeComponent);
	
	        var _this = _possibleConstructorReturn(this, (ShapeComponent.__proto__ || Object.getPrototypeOf(ShapeComponent)).call(this));
	
	        _this.shape = new createjs.Shape();
	        params.stage.addChild(_this.shape);
	
	        _this.vertexShapes = [];
	        _this.labelShape = undefined;
	
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = params.model.geom.vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var vertex = _step.value;
	
	                var vertexShape = new createjs.Shape();
	                vertexShape.geom = vertex; // augment Shape with geom struct
	                vertexShape.mouseEnabled = false;
	                params.stage.addChild(vertexShape);
	                _this.vertexShapes.push(vertexShape);
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        if (params.model.label && params.model.label.trim() !== "") {
	            var html = document.createElement('div');
	            html.innerText = params.model.label;
	            html.style.position = "absolute";
	            html.style.top = 0;
	            html.style.left = 0;
	
	            document.body.appendChild(html);
	
	            _this.labelShape = new createjs.DOMElement(html);
	
	            _this.labelShape.geom = params.model.geom; // augment label Shape with geom struct
	            params.stage.addChild(_this.labelShape);
	        }
	
	        // this.handleMouseMove = this.handleMouseMove.bind(this);
	        _this.handleMouseOver = _this.handleMouseOver.bind(_this);
	        _this.handleMouseOut = _this.handleMouseOut.bind(_this);
	        _this.handleClick = _this.handleClick.bind(_this);
	        return _this;
	    }
	
	    _createClass(ShapeComponent, [{
	        key: 'handleMouseOver',
	        value: function handleMouseOver(event) {
	            this.props.onMouseOver(this.props.model);
	        }
	    }, {
	        key: 'handleMouseOut',
	        value: function handleMouseOut(event) {
	            this.props.onMouseOut();
	        }
	    }, {
	        key: 'handleClick',
	        value: function handleClick(event) {
	            this.props.onClick(this.props.model, this.props.layer);
	        }
	    }, {
	        key: 'redrawVertices',
	        value: function redrawVertices(stroke, fill, alpha) {
	            var stage = this.props.stage;
	
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.vertexShapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var vertexShape = _step2.value;
	
	                    var vertex = vertexShape.geom;
	                    if (vertexShape.graphics.isEmpty()) {
	                        vertexShape.graphics = (0, _graphics.graphics)(vertex, // vertex.graphics({
	                        {
	                            stroke: stroke, // this.props.color,
	                            fill: fill,
	                            radius: 3. / (stage.zoomFactor * stage.resolution)
	                        });
	                    } else {
	                        vertexShape.graphics.circle.radius = 3. / (stage.zoomFactor * stage.resolution);
	                        vertexShape.graphics.fill.style = fill;
	                    }
	                    vertexShape.alpha = alpha;
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'redrawLabels',
	        value: function redrawLabels(showLabel) {
	            if (!this.labelShape) return;
	
	            var stage = this.props.stage;
	
	            this.labelShape.htmlElement.style.display = showLabel ? "block" : "none";
	
	            var box = this.props.model.geom.box;
	            var point = { x: (box.xmin + box.xmax) / 2, y: (box.ymin + box.ymax) / 2 };
	            var dx = 6. / (stage.zoomFactor * stage.resolution);
	            var dy = 4. / (stage.zoomFactor * stage.resolution);
	
	            this.labelShape.htmlElement.style.font = "16px Arial";
	            var unscale = 1. / (stage.zoomFactor * stage.resolution);
	            var tx = stage.canvas.offsetLeft / (stage.zoomFactor * stage.resolution) + point.x + dx;
	            var ty = -stage.canvas.offsetTop / (stage.zoomFactor * stage.resolution) + point.y + dy;
	            this.labelShape.setTransform(tx, ty, unscale, -unscale);
	        }
	    }, {
	        key: 'redraw',
	        value: function redraw() {
	            // Draw shape
	            var stage = this.props.stage;
	            var color = this.props.hovered || this.props.selected ? "black" : this.props.color;
	            var alpha = this.props.hovered || this.props.selected ? 1.0 : 0.6;
	            var widthOn = this.props.widthOn;
	
	            var strokeStyle = this.props.model.geom.aperture ? this.props.model.geom.aperture : undefined;
	            var fill = widthOn && !this.props.displayVertices ? this.props.color : "white";
	
	            if (this.shape.graphics.isEmpty()) {
	                this.shape.graphics = (0, _graphics.graphics)(this.props.model.geom, {
	                    strokeStyle: strokeStyle,
	                    ignoreScale: true,
	                    stroke: color,
	                    fill: fill,
	                    radius: 3. / (stage.zoomFactor * stage.resolution)
	                });
	
	                // this.skeletonShape = new createjs.Shape();
	                // this.skeletonShape.graphics = this.props.model.geom.graphics({
	                //     strokeStyle: 1,
	                //     ignoreScale: true,
	                //     stroke: color,
	                //     fill: fill,
	                //     radius: 3. / (stage.zoomFactor * stage.resolution)
	                // });
	                // this.skeletonShape.alpha = 1;
	                // this.props.stage.addChild(this.skeletonShape);
	            } else {
	                if (this.shape.graphics.stroke) this.shape.graphics.stroke.style = color;
	                if (this.shape.graphics.fill) this.shape.graphics.fill.style = fill;
	                if (this.shape.graphics.circle) this.shape.graphics.circle.radius = 3. / (stage.zoomFactor * stage.resolution);
	            }
	            this.shape.alpha = this.props.displayed ? alpha : 0.0;
	
	            // let box = this.props.model.geom.box;
	            // this.shape.cache(box.xmin, box.ymin, box.xmax - box.xmin, box.ymax - box.ymin);
	
	            // Draw vertices
	            alpha = this.props.displayed && this.props.displayVertices ? 1.0 : 0.0;
	            this.redrawVertices(color, color, alpha);
	
	            // Draw labels
	            var showLabel = this.props.displayed && this.props.displayLabels;
	            this.redrawLabels(showLabel);
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.shape.on("mouseover", this.handleMouseOver);
	            this.shape.on("mouseout", this.handleMouseOut);
	            this.shape.on("click", this.handleClick);
	
	            // this.shape.mouseEnabled = false;
	
	            this.redraw();
	        }
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            if (_utils2.default.is_equal(this.props, nextProps)) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.redraw();
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            this.shape.off("mouseover", this.handleMouseOver);
	            this.shape.off("mouseout", this.handleMouseOut);
	            this.shape.off("click", this.handleClick);
	            this.props.stage.removeChild(this.shape);
	            this.shape.graphics.clear();
	            this.props.stage.removeChild(this.labelShape);
	            this.labelShape = undefined;
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = this.vertexShapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var vertexShape = _step3.value;
	
	                    this.props.stage.removeChild(vertexShape);
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            this.vertexShapes = [];
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return ShapeComponent;
	}(_react.Component);

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.StageComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _layerComponent = __webpack_require__(36);
	
	var _measureShapesTool = __webpack_require__(69);
	
	var _aabbDemoTool = __webpack_require__(65);
	
	var _collisionDistanceDemoTool = __webpack_require__(66);
	
	var _displayCoordsTool = __webpack_require__(67);
	
	var _utils = __webpack_require__(9);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var StageComponent = exports.StageComponent = function (_Component) {
	    _inherits(StageComponent, _Component);
	
	    function StageComponent() {
	        _classCallCheck(this, StageComponent);
	
	        return _possibleConstructorReturn(this, (StageComponent.__proto__ || Object.getPrototypeOf(StageComponent)).apply(this, arguments));
	    }
	
	    _createClass(StageComponent, [{
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            if (_utils2.default.is_equal(this.props, nextProps)) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.props.stage.canvas && this.props.stage.canvas.getContext('2d')) {
	
	                var origin = this.props.stage.origin;
	                var zoomFactor = this.props.stage.zoomFactor * this.props.stage.resolution;
	                this.props.stage.setTransform(origin.x, origin.y, zoomFactor, -zoomFactor);
	
	                this.props.stage.update();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            var layerComponents = this.props.layers.map(function (layer) {
	                return _react2.default.createElement(_layerComponent.LayerComponent, {
	                    key: layer.name,
	                    stage: _this2.props.stage,
	                    layer: layer,
	                    color: layer.color,
	                    displayed: layer.displayed,
	                    displayVertices: _this2.props.displayVertices,
	                    displayLabels: _this2.props.displayLabels,
	                    widthOn: _this2.props.widthOn,
	                    hoveredShape: _this2.props.hoveredShape,
	                    firstMeasuredShape: _this2.props.firstMeasuredShape,
	                    secondMeasuredShape: _this2.props.secondMeasuredShape,
	                    zoomFactor: _this2.props.zoomFactor,
	                    onMouseOver: _this2.props.onMouseOver,
	                    onMouseOut: _this2.props.onMouseOut,
	                    onClick: _this2.props.onClick
	                });
	            });
	
	            var displayCoordsTool = this.props.stage ? _react2.default.createElement(_displayCoordsTool.DisplayCoordsTool, {
	                key: 'displayCoordinatedTool',
	                stage: this.props.stage,
	                units: this.props.units,
	                divisor: this.props.divisor,
	                decimals: this.props.decimals,
	                coordX: this.props.coordX,
	                coordY: this.props.coordY
	            }) : null;
	
	            var measuredLayersDisplayed = this.props.firstMeasuredShape && this.props.secondMeasuredShape && this.props.firstMeasuredLayer.displayed && this.props.secondMeasuredLayer.displayed;
	
	            var measureShapesTool = this.props.distance && this.props.shortestSegment && measuredLayersDisplayed ? _react2.default.createElement(_measureShapesTool.MeasureShapesTool, {
	                key: 'MeasureShapesTool',
	                stage: this.props.stage,
	                firstMeasuredShape: this.props.firstMeasuredShape,
	                secondMeasuredShape: this.props.secondMeasuredShape,
	                firstMeasuredLayer: this.props.firstMeasuredLayer,
	                secondMeasuredLayer: this.props.secondMeasuredLayer,
	                distance: this.props.distance,
	                shortestSegment: this.props.shortestSegment,
	                divisor: this.props.divisor,
	                decimals: this.props.decimals
	            }) : null;
	
	            var aabbDdemoTool = this.props.aabbDemoToolActivated ? _react2.default.createElement(_aabbDemoTool.AabbDemoTool, {
	                key: 'AabbDemoTool',
	                stage: this.props.stage,
	                firstMeasuredShape: this.props.firstMeasuredShape,
	                secondMeasuredShape: this.props.secondMeasuredShape,
	                firstMeasuredLayer: this.props.firstMeasuredLayer,
	                secondMeasuredLayer: this.props.secondMeasuredLayer,
	                firstMeasuredShapeLevel: this.props.firstMeasuredShapeLevel,
	                secondMeasuredShapeLevel: this.props.secondMeasuredShapeLevel,
	                distance: this.props.distance,
	                shortestSegment: this.props.shortestSegment,
	                selectedEdgesTree: this.props.selectedEdgesTree,
	                minStop: this.props.minStop
	            }) : null;
	
	            var collisionDemoTool = this.props.collisionDistanceDemoToolActivated ? _react2.default.createElement(_collisionDistanceDemoTool.CollisionDistanceDemoTool, {
	                key: 'CollisionDemoTool',
	                stage: this.props.stage,
	                firstMeasuredShape: this.props.firstMeasuredShape,
	                secondMeasuredShape: this.props.secondMeasuredShape,
	                firstMeasuredLayer: this.props.firstMeasuredLayer,
	                secondMeasuredLayer: this.props.secondMeasuredLayer
	            }) : null;
	
	            var components = [].concat(_toConsumableArray(layerComponents), [displayCoordsTool, measureShapesTool, aabbDdemoTool, collisionDemoTool]);
	
	            return components;
	        }
	    }]);

	    return StageComponent;
	}(_react.Component);

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.StatusComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/06/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	// import '../App.css';
	
	var StatusComponent = exports.StatusComponent = function (_Component) {
	    _inherits(StatusComponent, _Component);
	
	    function StatusComponent() {
	        _classCallCheck(this, StatusComponent);
	
	        return _possibleConstructorReturn(this, (StatusComponent.__proto__ || Object.getPrototypeOf(StatusComponent)).apply(this, arguments));
	    }
	
	    _createClass(StatusComponent, [{
	        key: "measurement",
	        value: function measurement() {
	            var message = "";
	            if (this.props.shortestSegment && this.props.distance) {
	                var segment = this.props.shortestSegment;
	                var dx = segment.end.x - segment.start.x;
	                var dy = segment.end.y - segment.start.y;
	                var dist = this.props.distance;
	
	                message = "DX=" + this.format(dx) + ",DY=" + this.format(dy) + ",D=" + this.format(dist);
	            }
	            return message;
	        }
	    }, {
	        key: "format",
	        value: function format(num) {
	            return (num / this.props.divisor).toFixed(this.props.decimals);
	        }
	    }, {
	        key: "render",
	        value: function render() {
	            // let stage = this.props.stage;
	            // let coordX = 0;
	            // let coordY = 0;
	            // if (stage) {
	            //     coordX = this.format(stage.C2W_X(this.props.coordX));
	            //     coordY = this.format(stage.C2W_Y(this.props.coordY));
	            // }
	            // let message = this.measurement();
	
	            return _react2.default.createElement(
	                "div",
	                { className: "App-status-bar" },
	                _react2.default.createElement(
	                    "div",
	                    { style: { flex: 6, textAlign: "left", marginLeft: 10, padding: 5 } },
	                    _react2.default.createElement(
	                        "h5",
	                        { style: { margin: 0, padding: 0 } },
	                        "\xA0"
	                    )
	                )
	            );
	        }
	    }]);
	
	    return StatusComponent;
	}(_react.Component);
	
	/*
	                <div style={{flex: 4, textAlign: "left", marginLeft: 10, padding: 5}}>
	                    <h5>
	                        {`X: ${coordX} Y: ${coordY}`}
	                    </h5>
	                </div>

	                <div style={{flex: 6, textAlign: "left", marginLeft: 10, padding: 5}}>
	                    <h5>
	                        {message}
	                    </h5>
	                </div>

	                <button
	                    style={{flex: 2, height: "50%", margin: 5, border: "1px", backgroundColor: "inherit"}}
	                    onClick={this.props.onUnitClicked}
	                >
	                    <h3>Units</h3>
	                </button>
	                <h5 style={{flex: 2, height: "50%", margin: 5}}>
	                    {this.props.units}
	                </h5>

	 */

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ToolbarComponent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactFontawesome = __webpack_require__(24);
	
	var _reactFontawesome2 = _interopRequireDefault(_reactFontawesome);
	
	var _measureContour = __webpack_require__(124);
	
	var _measureContour2 = _interopRequireDefault(_measureContour);
	
	var _measurePoints = __webpack_require__(125);
	
	var _measurePoints2 = _interopRequireDefault(_measurePoints);
	
	var _WidthOn = __webpack_require__(122);
	
	var _WidthOn2 = _interopRequireDefault(_WidthOn);
	
	var _editContourVertextOnOff = __webpack_require__(123);
	
	var _editContourVertextOnOff2 = _interopRequireDefault(_editContourVertextOnOff);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import open from '../../public/icons/Browse.png';
	// import home from '../../public/icons/homeIcon20x20.png';
	// import pan from '../../public/icons/handDrag20.png';
	
	// import label from '../../public/icons/label_icon.png';
	// import setting from '../../public/icons/Setting.png';
	// import about from '../../public/icons/About.png';
	
	var ToolbarComponent = exports.ToolbarComponent = function (_Component) {
	    _inherits(ToolbarComponent, _Component);
	
	    function ToolbarComponent() {
	        _classCallCheck(this, ToolbarComponent);
	
	        var _this = _possibleConstructorReturn(this, (ToolbarComponent.__proto__ || Object.getPrototypeOf(ToolbarComponent)).call(this));
	
	        _this.openJobButtonClicked = _this.openJobButtonClicked.bind(_this);
	        _this.notImplemented = _this.notImplemented.bind(_this);
	        return _this;
	    }
	
	    _createClass(ToolbarComponent, [{
	        key: 'openJobButtonClicked',
	        value: function openJobButtonClicked() {
	            document.getElementById("browseFiles").click();
	        }
	    }, {
	        key: 'notImplemented',
	        value: function notImplemented() {
	            alert("Not implemented yet");
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'App-toolbar' },
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Open file', onClick: this.openJobButtonClicked },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'folder-open-o',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement('input', { style: { fontSize: 16, marginTop: 5, marginBottom: 5, display: "none" },
	                    type: 'file', id: 'browseFiles', name: 'files[]', multiple: true,
	                    onChange: this.props.onFileSelected
	                }),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Zoom and pan to home view', onClick: this.props.onHomeButtonPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'home',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Pan by drag', onClick: this.props.onPanByDragPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'arrows',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Measure distance between points', onClick: this.props.onMeasurePointsButtonPressed },
	                    _react2.default.createElement('img', { src: _measurePoints2.default, alt: 'measurePoints' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Measure distance between shapes', onClick: this.props.onMeasureBetweenShapesButtonPressed },
	                    _react2.default.createElement('img', { src: _measureContour2.default, alt: 'measureShapes' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Display solid or wire', onClick: this.props.onToggleWidthModePressed },
	                    _react2.default.createElement('img', { src: _WidthOn2.default, alt: 'width' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Display vertices on/off', onClick: this.props.onToggleVerticesPressed },
	                    _react2.default.createElement('img', { src: _editContourVertextOnOff2.default, alt: 'vertices' })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    { title: 'Display labels on/off', onClick: this.props.onToggleLabelsPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'tag',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                this.props.aabbDemoToolActivated ? _react2.default.createElement(
	                    'button',
	                    { title: 'AABB Tree Demo', onClick: this.props.onAabbToolNext },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'tree',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ) : null,
	                this.props.showCollisionDemoToolButton ? _react2.default.createElement(
	                    'button',
	                    { title: 'Collision Distance Demo', onClick: this.props.onCollisionDemoButtonPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'arrows-h',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ) : null,
	                this.props.showSkeletonRecognitionButton ? _react2.default.createElement(
	                    'button',
	                    { title: 'Skeleton Recognition Demo', onClick: this.props.onSkeletonRecognitionButtonPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'tree',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ) : null,
	                _react2.default.createElement(
	                    'button',
	                    { title: 'About', onClick: this.props.onShowAboutPopupPressed },
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'info',
	                        size: '2x',
	                        style: { color: "grey" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'button',
	                    null,
	                    _react2.default.createElement(_reactFontawesome2.default, {
	                        name: 'ellipsis-v',
	                        size: '2x',
	                        style: { color: "white" }
	                    })
	                ),
	                _react2.default.createElement(
	                    'span',
	                    { style: { position: "relative", top: -3 } },
	                    'Units:'
	                ),
	                _react2.default.createElement(
	                    'button',
	                    {
	                        style: { position: "relative", top: -3 },
	                        onClick: this.props.onUnitClicked
	                    },
	                    _react2.default.createElement(
	                        'h3',
	                        null,
	                        this.props.units
	                    )
	                )
	            );
	        }
	    }]);
	
	    return ToolbarComponent;
	}(_react.Component);
	
	;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AboutPopup = undefined;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	
	var AboutPopup = exports.AboutPopup = function AboutPopup(props) {
	    var offsetX = void 0,
	        offsetY = void 0;
	    var dragX = void 0,
	        dragY = void 0;
	
	    var onCloseButtonPressed = function onCloseButtonPressed() {
	        props.onCloseAboutPopupPressed();
	    };
	
	    var handleKeyDown = function handleKeyDown(ev) {
	        if (ev.code === "Escape") {
	            props.onCloseAboutPopupPressed();
	        }
	    };
	
	    var elementDrag = function elementDrag(ev) {
	        ev = ev || window.event;
	        // calculate the new cursor position:
	        offsetX = dragX - ev.clientX;
	        offsetY = dragY - ev.clientY;
	        dragX = ev.clientX;
	        dragY = ev.clientY;
	        // set the element's new position:
	        var element = ev.target;
	        element.style.top = element.offsetTop - offsetY + "px";
	        element.style.left = element.offsetLeft - offsetX + "px";
	    };
	
	    var closeDragElement = function closeDragElement(ev) {
	        /* stop moving when mouse button is released:*/
	        ev.target.onmouseup = null;
	        ev.target.onmousemove = null;
	    };
	
	    var dragMouseDown = function dragMouseDown(ev) {
	        ev = ev || window.event;
	        // get the mouse cursor position at startup:
	        dragX = ev.clientX;
	        dragY = ev.clientY;
	        ev.target.onmouseup = closeDragElement;
	        // call a function whenever the cursor moves:
	        ev.target.onmousemove = elementDrag;
	    };
	
	    document.addEventListener('keydown', handleKeyDown);
	
	    return _react2.default.createElement(
	        'div',
	        { className: 'modal' },
	        _react2.default.createElement(
	            'div',
	            { className: 'App-modal-popup',
	                id: 'aboutPopup',
	                onMouseDown: dragMouseDown,
	                onMouseMove: elementDrag
	            },
	            _react2.default.createElement(
	                'h2',
	                null,
	                props.title,
	                ' v',
	                props.version
	            ),
	            _react2.default.createElement(
	                'h4',
	                null,
	                'Build 362de89c 25/02/2018'
	            ),
	            _react2.default.createElement(
	                'button',
	                { onClick: onCloseButtonPressed },
	                'Close'
	            )
	        )
	    );
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LayerEditForm = undefined;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by alexanderbol on 13/04/2017.
	 */
	
	var LayerEditForm = exports.LayerEditForm = function LayerEditForm(props) {
	    var onSubmitLayerEditForm = function onSubmitLayerEditForm(ev) {
	        ev.stopPropagation();
	        ev.preventDefault();
	        var form = ev.target.parentElement;
	        var newLayer = Object.assign({}, props.layer, {
	            name: form.layerName.value,
	            title: form.layerTitle.value
	        });
	        props.onSubmitLayerEditForm(props.layer, newLayer);
	        return false;
	    };
	    var setFocus = function setFocus(ev) {
	        ev.stopPropagation();
	        ev.target.focus();
	    };
	
	    var onCancelLayerEditForm = function onCancelLayerEditForm() {
	        props.onEscapeLayerEditForm(props.layer);
	    };
	
	    var handleKeyDown = function handleKeyDown(ev) {
	        if (ev.code === "Escape") {
	            props.onEscapeLayerEditForm(props.layer);
	        }
	    };
	
	    document.addEventListener('keydown', handleKeyDown);
	
	    return _react2.default.createElement(
	        'div',
	        { className: 'modal' },
	        _react2.default.createElement(
	            'form',
	            { className: 'App-modal-popup App-layer-edit-form',
	                id: 'layerEditForm',
	                draggable: 'true',
	                onSubmit: onSubmitLayerEditForm
	            },
	            _react2.default.createElement(
	                'label',
	                null,
	                'Layer name:'
	            ),
	            _react2.default.createElement('br', null),
	            _react2.default.createElement('input', { type: 'text', id: 'layer-name', name: 'layerName', size: '80', defaultValue: props.layer.name, onClick: setFocus }),
	            _react2.default.createElement('br', null),
	            _react2.default.createElement(
	                'label',
	                null,
	                'Layer info:'
	            ),
	            _react2.default.createElement('br', null),
	            _react2.default.createElement('textarea', { id: 'layer-title', name: 'layerTitle', cols: '78', rows: '3', defaultValue: props.layer.title, onClick: setFocus }),
	            _react2.default.createElement('br', null),
	            _react2.default.createElement(
	                'button',
	                { onClick: onCancelLayerEditForm },
	                'Cancel'
	            ),
	            _react2.default.createElement(
	                'button',
	                { onClick: onSubmitLayerEditForm },
	                'OK'
	            )
	        )
	    );
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(23);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _App = __webpack_require__(31);
	
	__webpack_require__(70);
	
	var _redux = __webpack_require__(27);
	
	var _reducer = __webpack_require__(64);
	
	var _log = __webpack_require__(52);
	
	var _log2 = _interopRequireDefault(_log);
	
	var _readFiles = __webpack_require__(54);
	
	var _readFiles2 = _interopRequireDefault(_readFiles);
	
	var _pasteData = __webpack_require__(53);
	
	var _pasteData2 = _interopRequireDefault(_pasteData);
	
	var _stageController = __webpack_require__(56);
	
	var _stageController2 = _interopRequireDefault(_stageController);
	
	var _demo = __webpack_require__(51);
	
	var _demo2 = _interopRequireDefault(_demo);
	
	var _aabb_demo = __webpack_require__(48);
	
	var _aabb_demo2 = _interopRequireDefault(_aabb_demo);
	
	var _collision_demo = __webpack_require__(50);
	
	var _collision_demo2 = _interopRequireDefault(_collision_demo);
	
	var _boolean_test = __webpack_require__(49);
	
	var _boolean_test2 = _interopRequireDefault(_boolean_test);
	
	var _skeleton_recognition = __webpack_require__(55);
	
	var _skeleton_recognition2 = _interopRequireDefault(_skeleton_recognition);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import matrix_test from './middleware/matrix-test';
	// import webgl_test from './middleware/webgl-test';
	
	var store = (0, _redux.createStore)(_reducer.reducer, (0, _redux.compose)((0, _redux.applyMiddleware)(_log2.default, _readFiles2.default, _pasteData2.default, _demo2.default, _aabb_demo2.default, _collision_demo2.default, _boolean_test2.default, _skeleton_recognition2.default, _stageController2.default)));
	
	// import about from './middleware/about';
	
	
	_reactDom2.default.render(_react2.default.createElement(_App.App, { store: store }), document.getElementById('root'));

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	// import { parseXML } from "../models/parserXML";
	// import { Layers } from '../models/layers';
	// import { Model } from "../models/model";
	
	// let {point, arc, segment, circle, Polygon} = Flatten;
	
	var aabb_demo = function aabb_demo(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type === ActionTypes.NEW_STAGE_CREATED || action.type === ActionTypes.WINDOW_HASH_CHANGED) {
	                if (document.location.href.split('#')[1] === 'aabb_demo') {
	                    dispatch({
	                        type: ActionTypes.AABB_DEMO_URI
	                    });
	                }
	            }
	            return next(action);
	        };
	    };
	};
	
	exports.default = aabb_demo;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import { Model } from "../models/model";
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	var point = _flattenJs2.default.point,
	    Polygon = _flattenJs2.default.Polygon;
	// let {union, subtract, intersect, arrange} = BooleanOp;
	
	function zoomHome(shape, stage) {
	    var box = shape.box;
	    var x = (box.xmin + box.xmax) / 2;
	    var y = (box.ymin + box.ymax) / 2;
	    stage.panToCoordinate(x, y);
	    stage.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	}
	
	var boolean_test = function boolean_test(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type === ActionTypes.NEW_STAGE_CREATED) {
	                if (document.location.href.split('#')[1] === 'boolean_test') {
	
	                    var stage = action.stage;
	                    var state = getState();
	                    var layers = state.layers;
	
	                    var polygon1 = new Polygon();
	                    polygon1.addFace([point(-20, 0), point(-20, 20), point(20, 20), point(20, 0)]);
	
	                    var polygon2 = new Polygon();
	                    polygon2.addFace([point(-5, -10), point(-5, 30), point(5, 30), point(5, -10)]);
	
	                    var layer = _layers.Layers.newLayer(stage, layers);
	                    layer.name = "polygon1";
	                    layer.title = "data";
	
	                    layer.add(polygon1);
	                    layer.add(polygon2);
	
	                    // layer = Layers.newLayer(stage, layers);
	                    // layer.name = "polygon2";
	                    // layer.add(polygon2);
	                    // state.layers.push(layer);
	
	                    zoomHome(layer, stage);
	                    state.layers.push(layer);
	                }
	            }
	            return next(action);
	        };
	    };
	};
	
	exports.default = boolean_test;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Vector = _flattenJs2.default.Vector,
	    Polygon = _flattenJs2.default.Polygon;
	// import { Model } from "../models/model";
	// import file1 from '../../public/Block_53388_2parts_Cont.txt';
	// import {parseODB} from "../models/parserODB";
	
	var filename = "Block_53388_2parts_Cont.txt";
	// let filename = "polygon.txt";
	
	function zoomHome(shape, stage) {
	    var box = shape.box;
	    var x = (box.xmin + box.xmax) / 2;
	    var y = (box.ymin + box.ymax) / 2;
	    stage.panToCoordinate(x, y);
	    stage.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	}
	
	function translate(polygon, vec) {
	    var newPolygon = new Polygon();
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = polygon.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var face = _step.value;
	
	            var shapes = [];
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = face[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var edge = _step2.value;
	
	                    if (edge.shape instanceof Segment) {
	                        shapes.push(new Segment(edge.shape.ps.translate(vec), edge.shape.pe.translate(vec)));
	                    } else if (edge.shape instanceof Arc) {
	                        var arc_trans = edge.shape.clone();
	                        arc_trans.pc = edge.shape.pc.translate(vec);
	                        shapes.push(arc_trans);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            newPolygon.addFace(shapes);
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return newPolygon;
	}
	
	var collision_demo = function collision_demo(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type === ActionTypes.NEW_STAGE_CREATED || action.type === ActionTypes.WINDOW_HASH_CHANGED) {
	                if (document.location.href.split('#')[1] === 'collision_demo') {
	                    // let str = file1;
	                    // let text = atob(str.split(',')[1]);
	
	                    var stage = action.stage;
	                    var state = getState();
	
	                    var xhr = new XMLHttpRequest();
	                    var url = ("/debug-viewer") + '/' + filename;
	                    // let url = "./public/" + filename;
	                    xhr.open('GET', url, true);
	                    xhr.onreadystatechange = function (event) {
	                        if (this.readyState === 4 && this.status === 200) {
	                            var text = this.responseText;
	
	                            var layers = state.layers;
	                            var layer = _layers.Layers.newLayer(stage, layers);
	                            layer.name = "collision_demo";
	                            layer.title = "collision_demo";
	
	                            var parser = state.app.parser;
	                            var polygon = parser.parseToPolygon(text);
	                            layer.add(polygon);
	
	                            var vec = new Vector(2 * (polygon.box.xmax - polygon.box.xmin), 0);
	                            // let vec = new Vector(500000, 0);
	                            var trPolygon = translate(polygon, vec);
	                            layer.add(trPolygon);
	
	                            zoomHome(layer, stage);
	                            state.layers.push(layer);
	
	                            dispatch({
	                                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                stage: stage,
	                                shape: layer
	                            });
	
	                            dispatch({
	                                type: ActionTypes.COLLISION_DEMO_URI
	                            });
	                        }
	                    };
	                    xhr.send();
	                }
	            }
	            return next(action);
	        };
	    };
	};
	
	exports.default = collision_demo;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	var _model = __webpack_require__(11);
	
	var _parserODB = __webpack_require__(17);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	// let {point, arc, segment, circle, Polygon} = Flatten;
	
	function zoomHome(shape, stage) {
	    var box = shape.box;
	    var x = (box.xmin + box.xmax) / 2;
	    var y = (box.ymin + box.ymax) / 2;
	    stage.panToCoordinate(x, y);
	    stage.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	}
	
	var demo = function demo(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type === ActionTypes.NEW_STAGE_CREATED || action.type === ActionTypes.WINDOW_HASH_CHANGED) {
	                if (document.location.href.split('#')[1] === 'demo') {
	                    // console.log(document.location.pathname);
	                    // console.log(getState());
	
	                    var stage = action.stage;
	                    var state = getState();
	
	                    var layers = state.layers;
	                    var layer = _layers.Layers.newLayer(stage, layers);
	                    layer.name = "features";
	                    layer.title = "features";
	
	                    var xhr = new XMLHttpRequest();
	                    xhr.open('GET', ("/debug-viewer") + '/features', true);
	                    xhr.onreadystatechange = function (event) {
	                        if (this.readyState === 4 && this.status === 200) {
	                            var text = this.responseText;
	                            var job = (0, _parserODB.parseODB)("features", text);
	
	                            var _iteratorNormalCompletion = true;
	                            var _didIteratorError = false;
	                            var _iteratorError = undefined;
	
	                            try {
	                                for (var _iterator = job.shapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                    var shape = _step.value;
	
	                                    var model = new _model.Model(shape, undefined, shape.label);
	                                    layer.add(model);
	                                }
	                            } catch (err) {
	                                _didIteratorError = true;
	                                _iteratorError = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion && _iterator.return) {
	                                        _iterator.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError) {
	                                        throw _iteratorError;
	                                    }
	                                }
	                            }
	
	                            zoomHome(layer, stage);
	                            state.layers.push(layer);
	
	                            dispatch({
	                                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                stage: stage,
	                                shape: layer
	                            });
	                        }
	                    };
	                    xhr.send();
	                }
	            }
	            return next(action);
	        };
	    };
	};
	
	exports.default = demo;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var log = function log(_ref) {
	    var getState = _ref.getState,
	        dispatch = _ref.dispatch;
	    return function (next) {
	        return function (action) {
	
	            if (action.type !== ActionTypes.MOUSE_MOVED_ON_STAGE) {
	                console.log('ACTION: ' + action.type, action);
	            }
	
	            next(action);
	        };
	    };
	};
	
	exports.default = log;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var pasteData = function pasteData(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type !== ActionTypes.DATA_FROM_BUFFER_PASTED) {
	                return next(action);
	            }
	
	            var state = getState();
	            var stage = state.stage;
	            var layers = state.layers;
	            var parser = state.app.parser;
	
	            var layer = undefined;
	            if (state.app.importDataToNewLayer) {
	                // import data to new layer
	                layer = _layers.Layers.newLayer(stage, layers);
	                layers.push(layer);
	            } else {
	                // import data to affected layer
	                layer = layers.find(function (lay) {
	                    return lay.affected;
	                });
	                if (!layer) {
	                    // if no layer affected, add new
	                    layer = _layers.Layers.newLayer(stage, layers);
	                    layers.push(layer);
	                }
	            }
	
	            // Paste data from ClipBoard
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = action.data.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var item = _step.value;
	
	                    item.getAsString(function (string) {
	                        var shapesArray = parser.parse(string);
	
	                        // TODO: add something like poly.valid()
	
	                        if (shapesArray.length > 0) {
	                            var _iteratorNormalCompletion2 = true;
	                            var _didIteratorError2 = false;
	                            var _iteratorError2 = undefined;
	
	                            try {
	                                for (var _iterator2 = shapesArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                                    var shape = _step2.value;
	
	                                    layer.add(shape);
	                                }
	                            } catch (err) {
	                                _didIteratorError2 = true;
	                                _iteratorError2 = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                        _iterator2.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError2) {
	                                        throw _iteratorError2;
	                                    }
	                                }
	                            }
	                        }
	
	                        if (layer.shapes.length > 0) {
	                            dispatch({
	                                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                shape: layer,
	                                stage: stage
	                            });
	                            dispatch({
	                                type: ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED,
	                                layer: layer
	                            });
	                        }
	                    });
	
	                    break;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        };
	    };
	};
	
	exports.default = pasteData;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	var _model = __webpack_require__(11);
	
	var _parserXML = __webpack_require__(62);
	
	var _parserODB = __webpack_require__(17);
	
	var _parsePGM = __webpack_require__(60);
	
	var _parseCSV = __webpack_require__(59);
	
	var _parseTXT = __webpack_require__(61);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	// import { Shape } from '../models/shape';
	var readAsText = function readAsText(reader, file, stage, layers, dispatch, files) {
	
	    // Closure to capture file information and parameters
	    reader.onload = function (theFile, stage, layers, dispatch, files) {
	        return function (event) {
	            var string = event.target.result;
	
	            var namesplitted = theFile.name.split('.');
	            var extension = namesplitted[namesplitted.length - 1];
	            var job = void 0;
	            if (extension === 'xml') {
	                job = (0, _parserXML.parseXML)(theFile.name, string);
	            } else if (extension === 'csv') {
	                job = (0, _parseCSV.parseCSV)(theFile.name, string);
	            } else if (extension === 'txt') {
	                job = (0, _parseTXT.parseTXT)(theFile.name, string);
	            } else {
	                job = (0, _parserODB.parseODB)(theFile.name, string);
	            }
	            var layer = _layers.Layers.newLayer(stage, layers);
	            if (theFile.name !== "") {
	                layer.name = theFile.name;
	            }
	            layer.title = job.title;
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = job.profiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var polygon = _step.value;
	
	                    if (polygon.edges.size > 0 && polygon.faces.size > 0) {
	                        // let watch = undefined; //  parser.parseToWatchArray(string);
	                        // let shape = new Shape(polygon, stage, polygon.style, watch);
	                        var _shape = new _model.Model(polygon, undefined, polygon.label);
	
	                        layer.add(_shape);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = job.materials[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var _polygon = _step2.value;
	
	                    if (_polygon.edges.size > 0 && _polygon.faces.size > 0) {
	                        // let watch = undefined; //  parser.parseToWatchArray(string);
	                        // let shape = new Shape(polygon, stage, polygon.style, watch);
	                        var _shape2 = new _model.Model(_polygon, undefined, _polygon.label);
	
	                        layer.add(_shape2);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = job.shapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var shape = _step3.value;
	
	                    var model = new _model.Model(shape, undefined, shape.label);
	                    layer.add(model);
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            layers.push(layer);
	
	            if (theFile === files[0]) {
	                _layers.Layers.setAffected(layers, layer);
	                layer.color = _layers.Layers.getNextColor(layers);
	                layer.displayed = true;
	                dispatch({
	                    type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                    stage: stage,
	                    shape: layer
	                });
	            }
	        };
	    }(file, stage, layers, dispatch, files);
	
	    reader.readAsText(file);
	};
	
	var readAsImage = function readAsImage(reader, file, stage, layers, dispatch, files) {
	    reader.addEventListener("load", function () {
	        // let image = {};          // TODO: to be Flatten.Image
	        // image.uri = this.result;
	        // image.center = new Flatten.Point(0,0);
	        // image.width = 2*400000;    // 2 micron
	        // image.box = new Flatten.Box(
	        //     image.center.x - image.width/2,
	        //     image.center.y - image.width/2,
	        //     image.center.x + image.width/2,
	        //     image.center.y + image.width/2,
	        // );
	
	        var image = (0, _parsePGM.parseImage)(file);
	        image.uri = this.result;
	
	        var model = new _model.Model(image);
	
	        var layer = _layers.Layers.newLayer(stage, layers);
	        if (file.name !== "") {
	            layer.name = file.name;
	        }
	
	        layer.add(model);
	
	        layers.push(layer);
	
	        if (file === files[0]) {
	            _layers.Layers.setAffected(layers, layer);
	            layer.color = _layers.Layers.getNextColor(layers);
	            layer.displayed = true;
	            dispatch({
	                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                stage: stage,
	                shape: layer
	            });
	        } else {
	            dispatch({
	                type: ActionTypes.ADD_LAYER_PRESSED,
	                layer: layer
	            });
	        }
	    }, false);
	
	    reader.readAsDataURL(file);
	};
	
	var readFile = function readFile(file, stage, layers, dispatch, files) {
	    if (file.type !== "" && !(file.type.match('text.*') || file.type.match('application.*') || file.type.match('image.*'))) return; // validate type is text
	
	    var reader = new FileReader();
	
	    if (file.type.match('text.*') || file.type.match('application.*') || file.name.match('features*')) {
	        readAsText(reader, file, stage, layers, dispatch, files);
	    } else if (file.type.match('image.*')) {
	        readAsImage(reader, file, stage, layers, dispatch, files);
	    }
	};
	
	var readFiles = function readFiles(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type !== ActionTypes.FILENAME_LIST_SELECTED) {
	                return next(action);
	            }
	
	            var stage = action.stage;
	            var layers = action.layers;
	
	            // Load and parse files
	            var _iteratorNormalCompletion4 = true;
	            var _didIteratorError4 = false;
	            var _iteratorError4 = undefined;
	
	            try {
	                for (var _iterator4 = action.files[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                    var file = _step4.value;
	
	                    readFile(file, stage, layers, dispatch, action.files);
	                }
	            } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                        _iterator4.return();
	                    }
	                } finally {
	                    if (_didIteratorError4) {
	                        throw _iteratorError4;
	                    }
	                }
	            }
	        };
	    };
	};
	
	exports.default = readFiles;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _layers = __webpack_require__(5);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var Algorithmia = Window.Algorithmia;
	
	// import { Model } from "../models/model";
	
	var point = _flattenJs2.default.point,
	    arc = _flattenJs2.default.arc,
	    segment = _flattenJs2.default.segment;
	
	// function zoomHome(shape, stage) {
	//     let box = shape.box;
	//     let x = (box.xmin + box.xmax)/2;
	//     let y = (box.ymin + box.ymax)/2;
	//     stage.panToCoordinate(x, y);
	//     stage.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	// }
	
	var skeleton_recognition = function skeleton_recognition(_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	        return function (action) {
	
	            if (action.type === ActionTypes.NEW_STAGE_CREATED || action.type === ActionTypes.WINDOW_HASH_CHANGED || action.type == ActionTypes.SKELETON_RECOGNITION_BUTTON_PRESSED) {
	                if (document.location.href.split('#')[1] === 'skeleton') {
	                    // console.log(document.location.pathname);
	                    if (action.type == ActionTypes.SKELETON_RECOGNITION_BUTTON_PRESSED) {
	                        var state = getState();
	                        var stage = state.stage;
	
	                        var layers = state.layers;
	                        var currentLayer = _layers.Layers.getAffected(layers);
	                        var shapes = currentLayer.shapes;
	                        var input = shapes.map(function (shape) {
	                            return [shape.geom.x / 400., shape.geom.y / 400., shape.geom.nx, shape.geom.ny];
	                        });
	
	                        var client = Algorithmia.client("simby4RUwqQmtMDaHAPj5wsQwlD1");
	                        var algorithm = "alexbol99/SeketonRecognition"; // demo/Hello
	
	                        client.algo(algorithm).pipe(input).then(function (output) {
	                            if (output.error) return console.error("error: " + output.error);
	
	                            var newLayer = _layers.Layers.newLayer(stage, layers);
	                            newLayer.name = "recognized";
	                            newLayer.title = "recognized";
	                            // newLayer.displayed = true;
	
	                            var _iteratorNormalCompletion = true;
	                            var _didIteratorError = false;
	                            var _iteratorError = undefined;
	
	                            try {
	                                for (var _iterator = output.result[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                    var row = _step.value;
	
	                                    var shape = void 0;
	                                    if (row[0] instanceof Array && row[0].length === 2) {
	                                        var pc = point(row[0][0] * 400, row[0][1] * 400);
	                                        var r = row[1] * 400;
	                                        /********center radius startAng endAng **********/
	                                        shape = arc(pc, r, row[2], row[3], _flattenJs2.default.CCW);
	                                    } else {
	                                        shape = segment(point(row[0] * 400, row[1] * 400), point(row[2] * 400, row[3] * 400));
	                                    }
	                                    if (row[4]) {
	                                        shape.label = row[4];
	                                    }
	                                    newLayer.add(shape);
	                                }
	                            } catch (err) {
	                                _didIteratorError = true;
	                                _iteratorError = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion && _iterator.return) {
	                                        _iterator.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError) {
	                                        throw _iteratorError;
	                                    }
	                                }
	                            }
	
	                            layers.push(newLayer);
	
	                            dispatch({
	                                type: ActionTypes.PAN_AND_ZOOM_TO_SHAPE,
	                                stage: stage,
	                                shape: currentLayer
	                            });
	                        });
	                    } else {
	                        dispatch({
	                            type: ActionTypes.SKELETON_RECOGNITION_URI
	                        });
	                    }
	                }
	            }
	            return next(action);
	        };
	    };
	};
	
	exports.default = skeleton_recognition;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var stageController = function stageController(_ref) {
	    var getState = _ref.getState,
	        dispatch = _ref.dispatch;
	    return function (next) {
	        return function (action) {
	
	            // let state = getState();
	            var stage = action.stage;
	
	            if (stage) {
	                switch (action.type) {
	                    case ActionTypes.STAGE_RESIZED:
	                        stage.resize();
	                        break;
	
	                    case ActionTypes.MOUSE_DOWN_ON_STAGE:
	                        stage.panByMouseStart();
	                        break;
	
	                    case ActionTypes.MOUSE_MOVED_ON_STAGE:
	                        if (action.dx !== undefined && action.dy !== undefined) {
	                            stage.panByMouseMove(action.dx, action.dy);
	                        }
	                        break;
	
	                    case ActionTypes.MOUSE_UP_ON_STAGE:
	                        stage.panByMouseStop();
	                        break;
	
	                    case ActionTypes.PAN_AND_ZOOM_TO_SHAPE:
	                        var center = action.shape.center;
	                        var box = action.shape.box;
	                        stage.panToCoordinate(center.x, center.y);
	                        stage.zoomToLimits(box.xmax - box.xmin, box.ymax - box.ymin);
	                        break;
	
	                    case ActionTypes.MOUSE_WHEEL_MOVE_ON_STAGE:
	                        var bIn = action.delta > 0;
	                        // stage.zoomByMouse(action.x, action.y, bIn, 1 + Math.abs(action.delta)/100.);
	                        stage.zoomByMouse(action.x, action.y, bIn, 1.2);
	                        break;
	
	                    default:
	                        break;
	                }
	            }
	
	            next(action);
	        };
	    };
	};
	
	exports.default = stageController;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Distance = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Distance = exports.Distance = function () {
	    function Distance() {
	        _classCallCheck(this, Distance);
	    }
	
	    _createClass(Distance, null, [{
	        key: 'box2box_minmax',
	
	        /**
	         }
	         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes
	         * Minimal distance by x is
	         *    (box2.xmin - box1.xmax), if box1 is left to box2
	         *    (box1.xmin - box2.xmax), if box2 is left to box1
	         *    0,                       if box1 and box2 are intersected by x
	         * Minimal distance by y is defined in the same way
	         *
	         * Maximal distance is estimated as a sum of squared dimensions of the merged box
	         *
	         * @param box1
	         * @param box2
	         * @returns {Number | Number} - minimal and maximal distance
	         */
	        value: function box2box_minmax(box1, box2) {
	            var mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));
	            var mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));
	            var mindist = mindist_x * mindist_x + mindist_y * mindist_y;
	
	            var box = box1.merge(box2);
	            var dx = box.xmax - box.xmin;
	            var dy = box.ymax - box.ymin;
	            var maxdist = dx * dx + dy * dy;
	
	            return [mindist, maxdist];
	        }
	    }, {
	        key: 'minmax_tree_process_level',
	        value: function minmax_tree_process_level(shape, level, min_stop, tree) {
	            // Calculate minmax distance to each shape in current level
	            // Insert result into the interval tree for further processing
	            // update min_stop with maxdist, it will be the new stop distance
	            var mindist = void 0,
	                maxdist = void 0;
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = level[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var node = _step.value;
	
	                    // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);
	                    // if (Flatten.Utils.GT(mindist, min_stop))
	                    //     continue;
	
	                    // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box
	
	                    var _Distance$box2box_min = Distance.box2box_minmax(shape.box, node.item.key);
	
	                    var _Distance$box2box_min2 = _slicedToArray(_Distance$box2box_min, 2);
	
	                    mindist = _Distance$box2box_min2[0];
	                    maxdist = _Distance$box2box_min2[1];
	
	                    if (node.item.value instanceof _flattenJs2.default.Edge) {
	                        tree.insert([mindist, maxdist], node.item.value.shape);
	                    } else {
	                        tree.insert([mindist, maxdist], node.item.value);
	                    }
	                    if (_flattenJs2.default.Utils.LT(maxdist, min_stop)) {
	                        min_stop = maxdist; // this will be the new distance estimation
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            if (level.length === 0) return [min_stop, level, tree];
	
	            // Calculate new level from left and right children of the current
	            var new_level_left = level.map(function (node) {
	                return node.left.isNil() ? undefined : node.left;
	            }).filter(function (node) {
	                return node !== undefined;
	            });
	            var new_level_right = level.map(function (node) {
	                return node.right.isNil() ? undefined : node.right;
	            }).filter(function (node) {
	                return node !== undefined;
	            });
	            // Merge left and right subtrees and leave only relevant subtrees
	            var new_level = [].concat(_toConsumableArray(new_level_left), _toConsumableArray(new_level_right)).filter(function (node) {
	                // Node subtree quick reject, node.max is a subtree box
	                var mindist = Distance.box2box_minmax(shape.box, node.max)[0];
	                return _flattenJs2.default.Utils.LE(mindist, min_stop);
	            });
	
	            // min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);
	            return [min_stop, new_level, tree];
	        }
	
	        /**
	         * Calculates sorted tree of [mindist, maxdist] intervals between query shape
	         * and shapes of the planar set.
	         * @param shape
	         * @param set
	         */
	
	    }, {
	        key: 'minmax_tree',
	        value: function minmax_tree(shape, set, min_stop) {
	            var tree = new _flattenJs2.default.IntervalTree();
	            var level = [set.index.root];
	            var squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;
	            Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);
	            return tree;
	        }
	    }, {
	        key: 'minmax_tree_calc_distance',
	        value: function minmax_tree_calc_distance(shape, node, min_dist_and_segment) {
	            var min_dist_and_segment_new = void 0,
	                stop = void 0;
	            if (node != null && !node.isNil()) {
	                var _Distance$minmax_tree = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);
	
	                var _Distance$minmax_tree2 = _slicedToArray(_Distance$minmax_tree, 2);
	
	                min_dist_and_segment_new = _Distance$minmax_tree2[0];
	                stop = _Distance$minmax_tree2[1];
	
	
	                if (stop) {
	                    return [min_dist_and_segment_new, stop];
	                }
	
	                if (_flattenJs2.default.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {
	                    return [min_dist_and_segment_new, true]; // stop condition
	                }
	
	                var _Distance$distance = Distance.distance(shape, node.item.value),
	                    _Distance$distance2 = _slicedToArray(_Distance$distance, 2),
	                    dist = _Distance$distance2[0],
	                    shortest_segment = _Distance$distance2[1];
	                // console.log(dist)
	
	
	                if (_flattenJs2.default.Utils.LT(dist, min_dist_and_segment_new[0])) {
	                    min_dist_and_segment_new = [dist, shortest_segment];
	                }
	
	                var _Distance$minmax_tree3 = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);
	
	                var _Distance$minmax_tree4 = _slicedToArray(_Distance$minmax_tree3, 2);
	
	                min_dist_and_segment_new = _Distance$minmax_tree4[0];
	                stop = _Distance$minmax_tree4[1];
	
	
	                return [min_dist_and_segment_new, stop];
	            }
	
	            return [min_dist_and_segment, false];
	        }
	    }, {
	        key: 'shape2planarSet',
	        value: function shape2planarSet(shape, set) {
	            var min_stop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;
	
	            var min_dist_and_segment = [min_stop, new _flattenJs2.default.Segment()];
	            var stop = false;
	            if (set instanceof _flattenJs2.default.PlanarSet) {
	                var tree = Distance.minmax_tree(shape, set, min_stop);
	
	                var _Distance$minmax_tree5 = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);
	
	                var _Distance$minmax_tree6 = _slicedToArray(_Distance$minmax_tree5, 2);
	
	                min_dist_and_segment = _Distance$minmax_tree6[0];
	                stop = _Distance$minmax_tree6[1];
	            }
	            return min_dist_and_segment;
	        }
	    }]);

	    return Distance;
	}();

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Layer = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by alexanderbol on 17/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	// import { Shape } from '../models/shape';
	
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _model = __webpack_require__(11);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Layer = exports.Layer = function () {
	    function Layer(stage) {
	        _classCallCheck(this, Layer);
	
	        // super();
	        // cannot define Layer as extension of PlanarSet due to bug in compiler ?
	        this.stage = stage;
	        this.shapes = []; // new Flatten.PlanarSet();
	        this.name = "";
	        this.color = "";
	        this.title = "";
	        this.displayed = false;
	        this.edited = false;
	        this.affected = false;
	    }
	
	    _createClass(Layer, [{
	        key: 'clone',
	        value: function clone() {
	            var layer = new Layer(this.stage);
	            return Object.assign(layer, this);
	        }
	    }, {
	        key: 'add',
	        value: function add(shape) {
	            if (shape instanceof _model.Model) {
	                this.shapes.push(shape); // add(shape)
	            } else {
	                var geom = shape;
	                var newShape = new _model.Model(geom, {}, shape.label); // , this.stage);
	                this.shapes.push(newShape); // add(newShape);
	            }
	            return this;
	        }
	    }, {
	        key: 'addShapesArray',
	        value: function addShapesArray(shapes) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = shapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var shape = _step.value;
	
	                    this.add(shape);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return this;
	        }
	    }, {
	        key: 'toggleDisplayed',
	        value: function toggleDisplayed(color) {
	            var displayed = !this.displayed;
	            return Object.assign(this.clone(), {
	                displayed: displayed,
	                color: color
	            });
	        }
	    }, {
	        key: 'setAffected',
	        value: function setAffected(affected) {
	            return Object.assign(this.clone(), {
	                affected: affected
	            });
	        }
	    }, {
	        key: 'setEdited',
	        value: function setEdited(edited) {
	            return Object.assign(this.clone(), {
	                edited: edited
	            });
	        }
	    }, {
	        key: 'setNameAndTitle',
	        value: function setNameAndTitle(name, title) {
	            return Object.assign(this.clone(), {
	                name: name,
	                title: title,
	                edited: false
	            });
	        }
	    }, {
	        key: 'setAlpha',
	        value: function setAlpha() {
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.shapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var shape = _step2.value;
	
	                    shape.alpha = this.displayed ? 1 : 0;
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return this.shapes;
	        }
	    }, {
	        key: 'toggleExpanded',
	        value: function toggleExpanded(shapeToggle) {
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = this.shapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var shape = _step3.value;
	
	                    if (shape === shapeToggle) {
	                        shape.expanded = !shape.expanded;
	                    }
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	
	            return this;
	        }
	    }, {
	        key: 'box',
	        get: function get() {
	            var box = new _flattenJs2.default.Box();
	            var _iteratorNormalCompletion4 = true;
	            var _didIteratorError4 = false;
	            var _iteratorError4 = undefined;
	
	            try {
	                for (var _iterator4 = this.shapes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                    var shape = _step4.value;
	
	                    box = box.merge(shape.box);
	                }
	            } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                        _iterator4.return();
	                    }
	                } finally {
	                    if (_didIteratorError4) {
	                        throw _iteratorError4;
	                    }
	                }
	            }
	
	            return box;
	        }
	    }, {
	        key: 'center',
	        get: function get() {
	            var box = this.box;
	            return new _flattenJs2.default.Point((box.xmin + box.xmax) / 2, (box.ymin + box.ymax) / 2);
	        }
	    }]);

	    return Layer;
	}();

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseCSV = parseCSV;
	
	var _job = __webpack_require__(8);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var point = _flattenJs2.default.point,
	    vector = _flattenJs2.default.vector,
	    line = _flattenJs2.default.line;
	
	
	var micron2pixels = 400;
	function micronToPixels(str) {
	    return Math.round(Number(str) * micron2pixels, 0);
	}
	
	function parseCSV(filename, str) {
	    var job = new _job.Job();
	    job.filename = filename;
	
	    var arrayOfLines = str.match(/[^\r\n]+/g);
	
	    for (var i = 0; i < arrayOfLines.length; i++) {
	        var _line = arrayOfLines[i];
	        var terms = _line.split(',');
	
	        var px = micronToPixels(terms[0]);
	        var py = micronToPixels(terms[1]);
	        var nx = Number(terms[2]);
	        var ny = Number(terms[3]);
	        var shape = point(px, py);
	        shape.nx = nx;
	        shape.ny = ny;
	        job.shapes.push(shape);
	    }
	
	    return job;
	}

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseImage = parseImage;
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var pgmResolution = 25.500025;
	var microns2pixels = 400;
	// const inch2pixels = 10160;
	// const offsetX = 12.322830;
	// const offsetY = 8.326776;
	var sizeX = 3.0303;
	
	function toPixels(str) {
	    var num = Number(str);
	    return Math.round(num * pgmResolution * microns2pixels, 0);
	}
	
	function parseImage(file) {
	    var image = {}; // TODO: to be Flatten.Image
	
	    var terms = file.name.split('_');
	    var yStr = terms[0].substr(1);
	    var xStr = terms[1].substr(1);
	
	    var x = toPixels(xStr) + 90000;
	    var y = toPixels(yStr) - 40000;
	
	    image.center = new _flattenJs2.default.Point(x, y);
	    image.width = sizeX * microns2pixels * 1000; // 2 mm
	    image.box = new _flattenJs2.default.Box(image.center.x - image.width / 2, image.center.y - image.width / 2, image.center.x + image.width / 2, image.center.y + image.width / 2);
	
	    return image;
	}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseTXT = parseTXT;
	
	var _job = __webpack_require__(8);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _parser = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var point = _flattenJs2.default.point,
	    vector = _flattenJs2.default.vector,
	    line = _flattenJs2.default.line;
	function parseTXT(filename, str) {
	    var job = new _job.Job();
	    job.filename = filename;
	
	    var parser = new _parser.Parser();
	
	    var shapesArray = parser.parse(str);
	
	    if (shapesArray.length > 0) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = shapesArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var shape = _step.value;
	
	                job.shapes.push(shape);
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	    }
	
	    return job;
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseXML = parseXML;
	
	var _job = __webpack_require__(8);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Point = _flattenJs2.default.Point,
	    Segment = _flattenJs2.default.Segment,
	    Arc = _flattenJs2.default.Arc,
	    Polygon = _flattenJs2.default.Polygon;
	var vector = _flattenJs2.default.vector;
	
	
	function parseEdges(edgesXML) {
	    var edges = [];
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = edgesXML[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var edge = _step.value;
	
	            var type = edge.getAttribute('type');
	
	            if (type === "segment") {
	                var ps = new Point(parseInt(edge.getAttribute('xs'), 10), parseInt(edge.getAttribute('ys'), 10));
	                var pe = new Point(parseInt(edge.getAttribute('xe'), 10), parseInt(edge.getAttribute('ye'), 10));
	
	                edges.push(new Segment(ps, pe));
	            }
	
	            if (type === "curve") {
	                var _ps = new Point(parseInt(edge.getAttribute('xs'), 10), parseInt(edge.getAttribute('ys'), 10));
	                var _pe = new Point(parseInt(edge.getAttribute('xe'), 10), parseInt(edge.getAttribute('ye'), 10));
	                var pc = new Point(parseInt(edge.getAttribute('xc'), 10), parseInt(edge.getAttribute('yc'), 10));
	
	                var counterClockwise = edge.getAttribute('cw') === 'no' ? true : false;
	
	                var startAngle = vector(pc, _ps).slope;
	                var endAngle = vector(pc, _pe).slope;
	
	                var r = vector(pc, _ps).length;
	
	                edges.push(new Arc(pc, r, startAngle, endAngle, counterClockwise));
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return edges;
	}
	
	function parsePolygon(polygonsXML) {
	    var polygon = new Polygon();
	
	    // let nedges = parseInt(profile.getAttribute("n_edges"), 10);
	
	    // Augment Flatten object with style
	    var color = polygonsXML.getAttribute("color");
	    polygon.style = {
	        stroke: color || undefined,
	        fill: color || undefined,
	        alpha: 1.0
	    };
	
	    // Augment Flatten object with label
	    var label = polygonsXML.getAttribute("label");
	    polygon.label = label;
	
	    // Add islands
	    var islands = polygonsXML.getElementsByTagName('island');
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = islands[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var island = _step2.value;
	
	            var edgesXML = island.getElementsByTagName('edge');
	            polygon.addFace(parseEdges(edgesXML));
	        }
	
	        // Add holes
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    var holes = polygonsXML.getElementsByTagName('hole');
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = holes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var hole = _step3.value;
	
	            var edgesXML = hole.getElementsByTagName('edge');
	            polygon.addFace(parseEdges(edgesXML));
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    return polygon;
	}
	
	function parseSegment(segmentXML) {
	    var ps = new Point(parseInt(segmentXML.getAttribute('xs'), 10), parseInt(segmentXML.getAttribute('ys'), 10));
	    var pe = new Point(parseInt(segmentXML.getAttribute('xe'), 10), parseInt(segmentXML.getAttribute('ye'), 10));
	
	    var segment = new Segment(ps, pe);
	
	    // Augment Flatten object with label property
	    var label = segmentXML.getAttribute("label");
	    segment.label = label;
	
	    return segment;
	}
	
	function parseCurve(curveXML) {
	    var ps = new Point(parseInt(curveXML.getAttribute('xs'), 10), parseInt(curveXML.getAttribute('ys'), 10));
	    var pe = new Point(parseInt(curveXML.getAttribute('xe'), 10), parseInt(curveXML.getAttribute('ye'), 10));
	    var pc = new Point(parseInt(curveXML.getAttribute('xc'), 10), parseInt(curveXML.getAttribute('yc'), 10));
	
	    var counterClockwise = curveXML.getAttribute('cw') === 'yes' ? true : false;
	
	    var startAngle = vector(pc, ps).slope;
	    var endAngle = vector(pc, pe).slope;
	
	    var r = vector(pc, ps).length;
	
	    var arc = new Arc(pc, r, startAngle, endAngle, counterClockwise);
	
	    // Augment Flatten object with label property
	    var label = curveXML.getAttribute("label");
	    arc.label = label;
	
	    return arc;
	}
	
	function parsePoint(pointXML) {
	    var point = new Point(parseInt(pointXML.getAttribute('x'), 10), parseInt(pointXML.getAttribute('y'), 10));
	
	    // Augment Flatten object with label property
	    var label = pointXML.getAttribute("label");
	    point.label = label;
	
	    return point;
	}
	function parseXML(filename, str) {
	    var job = new _job.Job();
	
	    job.filename = filename;
	
	    var parser = new DOMParser();
	    var xmlDoc = parser.parseFromString(str, "text/xml");
	
	    // Parse document title
	    var titles = xmlDoc.getElementsByTagName('title');
	    if (titles && titles.length > 0) {
	        job.title = titles[0].firstChild.nodeValue; // take the first title if more than one
	    }
	
	    // Parse profiles and add polygons to the job
	    var profilesXML = xmlDoc.getElementsByTagName('profile');
	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;
	
	    try {
	        for (var _iterator4 = profilesXML[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var profileXML = _step4.value;
	
	            var polygon = parsePolygon(profileXML);
	            job.profiles.push(polygon);
	        }
	
	        // Parse materials and add polygons to the job
	    } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                _iterator4.return();
	            }
	        } finally {
	            if (_didIteratorError4) {
	                throw _iteratorError4;
	            }
	        }
	    }
	
	    var materialXML = xmlDoc.getElementsByTagName('material');
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;
	
	    try {
	        for (var _iterator5 = materialXML[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var shapeXML = _step5.value;
	
	            var polygon = parsePolygon(shapeXML);
	            job.materials.push(polygon);
	        }
	
	        // Parse segments
	    } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                _iterator5.return();
	            }
	        } finally {
	            if (_didIteratorError5) {
	                throw _iteratorError5;
	            }
	        }
	    }
	
	    var segmentsXML = xmlDoc.getElementsByTagName('segment');
	    var _iteratorNormalCompletion6 = true;
	    var _didIteratorError6 = false;
	    var _iteratorError6 = undefined;
	
	    try {
	        for (var _iterator6 = segmentsXML[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	            var segmentXML = _step6.value;
	
	            var segment = parseSegment(segmentXML);
	            job.shapes.push(segment);
	        }
	
	        // Parse segments
	    } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	            }
	        } finally {
	            if (_didIteratorError6) {
	                throw _iteratorError6;
	            }
	        }
	    }
	
	    var curvesXML = xmlDoc.getElementsByTagName('curve');
	    var _iteratorNormalCompletion7 = true;
	    var _didIteratorError7 = false;
	    var _iteratorError7 = undefined;
	
	    try {
	        for (var _iterator7 = curvesXML[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	            var curveXML = _step7.value;
	
	            var curve = parseCurve(curveXML);
	            job.shapes.push(curve);
	        }
	
	        // Parse points
	    } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                _iterator7.return();
	            }
	        } finally {
	            if (_didIteratorError7) {
	                throw _iteratorError7;
	            }
	        }
	    }
	
	    var pointsXML = xmlDoc.getElementsByTagName('point');
	    var _iteratorNormalCompletion8 = true;
	    var _didIteratorError8 = false;
	    var _iteratorError8 = undefined;
	
	    try {
	        for (var _iterator8 = pointsXML[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	            var pointXML = _step8.value;
	
	            var point = parsePoint(pointXML);
	            job.shapes.push(point);
	        }
	    } catch (err) {
	        _didIteratorError8 = true;
	        _iteratorError8 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                _iterator8.return();
	            }
	        } finally {
	            if (_didIteratorError8) {
	                throw _iteratorError8;
	            }
	        }
	    }
	
	    return job;
	}

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Stage = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import * as createjs from '../easeljs-NEXT.combined';
	
	// import { Shape } from '../models/shape';
	
	var Stage = exports.Stage = function (_createjs$Stage) {
	    _inherits(Stage, _createjs$Stage);
	
	    function Stage(canvas) {
	        _classCallCheck(this, Stage);
	
	        var _this = _possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this, canvas));
	
	        createjs.Touch.enable(_this);
	        _this.mouseMoveOutside = false; // true;
	        // this.enableDOMEvents(false);
	        _this.enableMouseOver(20);
	
	        if (_this.canvas.clientWidth > 0 && _this.canvas.clientHeight > 0) {
	            _this.canvas.width = _this.canvas.clientWidth;
	            _this.canvas.height = _this.canvas.clientHeight;
	            // this.updateViewport(this.canvas.width, this.canvas.height);
	        }
	        _this.origin = { x: _this.canvas.width / 2, y: _this.canvas.height / 2 };
	        _this.oldOrigin = { x: undefined, y: undefined }; // used by pan
	        _this.resolution = 0.00001; // MM 2 Pixels when zoomFactor = 1;
	        _this.zoomFactor = 1.0;
	        return _this;
	    }
	
	    _createClass(Stage, [{
	        key: 'clone',
	        value: function clone() {
	            var stage = new Stage(this.canvas);
	            return Object.assign(stage, this);
	        }
	    }, {
	        key: 'add',
	        value: function add(shape) {
	            this.addChild(shape);
	            return this;
	        }
	    }, {
	        key: 'scalingFactor',
	        value: function scalingFactor() {
	            return this.resolution * this.zoomFactor;
	        }
	    }, {
	        key: 'C2W_Scalar',
	        value: function C2W_Scalar(scalar) {
	            return scalar / this.scalingFactor();
	        }
	    }, {
	        key: 'W2C_Scalar',
	        value: function W2C_Scalar(scalar) {
	            return this.scalingFactor() * scalar;
	        }
	    }, {
	        key: 'C2W_X',
	        value: function C2W_X(canvasX) {
	            return (canvasX - this.origin.x) / this.scalingFactor();
	        }
	    }, {
	        key: 'C2W_Y',
	        value: function C2W_Y(canvasY) {
	            return (this.origin.y - canvasY) / this.scalingFactor();
	        }
	    }, {
	        key: 'W2C_X',
	        value: function W2C_X(worldX) {
	            return this.scalingFactor() * worldX + this.origin.x;
	        }
	    }, {
	        key: 'W2C_Y',
	        value: function W2C_Y(worldY) {
	            return this.origin.y - this.scalingFactor() * worldY;
	        }
	    }, {
	        key: 'W2C',
	        value: function W2C(point) {
	            return { x: this.W2C_X(point.x), y: this.W2C_Y(point.y) };
	        }
	    }, {
	        key: 'panTo',
	        value: function panTo(newOrigin) {
	            this.origin = { x: newOrigin.x, y: newOrigin.y };
	        }
	    }, {
	        key: 'panBy',
	        value: function panBy(deltaX, deltaY) {
	            this.origin = {
	                x: this.origin.x + deltaX,
	                y: this.origin.y + deltaY
	            };
	        }
	
	        // zoom by 10% each time
	
	    }, {
	        key: 'zoomIn',
	        value: function zoomIn(ratio) {
	            var curRatio = ratio || 1.1;
	            this.zoomFactor = Math.min(10000000, curRatio * this.zoomFactor);
	        }
	    }, {
	        key: 'zoomOut',
	        value: function zoomOut(ratio) {
	            var curRatio = ratio || 1.1;
	            this.zoomFactor = Math.max(0.001, this.zoomFactor / curRatio);
	        }
	
	        // ZoomIn/Out + "Focus follows mouse"
	
	    }, {
	        key: 'zoom',
	        value: function zoom(focusX, focusY, bIn, ratio) {
	            var worldX = this.C2W_X(focusX); // world coordinate of mouse focus before zoom
	            var worldY = this.C2W_Y(focusY);
	
	            bIn ? this.zoomIn(ratio) : this.zoomOut(ratio);
	
	            var newFocusX = this.W2C_X(worldX); // canvas coordinate after zoom
	            var newFocusY = this.W2C_Y(worldY);
	
	            this.panBy(focusX - newFocusX, focusY - newFocusY);
	
	            return [newFocusX, newFocusY];
	        }
	    }, {
	        key: 'zoomByMouse',
	        value: function zoomByMouse(focusX, focusY, bIn, ratio) {
	            this.zoom(focusX, focusY, bIn, ratio);
	        }
	    }, {
	        key: 'zoomToLimits',
	        value: function zoomToLimits(width, height) {
	            // prevent zero division in case of single point box
	            if (width === 0) width = 400000;
	            if (height === 0) height = 400000;
	            var resolution = Math.min(this.canvas.width / (1.1 * width), this.canvas.height / (1.1 * height));
	            var zoomFactor = resolution / this.resolution;
	            var ratio = zoomFactor / this.zoomFactor;
	            var bIn = true; //ratio > 1;
	
	            var focusX = this.canvas.width / 2;
	            var focusY = this.canvas.height / 2;
	            this.zoom(focusX, focusY, bIn, ratio);
	        }
	    }, {
	        key: 'resize',
	        value: function resize() {
	            // this.origin.x = this.canvas.width / 2;
	            // this.origin.y = this.canvas.height / 2;
	            if (this.canvas.clientWidth > 0 && this.canvas.clientHeight > 0) {
	                this.canvas.width = this.canvas.clientWidth;
	                this.canvas.height = this.canvas.clientHeight;
	            }
	        }
	
	        // drawSomething() {
	        //     let shape = new Shape();
	        //     shape.graphics.beginFill('red').drawRect(0, 0, 20, 20);
	        //     this.addChild(shape);
	        //     this.update();
	        // }
	
	    }, {
	        key: 'panByMouseStart',
	        value: function panByMouseStart() {
	            this.oldOrigin.x = this.origin.x;
	            this.oldOrigin.y = this.origin.y;
	        }
	    }, {
	        key: 'panByMouseMove',
	        value: function panByMouseMove(dx, dy) {
	            if (dx !== undefined && dy !== undefined && this.oldOrigin.x !== undefined && this.oldOrigin.y !== undefined) {
	                this.origin = {
	                    x: this.oldOrigin.x + dx,
	                    y: this.oldOrigin.y + dy
	                };
	            }
	        }
	    }, {
	        key: 'panByMouseStop',
	        value: function panByMouseStop() {
	            this.oldOrigin.x = undefined;
	            this.oldOrigin.y = undefined;
	            this.tx = undefined;
	            this.ty = undefined;
	        }
	    }, {
	        key: 'panToCoordinate',
	        value: function panToCoordinate(x, y) {
	            var canvasX = this.W2C_X(x);
	            var canvasY = this.W2C_Y(y);
	
	            var dx = this.canvas.width / 2 - canvasX;
	            var dy = this.canvas.height / 2 - canvasY;
	            this.panBy(dx, dy);
	        }
	    }, {
	        key: 'box',
	        get: function get() {
	            var minX = this.C2W_X(0);
	            var minY = this.C2W_Y(this.canvas.height);
	            var maxX = this.C2W_X(this.canvas.width);
	            var maxY = this.C2W_Y(0);
	
	            return new _flattenJs2.default.Box(minX, minY, maxX, maxY);
	        }
	    }]);
	
	    return Stage;
	}(createjs.Stage);

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.reducer = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _actionTypes = __webpack_require__(4);
	
	var ActionTypes = _interopRequireWildcard(_actionTypes);
	
	var _redux = __webpack_require__(27);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	var _flattenIntervalTree = __webpack_require__(13);
	
	var _flattenIntervalTree2 = _interopRequireDefault(_flattenIntervalTree);
	
	var _layers = __webpack_require__(5);
	
	var _parser = __webpack_require__(16);
	
	var _distance = __webpack_require__(57);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * Created by alexanderbol on 13/04/2017.
	                                                                                                                                                                                                     */
	
	// import {Stage} from './models/stage';
	// import {Layer} from './models/layer';
	
	
	var unitsList = [{
	    name: "pixels",
	    decimals: 0,
	    divisor: 1
	}, {
	    name: "inch",
	    decimals: 7,
	    divisor: 10160000
	}, {
	    name: "mm",
	    decimals: 6,
	    divisor: 400000
	}];
	
	var defaultAppState = {
	    title: "Debug Viewer",
	    version: "1.0",
	    build: "",
	    units: "pixels",
	    decimals: 0,
	    divisor: 1,
	    bg: "#F1F1F1",
	    parser: new _parser.Parser(),
	    widthOn: true,
	    displayVertices: false,
	    displayLabels: true,
	    measurePointsActive: false,
	    zoomFactor: undefined,
	    originX: undefined,
	    originY: undefined,
	    showAboutPopup: false,
	    importDataToNewLayer: true, // if false, import data to affected layer
	    showSkeletonRecognitionButton: false,
	    applySkeletonRecognition: false
	};
	
	var defaultMeasureShapesTool = {
	    measureShapesActive: false,
	    measureShapesFirstClick: true,
	    hoveredShape: null,
	    firstMeasuredShape: null,
	    secondMeasuredShape: null,
	    firstMeasuredLayer: null,
	    secondMeasuredLayer: null,
	    distance: undefined,
	    shortestSegment: null
	};
	
	var defaultAabbDemoToolState = {
	    aabbDemoToolActivated: false,
	    measureShapesActive: false,
	    measureShapesFirstClick: true,
	    hoveredShape: null,
	    firstMeasuredShape: null,
	    secondMeasuredShape: null,
	    firstMeasuredLayer: null,
	    secondMeasuredLayer: null,
	    distance: undefined,
	    shortestSegment: null,
	    firstMeasuredShapeLevel: [],
	    secondMeasuredShapeLevel: [],
	    min_stop: Number.POSITIVE_INFINITY,
	    tree: null
	};
	
	var defaultCollisionDistanceDemoToolState = {
	    showCollisionDemoToolButton: false,
	    collisionDistanceDemoToolActivated: false
	};
	
	var defaultMouseState = {
	    x: 0,
	    y: 0,
	    startX: undefined,
	    startY: undefined
	};
	
	function app() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAppState;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.NEW_STAGE_CREATED:
	        case ActionTypes.MOUSE_WHEEL_MOVE_ON_STAGE:
	        case ActionTypes.PAN_AND_ZOOM_TO_SHAPE:
	            return Object.assign({}, state, {
	                zoomFactor: action.stage.zoomFactor * action.stage.resolution,
	                originX: action.stage.origin.x,
	                originY: action.stage.origin.y
	            });
	        case ActionTypes.MOUSE_MOVED_ON_STAGE:
	            return Object.assign({}, state, {
	                originX: action.stage.origin.x,
	                originY: action.stage.origin.y
	            });
	        case ActionTypes.TOGGLE_UNITS_CLICKED:
	            var curUnitsId = unitsList.findIndex(function (units) {
	                return state.units === units.name;
	            });
	            var newUnits = unitsList[(curUnitsId + 1) % 3];
	            return Object.assign({}, state, {
	                units: newUnits.name,
	                decimals: newUnits.decimals,
	                divisor: newUnits.divisor
	            });
	        case ActionTypes.TOGGLE_WIDTH_MODE_CLICKED:
	            return Object.assign({}, state, {
	                widthOn: !state.widthOn,
	                displayVertices: state.widthOn ? state.displayVertices : false
	            });
	        case ActionTypes.TOGGLE_DISPLAY_VERTICES_CLICKED:
	            if (state.displayVertices) {
	                return Object.assign({}, state, {
	                    displayVertices: false
	                });
	            } else {
	                return Object.assign({}, state, {
	                    widthOn: false,
	                    displayVertices: true
	                });
	            }
	
	        case ActionTypes.TOGGLE_DISPLAY_LABELS_CLICKED:
	            return Object.assign({}, state, {
	                displayLabels: !state.displayLabels
	            });
	
	        case ActionTypes.SHOW_ABOUT_POPUP_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                showAboutPopup: true
	            });
	        case ActionTypes.CLOSE_ABOUT_POPUP_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                showAboutPopup: false
	            });
	
	        case ActionTypes.MEASURE_POINTS_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                measurePointsActive: true
	            });
	        case ActionTypes.MEASURE_SHAPES_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                measurePointsActive: false
	            });
	        case ActionTypes.MOUSE_DOWN_ON_STAGE:
	            if (state.hoveredShape) {
	                return state;
	            } else {
	                return Object.assign({}, state, {
	                    measureShapesFirstClick: true,
	                    firstMeasuredShape: null,
	                    firstMeasuredLayer: null,
	                    secondMeasuredShape: null,
	                    secondMeasuredLayer: null,
	                    distance: undefined,
	                    shortestSegment: null
	                });
	            }
	        case ActionTypes.SKELETON_RECOGNITION_URI:
	            return Object.assign({}, state, {
	                showSkeletonRecognitionButton: true
	            });
	        case ActionTypes.SKELETON_RECOGNITION_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                applySkeletonRecognition: true
	            });
	        case ActionTypes.LAYER_LIST_PANEL_PRESSED:
	            return state; // only to cause refresh of layers list component
	        case ActionTypes.AABB_TREE_NEXT_LEVEL:
	            return state;
	        default:
	            return state;
	    }
	}
	
	function layers() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var action = arguments[1];
	
	    var curLayer = state.find(function (layer) {
	        return layer.affected;
	    });
	    var curLayerId = state.findIndex(function (layer) {
	        return layer.affected;
	    });
	
	    switch (action.type) {
	        /*
	        case ActionTypes.NEW_STAGE_CREATED:
	            return [...state, action.layer];
	            */
	
	        case ActionTypes.ADD_LAYER_PRESSED:
	            return [].concat(_toConsumableArray(state), [action.layer]);
	
	        case ActionTypes.DELETE_LAYER_BUTTON_PRESSED:
	            return _layers.Layers.delete(action.layers, action.layer);
	
	        case ActionTypes.SORT_LAYERS_BUTTON_PRESSED:
	            return _layers.Layers.sort(action.layers);
	
	        case ActionTypes.TOGGLE_DISPLAY_LAYER_PRESSED:
	            var color = "";
	            if (!action.layer.displayed) {
	                color = _layers.Layers.getNextColor(state);
	                if (color === "") return; // no free colors
	            }
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    // if action.layer will be undisplayed,
	                    // it cannot become affected, then
	                    // keep affected on this layer
	                    if (action.layer.displayed) {
	                        return layer;
	                    } else {
	                        return layer.setAffected(false);
	                    }
	                } else {
	                    var newLayer = layer.toggleDisplayed(color);
	                    newLayer.affected = newLayer.displayed;
	                    return newLayer;
	                }
	                // return layer.toggleDisplayed(color);
	            });
	
	        case ActionTypes.TOGGLE_AFFECTED_LAYER_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer.setAffected(false);
	                } else {
	                    return layer.setAffected(!layer.affected);
	                }
	            });
	
	        case ActionTypes.NEW_SHAPE_PASTED:
	            return state.map(function (layer) {
	                if (layer.affected) {
	                    return layer.addShapesArray(action.shapesArray);
	                } else {
	                    return layer;
	                }
	            });
	
	        case ActionTypes.TOGGLE_WATCH_EXPAND_CLICKED:
	            return state.map(function (layer) {
	                if (layer.affected) {
	                    return layer.toggleExpanded(action.shape);
	                } else {
	                    return layer;
	                }
	            });
	
	        case ActionTypes.OPEN_LAYER_EDIT_FORM_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer;
	                } else {
	                    return layer.setEdited(true);
	                }
	            });
	
	        case ActionTypes.SUBMIT_LAYER_EDIT_FORM_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer;
	                } else {
	                    return layer.setNameAndTitle(action.newLayer.name, action.newLayer.title);
	                }
	            });
	
	        case ActionTypes.ESCAPE_LAYER_EDIT_FORM_PRESSED:
	            return state.map(function (layer) {
	                if (layer !== action.layer) {
	                    return layer;
	                } else {
	                    return layer.setEdited(false);
	                }
	            });
	
	        case ActionTypes.LAYERS_LIST_ARROW_DOWN_PRESSED:
	            if (curLayerId === state.length - 1) {
	                return state;
	            } else {
	
	                var nextLayer = state[curLayerId + 1];
	
	                return state.map(function (layer) {
	                    if (layer === curLayer) {
	                        var newCurLayer = layer.toggleDisplayed("");
	                        newCurLayer.affected = false;
	                        return newCurLayer;
	                    } else if (layer === nextLayer) {
	                        var _color = curLayer.color;
	                        var newNextLayer = layer.toggleDisplayed(_color);
	                        newNextLayer.affected = true;
	                        return newNextLayer;
	                    } else {
	                        return layer;
	                    }
	                });
	            }
	
	        case ActionTypes.LAYERS_LIST_ARROW_UP_PRESSED:
	            if (curLayerId === 0) {
	                return state;
	            } else {
	                var _nextLayer = state[curLayerId - 1];
	
	                return state.map(function (layer) {
	                    if (layer === curLayer) {
	                        var newCurLayer = layer.toggleDisplayed("");
	                        newCurLayer.affected = false;
	                        return newCurLayer;
	                    } else if (layer === _nextLayer) {
	                        var newNextLayer = layer.toggleDisplayed(curLayer.color);
	                        newNextLayer.displayed = true;
	                        newNextLayer.affected = true;
	                        return newNextLayer;
	                    } else {
	                        return layer;
	                    }
	                });
	            }
	
	        default:
	            return state;
	    }
	}
	
	function stage() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.NEW_STAGE_CREATED:
	            return action.stage;
	
	        default:
	            return state;
	    }
	}
	
	function measureShapesTool() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMeasureShapesTool;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.MEASURE_SHAPES_BUTTON_PRESSED:
	            return Object.assign({}, defaultMeasureShapesTool, {
	                measureShapesActive: true
	            });
	        case ActionTypes.PAN_BY_DRAG_BUTTON_CLICKED:
	            return Object.assign({}, defaultMeasureShapesTool);
	
	        case ActionTypes.MEASURE_POINTS_BUTTON_PRESSED:
	            return Object.assign({}, defaultMeasureShapesTool);
	
	        case ActionTypes.MOUSE_ROLL_OVER_SHAPE:
	            return Object.assign({}, state, {
	                hoveredShape: state.measureShapesActive ? action.shape : null
	            });
	        case ActionTypes.MOUSE_ROLL_OUT_SHAPE:
	            return Object.assign({}, state, {
	                hoveredShape: null
	            });
	        case ActionTypes.MOUSE_CLICKED_ON_SHAPE:
	            if (!state.measureShapesActive) {
	                return state;
	            }
	            // measureShapesActive
	
	            if (state.measureShapesFirstClick) {
	                return Object.assign({}, state, {
	                    firstMeasuredShape: action.shape,
	                    firstMeasuredLayer: action.layer,
	                    secondMeasuredShape: null,
	                    secondMeasuredLayer: null,
	                    measureShapesFirstClick: false,
	                    distance: undefined,
	                    shortestSegment: null
	                });
	            } else {
	                // second click
	                if (action.shape === state.firstMeasuredShape) {
	                    return state; // second click on the same shape
	                }
	
	                var shape1 = state.firstMeasuredShape.geom;
	                var shape2 = action.shape.geom;
	                var distance = void 0,
	                    shortestSegment = void 0;
	                // if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {
	                //     [distance, shortestSegment] = Flatten.Distance.polygon2polygon(shape1, shape2);
	                // }
	                // else {
	
	                // }
	
	
	                var _Flatten$Distance$dis = _flattenJs2.default.Distance.distance(shape1, shape2);
	
	                var _Flatten$Distance$dis2 = _slicedToArray(_Flatten$Distance$dis, 2);
	
	                distance = _Flatten$Distance$dis2[0];
	                shortestSegment = _Flatten$Distance$dis2[1];
	                return Object.assign({}, state, {
	                    secondMeasuredShape: action.shape,
	                    secondMeasuredLayer: action.layer,
	                    measureShapesFirstClick: true,
	                    distance: distance,
	                    shortestSegment: shortestSegment
	                });
	            }
	        case ActionTypes.MOUSE_DOWN_ON_STAGE:
	            if (state.hoveredShape) {
	                return state;
	            } else {
	                return Object.assign({}, state, {
	                    measureShapesFirstClick: true,
	                    firstMeasuredShape: null,
	                    firstMeasuredLayer: null,
	                    secondMeasuredShape: null,
	                    secondMeasuredLayer: null,
	                    distance: undefined,
	                    shortestSegment: null
	                });
	            }
	        default:
	            return state;
	    }
	}
	
	function aabbDemoTool() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAabbDemoToolState;
	    var action = arguments[1];
	
	    var firstShapeNewLevel = [];
	    var secondShapeNewLevel = [];
	    var level = [];
	    var min_stop = Number.POSITIVE_INFINITY;
	    var tree = null;
	
	    switch (action.type) {
	        case ActionTypes.AABB_DEMO_URI:
	            return Object.assign({}, state, {
	                aabbDemoToolActivated: true
	            });
	        case ActionTypes.AABB_TREE_NEXT_LEVEL:
	            {
	                if (state.firstMeasuredShape) {
	                    if (state.firstMeasuredShapeLevel.length === 0) {
	                        firstShapeNewLevel = [state.firstMeasuredShape.geom.edges.index.root];
	                    } else {
	                        firstShapeNewLevel = [];
	                        var _iteratorNormalCompletion = true;
	                        var _didIteratorError = false;
	                        var _iteratorError = undefined;
	
	                        try {
	                            for (var _iterator = state.firstMeasuredShapeLevel[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                var node = _step.value;
	
	                                if (!node.left.isNil()) {
	                                    firstShapeNewLevel.push(node.left);
	                                }
	                                if (!node.right.isNil()) {
	                                    firstShapeNewLevel.push(node.right);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError = true;
	                            _iteratorError = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion && _iterator.return) {
	                                    _iterator.return();
	                                }
	                            } finally {
	                                if (_didIteratorError) {
	                                    throw _iteratorError;
	                                }
	                            }
	                        }
	                    }
	                }
	                if (state.secondMeasuredShape) {
	                    if (state.secondMeasuredShapeLevel.length === 0) {
	                        secondShapeNewLevel = [state.secondMeasuredShape.geom.edges.index.root];
	                    } else {
	                        secondShapeNewLevel = [];
	                        var _iteratorNormalCompletion2 = true;
	                        var _didIteratorError2 = false;
	                        var _iteratorError2 = undefined;
	
	                        try {
	                            for (var _iterator2 = state.secondMeasuredShapeLevel[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                                var _node = _step2.value;
	
	                                if (!_node.left.isNil()) {
	                                    secondShapeNewLevel.push(_node.left);
	                                }
	                                if (!_node.right.isNil()) {
	                                    secondShapeNewLevel.push(_node.right);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError2 = true;
	                            _iteratorError2 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                    _iterator2.return();
	                                }
	                            } finally {
	                                if (_didIteratorError2) {
	                                    throw _iteratorError2;
	                                }
	                            }
	                        }
	                    }
	                }
	                if (state.firstMeasuredShape || state.secondMeasuredShape) {
	                    return Object.assign({}, state, {
	                        firstMeasuredShapeLevel: firstShapeNewLevel,
	                        secondMeasuredShapeLevel: secondShapeNewLevel
	                    });
	                } else {
	                    return state;
	                }
	            }
	        case ActionTypes.MOUSE_CLICKED_ON_SHAPE:
	            if (!state.aabbDemoToolActivated) {
	                return state;
	            }
	
	            if (state.measureShapesFirstClick) {
	                return Object.assign({}, state, {
	                    firstMeasuredShape: action.shape,
	                    firstMeasuredLayer: action.layer,
	                    firstMeasuredShapeLevel: [],
	                    secondMeasuredShapeLevel: [],
	                    min_stop: Number.POSITIVE_INFINITY,
	                    tree: null,
	                    measureShapesFirstClick: false
	                });
	            } else {
	                // second click
	                if (action.shape === state.firstMeasuredShape) {
	                    return state; // second click on the same shape
	                }
	                return Object.assign({}, state, {
	                    secondMeasuredShape: action.shape,
	                    secondMeasuredLayer: action.layer,
	                    measureShapesFirstClick: true
	                });
	            }
	        case ActionTypes.AABB_DEMO_NEXT_DIST_STEP:
	            if (!state.aabbDemoToolActivated) {
	                return state;
	            }
	            if (!state.firstMeasuredShape || !state.secondMeasuredShape) {
	                return state;
	            }
	            if (state.secondMeasuredShapeLevel.length === 0) {
	                level = [state.secondMeasuredShape.geom.edges.index.root];
	                min_stop = Number.POSITIVE_INFINITY;
	                tree = new _flattenIntervalTree2.default();
	            } else {
	                var _Distance$minmax_tree = _distance.Distance.minmax_tree_process_level(state.firstMeasuredShape, state.secondMeasuredShapeLevel, state.min_stop, state.tree);
	
	                var _Distance$minmax_tree2 = _slicedToArray(_Distance$minmax_tree, 3);
	
	                min_stop = _Distance$minmax_tree2[0];
	                level = _Distance$minmax_tree2[1];
	                tree = _Distance$minmax_tree2[2];
	            }
	            return Object.assign({}, state, {
	                secondMeasuredShapeLevel: level,
	                min_stop: min_stop,
	                tree: tree
	            });
	
	        default:
	            return state;
	    }
	}
	
	function collisionDistanceDemoTool() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCollisionDistanceDemoToolState;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.COLLISION_DEMO_URI:
	            return Object.assign({}, state, {
	                showCollisionDemoToolButton: true
	            });
	        case ActionTypes.COLLISION_DEMO_BUTTON_PRESSED:
	            return Object.assign({}, state, {
	                collisionDistanceDemoToolActivated: true
	            });
	        default:
	            return state;
	    }
	}
	
	function mouse() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMouseState;
	    var action = arguments[1];
	
	    switch (action.type) {
	        case ActionTypes.MOUSE_MOVED_ON_STAGE:
	            return Object.assign({}, state, {
	                x: action.x,
	                y: action.y
	            });
	        case ActionTypes.MOUSE_DOWN_ON_STAGE:
	            return Object.assign({}, state, {
	                startX: action.x,
	                startY: action.y
	            });
	        case ActionTypes.MOUSE_UP_ON_STAGE:
	            return Object.assign({}, state, {
	                startX: undefined,
	                startY: undefined
	            });
	        default:
	            return state;
	    }
	}
	
	var reducer = exports.reducer = (0, _redux.combineReducers)({
	    app: app,
	    layers: layers,
	    stage: stage,
	    measureShapesTool: measureShapesTool,
	    aabbDemoTool: aabbDemoTool,
	    collisionDistanceDemoTool: collisionDistanceDemoTool,
	    mouse: mouse
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AabbDemoTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _graphics = __webpack_require__(7);
	
	__webpack_require__(3);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	
	
	var AabbDemoTool = exports.AabbDemoTool = function (_Component) {
	    _inherits(AabbDemoTool, _Component);
	
	    function AabbDemoTool(params) {
	        _classCallCheck(this, AabbDemoTool);
	
	        var _this2 = _possibleConstructorReturn(this, (AabbDemoTool.__proto__ || Object.getPrototypeOf(AabbDemoTool)).call(this));
	
	        _this2.boxShapes = [];
	        _this2.edgeShapes = [];
	        return _this2;
	    }
	
	    _createClass(AabbDemoTool, [{
	        key: 'draw',
	        value: function draw() {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = this.boxShapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var shape = _step.value;
	
	                    this.props.stage.removeChild(shape);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            this.boxShapes = [];
	            this.drawTreeLevel(this.props.firstMeasuredShapeLevel);
	            this.drawTreeLevel(this.props.secondMeasuredShapeLevel);
	
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = this.edgeShapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var _shape = _step2.value;
	
	                    this.props.stage.removeChild(_shape);
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            this.edgeShapes = [];
	            this.drawSelectedEdges();
	        }
	    }, {
	        key: 'drawTreeLevel',
	        value: function drawTreeLevel(level) {
	            if (level.length === 0) return;
	            var stage = this.props.stage;
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	                for (var _iterator3 = level[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var node = _step3.value;
	
	                    var nodeGraphics = void 0;
	                    if (node.max) {
	                        nodeGraphics = (0, _graphics.graphics)(node.max);
	                    }
	                    if (nodeGraphics) {
	                        var shape = new createjs.Shape(nodeGraphics);
	                        stage.addChild(shape);
	                        this.boxShapes.push(shape);
	
	                        var edge = new createjs.Shape((0, _graphics.graphics)(node.item.key, {
	                            strokeStyle: 3,
	                            stroke: "blue"
	                        }));
	                        stage.addChild(edge);
	                        this.boxShapes.push(edge);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'drawSelectedEdges',
	        value: function drawSelectedEdges() {
	            var stage = this.props.stage;
	            var _this = this;
	            if (!this.props.selectedEdgesTree) return;
	            this.props.selectedEdgesTree.forEach(function (interval, shape) {
	                if (interval.low < _this.props.minStop) {
	                    var edge = new createjs.Shape((0, _graphics.graphics)(shape, {
	                        strokeStyle: 3,
	                        stroke: "blue"
	                    }));
	                    stage.addChild(edge);
	                    _this.edgeShapes.push(edge);
	                }
	            });
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.draw();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.props.firstMeasuredShape && this.props.firstMeasuredLayer.displayed || this.props.secondMeasuredShape && this.props.secondMeasuredLayer.displayed) {
	
	                this.draw();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            var _iteratorNormalCompletion4 = true;
	            var _didIteratorError4 = false;
	            var _iteratorError4 = undefined;
	
	            try {
	                for (var _iterator4 = this.boxShapes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                    var shape = _step4.value;
	
	                    this.props.stage.removeChild(shape);
	                }
	            } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                        _iterator4.return();
	                    }
	                } finally {
	                    if (_didIteratorError4) {
	                        throw _iteratorError4;
	                    }
	                }
	            }
	
	            this.boxShapes = [];
	            var _iteratorNormalCompletion5 = true;
	            var _didIteratorError5 = false;
	            var _iteratorError5 = undefined;
	
	            try {
	                for (var _iterator5 = this.edgeShapes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                    var _shape2 = _step5.value;
	
	                    this.props.stage.removeChild(_shape2);
	                }
	            } catch (err) {
	                _didIteratorError5 = true;
	                _iteratorError5 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                        _iterator5.return();
	                    }
	                } finally {
	                    if (_didIteratorError5) {
	                        throw _iteratorError5;
	                    }
	                }
	            }
	
	            this.edgeShapes = [];
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return AabbDemoTool;
	}(_react.Component);

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CollisionDistanceDemoTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _graphics = __webpack_require__(7);
	
	__webpack_require__(3);
	
	var _collision_distance = __webpack_require__(29);
	
	var _collision_distance2 = _interopRequireDefault(_collision_distance);
	
	var _flattenJs = __webpack_require__(2);
	
	var _flattenJs2 = _interopRequireDefault(_flattenJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var vector = _flattenJs2.default.vector;
	
	var CollisionDistanceDemoTool = exports.CollisionDistanceDemoTool = function (_Component) {
	    _inherits(CollisionDistanceDemoTool, _Component);
	
	    function CollisionDistanceDemoTool(params) {
	        _classCallCheck(this, CollisionDistanceDemoTool);
	
	        var _this = _possibleConstructorReturn(this, (CollisionDistanceDemoTool.__proto__ || Object.getPrototypeOf(CollisionDistanceDemoTool)).call(this));
	
	        _this.shape = new createjs.Shape();
	        params.stage.addChild(_this.shape);
	        return _this;
	    }
	
	    _createClass(CollisionDistanceDemoTool, [{
	        key: 'draw',
	        value: function draw() {
	            var polygon1 = this.props.firstMeasuredShape.geom;
	            var polygon2 = this.props.secondMeasuredShape.geom;
	            var stage = this.props.stage;
	            var color = "magenta";
	            var alpha = 0.6;
	            // let widthOn = this.props.widthOn;
	
	            var strokeStyle = 1;
	            var fill = "grey"; // (widthOn && !this.props.displayVertices) ? this.props.color : "white";
	
	            if (this.shape.graphics.isEmpty()) {
	                var collision = _collision_distance2.default.apply(polygon1, polygon2);
	                var polygon3 = _collision_distance2.default.translate(polygon2, vector(-collision, 0));
	                // let [distance, shortest_segment] = polygon1.distanceTo(polygon3);
	
	                this.shape.graphics = (0, _graphics.graphics)(polygon3, {
	                    strokeStyle: strokeStyle,
	                    ignoreScale: true,
	                    stroke: color,
	                    fill: fill,
	                    radius: 3. / (stage.zoomFactor * stage.resolution)
	                });
	            } else {
	                if (this.shape.graphics.stroke) this.shape.graphics.stroke.style = color;
	                if (this.shape.graphics.fill) this.shape.graphics.fill.style = fill;
	            }
	            this.shape.alpha = alpha; // this.props.displayed ? alpha : 0.0;
	        }
	    }, {
	        key: 'clean',
	        value: function clean() {
	            if (this.shape) {
	                this.shape.graphics.clear();
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.firstMeasuredShape && this.props.firstMeasuredLayer.displayed && this.props.secondMeasuredShape && this.props.secondMeasuredLayer.displayed) {
	                this.draw();
	            }
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.props.firstMeasuredShape && this.props.firstMeasuredLayer.displayed && this.props.secondMeasuredShape && this.props.secondMeasuredLayer.displayed) {
	                this.draw();
	            } else {
	                this.clean();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if (this.shape) {
	                this.props.stage.removeChild(this.shape);
	                this.shape.graphics.clear();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return CollisionDistanceDemoTool;
	}(_react.Component);

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.DisplayCoordsTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var DisplayCoordsTool = exports.DisplayCoordsTool = function (_Component) {
	    _inherits(DisplayCoordsTool, _Component);
	
	    function DisplayCoordsTool() {
	        _classCallCheck(this, DisplayCoordsTool);
	
	        return _possibleConstructorReturn(this, (DisplayCoordsTool.__proto__ || Object.getPrototypeOf(DisplayCoordsTool)).apply(this, arguments));
	    }
	
	    _createClass(DisplayCoordsTool, [{
	        key: 'format',
	        value: function format(num) {
	            return (num / this.props.divisor).toFixed(this.props.decimals);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var mainCanvas = this.props.stage.canvas;
	            var top = mainCanvas.offsetTop + 10;
	            var left = mainCanvas.offsetLeft + 10;
	            var x = this.props.stage.C2W_X(this.props.coordX);
	            var y = this.props.stage.C2W_Y(this.props.coordY);
	            return _react2.default.createElement(
	                'div',
	                { style: { position: 'absolute', top: top, left: left } },
	                _react2.default.createElement(
	                    'h5',
	                    { style: { margin: 0, padding: 3 } },
	                    'X: ',
	                    this.format(x),
	                    '  Y: ',
	                    this.format(y)
	                )
	            );
	        }
	    }]);

	    return DisplayCoordsTool;
	}(_react.Component);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MeasurePointsTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	// import * as createjs from '../../public/easeljs-NEXT.combined.js';
	
	var MeasurePointsTool = exports.MeasurePointsTool = function (_Component) {
	    _inherits(MeasurePointsTool, _Component);
	
	    function MeasurePointsTool() {
	        _classCallCheck(this, MeasurePointsTool);
	
	        var _this = _possibleConstructorReturn(this, (MeasurePointsTool.__proto__ || Object.getPrototypeOf(MeasurePointsTool)).call(this));
	
	        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
	        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
	        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
	
	        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
	        _this.handleMouseWheelFox = _this.handleMouseWheelFox.bind(_this);
	
	        _this.startX = undefined;
	        _this.startY = undefined;
	        _this.endX = undefined;
	        _this.endY = undefined;
	        _this.measureStarted = false;
	        return _this;
	    }
	
	    _createClass(MeasurePointsTool, [{
	        key: 'handleMouseDown',
	        value: function handleMouseDown(event) {
	            event.preventDefault();
	
	            var canvas = this.refs.measureCanvas;
	            var stage = this.props.stage;
	
	            canvas.width = canvas.width;
	
	            var coordX = event.offsetX || event.originalEvent.layerX; // layerX for Firefox
	            var coordY = event.offsetY || event.originalEvent.layerY; // layery for Firefox
	
	            if (this.measureStarted) {
	                // second click - clear measurement
	                this.startX = undefined;
	                this.startY = undefined;
	                this.endX = undefined;
	                this.endY = undefined;
	                this.measureStarted = false;
	                canvas.style.cursor = "auto";
	            } else {
	                // first click - start measurment
	                this.startX = stage.C2W_X(coordX);
	                this.startY = stage.C2W_Y(coordY);
	                this.measureStarted = true;
	                canvas.style.cursor = "crosshair";
	            }
	        }
	    }, {
	        key: 'handleMouseMove',
	        value: function handleMouseMove(event) {
	            var stage = this.props.stage;
	
	            var coordX = event.offsetX /*|| event.originalEvent ? event.originalEvent.layerX : undefined*/; // layerX for Firefox
	            var coordY = event.offsetY /*|| event.originalEvent ? event.originalEvent.layerY : undefined*/; // layerY for Firefox
	
	            if (this.measureStarted) {
	                this.endX = stage.C2W_X(coordX);
	                this.endY = stage.C2W_Y(coordY);
	
	                this.draw();
	            }
	        }
	    }, {
	        key: 'handleMouseUp',
	        value: function handleMouseUp(event) {}
	    }, {
	        key: 'handleMouseWheel',
	        value: function handleMouseWheel(event) {
	            event.preventDefault();
	
	            var delta = event.detail || event.wheelDelta;
	            if (delta !== 0) {
	                this.props.onMouseWheelMove(event.offsetX, event.offsetY, delta);
	            }
	        }
	    }, {
	        key: 'handleMouseWheelFox',
	        value: function handleMouseWheelFox(event) {
	            event.preventDefault();
	
	            if (event.detail !== 0) {
	                this.props.onMousewheelMove(event.layerX, event.layerY, -event.detail);
	            }
	        }
	    }, {
	        key: 'draw',
	        value: function draw() {
	            var canvas = this.refs.measureCanvas;
	            var context = canvas.getContext('2d');
	            var stage = this.props.stage;
	
	            canvas.width = canvas.width;
	
	            // Draw rectangle
	            var pllX = Math.min(stage.W2C_X(this.startX), stage.W2C_X(this.endX));
	            var pllY = Math.min(stage.W2C_Y(this.startY), stage.W2C_Y(this.endY));
	            var width = Math.abs(stage.W2C_Scalar(this.startX - this.endX));
	            var height = Math.abs(stage.W2C_Scalar(this.startY - this.endY));
	
	            context.beginPath();
	            context.rect(pllX, pllY, width, height);
	
	            // Draw segment
	            context.moveTo(stage.W2C_X(this.startX), stage.W2C_Y(this.startY));
	            context.lineTo(stage.W2C_X(this.endX), stage.W2C_Y(this.endY));
	
	            context.lineWidth = 1;
	            context.strokeStyle = 'black';
	            context.stroke();
	
	            // Draw text
	            var textX = void 0,
	                textY = void 0,
	                textHeight = void 0,
	                textWidth = void 0;
	            var backX = void 0,
	                backY = void 0; // background rectangle
	            var text = this.measurement();
	
	            context.font = "12pt Arial";
	
	            textHeight = 12; /* font size*/
	            textWidth = context.measureText(text).width;
	
	            // Rectangle to the right of current point, text aligned left
	            if (Math.abs(stage.W2C_X(this.endX) - pllX) <= 2) {
	                context.textAlign = "left";
	                textX = pllX + 3;
	                backX = pllX;
	            }
	            // Rectangle to the left of current point, text aligned right
	            else {
	                    context.textAlign = "right";
	                    textX = pllX + width - 3;
	                    backX = textX - textWidth - 3;
	                }
	
	            if (Math.abs(stage.W2C_Y(this.endY) - pllY) <= 2) {
	                textY = pllY - 3;
	            } else {
	                textY = pllY + height + textHeight + 3;
	            }
	            backY = textY - textHeight - 3;
	
	            context.fillStyle = 'white';
	            context.globalAlpha = 0.4;
	            context.fillRect(backX, backY, textWidth + 6, textHeight + 6);
	
	            context.fillStyle = "black";
	            context.globalAlpha = 1;
	            context.fillText(this.measurement(), textX, textY);
	        }
	    }, {
	        key: 'measurement',
	        value: function measurement() {
	            var dx = this.endX - this.startX;
	            var dy = this.endY - this.startY;
	            var dist = Math.sqrt(dx * dx + dy * dy);
	            var message = "DX=" + this.format(dx) + ",DY=" + this.format(dy) + ",D=" + this.format(dist);
	            return message;
	        }
	    }, {
	        key: 'format',
	        value: function format(num) {
	            return (num / this.props.divisor).toFixed(this.props.decimals);
	        }
	    }, {
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            // this.dispatch = this.props.store.dispatch;
	            // this.setState(this.props.store.getState());
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var canvas = this.refs.measureCanvas;
	            canvas.addEventListener("mousedown", this.handleMouseDown);
	            canvas.addEventListener("mousemove", this.handleMouseMove);
	            canvas.addEventListener("mouseup", this.handleMouseUp);
	
	            canvas.addEventListener("mousewheel", this.handleMouseWheel);
	            canvas.addEventListener("DOMMouseScroll", this.handleMouseWheelFox);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.measureStarted) {
	                this.draw();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            var canvas = this.refs.measureCanvas;
	            canvas.width = canvas.width;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var mainCanvas = this.props.stage.canvas;
	            var width = mainCanvas.width;
	            var height = mainCanvas.height;
	            var top = mainCanvas.offsetTop;
	            var left = mainCanvas.offsetLeft;
	            return _react2.default.createElement('canvas', { tabIndex: '1', ref: 'measureCanvas', id: 'measurePoints',
	                width: width,
	                height: height,
	                style: { position: 'absolute', top: top, left: left }
	            });
	        }
	    }]);

	    return MeasurePointsTool;
	}(_react.Component);

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MeasureShapesTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _easeljsNEXTCombined = __webpack_require__(6);
	
	var createjs = _interopRequireWildcard(_easeljsNEXTCombined);
	
	var _graphics = __webpack_require__(7);
	
	__webpack_require__(3);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by alexanderbol on 21/04/2017.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	// import createjs from 'easel-js';
	
	
	var MeasureShapesTool = exports.MeasureShapesTool = function (_Component) {
	    _inherits(MeasureShapesTool, _Component);
	
	    function MeasureShapesTool(params) {
	        _classCallCheck(this, MeasureShapesTool);
	
	        var _this = _possibleConstructorReturn(this, (MeasureShapesTool.__proto__ || Object.getPrototypeOf(MeasureShapesTool)).call(this));
	
	        _this.segment = new createjs.Shape();
	        params.stage.addChild(_this.segment);
	
	        _this.labelShape = new createjs.Text();
	        _this.labelShape.x = 0;
	        _this.labelShape.y = 0;
	        params.stage.addChild(_this.labelShape);
	
	        // var html = document.createElement('div');
	        // html.innerText = ""; // params.model.label;
	        // html.style.position = "absolute";
	        // html.style.top = 0;
	        // html.style.left = 0;
	        //
	        // document.body.appendChild(html);
	        // this.labelShape = new createjs.DOMElement(html);
	        // params.stage.addChild(this.labelShape);
	        return _this;
	    }
	
	    // redrawLabel() {
	    //     if (!this.labelShape) return;
	    //
	    //     let stage = this.props.stage;
	    //
	    //     this.labelShape.htmlElement.style.display = "block";
	    //
	    //     let box = this.props.shortestSegment.box;
	    //     let point = {x: (box.xmin + box.xmax) / 2, y: (box.ymin + box.ymax) / 2};
	    //     let dx = 6. / (stage.zoomFactor * stage.resolution);
	    //     let dy = 4. / (stage.zoomFactor * stage.resolution);
	    //
	    //     this.labelShape.htmlElement.style.font = "16px Arial";
	    //     this.labelShape.htmlElement.innerText = this.props.shortestSegment.length;
	    //
	    //     let unscale = 1. / (stage.zoomFactor * stage.resolution);
	    //     let tx = stage.canvas.offsetLeft / (stage.zoomFactor * stage.resolution) + point.x + dx;
	    //     let ty = -stage.canvas.offsetTop / (stage.zoomFactor * stage.resolution) + point.y + dy;
	    //     this.labelShape.setTransform(tx, ty, unscale, -unscale);
	    // }
	
	    _createClass(MeasureShapesTool, [{
	        key: 'format',
	        value: function format(num) {
	            return (num / this.props.divisor).toFixed(this.props.decimals);
	        }
	    }, {
	        key: 'redrawLabel',
	        value: function redrawLabel() {
	            if (!this.labelShape) return;
	
	            var stage = this.props.stage;
	
	            var box = this.props.shortestSegment.box;
	            var point = { x: (box.xmin + box.xmax) / 2, y: (box.ymin + box.ymax) / 2 };
	            var dx = 6. / (stage.zoomFactor * stage.resolution);
	            var dy = 4. / (stage.zoomFactor * stage.resolution);
	
	            if (box.ymin === box.ymax) {
	                dx = 0;
	                dy = -dy;
	            }
	
	            // this.labelShape.htmlElement.style.display = "block";
	            // this.labelShape.htmlElement.style.font = "16px Arial";
	            // this.labelShape.htmlElement.innerText = this.props.shortestSegment.length;
	
	            this.labelShape.text = this.format(this.props.shortestSegment.length);
	
	            var fontSize = 14.; // / (stage.zoomFactor * stage.resolution);
	            this.labelShape.font = fontSize + 'px Arial';
	
	            var unscale = 1. / (stage.zoomFactor * stage.resolution);
	            // let tx = stage.canvas.offsetLeft / (stage.zoomFactor * stage.resolution) + point.x + dx;
	            // let ty = -stage.canvas.offsetTop / (stage.zoomFactor * stage.resolution) + point.y + dy;
	            var tx = point.x + dx;
	            var ty = point.y + dy;
	            this.labelShape.setTransform(tx, ty, unscale, -unscale);
	        }
	    }, {
	        key: 'draw',
	        value: function draw() {
	            if (this.props.shortestSegment) {
	                this.segment.graphics = (0, _graphics.graphics)(this.props.shortestSegment);
	                this.redrawLabel();
	            }
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.draw();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.segment.graphics.clear();
	            if (this.props.firstMeasuredShape && this.props.secondMeasuredShape && this.props.firstMeasuredLayer.displayed && this.props.secondMeasuredLayer.displayed) {
	
	                this.draw();
	                this.redrawLabel();
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            this.props.stage.removeChild(this.segment);
	            this.segment.graphics.clear();
	            this.props.stage.removeChild(this.labelShape);
	            this.labelShape.text = "";
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return null;
	        }
	    }]);

	    return MeasureShapesTool;
	}(_react.Component);

/***/ },
/* 70 */
3,
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(10);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (false) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(77);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 75 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(76);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 4/1/2017.
	 */
	
	let Interval = class Interval {
	    constructor(low, high) {
	        this.low = low;
	        this.high = high;
	    }
	
	    get max() {
	        return this.high;
	    }
	
	    interval(low, high) {
	        return new Interval(low, high);
	    }
	
	    clone() {
	        return new Interval(this.low, this.high);
	    }
	
	    less_than(other_interval) {
	        return this.low < other_interval.low ||
	            this.low == other_interval.low && this.high < other_interval.high;
	    }
	
	    equal_to(other_interval) {
	        return this.low == other_interval.low && this.high == other_interval.high;
	    }
	
	    intersect(other_interval) {
	        return !this.not_intersect(other_interval);
	    }
	
	    not_intersect(other_interval) {
	        return (this.high < other_interval.low || other_interval.high < this.low);
	    }
	
	    output() {
	        return [this.low, this.high];
	    }
	
	    maximal_val(val1, val2) {
	        return Math.max(val1, val2);
	    }
	
	    val_less_than(val1, val2 ) {     // trait to compare max property with item ?
	        return val1 < val2;
	    }
	};
	
	module.exports = Interval;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 4/1/2017.
	 */
	
	'use strict';
	
	// let defaultTraits = require('../utils/numeric_traits');
	let Interval = __webpack_require__(79);
	let {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = __webpack_require__(19);
	
	let Node = class Node {
	    constructor(key = undefined, value = undefined,
	                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
	        this.left = left;                     // reference to left child node
	        this.right = right;                   // reference to right child node
	        this.parent = parent;                 // reference to parent node
	        this.color = color;
	
	        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval
	
	        /* If not, this should by an array of two numbers */
	        if (key && key instanceof Array && key.length == 2) {
	            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
	                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));
	            }
	        }
	        this.max = this.item.key ? this.item.key.max : undefined;
	    }
	
	    isNil() {
	        return (this.item.key === undefined && this.item.value === undefined &&
	            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);
	    }
	
	    less_than(other_node) {
	        return this.item.key.less_than(other_node.item.key);
	    }
	
	    equal_to(other_node) {
	        let value_equal = true;
	        if (this.item.value && other_node.item.value) {
	            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :
	                this.item.value == other_node.item.value;
	        }
	        return this.item.key.equal_to(other_node.item.key) && value_equal;
	    }
	
	    intersect(other_node) {
	        return this.item.key.intersect(other_node.item.key);
	    }
	
	    copy_data(other_node) {
	        this.item.key = other_node.item.key.clone();
	        this.item.value = other_node.item.value;
	    }
	
	    update_max() {
	        // use key (Interval) max property instead of key.high
	        this.max = this.item.key ? this.item.key.max : undefined;
	        if (this.right && this.right.max) {
	            let maximal_val = this.item.key.maximal_val;
	            this.max = maximal_val(this.max, this.right.max);
	        }
	        if (this.left && this.left.max) {
	            let maximal_val = this.item.key.maximal_val;
	            this.max = maximal_val(this.max, this.left.max);
	        }
	    }
	
	    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
	    not_intersect_left_subtree(search_node) {
	        let val_less_than = this.item.key.val_less_than;
	        let high = this.left.max.high ? this.left.max.high : this.left.max;
	        return val_less_than(high, search_node.item.key.low);
	    }
	
	    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
	    not_intersect_right_subtree(search_node) {
	        let val_less_than = this.item.key.val_less_than;
	        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;
	        return val_less_than(search_node.item.key.high, low);
	    }
	};
	
	module.exports = Node;
	


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	let IntervalTree = __webpack_require__(13);
	
	module.exports = function(Flatten) {
	    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;
	
	    let {vector} = Flatten;
	
	    Flatten.Distance = class Distance {
	        /**
	         * Calculate distance and shortest segment between points
	         * @param pt1
	         * @param pt2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2point(pt1, pt2) {
	            return pt1.distanceTo(pt2);
	        }
	
	        /**
	         * Calculate distance and shortest segment between point and line
	         * @param pt
	         * @param line
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2line(pt, line) {
	            let closest_point = pt.projectionOn(line);
	            let vec = vector(pt, closest_point);
	            return [vec.length, new Segment(pt, closest_point)];
	        }
	
	        /**
	         * Calculate distance and shortest segment between point and circle
	         * @param pt
	         * @param circle
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2circle(pt, circle) {
	            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);
	            if (Flatten.Utils.EQ_0(dist2center)) {
	                return [circle.r, new Segment(pt, circle.toArc().start)];
	            }
	            else {
	                let dist = Math.abs(dist2center - circle.r);
	                let v = vector(circle.pc, pt).normalize().multiply(circle.r);
	                let closest_point = circle.pc.translate(v);
	                return [dist, new Segment(pt, closest_point)];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between point and segment
	         * @param pt
	         * @param segment
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2segment(pt, segment) {
	            /* Degenerated case of zero-length segment */
	            if (segment.start.equalTo(segment.end)) {
	                return  Distance.point2point(pt, segment.start);
	            }
	
	            let v_seg = new Flatten.Vector(segment.start, segment.end);
	            let v_ps2pt = new Flatten.Vector(segment.start, pt);
	            let v_pe2pt = new Flatten.Vector(segment.end, pt);
	            let start_sp = v_seg.dot(v_ps2pt);
	            /* dot product v_seg * v_ps2pt */
	            let end_sp = -v_seg.dot(v_pe2pt);
	            /* minus dot product v_seg * v_pe2pt */
	
	            let dist;
	            let closest_point;
	            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */
	                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);
	                /* unit vector ||v_unit|| = 1 */
	                dist = Math.abs(v_unit.cross(v_ps2pt));
	                /* dist = abs(v_unit x v_ps2pt) */
	                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));
	                return [dist, new Segment(pt, closest_point)];
	            }
	            else if (start_sp < 0) {                             /* point is out of scope closer to ps */
	                return pt.distanceTo(segment.start);
	            }
	            else {                                               /* point is out of scope closer to pe */
	                return pt.distanceTo(segment.end);
	            }
	        };
	
	        /**
	         * Calculate distance and shortest segment between point and arc
	         * @param pt
	         * @param arc
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2arc(pt, arc) {
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	            let dist_and_segment = [];
	            let dist, shortest_segment;
	            [dist, shortest_segment] = Distance.point2circle(pt, circle);
	            if (shortest_segment.end.on(arc)) {
	                dist_and_segment.push(Distance.point2circle(pt, circle));
	            }
	            dist_and_segment.push( Distance.point2point(pt, arc.start) );
	            dist_and_segment.push( Distance.point2point(pt, arc.end) );
	
	            Distance.sort(dist_and_segment);
	
	            return dist_and_segment[0];
	        }
	
	        /**
	         * Calculate distance and shortest segment between segment and line
	         * @param seg
	         * @param line
	         * @returns {Number | Segment}
	         */
	        static segment2line(seg, line) {
	            let ip = seg.intersect(line);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point
	            }
	            let dist_and_segment = [];
	            dist_and_segment.push(Distance.point2line(seg.start, line));
	            dist_and_segment.push(Distance.point2line(seg.end, line));
	
	            Distance.sort( dist_and_segment );
	            return dist_and_segment[0];
	
	        }
	
	        /**
	         * Calculate distance and shortest segment between two segments
	         * @param seg1
	         * @param seg2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static segment2segment(seg1, seg2) {
	            let ip = Segment.intersectSegment2Segment(seg1, seg2);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point
	            }
	
	            // Seg1 and seg2 not intersected
	            let dist_and_segment = [];
	
	            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));
	            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));
	            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));
	            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));
	
	            Distance.sort( dist_and_segment );
	            return dist_and_segment[0];
	        }
	
	        /**
	         * Calculate distance and shortest segment between segment and circle
	         * @param seg
	         * @param circle
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static segment2circle(seg, circle) {
	            /* Case 1 Segment and circle intersected. Return the first point and zero distance */
	            let ip = seg.intersect(circle);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            // No intersection between segment and circle
	
	            /* Case 2. Distance to projection of center point to line bigger than radius
	             * And projection point belong to segment
	              * Then measure again distance from projection to circle and return it */
	            let line = new Flatten.Line(seg.ps, seg.pe);
	            let [dist, shortest_segment] = Distance.point2line(circle.center, line);
	            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {
	                return Distance.point2circle(shortest_segment.end, circle);
	            }
	            /* Case 3. Otherwise closest point is one of the end points of the segment */
	            else {
	                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);
	                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);
	                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?
	                    [dist_from_start, shortest_segment_from_start] :
	                    [dist_from_end, shortest_segment_from_end];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between segment and arc
	         * @param seg
	         * @param arc
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static segment2arc(seg, arc) {
	            /* Case 1 Segment and arc intersected. Return the first point and zero distance */
	            let ip = seg.intersect(arc);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            // No intersection between segment and arc
	            let line = new Flatten.Line(seg.ps, seg.pe);
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	
	            /* Case 2. Distance to projection of center point to line bigger than radius AND
	             * projection point belongs to segment AND
	               * distance from projection point to circle belongs to arc  =>
	               * return this distance from projection to circle */
	            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);
	            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {
	                let [dist_from_projection, shortest_segment_from_projection] =
	                    Distance.point2circle(shortest_segment_from_center.end, circle);
	                if (shortest_segment_from_projection.end.on(arc)) {
	                    return [dist_from_projection, shortest_segment_from_projection];
	                }
	            }
	            /* Case 3. Otherwise closest point is one of the end points of the segment */
	            let dist_and_segment = [];
	            dist_and_segment.push(Distance.point2arc(seg.start, arc));
	            dist_and_segment.push(Distance.point2arc(seg.end, arc));
	
	            let dist_tmp, segment_tmp;
	            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);
	            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
	
	            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);
	            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
	
	            Distance.sort(dist_and_segment);
	            return dist_and_segment[0];
	        }
	
	        /**
	         * Calculate distance and shortest segment between two circles
	         * @param circle1
	         * @param circle2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static circle2circle(circle1, circle2) {
	            let ip = circle1.intersect(circle2);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts
	            if (circle1.center.equalTo(circle2.center)) {
	                let arc1 = circle1.toArc();
	                let arc2 = circle2.toArc();
	                return Distance.point2point(arc1.start, arc2.start);
	            }
	            else {
	                // Case 2. Not concentric circles
	                let line = new Line(circle1.center, circle2.center);
	                let ip1 = line.intersect(circle1);
	                let ip2 = line.intersect(circle2);
	
	                let dist_and_segment = [];
	
	                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));
	                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));
	                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));
	                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));
	
	                Distance.sort(dist_and_segment);
	                return dist_and_segment[0];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between two circles
	         * @param circle
	         * @param line
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static circle2line(circle, line) {
	            let ip = circle.intersect(line);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);
	            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);
	            shortest_segment = shortest_segment.reverse();
	            return [dist, shortest_segment];
	        }
	
	        /**
	         * Calculate distance and shortest segment between arc and line
	         * @param arc
	         * @param line
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static arc2line(arc, line) {
	            /* Case 1 Line and arc intersected. Return the first point and zero distance */
	            let ip = line.intersect(arc);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let circle = new Flatten.Circle(arc.center, arc.r);
	
	            /* Case 2. Distance to projection of center point to line bigger than radius AND
	             * projection point belongs to segment AND
	               * distance from projection point to circle belongs to arc  =>
	               * return this distance from projection to circle */
	            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);
	            if (Flatten.Utils.GE(dist_from_center, circle.r)) {
	                let [dist_from_projection, shortest_segment_from_projection] =
	                    Distance.point2circle(shortest_segment_from_center.end, circle);
	                if (shortest_segment_from_projection.end.on(arc)) {
	                    return [dist_from_projection, shortest_segment_from_projection];
	                }
	            }
	            else {
	                let dist_and_segment = [];
	                dist_and_segment.push( Distance.point2line(arc.start, line) );
	                dist_and_segment.push( Distance.point2line(arc.end, line) );
	
	                Distance.sort(dist_and_segment);
	                return dist_and_segment[0];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between arc and circle
	         * @param arc
	         * @param circle2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static arc2circle(arc, circle2) {
	            let ip = arc.intersect(circle2);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let circle1 = new Flatten.Circle(arc.center, arc.r);
	
	            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);
	            if (shortest_segment.start.on(arc)) {
	                return [dist, shortest_segment];
	            }
	            else {
	                let dist_and_segment = [];
	
	                dist_and_segment.push(Distance.point2circle(arc.start, circle2));
	                dist_and_segment.push(Distance.point2circle(arc.end, circle2));
	
	                Distance.sort(dist_and_segment);
	
	                return dist_and_segment[0];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between two arcs
	         * @param arc1
	         * @param arc2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static arc2arc(arc1, arc2) {
	            let ip = arc1.intersect(arc2);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let circle1 = new Flatten.Circle(arc1.center, arc1.r);
	            let circle2 = new Flatten.Circle(arc2.center, arc2.r);
	
	            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);
	            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {
	                return [dist, shortest_segment];
	            }
	            else {
	                let dist_and_segment = [];
	
	                let dist_tmp, segment_tmp;
	
	                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);
	                if (segment_tmp.end.on(arc2)) {
	                    dist_and_segment.push([dist_tmp, segment_tmp]);
	                }
	
	                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);
	                if (segment_tmp.end.on(arc2)) {
	                    dist_and_segment.push([dist_tmp, segment_tmp]);
	                }
	
	                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);
	                if (segment_tmp.end.on(arc1)) {
	                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
	                }
	
	                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);
	                if (segment_tmp.end.on(arc1)) {
	                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
	                }
	
	                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);
	                dist_and_segment.push([dist_tmp, segment_tmp]);
	
	                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);
	                dist_and_segment.push([dist_tmp, segment_tmp]);
	
	                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);
	                dist_and_segment.push([dist_tmp, segment_tmp]);
	
	                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);
	                dist_and_segment.push([dist_tmp, segment_tmp]);
	
	                Distance.sort(dist_and_segment);
	
	                return dist_and_segment[0];
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment between point and polygon
	         * @param point
	         * @param polygon
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static point2polygon(point, polygon) {
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];
	            for (let edge of polygon.edges) {
	                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?
	                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);
	                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                    min_dist_and_segment = [dist, shortest_segment];
	                }
	            }
	            return min_dist_and_segment;
	        }
	
	        static shape2polygon(shape, polygon) {
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];
	            for (let edge of polygon.edges) {
	                let [dist, shortest_segment] = shape.distanceTo(edge.shape);
	                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                    min_dist_and_segment = [dist, shortest_segment];
	                }
	            }
	            return min_dist_and_segment;
	        }
	
	/*
	        static arc2polygon(arc, polygon) {
	            let ip = arc.intersect(polygon);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];
	            for (let edge of polygon.edges) {
	                let [dist, shortest_segment] = arc.distanceTo(edge.shape);
	                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                    min_dist_and_segment = [dist, shortest_segment];
	                }
	            }
	            return min_dist_and_segment;
	        }
	
	        static line2polygon(line, polygon) {
	            let ip = line.intersect(polygon);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];
	            for (let edge of polygon.edges) {
	                let [dist, shortest_segment] = line.distanceTo(edge.shape);
	                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                    min_dist_and_segment = [dist, shortest_segment];
	                }
	            }
	            return min_dist_and_segment;
	        }
	
	        static circle2polygon(circle, polygon) {
	            let ip = circle.intersect(polygon);
	            if (ip.length > 0) {
	                return [0, new Segment(ip[0], ip[0])];
	            }
	
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];
	            for (let edge of polygon.edges) {
	                let [dist, shortest_segment] = circle.distanceTo(edge.shape);
	                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                    min_dist_and_segment = [dist, shortest_segment];
	                }
	            }
	            return min_dist_and_segment;
	        }
	*/
	
	        /**
	         * Calculate distance and shortest segment between two polygons
	         * @param polygon1
	         * @param polygon2
	         * @returns {Number | Segment} - distance and shortest segment
	         */
	        static polygon2polygon(polygon1, polygon2) {
	            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
	            for (let edge1 of polygon1.edges) {
	                for (let edge2 of polygon2.edges) {
	                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);
	                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
	                        min_dist_and_segment = [dist, shortest_segment];
	                    }
	                }
	            }
	            return min_dist_and_segment;
	        }
	
	        /**
	         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes
	         * Minimal distance by x is
	         *    (box2.xmin - box1.xmax), if box1 is left to box2
	         *    (box1.xmin - box2.xmax), if box2 is left to box1
	         *    0,                       if box1 and box2 are intersected by x
	         * Minimal distance by y is defined in the same way
	         *
	         * Maximal distance is estimated as a sum of squared dimensions of the merged box
	         *
	         * @param box1
	         * @param box2
	         * @returns {Number | Number} - minimal and maximal distance
	         */
	        static box2box_minmax(box1, box2) {
	            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );
	            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );
	            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;
	
	            let box = box1.merge(box2);
	            let dx = box.xmax - box.xmin;
	            let dy = box.ymax - box.ymin;
	            let maxdist = dx*dx + dy*dy;
	
	            return [mindist, maxdist];
	        }
	
	        static minmax_tree_process_level(shape, level, min_stop, tree) {
	            // Calculate minmax distance to each shape in current level
	            // Insert result into the interval tree for further processing
	            // update min_stop with maxdist, it will be the new stop distance
	            let mindist, maxdist;
	            for (let node of level) {
	
	                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);
	                // if (Flatten.Utils.GT(mindist, min_stop))
	                //     continue;
	
	                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box
	                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);
	                if (node.item.value instanceof Flatten.Edge) {
	                    tree.insert([mindist, maxdist], node.item.value.shape);
	                }
	                else {
	                    tree.insert([mindist, maxdist], node.item.value);
	                }
	                if (Flatten.Utils.LT(maxdist, min_stop)) {
	                    min_stop = maxdist;                       // this will be the new distance estimation
	                }
	            }
	
	            if (level.length === 0)
	                return min_stop;
	
	            // Calculate new level from left and right children of the current
	            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);
	            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);
	            // Merge left and right subtrees and leave only relevant subtrees
	            let new_level = [...new_level_left, ...new_level_right].filter( node => {
	                // Node subtree quick reject, node.max is a subtree box
	                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);
	                return (Flatten.Utils.LE(mindist, min_stop));
	            });
	
	            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);
	            return min_stop;
	        }
	
	        /**
	         * Calculates sorted tree of [mindist, maxdist] intervals between query shape
	         * and shapes of the planar set.
	         * @param shape
	         * @param set
	         */
	        static minmax_tree(shape, set, min_stop) {
	            let tree = new IntervalTree();
	            let level = [set.index.root];
	            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;
	            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);
	            return tree;
	        }
	
	        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {
	            let min_dist_and_segment_new, stop;
	            if (node != null && !node.isNil()) {
	                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);
	
	                if (stop) {
	                    return [min_dist_and_segment_new, stop];
	                }
	
	                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {
	                    return [min_dist_and_segment_new, true];   // stop condition
	                }
	
	                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);
	                // console.log(dist)
	                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {
	                    min_dist_and_segment_new = [dist, shortest_segment];
	                }
	
	                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);
	
	                return [min_dist_and_segment_new, stop];
	            }
	
	            return [min_dist_and_segment, false];
	        }
	
	        /**
	         * Calculates distance between shape and Planar Set of shapes
	         * @param shape
	         * @param {PlanarSet} set
	         * @param {Number} min_stop
	         * @returns {*}
	         */
	        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {
	            let min_dist_and_segment = [min_stop, new Flatten.Segment()];
	            let stop = false;
	            if (set instanceof Flatten.PlanarSet) {
	                let tree = Distance.minmax_tree(shape, set, min_stop);
	                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);
	            }
	            return min_dist_and_segment;
	        }
	
	        static sort(dist_and_segment) {
	            dist_and_segment.sort((d1, d2) => {
	                if (Flatten.Utils.LT(d1[0], d2[0])) {
	                    return -1;
	                }
	                if (Flatten.Utils.GT(d1[0], d2[0])) {
	                    return 1;
	                }
	                return 0;
	            });
	        }
	
	        static distance(shape1, shape2) {
	            return shape1.distanceTo(shape2);
	        }
	    }
	};

/***/ },
/* 82 */
/***/ function(module, exports) {

	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;
	
	    Flatten.ray_shoot = function(polygon, point) {
	        let contains = undefined;
	
	        // if (!(polygon instanceof Polygon && point instanceof Point)) {
	        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        // }
	
	        // 1. Quick reject
	        if (polygon.box.notIntersect(point.box)) {
	            return Flatten.OUTSIDE;
	        }
	
	        let ray = new Ray(point);
	        let line = new Line(ray.pt, ray.norm);
	
	        // 2. Locate relevant edges of the polygon
	        let resp_edges = polygon.edges.search(ray.box);
	
	        if (resp_edges.length == 0) {
	            return Flatten.OUTSIDE;
	        }
	
	        // 3. Calculate intersections
	        let intersections = [];
	        for (let edge of resp_edges) {
	            for (let ip of ray.intersect(edge.shape)) {
	
	                // If intersection is equal to query point then point lays on boundary
	                if (ip.equalTo(point)) {
	                    return Flatten.BOUNDARY;
	                }
	
	                intersections.push({
	                    pt: ip,
	                    edge: edge
	                });
	            }
	        }
	
	        // 4. Sort intersection in x-ascending order
	        intersections.sort( (i1, i2) => {
	            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {
	                return -1;
	            }
	            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {
	                return 1;
	            }
	            return 0;
	        });
	
	        // 5. Count real intersections, exclude touching
	        let counter = 0;
	
	        for (let i=0; i < intersections.length; i++) {
	            let intersection = intersections[i];
	            if (intersection.pt.equalTo(intersection.edge.shape.start)) {
	                /* skip same point between same edges if already counted */
	                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&
	                    intersection.edge.prev === intersections[i-1].edge) {
	                    continue;
	                }
	                let prev_edge = intersection.edge.prev;
	                let prev_tangent = prev_edge.shape.tangentInEnd();
	                let prev_point = intersection.pt.translate(prev_tangent);
	
	                let cur_tangent = intersection.edge.shape.tangentInStart();
	                let cur_point = intersection.pt.translate(cur_tangent);
	
	                let prev_on_the_left = prev_point.leftTo(line);
	                let cur_on_the_left = cur_point.leftTo(line);
	
	                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {
	                    counter++;
	                }
	            }
	            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {
	                /* skip same point between same edges if already counted */
	                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&
	                    intersection.edge.next === intersections[i-1].edge) {
	                    continue;
	                }
	                let next_edge = intersection.edge.next;
	                let next_tangent = next_edge.shape.tangentInStart();
	                let next_point = intersection.pt.translate(next_tangent);
	
	                let cur_tangent = intersection.edge.shape.tangentInEnd();
	                let cur_point = intersection.pt.translate(cur_tangent);
	
	                let next_on_the_left = next_point.leftTo(line);
	                let cur_on_the_left = cur_point.leftTo(line);
	
	                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {
	                    counter++;
	                }
	            }
	            else {        /* intersection point is not a coincident with a vertex */
	                if (intersection.edge.shape instanceof Segment) {
	                    counter++;
	                }
	                else {
	                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */
	                    let box = intersection.edge.shape.box;
	                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||
	                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {
	                        counter++;
	                    }
	                }
	            }
	        }
	
	        // 6. Odd or even?
	        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;
	
	        return contains;
	    };
	};

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/10/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a circular arc
	     * @type {Arc}
	     */
	    Flatten.Arc = class Arc {
	        /**
	         *
	         * @param {Point} pc - arc center
	         * @param {number} r - arc radius
	         * @param {number} startAngle - start angle in radians from 0 to 2*PI
	         * @param {number} endAngle - end angle in radians from 0 to 2*PI
	         * @param {boolean} counterClockwise - arc direction, true - clockwise (or {@link Flatten.CCW}), false - counter clockwise (or {@link Flatten.CW)}
	         */
	        constructor(pc=new Flatten.Point(), r=1, startAngle=0, endAngle=2*Math.PI, counterClockwise=true) {
	            this.pc = pc.clone();
	            this.r = r;
	            this.startAngle = startAngle;
	            this.endAngle = endAngle;
	            this.counterClockwise = counterClockwise;
	        }
	
	        /**
	         * Return new instance of arc
	         * @returns {Arc}
	         */
	        clone() {
	            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);
	        }
	
	        /**
	         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI
	         * @returns {number}
	         */
	        get sweep() {
	            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))
	                return 0.0;
	            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {
	                return Flatten.PIx2;
	            }
	            let sweep;
	            if (this.counterClockwise) {
	                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?
	                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;
	            } else {
	                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?
	                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;
	            }
	
	            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {
	                sweep -= Flatten.PIx2;
	            }
	            if ( Flatten.Utils.LT(sweep, 0) ) {
	                sweep += Flatten.PIx2;
	            }
	            return sweep;
	        }
	
	        /**
	         * Get start point of arc
	         * @returns {Point}
	         */
	        get start() {
	            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
	            return p0.rotate(this.startAngle, this.pc);
	        }
	
	        /**
	         * Get end point of arc
	         * @returns {Point}
	         */
	        get end() {
	            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
	            return p0.rotate(this.endAngle, this.pc);
	        }
	
	        /**
	         * Get center of arc
	         * @returns {Point}
	         */
	        get center() {
	            return this.pc.clone();
	        }
	
	        get vertices() {
	            return [this.start.clone(), this.end.clone()];
	        }
	
	        /**
	         * Get arc length
	         * @returns {number}
	         */
	        get length() {
	            return Math.abs(this.sweep*this.r);
	        }
	
	        /**
	         * Get bounding box of the arc
	         * @returns {Box}
	         */
	        get box() {
	            let func_arcs = this.breakToFunctional();
	            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );
	            box = box.merge(this.end.box);
	            return box;
	        }
	
	        /**
	         * Returns true if arc contains point, false otherwise
	         * @param {Point} pt - point to test
	         * @returns {boolean}
	         */
	        contains(pt) {
	            // first check if  point on circle (pc,r)
	            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))
	                return false;
	
	            // point on circle
	
	            if (pt.equalTo(this.start))
	                return true;
	
	            let angle = new Flatten.Vector(this.pc, pt).slope;
	            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);
	            return Flatten.Utils.LE(test_arc.length, this.length);
	        }
	
	        /**
	         * When given point belongs to arc, return array of two arcs split by this point. If points is incident
	         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return
	         * empty array.
	         * @param {Point} pt Query point
	         * @returns {Arc[]}
	         */
	        split(pt) {
	            if (!this.contains(pt))
	                return [];
	
	            if (Flatten.Utils.EQ_0(this.sweep))
	                return [this.clone()];
	
	            if (this.start.equalTo(pt) || this.end.equalTo(pt))
	                return [this.clone()];
	
	            let angle = new Flatten.Vector(this.pc, pt).slope;
	
	            return [
	                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),
	                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)
	            ]
	        }
	
	        /**
	         * Return middle point of the arc
	         * @returns {Point}
	         */
	        middle() {
	            let endAngle = this.counterClockwise === Flatten.CCW ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;
	            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);
	            return arc.end;
	        }
	
	        /**
	         * Returns chord height ("sagitta") of the arc
	         * @returns {number}
	         */
	        chordHeight() {
	            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;
	        }
	
	        /**
	         * Returns array of intersection points between arc and other shape
	         * @param {Shape} shape Shape of the one of supported types Line, Circle, Segment, Arc <br/>
	         * TODO: support Polygon and Planar Set
	         * @returns {Points[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return shape.intersect(this);
	            }
	            if (shape instanceof Flatten.Circle) {
	                return Arc.intersectArc2Circle(this, shape);
	            }
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	            if (shape instanceof Flatten.Arc) {
	                return Arc.intersectArc2Arc(this, shape);
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
	         * @returns {number} distance from arc to shape
	         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)
	
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	
	            if (shape instanceof Flatten.Point) {
	                let [dist, shortest_segment] = Distance.point2arc(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                let [dist, shortest_segment] = Distance.arc2circle(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Line) {
	                let [dist, shortest_segment] = Distance.arc2line(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                let [dist, shortest_segment] = Distance.segment2arc(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                let [dist, shortest_segment] = Distance.arc2arc(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.PlanarSet) {
	                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);
	                return [dist, shortest_segment];
	            }
	        }
	
	        /**
	         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs
	         * @returns {Arcs[]}
	         */
	        breakToFunctional() {
	            let func_arcs_array = [];
	            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];
	            let pts = [
	                this.pc.translate(this.r,0),
	                this.pc.translate(0,this.r),
	                this.pc.translate(-this.r,0),
	                this.pc.translate(0,-this.r)
	            ];
	
	            // If arc contains extreme point,
	            // create test arc started at start point and ended at this extreme point
	            let test_arcs = [];
	            for (let i=0; i < 4; i++) {
	                if (pts[i].on(this)) {
	                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));
	                }
	            }
	
	            if (test_arcs.length == 0) {                  // arc does contain any extreme point
	                func_arcs_array.push(this.clone());
	            }
	            else {                                        // arc passes extreme point
	                // sort these arcs by length
	                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);
	
	                for (let i = 0; i < test_arcs.length; i++) {
	                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
	                    let new_arc;
	                    if (prev_arc) {
	                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);
	                    }
	                    else {
	                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);
	                    }
	                    if (!Flatten.Utils.EQ_0(new_arc.length)) {
	                        func_arcs_array.push(new_arc.clone());
	                    }
	                }
	
	                // add last sub arc
	                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
	                let new_arc;
	                if (prev_arc) {
	                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);
	                }
	                else {
	                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);
	                }
	                if (!Flatten.Utils.EQ_0(new_arc.length)) {
	                    func_arcs_array.push(new_arc.clone());
	                }
	            }
	            return func_arcs_array;
	        }
	
	        /**
	         * Return tangent unit vector in the start point in the direction from start to end
	         * @returns {Vector}
	         */
	        tangentInStart() {
	            let vec = new Flatten.Vector(this.pc, this.start);
	            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;
	            let tangent = vec.rotate(angle).normalize();
	            return tangent;
	        }
	
	        /**
	         * Return tangent unit vector in the end point in the direction from end to start
	         * @returns {Vector}
	         */
	        tangentInEnd() {
	            let vec = new Flatten.Vector(this.pc, this.end);
	            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;
	            let tangent = vec.rotate(angle).normalize();
	            return tangent;
	        }
	
	        /**
	         * Returns new arc with swapped start and end angles and reversed direction
	         * @returns {Arc}
	         */
	        reverse() {
	            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);
	        }
	
	        /**
	         * Returns new arc translated by vector vec
	         * @param {Vector} vec
	         * @returns {Segment}
	         */
	        translate(vec) {
	            let arc = this.clone();
	            arc.pc = this.pc.translate(vec);
	            return arc;
	        }
	
	        /**
	         * Return new segment rotated by given angle around given point
	         * If point omitted, rotate around origin (0,0)
	         * Positive value of angle defines rotation counter clockwise, negative - clockwise
	         * @param {number} angle - rotation angle in radians
	         * @param {Point} center - center point, default is (0,0)
	         * @returns {Arc}
	         */
	        rotate(angle = 0, center = new Flatten.Point()) {
	            let m = new Flatten.Matrix();
	            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);
	            return this.transform(m);
	        }
	
	        /**
	         * Return new arc transformed using affine transformation matrix <br/>
	         * Note, that non-equal scaling by x and y (matrix[0] != matrix[3]) produce illegal result
	         * TODO: support non-equal scaling arc to ellipse or throw exception ?
	         * @param {Matrix} matrix - affine transformation matrix
	         * @returns {Arc}
	         */
	        transform(matrix = new Flatten.Matrix()) {
	            let newStart = this.start.transform(matrix);
	            let newEnd = this.end.transform(matrix);
	            let newCenter = this.pc.transform(matrix);
	            let arc = Arc.arcSE(newCenter, newStart, newEnd, this.counterClockwise);
	            return arc;
	        }
	
	        static arcSE(center, start, end, counterClockwise) {
	            let {vector} = Flatten;
	            let startAngle = vector(center,start).slope;
	            let endAngle = vector(center, end).slope;
	            if (Flatten.Utils.EQ(startAngle, endAngle)) {
	                endAngle += 2*Math.PI;
	                counterClockwise = true;
	            }
	            let r = vector(center, start).length;
	
	            return new Arc(center, r, startAngle, endAngle, counterClockwise);
	        }
	
	        static intersectArc2Arc(arc1, arc2) {
	            var ip = [];
	
	            if (arc1.box.notIntersect(arc2.box)) {
	                return ip;
	            }
	
	            // Special case: overlapping arcs
	            // May return up to 4 intersection points
	            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {
	                let pt;
	
	                pt = arc1.start;
	                if (pt.on(arc2))
	                    ip.push(pt);
	
	                pt = arc1.end;
	                if (pt.on(arc2))
	                    ip.push(pt);
	
	                pt = arc2.start;
	                if (pt.on(arc1)) ip.push(pt);
	
	                pt = arc2.end;
	                if (pt.on(arc1)) ip.push(pt);
	
	                return ip;
	            }
	
	            // Common case
	            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);
	            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
	            let ip_tmp =  circle1.intersect(circle2);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc1) && pt.on(arc2)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	        }
	
	        static intersectArc2Circle(arc, circle) {
	            let ip = [];
	
	            if (arc.box.notIntersect(circle.box)) {
	                return ip;
	            }
	
	            // Case when arc center incident to circle center
	            // Return arc's end points as 2 intersection points
	            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {
	                ip.push(arc.start);
	                ip.push(arc.end);
	                return ip;
	            }
	
	            // Common case
	            let circle1 = circle;
	            let circle2 = new Flatten.Circle(arc.pc, arc.r);
	            let ip_tmp = circle1.intersect(circle2);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	        }
	
	        definiteIntegral(ymin=0) {
	            let f_arcs = this.breakToFunctional();
	            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );
	            return area;
	        }
	
	        circularSegmentDefiniteIntegral(ymin) {
	            let line = new Flatten.Line(this.start, this.end);
	            let onLeftSide = this.pc.leftTo(line);
	            let segment = new Flatten.Segment(this.start, this.end);
	            let areaTrapez = segment.definiteIntegral(ymin);
	            let areaCircularSegment = this.circularSegmentArea();
	            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;
	            return area;
	        }
	
	        circularSegmentArea() {
	            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))
	        }
	
	        /**
	         * Return string to draw arc in svg
	         * @param {Object} attrs - json structure with attributes of svg path element,
	         * like "stroke", "strokeWidth", "fill" <br/>
	         * Defaults are stroke:"black", strokeWidth:"1", fill:"none"
	         * @returns {string}
	         */
	        svg(attrs = {}) {
	            let largeArcFlag = this.sweep <= Math.PI ? "0" : "1";
	            let sweepFlag = this.counterClockwise ? "1" : "0";
	            let {stroke, strokeWidth, fill, id, className} = attrs;
	            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	
	            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {
	                let circle = new Flatten.Circle(this.pc, this.r);
	                return circle.svg(attrs);
	            }
	            else {
	                return `\n<path d="M${this.start.x},${this.start.y}
	                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}"
	                    stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" fill="${fill || "none"}" ${id_str} ${class_str} />`
	            }
	        }
	    };
	
	    /**
	     * Function to create arc equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.arc = (...args) => new Flatten.Arc(...args);
	};

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/7/2017.
	 */
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class Box represent bounding box of the shape
	     * @type {Box}
	     */
	    Flatten.Box = class Box {
	        /**
	         *
	         * @param {number} xmin - minimal x coordinate
	         * @param {number} ymin - minimal y coordinate
	         * @param {number} xmax - maximal x coordinate
	         * @param {number} ymax - maximal y coordinate
	         */
	        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {
	            /**
	             * Minimal x coordinate
	             * @type {number}
	             */
	            this.xmin = xmin;
	            /**
	             * Minimal y coordinate
	             * @type {number}
	             */
	            this.ymin = ymin;
	            /**
	             * Maximal x coordinate
	             * @type {number}
	             */
	            this.xmax = xmax;
	            /**
	             * Maximal y coordinate
	             * @type {number}
	             */
	            this.ymax = ymax;
	        }
	
	        /**
	         * Clones and returns new instance of box
	         * @returns {Box}
	         */
	        clone() {
	            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);
	        }
	
	        /**
	         * Property low need for interval tree interface
	         * @returns {Point}
	         */
	        get low() {
	            return new Flatten.Point(this.xmin, this.ymin);
	        }
	
	        /**
	         * Property high need for interval tree interface
	         * @returns {Point}
	         */
	        get high() {
	            return new Flatten.Point(this.xmax, this.ymax);
	        }
	
	        /**
	         * Property max returns the box itself !
	         * @returns {Box}
	         */
	        get max() {
	            return this.clone();
	        }
	
	        /**
	         * Return center of the box
	         * @returns {Point}
	         */
	        get center() {
	            return new Flatten.Point( (this.xmin + this.xmax)/2, (this.ymin + this.ymax)/2 );
	        }
	
	        /**
	         * Returns true if not intersected with other box
	         * @param {Box} other_box - other box to test
	         * @returns {boolean}
	         */
	        notIntersect(other_box) {
	            return (
	                this.xmax < other_box.xmin ||
	                this.xmin > other_box.xmax ||
	                this.ymax < other_box.ymin ||
	                this.ymin > other_box.ymax
	            );
	        }
	
	        /**
	         * Returns true if intersected with other box
	         * @param {Box} other_box - Query box
	         * @returns {boolean}
	         */
	        intersect(other_box) {
	            return !this.notIntersect(other_box);
	        }
	
	        /**
	         * Returns new box merged with other box
	         * @param {Box} other_box - Other box to merge with
	         * @returns {Box}
	         */
	        merge(other_box) {
	            return new Box(
	                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),
	                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),
	                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),
	                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)
	            );
	        }
	
	        /**
	         * Defines predicate "less than" between two boxes. Need for interval index
	         * @param {Box} other_box - other box
	         * @returns {boolean} - true if this box less than other box, false otherwise
	         */
	        less_than(other_box) {
	            if (this.low.lessThan(other_box.low))
	                return true;
	            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))
	                return true;
	            return false;
	        }
	
	        /**
	         * Returns true if this box is equal to other box, false otherwise
	         * @param {Box} other_box - query box
	         * @returns {boolean}
	         */
	        equal_to(other_box) {
	            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));
	        }
	
	        output() {
	            return this.clone();
	        }
	
	        maximal_val(box1, box2) {
	            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();
	            return box1.merge(box2);
	        }
	
	        val_less_than(pt1, pt2) {
	            return pt1.lessThan(pt2);
	        }
	
	        /**
	         * Set new values to the box object
	         * @param {number} xmin - miminal x coordinate
	         * @param {number} ymin - minimal y coordinate
	         * @param {number} xmax - maximal x coordinate
	         * @param {number} ymax - maximal y coordinate
	         */
	        set(xmin, ymin, xmax, ymax) {
	            this.xmin = xmin;
	            this.ymin = ymin;
	            this.xmax = xmax;
	            this.ymax = ymax;
	        }
	
	        /**
	         * Return string to draw circle in svg
	         * @param {Object} attrs - json structure with attributes of svg rectangle element,
	         * like "stroke", "strokeWidth", "fill" <br/>
	         * Defaults are stroke:"black", strokeWidth:"1", fill:"none"
	         * @returns {string}
	         */
	        svg(attrs = {}) {
	            let {stroke, strokeWidth, fill, id, className} = attrs;
	            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	            let width = this.xmax - this.xmin;
	            let height = this.ymax - this.ymin;
	
	            return `\n<rect x="${this.xmin}" y="${this.ymin}" width=${width} height=${height} stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" fill="${fill || "none"}" ${id_str} ${class_str} />`;
	        }
	    };
	};


/***/ },
/* 85 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/6/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Arc,vector} = Flatten;
	    /**
	     * Class representing a circle
	     * @type {Circle}
	     */
	    Flatten.Circle = class Circle {
	        /**
	         *
	         * @param {Point} pc - circle center point
	         * @param {number} r - circle radius
	         */
	        constructor(pc, r) {
	            /**
	             * Circle center
	             * @type {Point}
	             */
	            this.pc = pc;
	            /**
	             * Circle radius
	             * @type {number}
	             */
	            this.r = r;
	        }
	
	        /**
	         * Method clone returns new instance of a Circle
	         * @returns {Circle}
	         */
	        clone() {
	            return new Flatten.Circle(this.pc.clone(), this.r);
	        }
	
	        /**
	         * Circle center
	         * @returns {Point}
	         */
	        get center() {
	            return this.pc;
	        }
	
	        /**
	         * Circle bounding box
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(
	                this.pc.x - this.r,
	                this.pc.y - this.r,
	                this.pc.x + this.r,
	                this.pc.y + this.r
	            );
	        }
	
	        /**
	         * Return true if circle contains point
	         * @param {Point} pt - test point
	         * @returns {boolean}
	         */
	        contains(pt) {
	            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);
	        }
	
	        /**
	         * Transform circle to closed arc
	         * @param {boolean} counterclockwise
	         * @returns {Arc}
	         */
	        toArc(counterclockwise=true) {
	            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);
	        }
	
	        /**
	         * Returns array of intersection points between circle and other shape
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Circle.intersectCirle2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return shape.intersect(this);
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
	         * @returns {number} distance from circle to shape
	         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)
	
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;
	
	            if (shape instanceof Flatten.Point) {
	                let [distance, shortest_segment] = point2circle(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                let [distance, shortest_segment] = circle2circle(this, shape);
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Line) {
	                let [distance, shortest_segment] = circle2line(this, shape);
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                let [distance, shortest_segment] = segment2circle(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                let [distance, shortest_segment] = arc2circle(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.PlanarSet) {
	                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);
	                return [dist, shortest_segment];
	            }
	        }
	
	        static intersectCirle2Circle(circle1, circle2) {
	            let ip = [];
	
	            if (circle1.box.notIntersect(circle2.box)) {
	                return ip;
	            }
	
	            let vec = new Flatten.Vector(circle1.pc, circle2.pc);
	
	            let r1 = circle1.r;
	            let r2 = circle2.r;
	
	            // Degenerated circle
	            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))
	                return ip;
	
	            // In case of equal circles return one leftmost point
	            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {
	                ip.push(circle1.pc.translate(-r1, 0));
	                return ip;
	            }
	
	            let dist = circle1.pc.distanceTo(circle2.pc)[0];
	
	            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections
	                return ip;
	
	            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections
	                return ip;
	
	            // Normalize vector.
	            vec.x /= dist;
	            vec.y /= dist;
	
	            let pt;
	
	            // Case of touching from outside or from inside - single intersection point
	            // TODO: check this specifically not sure if correct
	            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {
	                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);
	                ip.push(pt);
	                return ip;
	            }
	
	            // Case of two intersection points
	
	            // Distance from first center to center of common chord:
	            //   a = (r1^2 - r2^2 + d^2) / 2d
	            // Separate for better accuracy
	            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;
	
	            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);
	            let h = Math.sqrt(r1*r1 - a*a);
	            // let norm;
	
	            // norm = vec.rotate90CCW().multiply(h);
	            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));
	            ip.push(pt);
	
	            // norm = vec.rotate90CW();
	            pt = mid_pt.translate(vec.rotate90CW().multiply(h));
	            ip.push(pt);
	
	            return ip;
	        }
	
	        /**
	         * Return string to draw circle in svg
	         * @param {Object} attrs - json structure with attributes of svg circle element,
	         * like "stroke", "strokeWidth", "fill" <br/>
	         * Defaults are stroke:"black", strokeWidth:"1", fill:"none"
	         * @returns {string}
	         */
	        svg(attrs = {}) {
	            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;
	            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	
	            return `\n<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}" stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" fill="${fill || "none"}" fill-opacity="${fillOpacity || 1.0}" ${id_str} ${class_str} />`;
	        }
	    };
	
	    /**
	     * Shortcut to create new circle
	     * @param args
	     */
	    Flatten.circle = (...args) => new Flatten.Circle(...args);
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/17/2017.
	 */
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing an edge of polygon. Edge shape may be Segment or Arc.
	     * Each edge contains references to the next and previous edges in the face of the polygon.
	     *
	     * @type {Edge}
	     */
	    Flatten.Edge = class Edge {
	        /**
	         * Construct new instance of edge
	         * @param {Shape} shape Shape of type Segment of Arc
	         */
	        constructor(shape) {
	            /**
	             * Shape of the edge: Segment or Arc
	             */
	            this.shape = shape;
	            /**
	             * Pointer to the next edge in the face
	             */
	            this.next;
	            /**
	             * Pointer to the previous edge in the face
	             */
	            this.prev;
	            /**
	             * Pointer to the face containing this edge
	             * @type {Face}
	             */
	            this.face;
	            /**
	             * "Arc distance" from the face start
	             * @type {number}
	             */
	            this.arc_length = 0;
	            /**
	             * Start inclusion flag (inside/outside/boundary)
	             * @type {Boolean}
	             */
	            this.bvStart = undefined;
	            /**
	             * End inclusion flag (inside/outside/boundary)
	             * @type {Boolean}
	             */
	            this.bvEnd = undefined;
	            /**
	             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)
	             * @type {*}
	             */
	            this.bv = undefined;
	            /**
	             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)
	             * @type {*}
	             */
	            this.overlap = undefined;
	        }
	
	        /**
	         * Get edge start point
	         */
	        get start() {
	            return this.shape.start;
	        }
	
	        /**
	         * Get edge end point
	         */
	        get end() {
	            return this.shape.end;
	        }
	
	        /**
	         * Get edge length
	         */
	        get length() {
	            return this.shape.length;
	        }
	
	        /**
	         * Get bounding box of the edge
	         * @returns {Box}
	         */
	        get box() {
	            return this.shape.box;
	        }
	
	        isSegment() {
	            return this.shape instanceof Flatten.Segment;
	        }
	
	        isArc() {
	            return this.shape instanceof Flatten.Arc;
	        }
	        /**
	         * Get middle point of the edge
	         * @returns {Point}
	         */
	        middle() {
	            return this.shape.middle();
	        }
	
	        /**
	         * Returns true if point belongs to the edge, false otherwise
	         * @param {Point} pt - test point
	         */
	        contains(pt) {
	            return this.shape.contains(pt);
	        }
	
	        /**
	         * Set inclusion flag of the edge with respect to another polygon
	         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY
	         * @param polygon
	         */
	        setInclusion(polygon) {
	            if (this.bv !== undefined) return this.bv;
	
	            if (this.bvStart === undefined) {
	                this.bvStart = Flatten.ray_shoot(polygon, this.start);
	            }
	            if (this.bvEnd === undefined) {
	                this.bvEnd = Flatten.ray_shoot(polygon, this.end);
	            }
	            /* At least one end outside - the whole edge outside */
	            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {
	                this.bv = Flatten.OUTSIDE;
	            }
	            /* At least one end inside - the whole edge inside */
	            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {
	                this.bv = Flatten.INSIDE;
	            }
	            /* Both are boundary - check the middle point */
	            else {
	                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());
	                this.bv = bvMiddle;
	            }
	            return this.bv;
	        }
	
	        /**
	         * Set overlapping between two coincident boundary edges
	         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE
	         * @param edge
	         */
	        setOverlap(edge) {
	            let flag = undefined;
	            let shape1 = this.shape;
	            let shape2 = edge.shape;
	
	            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {
	                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {
	                    flag = Flatten.OVERLAP_SAME;
	                }
	                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {
	                    flag = Flatten.OVERLAP_OPPOSITE;
	                }
	            }
	            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {
	                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.counterClockwise === shape2.counterClockwise &&
	                    shape1.middle().equalTo(shape2.middle())) {
	                    flag = Flatten.OVERLAP_SAME;
	                }
	                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.counterClockwise !== shape2.counterClockwise &&
	                    shape1.middle().equalTo(shape2.middle())) {
	                    flag = Flatten.OVERLAP_OPPOSITE;
	                }
	            }
	            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||
	                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {
	                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {
	                    flag = Flatten.OVERLAP_SAME;
	                }
	                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {
	                    flag = Flatten.OVERLAP_OPPOSITE;
	                }
	            }
	
	            /* Do not update overlap flag if already set on previous chain */
	            if (this.overlap === undefined) this.overlap = flag;
	            if (edge.overlap === undefined) edge.overlap = flag;
	        }
	
	        svg() {
	            if (this.shape instanceof Flatten.Segment) {
	                return ` L${this.shape.end.x},${this.shape.end.y}`;
	            }
	            else if (this.shape instanceof  Flatten.Arc) {
	                let arc = this.shape;
	                let largeArcFlag;
	                let sweepFlag = arc.counterClockwise ? "1" : "0";
	
	                // Draw full circe arc as special case: split it into two half-circles
	                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {
	                    let sign = arc.counterClockwise ? 1 : -1;
	                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);
	                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);
	
	                    largeArcFlag = "0";
	
	                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}
	                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`
	                }
	                else {
	                    largeArcFlag = arc.sweep <= Math.PI ? "0" : "1";
	
	                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;
	                }
	            }
	        }
	
	        toJSON() {
	            let json = this.shape.clone();
	            // json.name = this.shape.constructor.name;          // not pass webpack minification
	            json.name = this.shape instanceof  Flatten.Segment ? "segment" : "arc";
	            return json;
	        }
	    };
	};

/***/ },
/* 87 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/17/2017.
	 */
	
	"use strict";
	
	module.exports = function (Flatten) {
	    let {Point, Segment, Arc, Box, Edge} = Flatten;
	    /**
	     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.
	     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.
	     * Face object cannot be instantiated with a constructor.
	     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.
	     * <br/>
	     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.
	     * Container of edges is a property of the polygon object. <br/>
	     *
	     * @example
	     * // Face implements "next" iterator which enables to iterate edges in for loop:
	     * for (let edge of face) {
	     *      console.log(edge.shape.length)     // do something
	     * }
	     *
	     * // Instead, it is possible to iterate edges as linked list, starting from face.first:
	     * let edge = face.first;
	     * do {
	     *   console.log(edge.shape.length);   // do something
	     *   edge = edge.next;
	     * } while (edge != face.first)
	     */
	    Flatten.Face = class Face {
	        constructor(polygon, ...args) {
	            /**
	             * Reference to the first edge in face
	             */
	            this.first;
	            /**
	             * Reference to the last edge in face
	             */
	            this.last;
	
	            this._box = undefined;  // new Box();
	            this._orientation = undefined;
	
	            if (args.length == 0) {
	                return;
	            }
	
	            /* If passed an array it supposed to be:
	             1) array of shapes that performs close loop or
	             2) array of points that performs set of vertices
	             */
	            if (args.length == 1) {
	                if (args[0] instanceof Array) {
	                    // let argsArray = args[0];
	                    let shapes = args[0];  // argsArray[0];
	                    if (shapes.length == 0)
	                        return;
	
	                    if (shapes.every((shape) => {
	                            return shape instanceof Point
	                        })) {
	                        let segments = Face.points2segments(shapes);
	                        this.shapes2face(polygon.edges, segments);
	                    }
	                    else if (shapes.every((shape) => {
	                            return (shape instanceof Segment || shape instanceof Arc)
	                        })) {
	                        this.shapes2face(polygon.edges, shapes);
	                    }
	                    // this is from JSON.parse object
	                    else if (shapes.every((shape) => {
	                            return (shape.name === "segment" || shape.name === "arc")
	                        })) {
	                        let flattenShapes = [];
	                        for (let shape of shapes) {
	                            let flattenShape;
	                            if (shape.name === "segment") {
	                                flattenShape = new Segment(shape.ps.x, shape.ps.y, shape.pe.x, shape.pe.y);
	                            }
	                            else {
	                                flattenShape = new Arc(new Point(shape.pc.x, shape.pc.y),
	                                    shape.r, shape.startAngle, shape.endAngle, shape.counterClockwise);
	                            }
	                            flattenShapes.push(flattenShape);
	                        }
	                        this.shapes2face(polygon.edges, flattenShapes);
	                    }
	                }
	                /* Create new face and copy edges into polygon.edges set */
	                else if (args[0] instanceof Face) {
	                    let face = args[0];
	                    this.first = face.first;
	                    this.last = face.last;
	                    for (let edge of face) {
	                        polygon.edges.add(edge);
	                    }
	                }
	            }
	            /* If passed two edges, consider them as start and end of the face loop */
	            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */
	            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */
	            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {
	                this.first = args[0];                          // first edge in face or undefined
	                this.last = args[1];                           // last edge in face or undefined
	                this.last.next = this.first;
	                this.first.prev = this.last;
	
	                // set arc length
	                this.setArcLength();
	                /*
	                 let edge = this.first;
	                 edge.arc_length = 0;
	                 edge = edge.next;
	                 while (edge !== this.first) {
	                 edge.arc_length = edge.prev.arc_length + edge.prev.length;
	                 edge = edge.next;
	                 }
	                 */
	
	                // this.box = this.getBox();
	                // this.orientation = this.getOrientation();      // face direction cw or ccw
	            }
	        }
	
	        [Symbol.iterator]() {
	            let edge = undefined;
	            return {
	                next: () => {
	                    let value = edge ? edge : this.first;
	                    let done = this.first ? (edge ? edge === this.first : false) : true;
	                    edge = value ? value.next : undefined;
	                    return {value: value, done: done};
	                }
	            };
	        };
	
	        /**
	         * Return array of edges from first to last
	         * @returns {Array}
	         */
	        get edges() {
	            let face_edges = [];
	            for (let edge of this) {
	                face_edges.push(edge);
	            }
	            return face_edges;
	        }
	
	        /**
	         * Return number of edges in the face
	         * @returns {number}
	         */
	        get size() {
	            let counter = 0;
	            for (let edge of this) {
	                counter++;
	            }
	            return counter;
	        }
	
	        /**
	         * Return bounding box of the face
	         * @returns {Box}
	         */
	        get box() {
	            if (this._box === undefined) {
	                let box = new Flatten.Box();
	                for (let edge of this) {
	                    box = box.merge(edge.box);
	                }
	                this._box = box;
	            }
	            return this._box;
	        }
	
	        static points2segments(points) {
	            let segments = [];
	            for (let i = 0; i < points.length; i++) {
	                segments.push(new Segment(points[i], points[(i + 1) % points.length]));
	            }
	            return segments;
	        }
	
	        shapes2face(edges, shapes) {
	            for (let shape of shapes) {
	                let edge = new Edge(shape);
	                this.append(edges, edge);
	                // this.box = this.box.merge(shape.box);
	                // edges.add(edge);
	            }
	            // this.orientation = this.getOrientation();              // face direction cw or ccw
	        }
	
	        /**
	         * Returns true if face is empty, false otherwise
	         * @returns {boolean}
	         */
	        isEmpty() {
	            return (this.first === undefined && this.last === undefined)
	        }
	
	        /**
	         * Append given edge after the last edge (and before the first edge). <br/>
	         * This method mutates current object and does not return any value
	         * @param {PlanarSet} edges - Container of edges
	         * @param {Edge} edge - Edge to be appended to the linked list
	         */
	        append(edges, edge) {
	            if (this.first === undefined) {
	                edge.prev = edge;
	                edge.next = edge;
	                this.first = edge;
	                this.last = edge;
	                edge.arc_length = 0;
	            }
	            else {
	                // append to end
	                edge.prev = this.last;
	                this.last.next = edge;
	
	                // update edge to be last
	                this.last = edge;
	
	                // restore circular links
	                this.last.next = this.first;
	                this.first.prev = this.last;
	
	                // set arc length
	                edge.arc_length = edge.prev.arc_length + edge.prev.length;
	            }
	            edge.face = this;
	
	            edges.add(edge);      // Add new edges into edges container
	        }
	
	        /**
	         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>
	         * This method mutates current object and does not return any value
	         * @param {PlanarSet} edges - Container of edges
	         * @param {Edge} newEdge - Edge to be inserted into linked list
	         * @param {Edge} edgeBefore - Edge to insert newEdge after it
	         */
	        insert(edges, newEdge, edgeBefore) {
	            if (this.first === undefined) {
	                newEdge.prev = newEdge;
	                newEdge.next = newEdge;
	                this.first = newEdge;
	                this.last = newEdge;
	            }
	            else {
	                /* set links to new edge */
	                let edgeAfter = edgeBefore.next;
	                edgeBefore.next = newEdge;
	                edgeAfter.prev = newEdge;
	
	                /* set links from new edge */
	                newEdge.prev = edgeBefore;
	                newEdge.next = edgeAfter;
	
	                /* extend chain if new edge added after last edge */
	                if (this.last === edgeBefore)
	                    this.first = newEdge;
	            }
	            newEdge.face = this;
	
	            // set arc length
	            if (newEdge.prev === this.last) {
	                newEdge.arc_length = 0;
	            }
	            else {
	                newEdge.arc_length = newEdge.prev.arc_length + newEdge.prev.length;
	            }
	
	            edges.add(newEdge);      // Add new edges into edges container
	        }
	
	        /**
	         * Remove the given edge from the linked list of the face <br/>
	         * This method mutates current object and does not return any value
	         * @param {PlanarSet} edges - Container of edges
	         * @param {Edge} edge - Edge to be removed
	         */
	        remove(edges, edge) {
	            // special case if last edge removed
	            if (edge === this.first && edge === this.last) {
	                this.first = undefined;
	                this.last = undefined;
	            }
	            else {
	                // update linked list
	                edge.prev.next = edge.next;
	                edge.next.prev = edge.prev;
	                // update first if need
	                if (edge === this.first) {
	                    this.first = edge.next;
	                }
	                // update last if need
	                if (edge === this.last) {
	                    this.last = edge.prev;
	                }
	            }
	            edges.delete(edge);      // delete from PlanarSet of edges and update index
	        }
	
	        /**
	         * Reverse orientation of the face: first edge become last and vice a verse,
	         * all edges starts and ends swapped, direction of arcs inverted.
	         */
	        reverse() {
	            // collect edges in revert order with reverted shapes
	            let edges = [];
	            let edge_tmp = this.last;
	            do {
	                // reverse shape
	                edge_tmp.shape = edge_tmp.shape.reverse();
	                edges.push(edge_tmp);
	                edge_tmp = edge_tmp.prev;
	            } while (edge_tmp !== this.last);
	
	            // restore linked list
	            this.first = undefined;
	            this.last = undefined;
	            for (let edge of edges) {
	                if (this.first === undefined) {
	                    edge.prev = edge;
	                    edge.next = edge;
	                    this.first = edge;
	                    this.last = edge;
	                    edge.arc_length = 0;
	                }
	                else {
	                    // append to end
	                    edge.prev = this.last;
	                    this.last.next = edge;
	
	                    // update edge to be last
	                    this.last = edge;
	
	                    // restore circular links
	                    this.last.next = this.first;
	                    this.first.prev = this.last;
	
	                    // set arc length
	                    edge.arc_length = edge.prev.arc_length + edge.prev.length;
	                }
	            }
	
	            // Recalculate orientation, if set
	            if (this._orientation !== undefined) {
	                this._orientation = undefined;
	                this._orientation = this.orientation();
	            }
	        }
	
	
	        /**
	         * Set arc_length property for each of the edges in the face.
	         * Arc_length of the edge it the arc length from the first edge of the face
	         */
	        setArcLength() {
	            for (let edge of this) {
	                if (edge === this.first) {
	                    edge.arc_length = 0.0;
	                }
	                else {
	                    edge.arc_length = edge.prev.arc_length + edge.prev.length;
	                }
	                edge.face = this;
	            }
	        }
	
	        /**
	         * Returns the absolute value of the area of the face
	         * @returns {number}
	         */
	        area() {
	            return Math.abs(this.signedArea());
	        }
	
	        /**
	         * Returns signed area of the simple face.
	         * Face is simple if it has no self intersections that change its orientation.
	         * Then the area will be positive if the orientation of the face is clockwise,
	         * and negative if orientation is counterclockwise.
	         * It may be zero if polygon is degenerated.
	         * @returns {number}
	         */
	        signedArea() {
	            let sArea = 0;
	            for (let edge of this) {
	                sArea += edge.shape.definiteIntegral(this.box.ymin);
	            }
	            return sArea;
	        }
	
	        /**
	         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>
	         * According to Green theorem the area of a closed curve may be calculated as double integral,
	         * and the sign of the integral will be defined by the direction of the curve.
	         * When the integral ("signed area") will be negative, direction is counter clockwise,
	         * when positive - clockwise and when it is zero, polygon is not orientable.
	         * See {@link https://mathinsight.org/greens_theorem_find_area}
	         * @returns {number}
	         */
	        orientation() {
	            if (this._orientation === undefined) {
	                let area = this.signedArea();
	                if (Flatten.Utils.EQ_0(area)) {
	                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;
	                }
	                else if (Flatten.Utils.LT(area, 0)) {
	                    this._orientation = Flatten.ORIENTATION.CCW;
	                }
	                else {
	                    this._orientation = Flatten.ORIENTATION.CW;
	                }
	            }
	            return this._orientation;
	        }
	
	        /**
	         * Check relation between face and other polygon
	         * on strong assumption that they are NOT INTERSECTED <br/>
	         * Then there are 4 options: <br/>
	         * face disjoint to polygon - Flatten.OUTSIDE <br/>
	         * face inside polygon - Flatten.INSIDE <br/>
	         * face contains polygon - Flatten.CONTAIN <br/>
	         * face interlaced with polygon: inside some face and contains other face - Flatten.INTERLACE <br/>
	         * @param {Polygon} polygon - Polygon to check relation
	         */
	        getRelation(polygon) {
	            this.first.bv = this.first.bvStart = this.first.bvEnd = undefined;
	            let bvThisInOther = this.first.setInclusion(polygon);
	            let resp = polygon.faces.search(this.box);
	            if (resp.length === 0) {
	                return bvThisInOther;        // OUTSIDE or INSIDE
	            }
	            else {                           // possible INTERLACE
	                let polyTmp = new Flatten.Polygon();
	                polyTmp.addFace(this);
	
	                let numInsideThis = 0;
	                for (let face of resp) {
	                    face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;
	                    let bvOtherInThis = face.first.setInclusion(polyTmp);
	                    if (bvOtherInThis === Flatten.INSIDE) {
	                        numInsideThis++;
	                    }
	                }
	                if (bvThisInOther === Flatten.OUTSIDE) {
	                    if (numInsideThis === 0) {                   // none inside this - outside
	                        return Flatten.OUTSIDE;
	                    }
	                    else if (numInsideThis === resp.length) {      // all from resp inside this - contains or interlace
	                        if (resp.length === polygon.faces.size) {
	                            return Flatten.CONTAINS;               // all faces from polygon are in response - contains
	                        }
	                        else {
	                            return Flatten.INTERLACE;              // some faces inside - interlace
	                        }
	                    }
	                    else {
	                        return Flatten.INTERLACE;                  // some faces inside - interlace
	                    }
	                }
	                else if (bvThisInOther === Flatten.INSIDE) {
	                    return numInsideThis === 0 ? Flatten.INSIDE : Flatten.INTERLACE;
	                }
	            }
	        }
	
	        /**
	         * Returns true if face of the polygon is simple (no self-intersection points found)
	         * NOTE: this method is incomplete because it doe not exclude touching points
	         * Real self intersection inverts orientation of the polygon.
	         * But this is also good enough for the demonstration of the idea
	         * @param {Edges} edges - reference to polygon.edges to provide search index
	         * @returns {boolean}
	         */
	        isSimple(edges) {
	            let ip = Face.getSelfIntersections(this, edges, true);
	            return ip.length == 0;
	        }
	
	        static getSelfIntersections(face, edges, exitOnFirst = false) {
	            let int_points = [];
	
	            // calculate intersections
	            for (let edge1 of face) {
	
	                // request edges of polygon in the box of edge1
	                let resp = edges.search(edge1.box);
	
	                // for each edge2 in response
	                for (let edge2 of resp) {
	
	                    // Skip itself
	                    if (edge1 === edge2)
	                        continue;
	
	                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)
	                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&
	                        (edge1.next === edge2 || edge1.prev === edge2))
	                        continue;
	
	                    // calculate intersections between edge1 and edge2
	                    let ip = edge1.shape.intersect(edge2.shape);
	
	                    // for each intersection point
	                    for (let pt of ip) {
	
	                        // skip start-end connections
	                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)
	                            continue;
	                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)
	                            continue;
	
	                        int_points.push(pt);
	
	                        if (exitOnFirst)
	                            break;
	                    }
	
	                    if (int_points.length > 0 && exitOnFirst)
	                        break;
	                }
	
	                if (int_points.length > 0 && exitOnFirst)
	                    break;
	
	            }
	            return int_points;
	        }
	
	        toJSON() {
	            return this.edges.map(edge => edge.toJSON());
	        }
	
	        svg() {
	            let svgStr = `\nM${this.first.start.x},${this.first.start.y}`;
	
	            for (let edge of this) {
	                svgStr += edge.svg();
	            }
	
	            svgStr += ` z`;
	            return svgStr;
	        }
	
	    };
	};

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/20/2017.
	 */
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a line
	     * @type {Line}
	     */
	    Flatten.Line = class Line {
	        /**
	         * Line may be constructed by point and normal vector or by two points that a line passes through
	         * @param {Point} pt - point that a line passes through
	         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through
	         */
	        constructor(...args) {
	            /**
	             * Point a line passes through
	             * @type {Point}
	             */
	            this.pt = new Flatten.Point();
	            /**
	             * Normal unit vector to a line
	             * @type {Vector}
	             */
	            this.norm = new Flatten.Vector(0,1);
	
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 2) {
	                let a1 = args[0];
	                let a2 = args[1];
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
	                    this.pt = a1;
	                    this.norm = Line.points2norm(a1, a2);
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {
	                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {
	                        throw Flatten.Errors.ILLEGAL_PARAMETERS;
	                    }
	                    this.pt = a1.clone();
	                    this.norm = a2.clone();
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {
	                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {
	                        throw Flatten.Errors.ILLEGAL_PARAMETERS;
	                    }
	                    this.pt = a2.clone();
	                    this.norm = a1.clone();
	                    return;
	                }
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Returns cloned new instance of a line
	         * @returns {Line}
	         */
	        clone() {
	            return new Flatten.Line(this.pt, this.norm);
	        }
	
	        /**
	         * Slope of the line - angle in radians between line and axe x from 0 to 2PI
	         * @returns {number} - slope of the line
	         */
	        get slope() {
	            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);
	            return vec.slope;
	        }
	
	        /**
	         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C
	         * @code [A, B, C] = line.standard
	         * @returns {number[]} - array of coefficients
	         */
	        get standard() {
	            let A = this.norm.x;
	            let B = this.norm.y;
	            let C = this.norm.dot(this.pt);
	
	            return [A,B,C];
	        }
	
	        /**
	         * Return true if parallel or incident to other line
	         * @param {Line} other_line - line to check
	         * @returns {boolean}
	         */
	        parallelTo(other_line) {
	            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));
	        }
	
	        /**
	         * Returns true if incident to other line
	         * @param {Line} other_line - line to check
	         * @returns {boolean}
	         */
	        incidentTo(other_line) {
	            return this.parallelTo(other_line) && this.pt.on(other_line);
	        }
	
	        /**
	         * Returns true if point belongs to line
	         * @param {Point} pt Query point
	         * @returns {boolean}
	         */
	        contains(pt) {
	            if (this.pt.equalTo(pt)) {
	                return true;
	            }
	            /* Line contains point if vector to point is orthogonal to the line normal vector */
	            let vec = new Flatten.Vector(this.pt, pt);
	            return Flatten.Utils.EQ_0(this.norm.dot(vec));
	        }
	
	        /**
	         * Returns array of intersection points
	         * @param {Shape} shape - shape to intersect with of the type Line, Circle, Segment, Arc
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return Line.intersectLine2Line(this, shape);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Line.intersectLine2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return shape.intersect(this);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return Line.intersectLine2Arc(this, shape);
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]
	         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon
	         * @returns {Number}
	         * @returns {Segment}
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	
	            if (shape instanceof Flatten.Point) {
	                let [distance, shortest_segment] = Distance.point2line(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                let [distance, shortest_segment] = Distance.circle2line(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [distance, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                let [distance, shortest_segment] = Distance.segment2line(shape, this);
	                return [distance, shortest_segment.reverse()];
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                let [distance, shortest_segment] = Distance.arc2line(shape, this);
	                return [distance, shortest_segment.reverse()];
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);
	                return [distance, shortest_segment];
	            }
	        }
	
	        /**
	         * Return string to draw svg segment representing line inside given box
	         * @param {Box} box Box representing drawing area
	         * @param {Object} attrs - json structure with attributes of svg circle element
	         */
	        svg(box, attrs = {}) {
	            let ip = Line.intersectLine2Box(this, box);
	            if (ip.length === 0)
	                return "";
	            let ps = ip[0];
	            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );
	            if (pe === undefined) pe = ps;
	            let segment = new Flatten.Segment(ps, pe);
	            return segment.svg(attrs);
	        }
	
	        static points2norm(pt1, pt2) {
	            if (pt1.equalTo(pt2)) {
	                throw Flatten.Errors.ILLEGAL_PARAMETERS;
	            }
	            let vec = new Flatten.Vector(pt1, pt2);
	            let unit = vec.normalize();
	            return unit.rotate90CCW();
	        }
	
	        static intersectLine2Line(line1, line2) {
	            let ip = [];
	
	            let [A1, B1, C1] = line1.standard;
	            let [A2, B2, C2] = line2.standard;
	
	            /* Cramer's rule */
	            let det = A1*B2 - B1*A2;
	            let detX = C1*B2 - B1*C2;
	            let detY = A1*C2 - C1*A2;
	
	            if (!Flatten.Utils.EQ_0(det)) {
	                let new_ip = new Flatten.Point( detX/det, detY/det );
	                ip.push(new_ip);
	            }
	            return ip;
	        }
	
	        static intersectLine2Circle(line, circle) {
	            let ip = [];
	            let prj = circle.pc.projectionOn(line);            // projection of circle center on line
	            let dist = circle.pc.distanceTo(prj)[0];              // distance from circle center to projection
	
	            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point
	                ip.push(prj);
	            }
	            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points
	                var delta = Math.sqrt(circle.r*circle.r - dist*dist);
	                var v_trans, pt;
	
	                v_trans = line.norm.rotate90CCW().multiply(delta);
	                pt = prj.translate(v_trans);
	                ip.push(pt);
	
	                v_trans = line.norm.rotate90CW().multiply(delta);
	                pt = prj.translate(v_trans);
	                ip.push(pt);
	            }
	            return ip;
	        }
	
	        static intersectLine2Box(line, box) {
	            let pts = [
	                new Flatten.Point(box.xmin, box.ymin),
	                new Flatten.Point(box.xmax, box.ymin),
	                new Flatten.Point(box.xmax, box.ymax),
	                new Flatten.Point(box.xmin, box.ymax)
	            ];
	            let segs = [
	                new Flatten.Segment(pts[0], pts[1]),
	                new Flatten.Segment(pts[1], pts[2]),
	                new Flatten.Segment(pts[2], pts[3]),
	                new Flatten.Segment(pts[3], pts[0])
	            ];
	
	            let ips =  [];
	
	            for(let seg of segs) {
	                let ips_tmp = seg.intersect(line);
	                for (let ip of ips_tmp) {
	                    ips.push(ip);
	                }
	            };
	            return ips;
	        }
	
	        static intersectLine2Arc(line, arc) {
	            let ip = [];
	
	            if (Line.intersectLine2Box(line, arc.box).length == 0) {
	                return ip;
	            }
	
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	            let ip_tmp = line.intersect(circle);
	            for (let pt of ip_tmp) {
	                if (pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	
	            return ip;
	        }
	    };
	
	    /**
	     * Function to create line equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.line = (...args) => new Flatten.Line(...args);
	};


/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing an affine transformation 3x3 matrix:
	     * <pre>
	     *      [ a  c  tx
	     * A =    b  d  ty
	     *        0  0  1  ]
	     * </pre
	     * @type {Matrix}
	     */
	    Flatten.Matrix = class Matrix {
	        /**
	         * Construct new instance of affine transformation matrix <br/>
	         * If parameters omitted, construct identity matrix a = 1, d = 1
	         * @param {number} a - position(0,0)   sx*cos(alpha)
	         * @param {number} b - position (0,1)  sx*sin(alpha)
	         * @param {number} c - position (1,0)  -sy*sin(alpha)
	         * @param {number} d - position (1,1)  sy*cos(alpha)
	         * @param {number} tx - position (2,0) translation by x
	         * @param {number} ty - position (2,1) translation by y
	         */
	        constructor(a=1,b=0,c=0,d=1,tx=0,ty=0) {
	            this.a = a;
	            this.b = b;
	            this.c = c;
	            this.d = d;
	            this.tx = tx;
	            this.ty = ty;
	        }
	
	        /**
	         * Returns a clone of the Matrix instance.
	         * @return {Matrix}
	         **/
	        clone() {
	            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
	        };
	
	        /**
	         * Transform vector [x,y] using transformation matrix. <br/>
	         * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>
	         * The result is also an abstract vector [x',y'] = A * [x,y]:
	         * <code>
	         * [x'       [ ax + by + tx
	         *  y'   =     cx + dy + ty
	         *  1]                    1 ]
	         * </code>
	         * @param {number[]} vector - array[2] of numbers
	         * @returns {number[]} transformation result - array[2] of numbers
	         */
	        transform(vector) {
	            return [
	                vector[0]*this.a+vector[1]*this.c+this.tx,
	                vector[0]*this.b+vector[1]*this.d+this.ty
	            ]
	        };
	
	        /**
	         * Returns result of multiplication of this matrix by other matrix
	         * @param {Matrix} other_matrix - matrix to multiply by
	         * @returns {Matrix}
	         */
	        multiply(other_matrix) {
	            return new Matrix(
	                this.a*other_matrix.a + this.c*other_matrix.b,
	                this.b*other_matrix.a + this.d*other_matrix.b,
	                this.a*other_matrix.c + this.c*other_matrix.d,
	                this.b*other_matrix.c + this.d*other_matrix.d,
	                this.a*other_matrix.tx + this.c*other_matrix.ty + this.tx,
	                this.b*other_matrix.tx + this.d*other_matrix.ty + this.ty
	            )
	        };
	
	        /**
	         * Return new matrix as a result of multiplication of the current matrix
	         * by the matrix(1,0,0,1,tx,ty)
	         * @param {number} tx - translation by x
	         * @param {number} ty - translation by y
	         * @returns {Matrix}
	         */
	        translate(tx, ty) {
	            return this.multiply(new Matrix(1,0,0,1,tx,ty))
	        };
	
	        /**
	         * Return new matrix as a result of multiplication of the current matrix
	         * by the matrix that defines rotation by given angle (in radians) around
	         * point (0,0) in counter clockwise direction
	         * @param angle
	         * @returns {Matrix}
	         */
	        rotate(angle) {
	            let cos = Math.cos(angle);
	            let sin = Math.sin(angle);
	            return this.multiply(new Matrix(cos,sin,-sin,cos,0,0));
	        };
	
	        /**
	         * Return new matrix as result of mutiplication of the current matrix
	         * by the matrix (sx,0,0,sy,0,0) that defines scaling
	         * @param sx
	         * @param sy
	         * @returns {Matrix}
	         */
	        scale(sx, sy) {
	            return this.multiply(new Matrix(sx,0,0,sy,0,0));
	        };
	
	        /**
	         * Returns true if two matrix are equal parameter by parameter
	         * @param {Matrix} matrix - other matrix
	         * @returns {boolean} true if equal, false otherwise
	         */
	        equalTo(matrix) {
	            if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;
	            if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;
	            if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;
	            if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;
	            if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;
	            if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;
	            return true;
	        };
	    };
	
	    /**
	     * Function to create matrix equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.matrix = (...args) => new Flatten.Matrix(...args);
	};


/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	
	/**
	 *
	 * @param Flatten
	 */
	module.exports = function(Flatten) {
	    /**
	     *
	     * Class representing a point
	     * @type {Point}
	     */
	    Flatten.Point = class Point {
	        /**
	         *
	         * @param {number} x - x-coordinate (float number)
	         * @param {number} y - y-coordinate (float number)
	         */
	        constructor(x = 0, y = 0) {
	            /**
	             * x-coordinate (float number)
	             * @type {number}
	             */
	            this.x = Number.isNaN(x) ? 0 : x;
	            /**
	             * y-coordinate (float number)
	             * @type {number}
	             */
	            this.y = Number.isNaN(y) ? 0: y;
	        }
	
	        /**
	         * Returns bounding box of a point
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(this.x, this.y, this.x, this.y);
	        }
	
	        /**
	         * Method clone returns new copied instance of point
	         * @returns {Point}
	         */
	        clone() {
	            return new Flatten.Point(this.x, this.y);
	        }
	
	        get vertices() {
	            return [this.clone()];
	        }
	
	        /**
	         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance
	         * @param {Point} pt Query point
	         * @returns {boolean}
	         */
	        equalTo(pt) {
	            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);
	        }
	
	        /**
	         * Defines predicate "less than" between points. Returns true if the point is less than query points, false otherwise <br/>
	         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>
	         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance
	         * @param {Point} pt Query point
	         * @returns {boolean}
	         */
	        lessThan(pt) {
	            if (Flatten.Utils.LT(this.y, pt.y))
	                return true;
	            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))
	                return true;
	            return false;
	        }
	
	        /**
	         * Returns new point rotated by given angle around given center point.
	         * If center point is omitted, rotates around zero point (0,0).
	         * Positive value of angle defines rotation in counter clockwise direction,
	         * negative angle defines rotation in clockwise clockwise direction
	         * @param {number} angle - angle in radians
	         * @param {Point} [center=(0,0)] center
	         * @returns {Point}
	         */
	        rotate(angle, center = {x:0, y:0}) {
	            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);
	            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);
	
	            return new Flatten.Point(x_rot, y_rot);
	        }
	
	        /**
	         * Returns new point translated by given vector.
	         * Translation vector may by also defined by a pair of numbers.
	         * @param {Vector} vector - Translation vector defined as Flatten.Vector or
	         * @param {number|number} - Translation vector defined as pair of numbers
	         * @returns {Point}
	         */
	        translate(...args) {
	            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {
	                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);
	            }
	
	            if (args.length == 2 && typeof(args[0]) == "number" && typeof(args[1]) == "number") {
	                return new Flatten.Point(this.x + args[0], this.y + args[1]);
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Return new point transformed by affine transformation matrix m
	         * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)
	         * @returns {Point}
	         */
	        transform(m) {
	            let [x,y] = m.transform([this.x,this.y]);
	            return new Flatten.Point(x,y)
	        }
	
	        /**
	         * Returns projection point on given line
	         * @param {Line} line Line this point be projected on
	         * @returns {Point}
	         */
	        projectionOn(line) {
	            if (this.equalTo(line.pt))                   // this point equal to line anchor point
	                return this.clone();
	
	            let vec = new Flatten.Vector(this, line.pt);
	            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector
	                return line.pt.clone();
	
	            let dist = vec.dot(line.norm);             // signed distance
	            let proj_vec = line.norm.multiply(dist);
	            return this.translate(proj_vec);
	        }
	
	        /**
	         * Returns true if point belongs to the "left" semi-plane, which means, point belongs to the same semi plane where line normal vector points to
	         * Return false if point belongs to the "right" semi-plane or to the line itself
	         * @param {Line} line Query line
	         * @returns {boolean}
	         */
	        leftTo(line) {
	            let vec = new Flatten.Vector(line.pt, this);
	            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);
	            return onLeftSemiPlane;
	        }
	
	        /**
	         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
	         * @returns {number} distance from point to shape
	         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	
	            if (shape instanceof Point) {
	                let dx = shape.x - this.x;
	                let dy = shape.y - this.y;
	                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];
	            }
	
	            if (shape instanceof Flatten.Line) {
	                return Distance.point2line(this, shape);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Distance.point2circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return Distance.point2segment(this, shape);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                // let [dist, ...rest] = Distance.point2arc(this, shape);
	                // return dist;
	                return Distance.point2arc(this, shape);
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                // let [dist, ...rest] = Distance.point2polygon(this, shape);
	                // return dist;
	                return Distance.point2polygon(this, shape);
	            }
	
	            if (shape instanceof Flatten.PlanarSet) {
	                return Distance.shape2planarSet(this, shape);
	            }
	        }
	
	        /**
	         * Returns true if point is on a shape, false otherwise
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon
	         * @returns {boolean}
	         */
	        on(shape) {
	            if (shape instanceof Flatten.Point) {
	                return this.equalTo(shape);
	            }
	
	            if (shape instanceof Flatten.Line) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof  Flatten.Segment) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return shape.contains(this);
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                return shape.contains(this);
	            }
	        }
	
	        /**
	         * Return string to draw point in svg as circle with radius "r" <br/>
	         * Accept any valid attributes of svg elements as svg object
	         * Defaults attribues are: <br/>
	         * {
	         *    r:"3",
	         *    stroke:"black",
	         *    strokeWidth:"1",
	         *    fill:"red"
	         * }
	         * @param {Object} attrs - Any valid attributes of svg circle element, like "r", "stroke", "strokeWidth", "fill"
	         * @returns {String}
	         */
	        svg(attrs = {}) {
	            let {r, stroke, strokeWidth, fill, id, className} = attrs;
	            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	            return `\n<circle cx="${this.x}" cy="${this.y}" r="${r || 3}" stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" fill="${fill || "red"}" ${id_str} ${class_str} />`;
	        }
	
	    };
	
	    /**
	     * Function to create point equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.point = (...args) => new Flatten.Point(...args);
	};


/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/15/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    let {Edge, Face, PlanarSet, Box} = Flatten;
	    let {ray_shoot} = Flatten;
	    /**
	     * Class representing a polygon.<br/>
	     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>
	     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>
	     * @type {Polygon}
	     */
	    Flatten.Polygon = class Polygon {
	        /**
	         * Constructor creates new instance of polygon.<br/>
	         * New polygon is empty. Add face to the polygon using method <br/>
	         * <code>
	         *     polygon.addFace(Points[]|Segments[]|Arcs[])
	         * </code>
	         */
	        constructor() {
	            /**
	             * Container of faces (closed loops), may be empty
	             * @type {PlanarSet}
	             */
	            this.faces = new PlanarSet();
	            /**
	             * Container of edges
	             * @type {PlanarSet}
	             */
	            this.edges = new PlanarSet();
	        }
	
	        /**
	         * (Getter) Returns bounding box of the polygon
	         * @returns {Box}
	         */
	        get box() {
	            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );
	        }
	
	        /**
	         * (Getter) Returns array of vertices
	         * @returns {Array}
	         */
	        get vertices() {
	            return [...this.edges].map( edge => edge.start);
	        }
	
	        /**
	         * Add new face to polygon. Returns added face
	         * @param {Points[]|Segments[]|Arcs[]} args - list of points or list of shapes (segments and arcs)
	         * which comprise a closed loop
	         * @returns {Face}
	         */
	        addFace(...args) {
	            let face = new Face(this, ...args);
	            this.faces.add(face);
	            return face;
	        }
	
	        /**
	         * Delete existing face from polygon
	         * @param {Face} face Face to be deleted
	         * @returns {boolean}
	         */
	        deleteFace(face) {
	            for (let edge of face) {
	                let deleted = this.edges.delete(edge);
	            }
	            let deleted = this.faces.delete(face);
	            return deleted;
	        }
	
	        /**
	         * Delete chain of edges from the face.
	         * @param {Face} face Face to remove chain
	         * @param {Edge} edgeFrom Start of the chain of edges to be removed
	         * @param {Edge} edgeTo End of the chain of edges to be removed
	         */
	        removeChain(face, edgeFrom, edgeTo) {
	            // Special case: all edges removed
	            if (edgeTo.next === edgeFrom) {
	                this.deleteFace(face);
	                return;
	            }
	            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {
	                face.remove(this.edges, edge);
	                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index
	                if (face.isEmpty()) {
	                    this.deleteFace(face);    // delete from PlanarSet of faces and update index
	                    break;
	                }
	            }
	        }
	
	        /**
	         * Add point as a new vertex and split edge. Point supposed to belong to an edge.
	         * When edge is split, new edge created from the start of the edge to the new vertex
	         * and inserted before current edge.
	         * Current edge is trimmed and updated. Method returns new edge added.
	         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start
	         * @param {Point} pt Point to be added as a new vertex
	         * @returns {Edge}
	         */
	        addVertex(pt, edge) {
	            let shapes = edge.shape.split(pt);
	            if (shapes.length < 2) return;
	            let newEdge = new Flatten.Edge(shapes[0]);
	            let edgeBefore = edge.prev;
	
	            /* Insert first split edge into linked list after edgeBefore */
	            edge.face.insert(this.edges, newEdge, edgeBefore);
	
	            // Remove old edge from edges container and 2d index
	            this.edges.delete(edge);
	
	            // Update edge shape with second split edge keeping links
	            edge.shape = shapes[1];
	
	            // Add updated edge to the edges container and 2d index
	            this.edges.add(edge);
	
	            return newEdge;
	        }
	
	        reverse() {
	            for (let face of this.faces) {
	                face.reverse();
	            }
	            return this;
	        }
	
	        /**
	         * Create new copied instance of the polygon
	         * @returns {Polygon}
	         */
	        clone() {
	            let polygon = new Polygon();
	            for (let face of this.faces) {
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape.clone());
	                }
	                polygon.addFace(shapes);
	            }
	            return polygon;
	        }
	
	        /**
	         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted
	         * @returns {number}
	         */
	        area() {
	            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);
	            return Math.abs(signedArea);
	        }
	
	        /**
	         * Returns true if polygon contains point, including polygon boundary, false otherwise
	         * Point in polygon test based on ray shooting algorithm
	         * @param {Point} point - test point
	         * @returns {boolean}
	         */
	        contains(point) {
	            let rel = ray_shoot(this, point);
	            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;
	        }
	
	        /**
	         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]
	         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon
	         * @returns {Number | Segment}
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	
	            if (shape instanceof Flatten.Point) {
	                let [dist, shortest_segment] = Distance.point2polygon(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Circle ||
	            shape instanceof Flatten.Line ||
	            shape instanceof Flatten.Segment ||
	            shape instanceof Flatten.Arc) {
	                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [dist, shortest_segment];
	            }
	
	            /* this method is bit faster */
	            if (shape instanceof  Flatten.Polygon) {
	                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
	                let dist, shortest_segment;
	
	                for (let edge of this.edges) {
	                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);
	                    let min_stop = min_dist_and_segment[0];
	                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);
	                    if (Flatten.Utils.LT(dist, min_stop)) {
	                        min_dist_and_segment = [dist, shortest_segment];
	                    }
	                }
	                return min_dist_and_segment;
	            }
	        }
	
	        /**
	         * Return true if polygon is valid for boolean operations
	         * Polygon is valid if <br/>
	         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>
	         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>
	         * 3. There is no intersections between faces (excluding touching) - TODO <br/>
	         * @returns {boolean}
	         */
	        isValid() {
	            let valid = true;
	            // 1. Polygon is invalid if at least one face is not simple
	            for (let face of this.faces) {
	                if (!face.isSimple(this.edges)) {
	                    valid = false;
	                    break;
	                }
	            }
	            // 2. TODO: check if no island inside island and no hole inside hole
	            // 3. TODO: check the there is no intersection between faces
	            return valid;
	        }
	
	        /**
	         * Returns new polygon translated by vector vec
	         * @param {Vector} vec
	         * @returns {Polygon}
	         */
	        translate(vec) {
	            let newPolygon = new Polygon();
	            for (let face of this.faces) {
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape.translate(vec));
	                }
	                newPolygon.addFace(shapes);
	            }
	            return newPolygon;
	        }
	
	        /**
	         * Return new polygon rotated by given angle around given point
	         * If point omitted, rotate around origin (0,0)
	         * Positive value of angle defines rotation counter clockwise, negative - clockwise
	         * @param {number} angle - rotation angle in radians
	         * @param {Point} center - rotation center, default is (0,0)
	         * @returns {Polygon} - new rotated polygon
	         */
	        rotate(angle=0, center=new Flatten.Point()) {
	            let newPolygon = new Polygon();
	            for (let face of this.faces) {
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape.rotate(angle, center));
	                }
	                newPolygon.addFace(shapes);
	            }
	            return newPolygon;
	        }
	
	        /**
	         * Return new polygon transformed using affine transformation matrix
	         * @param {Matrix} matrix - affine transformation matrix
	         * @returns {Polygon} - new polygon
	         */
	        transform(matrix = new Flatten.Matrix()) {
	            let newPolygon = new Polygon();
	            for (let face of this.faces) {
	                let shapes = [];
	                for (let edge of face) {
	                    shapes.push(edge.shape.transform(matrix));
	                }
	                newPolygon.addFace(shapes);
	            }
	            return newPolygon;
	        }
	
	        /**
	         * Return string to draw polygon in svg
	         * @param attrs  - json structure with attributes for svg path element,
	         * like "stroke", "strokeWidth", "fill", "fillRule"
	         * Defaults are stroke:"black", strokeWidth:"1", fill:"lightcyan", fillRule:"evenodd"
	         * @returns {string}
	         */
	        svg(attrs = {}) {
	            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;
	            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	
	            let svgStr = `\n<path stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" fill="${fill || "lightcyan"}" fill-rule="${fillRule || "evenodd"}" fill-opacity="${fillOpacity || 1.0}" ${id_str} ${class_str} d="`;
	            for (let face of this.faces) {
	                svgStr += face.svg();
	            }
	            svgStr += `" >\n</path>`;
	
	            return svgStr;
	        }
	
	        toJSON() {
	            return [...this.faces].map(face => face.toJSON());
	        }
	    }
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function(Flatten) {
	    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;
	    /**
	     * Class representing a horizontal ray, used by ray shooting algorithm
	     * @type {Ray}
	     */
	    Flatten.Ray = class Ray {
	        /**
	         * Construct ray by setting start point
	         * @param {Point} pt - start point
	         */
	        constructor(...args) {
	            this.pt = new Point();
	
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 1 && args[0] instanceof Point) {
	                this.pt = args[0].clone();
	                return;
	            }
	
	            if (args.length == 2 && typeof(args[0]) == "number" && typeof(args[1]) == "number") {
	                this.pt = new Point(args[0], args[1]);
	                return;
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Returns copied instance of the ray object
	         * @returns {Ray}
	         */
	        clone() {
	            return new Ray(this.pt);
	        }
	
	        /**
	         * Returns half-infinite bounding box of the ray
	         * @returns {Box} - bounding box
	         */
	        get box() {
	            return new Box(
	                this.pt.x,
	                this.pt.y,
	                Number.POSITIVE_INFINITY,
	                this.pt.y
	            )
	        }
	
	        /**
	         * Return ray start point
	         * @returns {Point} - ray start point
	         */
	        get start() {
	            return this.pt;
	        }
	
	        /**
	         * Return ray normal vector (0,1) - horizontal ray
	         * @returns {Vector} - ray normal vector
	         */
	        get norm() {
	            return new Vector(0,1);
	        }
	
	        /**
	         * Returns array of intersection points between ray and segment or arc
	         * @param {Segment|Arc} - Shape to intersect with ray
	         * @returns {Array} array of intersection points
	         */
	        intersect(shape) {
	            if (shape instanceof Segment) {
	                return this.intersectRay2Segment(this, shape);
	            }
	
	            if (shape instanceof Arc) {
	                return this.intersectRay2Arc(this, shape);
	            }
	        }
	
	        intersectRay2Segment(ray, segment) {
	            let ip = [];
	
	            if (ray.box.notIntersect(segment.box)) {
	                return ip;
	            }
	
	            let line = new Line(ray.start, ray.norm);
	            let ip_tmp = line.intersect(segment);
	
	            for (let pt of ip_tmp) {
	                if (Flatten.Utils.GE(pt.x, ray.start.x)) {
	                    ip.push(pt);
	                }
	            }
	
	            /* If there were two intersection points between line and ray,
	            and now there is exactly one left, it means ray starts between these points
	            and there is another intersection point - start of the ray */
	            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {
	                ip.push(ray.start);
	            }
	
	            return ip;
	        }
	
	        intersectRay2Arc(ray, arc) {
	            let ip = [];
	
	            if (ray.box.notIntersect(arc.box)) {
	                return ip;
	            }
	
	            let line = new Line(ray.start, ray.norm);
	            let ip_tmp = line.intersect(arc);
	
	            for (let pt of ip_tmp) {
	                if (Flatten.Utils.GE(pt.x, ray.start.x)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	        }
	    };
	
	    Flatten.ray = (...args) => new Flatten.Ray(...args);
	};

/***/ },
/* 93 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 3/10/2017.
	 */
	
	"use strict";
	
	module.exports = function (Flatten) {
	    /**
	     * Class representing a segment
	     * @type {Segment}
	     */
	    Flatten.Segment = class Segment {
	        /**
	         *
	         * @param {Point} ps - start point
	         * @param {Point} pe - end point
	         */
	        constructor(...args) {
	            /**
	             * Start point
	             * @type {Point}
	             */
	            this.ps = new Flatten.Point();
	            /**
	             * End Point
	             * @type {Point}
	             */
	            this.pe = new Flatten.Point();
	
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {
	                let coords = args[0];
	                this.ps = new Flatten.Point(coords[0], coords[1]);
	                this.pe = new Flatten.Point(coords[2], coords[3]);
	                return;
	            }
	
	            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {
	                this.ps = args[0].clone();
	                this.pe = args[1].clone();
	                return;
	            }
	
	            if (args.length == 4) {
	                this.ps = new Flatten.Point(args[0], args[1]);
	                this.pe = new Flatten.Point(args[2], args[3]);
	                return;
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Method clone copies segment and returns a new instance
	         * @returns {Segment}
	         */
	        clone() {
	            return new Flatten.Segment(this.start, this.end);
	        }
	
	        /**
	         * Start point
	         * @returns {Point}
	         */
	        get start() {
	            return this.ps;
	        }
	
	        /**
	         * End point
	         * @returns {Point}
	         */
	        get end() {
	            return this.pe;
	        }
	
	
	        /**
	         * Returns array of start and end point
	         * @returns [Point,Point]
	         */
	        get vertices() {
	            return [this.ps.clone(), this.pe.clone()];
	        }
	
	        /**
	         * Length of a segment
	         * @returns {number}
	         */
	        get length() {
	            return this.start.distanceTo(this.end)[0];
	        }
	
	        /**
	         * Slope of the line - angle to axe x in radians from 0 to 2PI
	         * @returns {number}
	         */
	        get slope() {
	            let vec = new Flatten.Vector(this.start, this.end);
	            return vec.slope;
	        }
	
	        /**
	         * Bounding box
	         * @returns {Box}
	         */
	        get box() {
	            return new Flatten.Box(
	                Math.min(this.start.x, this.end.x),
	                Math.min(this.start.y, this.end.y),
	                Math.max(this.start.x, this.end.x),
	                Math.max(this.start.y, this.end.y)
	            )
	        }
	
	        /**
	         * Returns true if equals to query segment, false otherwise
	         * @param {Seg} seg - query segment
	         * @returns {boolean}
	         */
	        equalTo(seg) {
	            return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);
	        }
	
	        /**
	         * Returns true if segment contains point
	         * @param {Point} pt Query point
	         * @returns {boolean}
	         */
	        contains(pt) {
	            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));
	        }
	
	        /**
	         * Returns array of intersection points between segment and other shape
	         * @param {Shape} shape - Shape of the one of supported types Line, Circle, Segment, Arc <br/>
	         * TODO: support Polygon and Planar Set
	         * @returns {Point[]}
	         */
	        intersect(shape) {
	            if (shape instanceof Flatten.Line) {
	                return Segment.intersectSegment2Line(this, shape);
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                return Segment.intersectSegment2Segment(this, shape);
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                return Segment.intersectSegment2Circle(this, shape);
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                return Segment.intersectSegment2Arc(this, shape);
	            }
	        }
	
	        /**
	         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]
	         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
	         * @returns {number} distance from segment to shape
	         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)
	         */
	        distanceTo(shape) {
	            let {Distance} = Flatten;
	
	            if (shape instanceof Flatten.Point) {
	                let [dist, shortest_segment] = Distance.point2segment(shape, this);
	                shortest_segment = shortest_segment.reverse();
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Circle) {
	                let [dist, shortest_segment] = Distance.segment2circle(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Line) {
	                let [dist, shortest_segment] = Distance.segment2line(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Segment) {
	                let [dist, shortest_segment] = Distance.segment2segment(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Arc) {
	                let [dist, shortest_segment] = Distance.segment2arc(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.Polygon) {
	                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);
	                return [dist, shortest_segment];
	            }
	
	            if (shape instanceof Flatten.PlanarSet) {
	                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);
	                return [dist, shortest_segment];
	            }
	        }
	
	        /**
	         * Returns unit vector in the direction from start to end
	         * @returns {Vector}
	         */
	        tangentInStart() {
	            let vec = new Flatten.Vector(this.start, this.end);
	            return vec.normalize();
	        }
	
	        /**
	         * Return unit vector in the direction from end to start
	         * @returns {Vector}
	         */
	        tangentInEnd() {
	            let vec = new Flatten.Vector(this.end, this.start);
	            return vec.normalize();
	        }
	
	        /**
	         * Returns new segment with swapped start and end points
	         * @returns {Segment}
	         */
	        reverse() {
	            return new Segment(this.end, this.start);
	        }
	
	        /**
	         * When point belongs to segment, return array of two segments split by given point,
	         * if point is inside segment. Returns clone of this segment if query point is incident
	         * to start or end point of the segment. Returns empty array if point does not belong to segment
	         * @param {Point} pt Query point
	         * @returns {Segment[]}
	         */
	        split(pt) {
	            if (!this.contains(pt))
	                return [];
	
	            if (this.start.equalTo(this.end))
	                return [this.clone()];
	
	            if (this.start.equalTo(pt) || this.end.equalTo(pt))
	                return [this];
	
	            return [
	                new Flatten.Segment(this.start, pt),
	                new Flatten.Segment(pt, this.end)
	            ]
	        }
	
	        /**
	         * Return middle point of the segment
	         * @returns {Point}
	         */
	        middle() {
	            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);
	        }
	
	        distanceToPoint(pt) {
	            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);
	            return dist;
	        };
	
	        definiteIntegral(ymin = 0.0) {
	            let dx = this.end.x - this.start.x;
	            let dy1 = this.start.y - ymin;
	            let dy2 = this.end.y - ymin;
	            return ( dx * (dy1 + dy2) / 2 );
	        }
	
	        /**
	         * Returns new segment translated by vector vec
	         * @param {Vector} vec
	         * @returns {Segment}
	         */
	        translate(vec) {
	            return new Segment(this.ps.translate(vec), this.pe.translate(vec));
	        }
	
	        /**
	         * Return new segment rotated by given angle around given point
	         * If point omitted, rotate around origin (0,0)
	         * Positive value of angle defines rotation counter clockwise, negative - clockwise
	         * @param {number} angle - rotation angle in radians
	         * @param {Point} center - center point, default is (0,0)
	         * @returns {Segment}
	         */
	        rotate(angle = 0, center = new Flatten.Point()) {
	            let m = new Flatten.Matrix();
	            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);
	            return this.transform(m);
	        }
	
	        /**
	         * Return new segment transformed using affine transformation matrix
	         * @param {Matrix} matrix - affine transformation matrix
	         * @returns {Segment} - transformed segment
	         */
	        transform(matrix = new Flatten.Matrix()) {
	            return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))
	        }
	
	        /**
	         * Returns true if segment start is equal to segment end up to DP_TOL
	         * @returns {boolean}
	         */
	        isZeroLength() {
	            return this.ps.equalTo(this.pe)
	        }
	
	        static intersectSegment2Line(seg, line) {
	            let ip = [];
	
	            // Boundary cases
	            if (seg.ps.on(line)) {
	                ip.push(seg.ps);
	            }
	            // If both ends lay on line, return two intersection points
	            if (seg.pe.on(line) && !seg.isZeroLength()) {
	                ip.push(seg.pe);
	            }
	
	            if (ip.length > 0) {
	                return ip;          // done, intersection found
	            }
	
	            // If zero-length segment and nothing found, return no intersections
	            if (seg.isZeroLength()) {
	                return ip;
	            }
	
	            // Not a boundary case, check if both points are on the same side and
	            // hence there is no intersection
	            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||
	                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {
	                return ip;
	            }
	
	            // Calculate intersection between lines
	            let line1 = new Flatten.Line(seg.ps, seg.pe);
	            return line1.intersect(line);
	        }
	
	        static intersectSegment2Segment(seg1, seg2) {
	            let ip = [];
	
	            // quick reject
	            if (seg1.box.notIntersect(seg2.box)) {
	                return ip;
	            }
	
	            // Special case of seg1 zero length
	            if (seg1.isZeroLength()) {
	                if (seg1.ps.on(seg2)) {
	                    ip.push(seg1.ps);
	                }
	                return ip;
	            }
	
	            // Special case of seg2 zero length
	            if (seg2.isZeroLength()) {
	                if (seg2.ps.on(seg1)) {
	                    ip.push(seg2.ps);
	                }
	                return ip;
	            }
	
	            // Neither seg1 nor seg2 is zero length
	            let line1 = new Flatten.Line(seg1.ps, seg1.pe);
	            let line2 = new Flatten.Line(seg2.ps, seg2.pe);
	
	            // Check overlapping between segments in case of incidence
	            // If segments touching, add one point. If overlapping, add two points
	            if (line1.incidentTo(line2)) {
	                if (seg1.ps.on(seg2)) {
	                    ip.push(seg1.ps);
	                }
	                if (seg1.pe.on(seg2)) {
	                    ip.push(seg1.pe);
	                }
	                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {
	                    ip.push(seg2.ps);
	                }
	                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {
	                    ip.push(seg2.pe);
	                }
	            }
	            else {                /* not incident - parallel or intersect */
	                // Calculate intersection between lines
	                let new_ip = line1.intersect(line2);
	                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {
	                    ip.push(new_ip[0]);
	                }
	            }
	
	            return ip;
	        }
	
	        static intersectSegment2Circle(segment, circle) {
	            let ips = [];
	
	            if (segment.box.notIntersect(circle.box)) {
	                return ips;
	            }
	
	            // Special case of zero length segment
	            if (segment.isZeroLength()) {
	                let [dist,shortest_segment] = segment.ps.distanceTo(circle.pc);
	                if (Flatten.Utils.EQ(dist, circle.r)) {
	                    ips.push(segment.ps);
	                }
	                return ips;
	            }
	
	            // Non zero-length segment
	            let line = new Flatten.Line(segment.ps, segment.pe);
	
	            let ips_tmp = line.intersect(circle);
	
	            for (let ip of ips_tmp) {
	                if (ip.on(segment)) {
	                    ips.push(ip);
	                }
	            }
	
	            return ips;
	        }
	
	        static intersectSegment2Arc(segment, arc) {
	            let ip = [];
	
	            if (segment.box.notIntersect(arc.box)) {
	                return ip;
	            }
	
	            // Special case of zero-length segment
	            if (segment.isZeroLength()) {
	                if (segment.ps.on(arc)) {
	                    ip.push(segment.ps);
	                }
	                return ip;
	            }
	
	            // Non-zero length segment
	            let line = new Flatten.Line(segment.ps, segment.pe);
	            let circle = new Flatten.Circle(arc.pc, arc.r);
	
	            let ip_tmp = line.intersect(circle);
	
	            for (let pt of ip_tmp) {
	                if (pt.on(segment) && pt.on(arc)) {
	                    ip.push(pt);
	                }
	            }
	            return ip;
	
	        }
	
	        /**
	         * Return string to draw segment in svg
	         * @param {Object} attrs - Object with attributes for svg path element,
	         * like "stroke", "strokeWidth" <br/>
	         * Defaults are stroke:"black", strokeWidth:"1"
	         * @returns {string}
	         */
	        svg(attrs = {}) {
	            let {stroke, strokeWidth, id, className} = attrs;
	            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}="${rest[key]}"`, "");
	            let id_str = (id && id.length > 0) ? `id="${id}"` : "";
	            let class_str = (className && className.length > 0) ? `class="${className}"` : "";
	
	            return `\n<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" stroke="${stroke || "black"}" stroke-width="${strokeWidth || 1}" ${id_str} ${class_str} />`;
	
	        }
	    };
	
	    /**
	     * Shortcut method to create new segment
	     */
	    Flatten.segment = (...args) => new Flatten.Segment(...args);
	};

/***/ },
/* 94 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/19/2017.
	 */
	
	"use strict";
	
	module.exports = function(Flatten) {
	    /**
	     * Class representing a vector
	     * @type {Vector}
	     */
	    Flatten.Vector = class Vector {
	        /**
	         * Vector may be constructed by two points, or by two float numbers
	         * @param {Point} ps - start point
	         * @param {Point} pe - end point
	         */
	        constructor(...args) {
	            /**
	             * x-coordinate of a vector (float number)
	             * @type {number}
	             */
	            this.x = 0;
	            /**
	             * y-coordinate of a vector (float number)
	             * @type {number}
	             */
	            this.y = 0;
	
	            /* return zero vector */
	            if (args.length == 0) {
	                return;
	            }
	
	            if (args.length == 2) {
	                let a1 = args[0];
	                let a2 = args[1];
	
	                if (typeof(a1) == "number" && typeof(a2) == "number") {
	                    this.x = a1;
	                    this.y = a2;
	                    return;
	                }
	
	                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
	                    this.x = a2.x - a1.x;
	                    this.y = a2.y - a1.y;
	                    return;
	                }
	
	            }
	
	            throw Flatten.Errors.ILLEGAL_PARAMETERS;
	        }
	
	        /**
	         * Method clone returns new instance of Vector
	         * @returns {Vector}
	         */
	        clone() {
	            return new Vector(this.x, this.y);
	        }
	
	        /**
	         * Slope of the vector in radians from 0 to 2PI
	         * @returns {number}
	         */
	        get slope() {
	            let angle = Math.atan2(this.y, this.x);
	            if (angle<0) angle = 2*Math.PI + angle;
	            return angle;
	        }
	
	        /**
	         * Length of vector
	         * @returns {number}
	         */
	        get length() {
	            return Math.sqrt(this.dot(this));
	        }
	
	        /**
	         * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}
	         * tolerance
	         * @param {Vector} v
	         * @returns {boolean}
	         */
	        equalTo(v) {
	            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);
	        }
	
	        /**
	         * Returns new vector multiplied by scalar
	         * @param {number} scalar
	         * @returns {Vector}
	         */
	        multiply(scalar) {
	            return ( new Vector(scalar * this.x, scalar * this.y) );
	        }
	
	        /**
	         * Returns scalar product (dot product) of two vectors <br/>
	         * <code>dot_product = (this * v)</code>
	         * @param {Vector} v Other vector
	         * @returns {number}
	         */
	        dot(v) {
	            return ( this.x * v.x + this.y * v.y );
	        }
	
	        /**
	         * Returns vector product (cross product) of two vectors <br/>
	         * <code>cross_product = (this x v)</code>
	         * @param {Vector} v Other vector
	         * @returns {number}
	         */
	        cross(v) {
	            return ( this.x * v.y - this.y * v.x );
	        }
	
	        /**
	         * Returns unit vector.<br/>
	         * Throw error if given vector has zero length
	         * @returns {Vector}
	         */
	        normalize() {
	            if (!Flatten.Utils.EQ_0(this.length)) {
	                return ( new Vector(this.x / this.length, this.y / this.length) );
	            }
	            throw Flatten.Errors.ZERO_DIVISION;
	        }
	
	        /**
	         * Returns new vector rotated by given angle,
	         * positive angle defines rotation in counter clockwise direction,
	         * negative - in clockwise direction
	         * @param {number} angle - Angle in radians
	         * @returns {Vector}
	         */
	        rotate(angle) {
	            let point = new Flatten.Point(this.x, this.y);
	            let rpoint = point.rotate(angle);
	            return new Flatten.Vector(rpoint.x, rpoint.y);
	        }
	
	        /**
	         * Returns vector rotated 90 degrees counter clockwise
	         * @returns {Vector}
	         */
	        rotate90CCW() {
	            return new Flatten.Vector(-this.y, this.x);
	        };
	
	        /**
	         * Returns vector rotated 90 degrees clockwise
	         * @returns {Vector}
	         */
	        rotate90CW() {
	            return new Flatten.Vector(this.y, -this.x);
	        };
	
	        /**
	         * Return inverted vector
	         * @returns {Vector}
	         */
	        invert() {
	            return new Flatten.Vector(-this.x, -this.y);
	        }
	
	        /**
	         * Return result of addition of other vector to this vector as a new vector
	         * @param {Vector} v Other vector
	         * @returns {Vector}
	         */
	        add(v) {
	            return new Flatten.Vector(this.x + v.x, this.y + v.y);
	        }
	
	        /**
	         * Return result of subtraction of other vector from current vector as a new vector
	         * @param {Vector} v Another vector
	         * @returns {Vector}
	         */
	        subtract(v) {
	            return new Flatten.Vector(this.x - v.x, this.y - v.y);
	        }
	
	        /**
	         * Return angle between this vector and other vector. <br/>
	         * Angle is measured from 0 to 2*PI in the counter clockwise direction
	         * from current vector to other.
	         * @param {Vector} v Another vector
	         * @returns {number}
	         */
	        angleTo(v) {
	            let norm1 = this.normalize();
	            let norm2 = v.normalize();
	            let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));
	            if (angle<0) angle += 2*Math.PI;
	            return angle;
	        }
	
	        /**
	         * Return vector projection of the current vector on another vector
	         * @param {Vector} v Another vector
	         * @returns {Vector}
	         */
	        projectionOn(v){
	            let n = v.normalize();
	            let d = this.dot(n);
	            return n.multiply(d);
	        }
	    };
	
	    /**
	     * Function to create vector equivalent to "new" constructor
	     * @param args
	     */
	    Flatten.vector = (...args) => new Flatten.Vector(...args);
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Alex Bol on 3/12/2017.
	 */
	
	"use strict";
	
	// require("babel-polyfill");
	
	let IntervalTree = __webpack_require__(13);
	
	module.exports = function (Flatten) {
	    /**
	     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and
	     * perform spatial queries. Planar set is an extension of Set container, so it supports
	     * Set properties and methods
	     */
	    Flatten.PlanarSet = class PlanarSet extends Set {
	        /**
	         * Create new empty instance of PlanarSet
	         */
	        constructor() {
	            super();
	            this.index = new IntervalTree();
	        }
	
	        /**
	         * Add new shape to planar set and to its spatial index.<br/>
	         * If shape already exist, it will not be added again.
	         * This happens with no error, it is possible to use <i>size</i> property to check if
	         * a shape was actually added.<br/>
	         * Method returns planar set object updated and may be chained
	         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property
	         * @returns {PlanarSet}
	         */
	        add(shape) {
	            let size = this.size;
	            super.add(shape);
	            // size not changed - item not added, probably trying to add same item twice
	            if (this.size > size) {
	                let node = this.index.insert(shape.box, shape);
	            }
	            return this;         // in accordance to Set.add interface
	        }
	
	        /**
	         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise
	         * @param {Shape} shape - shape to be deleted
	         * @returns {boolean}
	         */
	        delete(shape) {
	            let deleted = super.delete(shape);
	            if (deleted) {
	                this.index.remove(shape.box, shape);
	            }
	            return deleted;
	        }
	
	        // update(shape) {
	        //     if (super.has(shape)) {
	        //         this.delete(shape);
	        //     }
	        //     this.add(shape);
	        //
	        //     return this;
	        // }
	
	        clear() {
	
	        }
	
	        /**
	         * 2d range search in planar set.<br/>
	         * Returns array of all shapes in planar set which bounding box is intersected with query box
	         * @param {Box} box - query box
	         * @returns {Shapes[]}
	         */
	        search(box) {
	            let resp = this.index.search(box);
	            return resp;
	        }
	
	        /**
	         * Point location test. Returns array of shapes which contains given point
	         * @param {Point} point - query point
	         * @returns {Array}
	         */
	        hit(point) {
	            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);
	            let resp = this.index.search(box);
	            return resp.filter((shape) => point.on(shape));
	        }
	
	        /**
	         * Returns svg string to draw all shapes in planar set
	         * @returns {String}
	         */
	        svg() {
	            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), "");
	            return svgcontent;
	        }
	    }
	};
	


/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/19/2017.
	 */
	module.exports = {
	    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),
	    ZERO_DIVISION: new Error('Zero division')
	};
	


/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Created by Alex Bol on 2/18/2017.
	 */
	
	const DP_TOL = 0.000001;
	const DECIMALS = 3;
	
	module.exports = {
	    DP_TOL: DP_TOL,
	    /**
	     * @return {boolean}
	     */
	    EQ_0: function(x) {
	        return ( (x) < DP_TOL && (x) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    EQ: function(x,y) {
	        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    GT: (x,y) => {
	        return ( (x)-(y) >  DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    GE: (x,y) => {
	        return ( (x)-(y) > -DP_TOL );
	    },
	    /**
	     * @return {boolean}
	     */
	    LT: (x,y) => {
	        return ( (x)-(y) < -DP_TOL )
	    },
	    /**
	     * @return {boolean}
	     */
	    LE: (x,y) => {
	        return ( (x)-(y) <  DP_TOL );
	    }
	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(20),
	    getRawTag = __webpack_require__(101),
	    objectToString = __webpack_require__(102);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 99 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(103);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(20);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 102 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(99);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 105 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//This file contains the ES6 extensions to the core Promises/A+ API
	
	var Promise = __webpack_require__(22);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');
	
	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;
	
	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;
	
	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};
	
	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);
	
	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};
	
	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};
	
	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};
	
	/* Prototype Methods */
	
	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(22);
	
	var DEFAULT_WHITELIST = [
	  ReferenceError,
	  TypeError,
	  RangeError
	];
	
	var enabled = false;
	exports.disable = disable;
	function disable() {
	  enabled = false;
	  Promise._10 = null;
	  Promise._97 = null;
	}
	
	exports.enable = enable;
	function enable(options) {
	  options = options || {};
	  if (enabled) disable();
	  enabled = true;
	  var id = 0;
	  var displayId = 0;
	  var rejections = {};
	  Promise._10 = function (promise) {
	    if (
	      promise._81 === 2 && // IS REJECTED
	      rejections[promise._72]
	    ) {
	      if (rejections[promise._72].logged) {
	        onHandled(promise._72);
	      } else {
	        clearTimeout(rejections[promise._72].timeout);
	      }
	      delete rejections[promise._72];
	    }
	  };
	  Promise._97 = function (promise, err) {
	    if (promise._45 === 0) { // not yet handled
	      promise._72 = id++;
	      rejections[promise._72] = {
	        displayId: null,
	        error: err,
	        timeout: setTimeout(
	          onUnhandled.bind(null, promise._72),
	          // For reference errors and type errors, this almost always
	          // means the programmer made a mistake, so log them after just
	          // 100ms
	          // otherwise, wait 2 seconds to see if they get handled
	          matchWhitelist(err, DEFAULT_WHITELIST)
	            ? 100
	            : 2000
	        ),
	        logged: false
	      };
	    }
	  };
	  function onUnhandled(id) {
	    if (
	      options.allRejections ||
	      matchWhitelist(
	        rejections[id].error,
	        options.whitelist || DEFAULT_WHITELIST
	      )
	    ) {
	      rejections[id].displayId = displayId++;
	      if (options.onUnhandled) {
	        rejections[id].logged = true;
	        options.onUnhandled(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      } else {
	        rejections[id].logged = true;
	        logError(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      }
	    }
	  }
	  function onHandled(id) {
	    if (rejections[id].logged) {
	      if (options.onHandled) {
	        options.onHandled(rejections[id].displayId, rejections[id].error);
	      } else if (!rejections[id].onUnhandled) {
	        console.warn(
	          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'
	        );
	        console.warn(
	          '  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' +
	          rejections[id].displayId + '.'
	        );
	      }
	    }
	  }
	}
	
	function logError(id, error) {
	  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
	  var errStr = (error && (error.stack || error)) + '';
	  errStr.split('\n').forEach(function (line) {
	    console.warn('  ' + line);
	  });
	}
	
	function matchWhitelist(error, list) {
	  return list.some(function (cls) {
	    return error instanceof cls;
	  });
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(10);
	var invariant = __webpack_require__(12);
	var ReactPropTypesSecret = __webpack_require__(110);
	
	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };
	
	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	if (false) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;
	
	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(108)();
	}


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 React v16.0.0
	 react-dom.production.min.js
	
	 Copyright (c) 2013-present, Facebook, Inc.
	
	 This source code is licensed under the MIT license found in the
	 LICENSE file in the root directory of this source tree.
	 Modernizr 3.0.0pre (Custom Build) | MIT
	*/
	'use strict';var aa=__webpack_require__(1);__webpack_require__(12);var l=__webpack_require__(72),n=__webpack_require__(14),ba=__webpack_require__(71),ca=__webpack_require__(10),da=__webpack_require__(18),ea=__webpack_require__(78),fa=__webpack_require__(73),ha=__webpack_require__(74),ia=__webpack_require__(75);
	function w(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:w("227");
	function ja(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
	var ka={Namespaces:{html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"},getIntrinsicNamespace:ja,getChildNamespace:function(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?ja(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}},la=null,oa={};
	function pa(){if(la)for(var a in oa){var b=oa[a],c=la.indexOf(a);-1<c?void 0:w("96",a);if(!qa.plugins[c]){b.extractEvents?void 0:w("97",a);qa.plugins[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;qa.eventNameDispatchConfigs.hasOwnProperty(h)?w("99",h):void 0;qa.eventNameDispatchConfigs[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ra(k[e],g,h);e=!0}else f.registrationName?(ra(f.registrationName,g,h),e=!0):e=!1;e?void 0:w("98",d,a)}}}}
	function ra(a,b,c){qa.registrationNameModules[a]?w("100",a):void 0;qa.registrationNameModules[a]=b;qa.registrationNameDependencies[a]=b.eventTypes[c].dependencies}
	var qa={plugins:[],eventNameDispatchConfigs:{},registrationNameModules:{},registrationNameDependencies:{},possibleRegistrationNames:null,injectEventPluginOrder:function(a){la?w("101"):void 0;la=Array.prototype.slice.call(a);pa()},injectEventPluginsByName:function(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];oa.hasOwnProperty(c)&&oa[c]===d||(oa[c]?w("102",c):void 0,oa[c]=d,b=!0)}b&&pa()}},sa=qa,ta={children:!0,dangerouslySetInnerHTML:!0,autoFocus:!0,defaultValue:!0,defaultChecked:!0,
	innerHTML:!0,suppressContentEditableWarning:!0,style:!0};function ua(a,b){return(a&b)===b}
	var wa={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=wa,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){xa.properties.hasOwnProperty(f)?w("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:ua(h,b.MUST_USE_PROPERTY),
	hasBooleanValue:ua(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:ua(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:ua(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:ua(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:ua(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:w("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);xa.properties[f]=
	g}}},xa={ID_ATTRIBUTE_NAME:"data-reactid",ROOT_ATTRIBUTE_NAME:"data-reactroot",ATTRIBUTE_NAME_START_CHAR:":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",ATTRIBUTE_NAME_CHAR:":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
	properties:{},shouldSetAttribute:function(a,b){if(xa.isReservedProp(a)||!("o"!==a[0]&&"O"!==a[0]||"n"!==a[1]&&"N"!==a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return xa.shouldAttributeAcceptBooleanValue(a);case "undefined":case "number":case "string":case "object":return!0;default:return!1}},getPropertyInfo:function(a){return xa.properties.hasOwnProperty(a)?xa.properties[a]:null},shouldAttributeAcceptBooleanValue:function(a){if(xa.isReservedProp(a))return!0;var b=xa.getPropertyInfo(a);
	if(b)return b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue;a=a.toLowerCase().slice(0,5);return"data-"===a||"aria-"===a},isReservedProp:function(a){return ta.hasOwnProperty(a)},injection:wa},A=xa,E={IndeterminateComponent:0,FunctionalComponent:1,ClassComponent:2,HostRoot:3,HostPortal:4,HostComponent:5,HostText:6,CoroutineComponent:7,CoroutineHandlerPhase:8,YieldComponent:9,Fragment:10},F={ELEMENT_NODE:1,TEXT_NODE:3,COMMENT_NODE:8,DOCUMENT_NODE:9,DOCUMENT_FRAGMENT_NODE:11},
	ya=E.HostComponent,za=E.HostText,Aa=F.ELEMENT_NODE,Ba=F.COMMENT_NODE,Ea=A.ID_ATTRIBUTE_NAME,Fa={hasCachedChildNodes:1},Ga=Math.random().toString(36).slice(2),Ha="__reactInternalInstance$"+Ga,Ia="__reactEventHandlers$"+Ga;function La(a){for(var b;b=a._renderedComponent;)a=b;return a}function Ma(a,b){a=La(a);a._hostNode=b;b[Ha]=a}
	function Na(a,b){if(!(a._flags&Fa.hasCachedChildNodes)){var c=a._renderedChildren;b=b.firstChild;var d;a:for(d in c)if(c.hasOwnProperty(d)){var e=c[d],f=La(e)._domID;if(0!==f){for(;null!==b;b=b.nextSibling){var g=b,h=f;if(g.nodeType===Aa&&g.getAttribute(Ea)===""+h||g.nodeType===Ba&&g.nodeValue===" react-text: "+h+" "||g.nodeType===Ba&&g.nodeValue===" react-empty: "+h+" "){Ma(e,b);continue a}}w("32",f)}}a._flags|=Fa.hasCachedChildNodes}}
	function Oa(a){if(a[Ha])return a[Ha];for(var b=[];!a[Ha];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=a[Ha];if(c.tag===ya||c.tag===za)return c;for(;a&&(c=a[Ha]);a=b.pop()){var d=c;b.length&&Na(c,a)}return d}
	var G={getClosestInstanceFromNode:Oa,getInstanceFromNode:function(a){var b=a[Ha];if(b)return b.tag===ya||b.tag===za?b:b._hostNode===a?b:null;b=Oa(a);return null!=b&&b._hostNode===a?b:null},getNodeFromInstance:function(a){if(a.tag===ya||a.tag===za)return a.stateNode;void 0===a._hostNode?w("33"):void 0;if(a._hostNode)return a._hostNode;for(var b=[];!a._hostNode;)b.push(a),a._hostParent?void 0:w("34"),a=a._hostParent;for(;b.length;a=b.pop())Na(a,a._hostNode);return a._hostNode},precacheChildNodes:Na,
	precacheNode:Ma,uncacheNode:function(a){var b=a._hostNode;b&&(delete b[Ha],a._hostNode=null)},precacheFiberNode:function(a,b){b[Ha]=a},getFiberCurrentPropsFromNode:function(a){return a[Ia]||null},updateFiberProps:function(a,b){a[Ia]=b}},Pa={remove:function(a){a._reactInternalFiber=void 0},get:function(a){return a._reactInternalFiber},has:function(a){return void 0!==a._reactInternalFiber},set:function(a,b){a._reactInternalFiber=b}},Qa={ReactCurrentOwner:aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner};
	function Ra(a){if("function"===typeof a.getName)return a.getName();if("number"===typeof a.tag){a=a.type;if("string"===typeof a)return a;if("function"===typeof a)return a.displayName||a.name}return null}var J={NoEffect:0,PerformedWork:1,Placement:2,Update:4,PlacementAndUpdate:6,Deletion:8,ContentReset:16,Callback:32,Err:64,Ref:128},Sa=E.HostComponent,Ta=E.HostRoot,Ua=E.HostPortal,Va=E.HostText,Wa=J.NoEffect,Xa=J.Placement;
	function Za(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if((b.effectTag&Xa)!==Wa)return 1;for(;b["return"];)if(b=b["return"],(b.effectTag&Xa)!==Wa)return 1}return b.tag===Ta?2:3}function $a(a){2!==Za(a)?w("188"):void 0}
	function ab(a){var b=a.alternate;if(!b)return b=Za(a),3===b?w("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return $a(e),a;if(g===d)return $a(e),b;g=g.sibling}w("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
	void 0:w("189")}}c.alternate!==d?w("190"):void 0}c.tag!==Ta?w("188"):void 0;return c.stateNode.current===c?a:b}
	var bb={isFiberMounted:function(a){return 2===Za(a)},isMounted:function(a){return(a=Pa.get(a))?2===Za(a):!1},findCurrentFiberUsingSlowPath:ab,findCurrentHostFiber:function(a){a=ab(a);if(!a)return null;for(var b=a;;){if(b.tag===Sa||b.tag===Va)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null},findCurrentHostFiberWithNoPortals:function(a){a=ab(a);
	if(!a)return null;for(var b=a;;){if(b.tag===Sa||b.tag===Va)return b;if(b.child&&b.tag!==Ua)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}},K={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?w("197"):void 0;cb=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,
	b,c,d,e,f,g,h,k){cb.apply(K,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){K.invokeGuardedCallback.apply(this,arguments);if(K.hasCaughtError()){var p=K.clearCaughtError();K._hasRethrowError||(K._hasRethrowError=!0,K._rethrowError=p)}},rethrowCaughtError:function(){return db.apply(K,arguments)},hasCaughtError:function(){return K._hasCaughtError},clearCaughtError:function(){if(K._hasCaughtError){var a=K._caughtError;K._caughtError=null;K._hasCaughtError=!1;return a}w("198")}};
	function cb(a,b,c,d,e,f,g,h,k){K._hasCaughtError=!1;K._caughtError=null;var p=Array.prototype.slice.call(arguments,3);try{b.apply(c,p)}catch(x){K._caughtError=x,K._hasCaughtError=!0}}function db(){if(K._hasRethrowError){var a=K._rethrowError;K._rethrowError=null;K._hasRethrowError=!1;throw a;}}var eb=K,fb;function gb(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=hb.getNodeFromInstance(d);eb.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
	var hb={isEndish:function(a){return"topMouseUp"===a||"topTouchEnd"===a||"topTouchCancel"===a},isMoveish:function(a){return"topMouseMove"===a||"topTouchMove"===a},isStartish:function(a){return"topMouseDown"===a||"topTouchStart"===a},executeDirectDispatch:function(a){var b=a._dispatchListeners,c=a._dispatchInstances;Array.isArray(b)?w("103"):void 0;a.currentTarget=b?hb.getNodeFromInstance(c):null;b=b?b(a):null;a.currentTarget=null;a._dispatchListeners=null;a._dispatchInstances=null;return b},executeDispatchesInOrder:function(a,
	b){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)gb(a,b,c[e],d[e]);else c&&gb(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null},executeDispatchesInOrderStopAtTrue:function(a){a:{var b=a._dispatchListeners;var c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++){if(b[d](a,c[d])){b=c[d];break a}}else if(b&&b(a,c)){b=c;break a}b=null}a._dispatchInstances=null;a._dispatchListeners=
	null;return b},hasDispatches:function(a){return!!a._dispatchListeners},getFiberCurrentPropsFromNode:function(a){return fb.getFiberCurrentPropsFromNode(a)},getInstanceFromNode:function(a){return fb.getInstanceFromNode(a)},getNodeFromInstance:function(a){return fb.getNodeFromInstance(a)},injection:{injectComponentTree:function(a){fb=a}}},ib=hb,jb=null,kb=null,lb=null;
	function mb(a){if(a=ib.getInstanceFromNode(a))if("number"===typeof a.tag){jb&&"function"===typeof jb.restoreControlledState?void 0:w("194");var b=ib.getFiberCurrentPropsFromNode(a.stateNode);jb.restoreControlledState(a.stateNode,a.type,b)}else"function"!==typeof a.restoreControlledState?w("195"):void 0,a.restoreControlledState()}
	var nb={injection:{injectFiberControlledHostComponent:function(a){jb=a}},enqueueStateRestore:function(a){kb?lb?lb.push(a):lb=[a]:kb=a},restoreStateIfNeeded:function(){if(kb){var a=kb,b=lb;lb=kb=null;mb(a);if(b)for(a=0;a<b.length;a++)mb(b[a])}}};function ob(a,b,c,d,e,f){return a(b,c,d,e,f)}function pb(a,b){return a(b)}function qb(a,b){return pb(a,b)}
	var rb=!1,sb={batchedUpdates:function(a,b){if(rb)return ob(qb,a,b);rb=!0;try{return ob(qb,a,b)}finally{rb=!1,nb.restoreStateIfNeeded()}},injection:{injectStackBatchedUpdates:function(a){ob=a},injectFiberBatchedUpdates:function(a){pb=a}}},tb=F.TEXT_NODE;function ub(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return a.nodeType===tb?a.parentNode:a}var vb=E.HostRoot,wb=[];
	function xb(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c=b;if("number"===typeof c.tag){for(;c["return"];)c=c["return"];c=c.tag!==vb?null:c.stateNode.containerInfo}else{for(;c._hostParent;)c=c._hostParent;c=G.getNodeFromInstance(c).parentNode}if(!c)break;a.ancestors.push(b);b=G.getClosestInstanceFromNode(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],yb._handleTopLevel(a.topLevelType,b,a.nativeEvent,ub(a.nativeEvent))}
	var yb={_enabled:!0,_handleTopLevel:null,setHandleTopLevel:function(a){yb._handleTopLevel=a},setEnabled:function(a){yb._enabled=!!a},isEnabled:function(){return yb._enabled},trapBubbledEvent:function(a,b,c){return c?ba.listen(c,b,yb.dispatchEvent.bind(null,a)):null},trapCapturedEvent:function(a,b,c){return c?ba.capture(c,b,yb.dispatchEvent.bind(null,a)):null},dispatchEvent:function(a,b){if(yb._enabled){var c=ub(b);c=G.getClosestInstanceFromNode(c);null===c||"number"!==typeof c.tag||bb.isFiberMounted(c)||
	(c=null);if(wb.length){var d=wb.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{sb.batchedUpdates(xb,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>wb.length&&wb.push(a)}}}},L=yb;function Cb(a,b){null==b?w("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}
	function Db(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var Eb=null;function Fb(a,b){a&&(ib.executeDispatchesInOrder(a,b),a.isPersistent()||a.constructor.release(a))}function Gb(a){return Fb(a,!0)}function Hb(a){return Fb(a,!1)}
	function Ib(a,b,c){switch(a){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":return!(!c.disabled||"button"!==b&&"input"!==b&&"select"!==b&&"textarea"!==b);default:return!1}}
	var Jb={injection:{injectEventPluginOrder:sa.injectEventPluginOrder,injectEventPluginsByName:sa.injectEventPluginsByName},getListener:function(a,b){if("number"===typeof a.tag){var c=a.stateNode;if(!c)return null;var d=ib.getFiberCurrentPropsFromNode(c);if(!d)return null;c=d[b];if(Ib(b,a.type,d))return null}else{d=a._currentElement;if("string"===typeof d||"number"===typeof d||!a._rootNodeID)return null;a=d.props;c=a[b];if(Ib(b,d.type,a))return null}c&&"function"!==typeof c?w("231",b,typeof c):void 0;
	return c},extractEvents:function(a,b,c,d){for(var e,f=sa.plugins,g=0;g<f.length;g++){var h=f[g];h&&(h=h.extractEvents(a,b,c,d))&&(e=Cb(e,h))}return e},enqueueEvents:function(a){a&&(Eb=Cb(Eb,a))},processEventQueue:function(a){var b=Eb;Eb=null;a?Db(b,Gb):Db(b,Hb);Eb?w("95"):void 0;eb.rethrowCaughtError()}},Kb;l.canUseDOM&&(Kb=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
	function Lb(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&Kb&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function Mb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
	var Nb={animationend:Mb("Animation","AnimationEnd"),animationiteration:Mb("Animation","AnimationIteration"),animationstart:Mb("Animation","AnimationStart"),transitionend:Mb("Transition","TransitionEnd")},Ob={},Pb={};l.canUseDOM&&(Pb=document.createElement("div").style,"AnimationEvent"in window||(delete Nb.animationend.animation,delete Nb.animationiteration.animation,delete Nb.animationstart.animation),"TransitionEvent"in window||delete Nb.transitionend.transition);
	function Qb(a){if(Ob[a])return Ob[a];if(!Nb[a])return a;var b=Nb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Pb)return Ob[a]=b[c];return""}
	var Rb={topAbort:"abort",topAnimationEnd:Qb("animationend")||"animationend",topAnimationIteration:Qb("animationiteration")||"animationiteration",topAnimationStart:Qb("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
	topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
	topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
	topTouchStart:"touchstart",topTransitionEnd:Qb("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Sb={},Tb=0,Ub="_reactListenersID"+(""+Math.random()).slice(2);function Vb(a){Object.prototype.hasOwnProperty.call(a,Ub)||(a[Ub]=Tb++,Sb[a[Ub]]={});return Sb[a[Ub]]}
	var M=n({},{handleTopLevel:function(a,b,c,d){a=Jb.extractEvents(a,b,c,d);Jb.enqueueEvents(a);Jb.processEventQueue(!1)}},{setEnabled:function(a){L&&L.setEnabled(a)},isEnabled:function(){return!(!L||!L.isEnabled())},listenTo:function(a,b){var c=Vb(b);a=sa.registrationNameDependencies[a];for(var d=0;d<a.length;d++){var e=a[d];c.hasOwnProperty(e)&&c[e]||("topWheel"===e?Lb("wheel")?L.trapBubbledEvent("topWheel","wheel",b):Lb("mousewheel")?L.trapBubbledEvent("topWheel","mousewheel",b):L.trapBubbledEvent("topWheel",
	"DOMMouseScroll",b):"topScroll"===e?L.trapCapturedEvent("topScroll","scroll",b):"topFocus"===e||"topBlur"===e?(L.trapCapturedEvent("topFocus","focus",b),L.trapCapturedEvent("topBlur","blur",b),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(Lb("cancel",!0)&&L.trapCapturedEvent("topCancel","cancel",b),c.topCancel=!0):"topClose"===e?(Lb("close",!0)&&L.trapCapturedEvent("topClose","close",b),c.topClose=!0):Rb.hasOwnProperty(e)&&L.trapBubbledEvent(e,Rb[e],b),c[e]=!0)}},isListeningToAllDependencies:function(a,
	b){b=Vb(b);a=sa.registrationNameDependencies[a];for(var c=0;c<a.length;c++){var d=a[c];if(!b.hasOwnProperty(d)||!b[d])return!1}return!0},trapBubbledEvent:function(a,b,c){return L.trapBubbledEvent(a,b,c)},trapCapturedEvent:function(a,b,c){return L.trapCapturedEvent(a,b,c)}}),Wb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,
	flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Xb=["Webkit","ms","Moz","O"];
	Object.keys(Wb).forEach(function(a){Xb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Wb[b]=Wb[a]})});
	var Yb={isUnitlessNumber:Wb,shorthandPropertyExpansions:{background:{backgroundAttachment:!0,backgroundColor:!0,backgroundImage:!0,backgroundPositionX:!0,backgroundPositionY:!0,backgroundRepeat:!0},backgroundPosition:{backgroundPositionX:!0,backgroundPositionY:!0},border:{borderWidth:!0,borderStyle:!0,borderColor:!0},borderBottom:{borderBottomWidth:!0,borderBottomStyle:!0,borderBottomColor:!0},borderLeft:{borderLeftWidth:!0,borderLeftStyle:!0,borderLeftColor:!0},borderRight:{borderRightWidth:!0,borderRightStyle:!0,
	borderRightColor:!0},borderTop:{borderTopWidth:!0,borderTopStyle:!0,borderTopColor:!0},font:{fontStyle:!0,fontVariant:!0,fontWeight:!0,fontSize:!0,lineHeight:!0,fontFamily:!0},outline:{outlineWidth:!0,outlineStyle:!0,outlineColor:!0}}},Zb=Yb.isUnitlessNumber,$b=!1;if(l.canUseDOM){var ac=document.createElement("div").style;try{ac.font=""}catch(a){$b=!0}}
	var bc={createDangerousStringForStyles:function(){},setValueForStyles:function(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||Zb.hasOwnProperty(e)&&Zb[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");if(d)a.setProperty(c,e);else if(e)a[c]=e;else if(d=$b&&Yb.shorthandPropertyExpansions[c])for(var g in d)a[g]="";else a[c]=""}}},cc=new RegExp("^["+A.ATTRIBUTE_NAME_START_CHAR+
	"]["+A.ATTRIBUTE_NAME_CHAR+"]*$"),dc={},ec={};function fc(a){if(ec.hasOwnProperty(a))return!0;if(dc.hasOwnProperty(a))return!1;if(cc.test(a))return ec[a]=!0;dc[a]=!0;return!1}
	var gc={setAttributeForID:function(a,b){a.setAttribute(A.ID_ATTRIBUTE_NAME,b)},setAttributeForRoot:function(a){a.setAttribute(A.ROOT_ATTRIBUTE_NAME,"")},getValueForProperty:function(){},getValueForAttribute:function(){},setValueForProperty:function(a,b,c){var d=A.getPropertyInfo(b);if(d&&A.shouldSetAttribute(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?gc.deleteValueForProperty(a,
	b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else gc.setValueForAttribute(a,b,A.shouldSetAttribute(b,c)?c:null)},setValueForAttribute:function(a,b,c){fc(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))},deleteValueForAttribute:function(a,b){a.removeAttribute(b)},deleteValueForProperty:function(a,b){var c=A.getPropertyInfo(b);
	c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}},hc=gc,ic=Qa.ReactDebugCurrentFrame;function jc(){return null}
	var kc={current:null,phase:null,resetCurrentFiber:function(){ic.getCurrentStack=null;kc.current=null;kc.phase=null},setCurrentFiber:function(a,b){ic.getCurrentStack=jc;kc.current=a;kc.phase=b},getCurrentFiberOwnerName:function(){return null},getCurrentFiberStackAddendum:jc},lc=kc,mc={getHostProps:function(a,b){var c=b.value,d=b.checked;return n({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?
	d:a._wrapperState.initialChecked})},initWrapperState:function(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}},updateWrapper:function(a,b){var c=b.checked;null!=c&&hc.setValueForProperty(a,"checked",c||!1);c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=
	c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)},postMountWrapper:function(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==
	b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)},restoreControlledState:function(a,b){mc.updateWrapper(a,b);var c=b.name;if("radio"===b.type&&null!=c){for(b=a;b.parentNode;)b=b.parentNode;c=b.querySelectorAll("input[name\x3d"+JSON.stringify(""+c)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=G.getFiberCurrentPropsFromNode(d);e?void 0:w("90");mc.updateWrapper(d,e)}}}}},qc=mc;
	function rc(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}var sc={validateProps:function(){},postMountWrapper:function(a,b){null!=b.value&&a.setAttribute("value",b.value)},getHostProps:function(a,b){a=n({children:void 0},b);if(b=rc(b.children))a.children=b;return a}};
	function tc(a,b,c){a=a.options;if(b){b={};for(var d=0;d<c.length;d++)b["$"+c[d]]=!0;for(c=0;c<a.length;c++)d=b.hasOwnProperty("$"+a[c].value),a[c].selected!==d&&(a[c].selected=d)}else{c=""+c;b=null;for(d=0;d<a.length;d++){if(a[d].value===c){a[d].selected=!0;return}null!==b||a[d].disabled||(b=a[d])}null!==b&&(b.selected=!0)}}
	var uc={getHostProps:function(a,b){return n({},b,{value:void 0})},initWrapperState:function(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}},postMountWrapper:function(a,b){a.multiple=!!b.multiple;var c=b.value;null!=c?tc(a,!!b.multiple,c):null!=b.defaultValue&&tc(a,!!b.multiple,b.defaultValue)},postUpdateWrapper:function(a,b){a._wrapperState.initialValue=void 0;var c=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!b.multiple;var d=b.value;
	null!=d?tc(a,!!b.multiple,d):c!==!!b.multiple&&(null!=b.defaultValue?tc(a,!!b.multiple,b.defaultValue):tc(a,!!b.multiple,b.multiple?[]:""))},restoreControlledState:function(a,b){var c=b.value;null!=c&&tc(a,!!b.multiple,c)}},vc={getHostProps:function(a,b){null!=b.dangerouslySetInnerHTML?w("91"):void 0;return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})},initWrapperState:function(a,b){var c=b.value,d=c;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?
	w("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:w("93"),b=b[0]),c=""+b),null==c&&(c=""),d=c);a._wrapperState={initialValue:""+d}},updateWrapper:function(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)},postMountWrapper:function(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)},restoreControlledState:function(a,b){vc.updateWrapper(a,b)}},wc=vc,xc=n({menuitem:!0},{area:!0,
	base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function yc(a,b){b&&(xc[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?w("137",a,""):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?w("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:w("61")),null!=b.style&&"object"!==typeof b.style?w("62",""):void 0)}
	function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
	function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
	var Bc={_getTrackerFromNode:function(a){return a._valueTracker},track:function(a){a._valueTracker||(a._valueTracker=Ac(a))},updateValueIfChanged:function(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1},stopTracking:function(a){(a=a._valueTracker)&&a.stopTracking()}};
	function Cc(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}
	var Dc=ka.Namespaces,Ec,Fc=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Dc.svg||"innerHTML"in a)a.innerHTML=b;else for(Ec=Ec||document.createElement("div"),Ec.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e",b=Ec.firstChild;b.firstChild;)a.appendChild(b.firstChild)}),Gc=/["'&<>]/,Hc=F.TEXT_NODE;
	function Ic(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&c.nodeType===Hc){c.nodeValue=b;return}}a.textContent=b}
	l.canUseDOM&&("textContent"in document.documentElement||(Ic=function(a,b){if(a.nodeType===Hc)a.nodeValue=b;else{if("boolean"===typeof b||"number"===typeof b)b=""+b;else{b=""+b;var c=Gc.exec(b);if(c){var d="",e,f=0;for(e=c.index;e<b.length;e++){switch(b.charCodeAt(e)){case 34:c="\x26quot;";break;case 38:c="\x26amp;";break;case 39:c="\x26#x27;";break;case 60:c="\x26lt;";break;case 62:c="\x26gt;";break;default:continue}f!==e&&(d+=b.substring(f,e));f=e+1;d+=c}b=f!==e?d+b.substring(f,e):d}}Fc(a,b)}}));
	var Jc=Ic,Kc=lc.getCurrentFiberOwnerName,Lc=F.DOCUMENT_NODE,Mc=F.DOCUMENT_FRAGMENT_NODE,Nc=M.listenTo,Oc=sa.registrationNameModules,Pc=ka.Namespaces.html,Qc=ka.getIntrinsicNamespace;function Rc(a,b){Nc(b,a.nodeType===Lc||a.nodeType===Mc?a:a.ownerDocument)}
	var Sc={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
	topWaiting:"waiting"},N={createElement:function(a,b,c,d){c=c.nodeType===Lc?c:c.ownerDocument;d===Pc&&(d=Qc(a));d===Pc?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a},createTextNode:function(a,b){return(b.nodeType===Lc?b:b.ownerDocument).createTextNode(a)},setInitialProperties:function(a,b,c,d){var e=Cc(b,c);switch(b){case "iframe":case "object":M.trapBubbledEvent("topLoad",
	"load",a);var f=c;break;case "video":case "audio":for(f in Sc)Sc.hasOwnProperty(f)&&M.trapBubbledEvent(f,Sc[f],a);f=c;break;case "source":M.trapBubbledEvent("topError","error",a);f=c;break;case "img":case "image":M.trapBubbledEvent("topError","error",a);M.trapBubbledEvent("topLoad","load",a);f=c;break;case "form":M.trapBubbledEvent("topReset","reset",a);M.trapBubbledEvent("topSubmit","submit",a);f=c;break;case "details":M.trapBubbledEvent("topToggle","toggle",a);f=c;break;case "input":qc.initWrapperState(a,
	c);f=qc.getHostProps(a,c);M.trapBubbledEvent("topInvalid","invalid",a);Rc(d,"onChange");break;case "option":sc.validateProps(a,c);f=sc.getHostProps(a,c);break;case "select":uc.initWrapperState(a,c);f=uc.getHostProps(a,c);M.trapBubbledEvent("topInvalid","invalid",a);Rc(d,"onChange");break;case "textarea":wc.initWrapperState(a,c);f=wc.getHostProps(a,c);M.trapBubbledEvent("topInvalid","invalid",a);Rc(d,"onChange");break;default:f=c}yc(b,f,Kc);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===
	h?bc.setValueForStyles(a,k):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&Fc(a,k)):"children"===h?"string"===typeof k?Jc(a,k):"number"===typeof k&&Jc(a,""+k):"suppressContentEditableWarning"!==h&&(Oc.hasOwnProperty(h)?null!=k&&Rc(d,h):e?hc.setValueForAttribute(a,h,k):null!=k&&hc.setValueForProperty(a,h,k))}switch(b){case "input":Bc.track(a);qc.postMountWrapper(a,c);break;case "textarea":Bc.track(a);wc.postMountWrapper(a,c);break;case "option":sc.postMountWrapper(a,c);break;case "select":uc.postMountWrapper(a,
	c);break;default:"function"===typeof f.onClick&&(a.onclick=ca)}},diffProperties:function(a,b,c,d,e){var f=null;switch(b){case "input":c=qc.getHostProps(a,c);d=qc.getHostProps(a,d);f=[];break;case "option":c=sc.getHostProps(a,c);d=sc.getHostProps(a,d);f=[];break;case "select":c=uc.getHostProps(a,c);d=uc.getHostProps(a,d);f=[];break;case "textarea":c=wc.getHostProps(a,c);d=wc.getHostProps(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=ca)}yc(b,d,Kc);
	var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]="");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&(Oc.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&
	b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&(Oc.hasOwnProperty(g)?(null!=k&&Rc(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f},updateProperties:function(a,b,c,d,e){Cc(c,d);d=Cc(c,e);for(var f=0;f<b.length;f+=
	2){var g=b[f],h=b[f+1];"style"===g?bc.setValueForStyles(a,h):"dangerouslySetInnerHTML"===g?Fc(a,h):"children"===g?Jc(a,h):d?null!=h?hc.setValueForAttribute(a,g,h):hc.deleteValueForAttribute(a,g):null!=h?hc.setValueForProperty(a,g,h):hc.deleteValueForProperty(a,g)}switch(c){case "input":qc.updateWrapper(a,e);Bc.updateValueIfChanged(a);break;case "textarea":wc.updateWrapper(a,e);break;case "select":uc.postUpdateWrapper(a,e)}},diffHydratedProperties:function(a,b,c,d,e){switch(b){case "iframe":case "object":M.trapBubbledEvent("topLoad",
	"load",a);break;case "video":case "audio":for(var f in Sc)Sc.hasOwnProperty(f)&&M.trapBubbledEvent(f,Sc[f],a);break;case "source":M.trapBubbledEvent("topError","error",a);break;case "img":case "image":M.trapBubbledEvent("topError","error",a);M.trapBubbledEvent("topLoad","load",a);break;case "form":M.trapBubbledEvent("topReset","reset",a);M.trapBubbledEvent("topSubmit","submit",a);break;case "details":M.trapBubbledEvent("topToggle","toggle",a);break;case "input":qc.initWrapperState(a,c);M.trapBubbledEvent("topInvalid",
	"invalid",a);Rc(e,"onChange");break;case "option":sc.validateProps(a,c);break;case "select":uc.initWrapperState(a,c);M.trapBubbledEvent("topInvalid","invalid",a);Rc(e,"onChange");break;case "textarea":wc.initWrapperState(a,c),M.trapBubbledEvent("topInvalid","invalid",a),Rc(e,"onChange")}yc(b,c,Kc);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Oc.hasOwnProperty(g)&&
	null!=f&&Rc(e,g));switch(b){case "input":Bc.track(a);qc.postMountWrapper(a,c);break;case "textarea":Bc.track(a);wc.postMountWrapper(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&(a.onclick=ca)}return d},diffHydratedText:function(a,b){return a.nodeValue!==b},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,
	b,c){switch(b){case "input":qc.restoreControlledState(a,c);break;case "textarea":wc.restoreControlledState(a,c);break;case "select":uc.restoreControlledState(a,c)}}},Tc=void 0;
	if(l.canUseDOM)if("function"!==typeof requestIdleCallback){var Uc=null,Vc=null,Wc=!1,Xc=!1,Yc=0,Zc=33,$c=33,ad={timeRemaining:"object"===typeof performance&&"function"===typeof performance.now?function(){return Yc-performance.now()}:function(){return Yc-Date.now()}},bd="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){a.source===window&&a.data===bd&&(Wc=!1,a=Vc,Vc=null,null!==a&&a(ad))},!1);var cd=function(a){Xc=!1;var b=a-Yc+$c;b<$c&&Zc<$c?(8>
	b&&(b=8),$c=b<Zc?Zc:b):Zc=b;Yc=a+$c;Wc||(Wc=!0,window.postMessage(bd,"*"));b=Uc;Uc=null;null!==b&&b(a)};Tc=function(a){Vc=a;Xc||(Xc=!0,requestAnimationFrame(cd));return 0}}else Tc=requestIdleCallback;else Tc=function(a){setTimeout(function(){a({timeRemaining:function(){return Infinity}})});return 0};
	var dd={rIC:Tc},ed={enableAsyncSubtreeAPI:!0},Q={NoWork:0,SynchronousPriority:1,TaskPriority:2,HighPriority:3,LowPriority:4,OffscreenPriority:5},fd=J.Callback,gd=Q.NoWork,hd=Q.SynchronousPriority,id=Q.TaskPriority,jd=E.ClassComponent,kd=E.HostRoot,md=void 0,nd=void 0;function od(a,b){return a!==id&&a!==hd||b!==id&&b!==hd?a===gd&&b!==gd?-255:a!==gd&&b===gd?255:a-b:0}function pd(){return{first:null,last:null,hasForceUpdate:!1,callbackList:null}}
	function qd(a,b,c,d){null!==c?c.next=b:(b.next=a.first,a.first=b);null!==d?b.next=d:a.last=b}function rd(a,b){b=b.priorityLevel;var c=null;if(null!==a.last&&0>=od(a.last.priorityLevel,b))c=a.last;else for(a=a.first;null!==a&&0>=od(a.priorityLevel,b);)c=a,a=a.next;return c}
	function sd(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=pd());null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=pd())):a=null;md=d;nd=a!==d?a:null;var e=md;c=nd;var f=rd(e,b),g=null!==f?f.next:e.first;if(null===c)return qd(e,b,f,g),null;d=rd(c,b);a=null!==d?d.next:c.first;qd(e,b,f,g);if(g===a&&null!==g||f===d&&null!==f)return null===d&&(c.first=b),null===a&&(c.last=null),null;b={priorityLevel:b.priorityLevel,partialState:b.partialState,callback:b.callback,isReplace:b.isReplace,
	isForced:b.isForced,isTopLevelUnmount:b.isTopLevelUnmount,next:null};qd(c,b,d,a);return b}function td(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
	var ud={addUpdate:function(a,b,c,d){sd(a,{priorityLevel:d,partialState:b,callback:c,isReplace:!1,isForced:!1,isTopLevelUnmount:!1,next:null})},addReplaceUpdate:function(a,b,c,d){sd(a,{priorityLevel:d,partialState:b,callback:c,isReplace:!0,isForced:!1,isTopLevelUnmount:!1,next:null})},addForceUpdate:function(a,b,c){sd(a,{priorityLevel:c,partialState:null,callback:b,isReplace:!1,isForced:!0,isTopLevelUnmount:!1,next:null})},getUpdatePriority:function(a){var b=a.updateQueue;return null===b||a.tag!==
	jd&&a.tag!==kd?gd:null!==b.first?b.first.priorityLevel:gd},addTopLevelUpdate:function(a,b,c,d){var e=null===b.element;b={priorityLevel:d,partialState:b,callback:c,isReplace:!1,isForced:!1,isTopLevelUnmount:e,next:null};a=sd(a,b);e&&(e=md,c=nd,null!==e&&null!==b.next&&(b.next=null,e.last=b),null!==c&&null!==a&&null!==a.next&&(a.next=null,c.last=b))},beginUpdateQueue:function(a,b,c,d,e,f,g){null!==a&&a.updateQueue===c&&(c=b.updateQueue={first:c.first,last:c.last,callbackList:null,hasForceUpdate:!1});
	a=c.callbackList;for(var h=c.hasForceUpdate,k=!0,p=c.first;null!==p&&0>=od(p.priorityLevel,g);){c.first=p.next;null===c.first&&(c.last=null);var x;if(p.isReplace)e=td(p,d,e,f),k=!0;else if(x=td(p,d,e,f))e=k?n({},e,x):n(e,x),k=!1;p.isForced&&(h=!0);null===p.callback||p.isTopLevelUnmount&&null!==p.next||(a=null!==a?a:[],a.push(p.callback),b.effectTag|=fd);p=p.next}c.callbackList=a;c.hasForceUpdate=h;null!==c.first||null!==a||h||(b.updateQueue=null);return e},commitCallbacks:function(a,b,c){a=b.callbackList;
	if(null!==a)for(b.callbackList=null,b=0;b<a.length;b++){var d=a[b];"function"!==typeof d?w("191",d):void 0;d.call(c)}}},vd=[],wd=-1,xd={createCursor:function(a){return{current:a}},isEmpty:function(){return-1===wd},pop:function(a){0>wd||(a.current=vd[wd],vd[wd]=null,wd--)},push:function(a,b){wd++;vd[wd]=a.current;a.current=b},reset:function(){for(;-1<wd;)vd[wd]=null,wd--}},yd=bb.isFiberMounted,zd=E.ClassComponent,Ad=E.HostRoot,Bd=xd.createCursor,Cd=xd.pop,Dd=xd.push,Ed=Bd(da),Fd=Bd(!1),Ld=da;
	function Md(a,b,c){a=a.stateNode;a.__reactInternalMemoizedUnmaskedChildContext=b;a.__reactInternalMemoizedMaskedChildContext=c}function Nd(a){return a.tag===zd&&null!=a.type.childContextTypes}function Od(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:w("108",Ra(a)||"Unknown",e);return n({},b,c)}
	var R={getUnmaskedContext:function(a){return Nd(a)?Ld:Ed.current},cacheContext:Md,getMaskedContext:function(a,b){var c=a.type.contextTypes;if(!c)return da;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&Md(a,b,e);return e},hasContextChanged:function(){return Fd.current},isContextConsumer:function(a){return a.tag===zd&&null!=a.type.contextTypes},isContextProvider:Nd,popContextProvider:function(a){Nd(a)&&
	(Cd(Fd,a),Cd(Ed,a))},popTopLevelContextObject:function(a){Cd(Fd,a);Cd(Ed,a)},pushTopLevelContextObject:function(a,b,c){null!=Ed.cursor?w("168"):void 0;Dd(Ed,b,a);Dd(Fd,c,a)},processChildContext:Od,pushContextProvider:function(a){if(!Nd(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||da;Ld=Ed.current;Dd(Ed,b,a);Dd(Fd,Fd.current,a);return!0},invalidateContextProvider:function(a,b){var c=a.stateNode;c?void 0:w("169");if(b){var d=Od(a,Ld,!0);c.__reactInternalMemoizedMergedChildContext=
	d;Cd(Fd,a);Cd(Ed,a);Dd(Ed,d,a)}else Cd(Fd,a);Dd(Fd,b,a)},resetContext:function(){Ld=da;Ed.current=da;Fd.current=!1},findCurrentUnmaskedContext:function(a){for(yd(a)&&a.tag===zd?void 0:w("170");a.tag!==Ad;){if(Nd(a))return a.stateNode.__reactInternalMemoizedMergedChildContext;(a=a["return"])?void 0:w("171")}return a.stateNode.context}},Pd={NoContext:0,AsyncUpdates:1},Qd=E.IndeterminateComponent,Rd=E.ClassComponent,Sd=E.HostRoot,Td=E.HostComponent,Ud=E.HostText,Vd=E.HostPortal,Wd=E.CoroutineComponent,
	Xd=E.YieldComponent,Yd=E.Fragment,Zd=Q.NoWork,$d=Pd.NoContext,ae=J.NoEffect;function be(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=ae;this.lastEffect=this.firstEffect=this.nextEffect=null;this.pendingWorkPriority=Zd;this.alternate=null}
	function ce(a,b,c){var d=void 0;"function"===typeof a?(d=a.prototype&&a.prototype.isReactComponent?new be(Rd,b,c):new be(Qd,b,c),d.type=a):"string"===typeof a?(d=new be(Td,b,c),d.type=a):"object"===typeof a&&null!==a&&"number"===typeof a.tag?d=a:w("130",null==a?a:typeof a,"");return d}
	var de={createWorkInProgress:function(a,b){var c=a.alternate;null===c?(c=new be(a.tag,a.key,a.internalContextTag),c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.effectTag=ae,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.pendingWorkPriority=b;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c},createHostRootFiber:function(){return new be(Sd,null,$d)},
	createFiberFromElement:function(a,b,c){b=ce(a.type,a.key,b,null);b.pendingProps=a.props;b.pendingWorkPriority=c;return b},createFiberFromFragment:function(a,b,c){b=new be(Yd,null,b);b.pendingProps=a;b.pendingWorkPriority=c;return b},createFiberFromText:function(a,b,c){b=new be(Ud,null,b);b.pendingProps=a;b.pendingWorkPriority=c;return b},createFiberFromElementType:ce,createFiberFromHostInstanceForDeletion:function(){var a=new be(Td,null,$d);a.type="DELETED";return a},createFiberFromCoroutine:function(a,
	b,c){b=new be(Wd,a.key,b);b.type=a.handler;b.pendingProps=a;b.pendingWorkPriority=c;return b},createFiberFromYield:function(a,b){return new be(Xd,null,b)},createFiberFromPortal:function(a,b,c){b=new be(Vd,a.key,b);b.pendingProps=a.children||[];b.pendingWorkPriority=c;b.stateNode={containerInfo:a.containerInfo,implementation:a.implementation};return b},largerPriority:function(a,b){return a!==Zd&&(b===Zd||b>a)?a:b}},ee=de.createHostRootFiber,fe=E.IndeterminateComponent,ge=E.FunctionalComponent,he=E.ClassComponent,
	ie=E.HostComponent,je,ke;"function"===typeof Symbol&&Symbol["for"]?(je=Symbol["for"]("react.coroutine"),ke=Symbol["for"]("react.yield")):(je=60104,ke=60105);
	var le={createCoroutine:function(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:je,key:null==d?null:""+d,children:a,handler:b,props:c}},createYield:function(a){return{$$typeof:ke,value:a}},isCoroutine:function(a){return"object"===typeof a&&null!==a&&a.$$typeof===je},isYield:function(a){return"object"===typeof a&&null!==a&&a.$$typeof===ke},REACT_YIELD_TYPE:ke,REACT_COROUTINE_TYPE:je},me="function"===typeof Symbol&&Symbol["for"]&&Symbol["for"]("react.portal")||
	60106,ne={createPortal:function(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:me,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}},isPortal:function(a){return"object"===typeof a&&null!==a&&a.$$typeof===me},REACT_PORTAL_TYPE:me},oe=le.REACT_COROUTINE_TYPE,pe=le.REACT_YIELD_TYPE,qe=ne.REACT_PORTAL_TYPE,re=de.createWorkInProgress,se=de.createFiberFromElement,te=de.createFiberFromFragment,ue=de.createFiberFromText,ve=de.createFiberFromCoroutine,
	we=de.createFiberFromYield,xe=de.createFiberFromPortal,ye=Array.isArray,ze=E.FunctionalComponent,Ae=E.ClassComponent,Be=E.HostText,Ce=E.HostPortal,De=E.CoroutineComponent,Ee=E.YieldComponent,Fe=E.Fragment,Ge=J.NoEffect,He=J.Placement,Ie=J.Deletion,Je="function"===typeof Symbol&&Symbol.iterator,Ke="function"===typeof Symbol&&Symbol["for"]&&Symbol["for"]("react.element")||60103;
	function Le(a){if(null===a||"undefined"===typeof a)return null;a=Je&&a[Je]||a["@@iterator"];return"function"===typeof a?a:null}
	function Me(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&("number"===typeof b.tag?(b.tag!==Ae?w("110"):void 0,d=b.stateNode):d=b.getPublicInstance());d?void 0:w("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===da?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?w("148"):void 0;b._owner?void 0:w("149",c)}return c}
	function Ne(a,b){"textarea"!==a.type&&w("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
	function Oe(a,b){function c(c,d){if(b){if(!a){if(null===d.alternate)return;d=d.alternate}var m=c.lastEffect;null!==m?(m.nextEffect=d,c.lastEffect=d):c.firstEffect=c.lastEffect=d;d.nextEffect=null;d.effectTag=Ie}}function d(a,d){if(!b)return null;for(;null!==d;)c(a,d),d=d.sibling;return null}function e(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function f(b,c){if(a)return b=re(b,c),b.index=0,b.sibling=null,b;b.pendingWorkPriority=c;b.effectTag=Ge;
	b.index=0;b.sibling=null;return b}function g(a,c,d){a.index=d;if(!b)return c;d=a.alternate;if(null!==d)return d=d.index,d<c?(a.effectTag=He,c):d;a.effectTag=He;return c}function h(a){b&&null===a.alternate&&(a.effectTag=He);return a}function k(a,b,c,d){if(null===b||b.tag!==Be)return c=ue(c,a.internalContextTag,d),c["return"]=a,c;b=f(b,d);b.pendingProps=c;b["return"]=a;return b}function p(a,b,c,d){if(null===b||b.type!==c.type)return d=se(c,a.internalContextTag,d),d.ref=Me(b,c),d["return"]=a,d;d=f(b,
	d);d.ref=Me(b,c);d.pendingProps=c.props;d["return"]=a;return d}function x(a,b,c,d){if(null===b||b.tag!==De)return c=ve(c,a.internalContextTag,d),c["return"]=a,c;b=f(b,d);b.pendingProps=c;b["return"]=a;return b}function S(a,b,c,d){if(null===b||b.tag!==Ee)return b=we(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=f(b,d);b.type=c.value;b["return"]=a;return b}function D(a,b,c,d){if(null===b||b.tag!==Ce||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return c=
	xe(c,a.internalContextTag,d),c["return"]=a,c;b=f(b,d);b.pendingProps=c.children||[];b["return"]=a;return b}function y(a,b,c,d){if(null===b||b.tag!==Fe)return c=te(c,a.internalContextTag,d),c["return"]=a,c;b=f(b,d);b.pendingProps=c;b["return"]=a;return b}function B(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ue(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Ke:return c=se(b,a.internalContextTag,c),c.ref=Me(null,b),c["return"]=
	a,c;case oe:return b=ve(b,a.internalContextTag,c),b["return"]=a,b;case pe:return c=we(b,a.internalContextTag,c),c.type=b.value,c["return"]=a,c;case qe:return b=xe(b,a.internalContextTag,c),b["return"]=a,b}if(ye(b)||Le(b))return b=te(b,a.internalContextTag,c),b["return"]=a,b;Ne(a,b)}return null}function H(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:k(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Ke:return c.key===e?p(a,
	b,c,d):null;case oe:return c.key===e?x(a,b,c,d):null;case pe:return null===e?S(a,b,c,d):null;case qe:return c.key===e?D(a,b,c,d):null}if(ye(c)||Le(c))return null!==e?null:y(a,b,c,d);Ne(a,c)}return null}function C(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,k(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Ke:return a=a.get(null===d.key?c:d.key)||null,p(b,a,d,e);case oe:return a=a.get(null===d.key?c:d.key)||null,x(b,a,d,e);case pe:return a=a.get(c)||
	null,S(b,a,d,e);case qe:return a=a.get(null===d.key?c:d.key)||null,D(b,a,d,e)}if(ye(d)||Le(d))return a=a.get(c)||null,y(b,a,d,e);Ne(b,d)}return null}function Ca(a,f,h,k){for(var m=null,t=null,q=f,r=f=0,p=null;null!==q&&r<h.length;r++){q.index>r?(p=q,q=null):p=q.sibling;var v=H(a,q,h[r],k);if(null===v){null===q&&(q=p);break}b&&q&&null===v.alternate&&c(a,q);f=g(v,f,r);null===t?m=v:t.sibling=v;t=v;q=p}if(r===h.length)return d(a,q),m;if(null===q){for(;r<h.length;r++)if(q=B(a,h[r],k))f=g(q,f,r),null===
	t?m=q:t.sibling=q,t=q;return m}for(q=e(a,q);r<h.length;r++)if(p=C(q,a,r,h[r],k)){if(b&&null!==p.alternate)q["delete"](null===p.key?r:p.key);f=g(p,f,r);null===t?m=p:t.sibling=p;t=p}b&&q.forEach(function(b){return c(a,b)});return m}function r(a,f,h,r){var m=Le(h);"function"!==typeof m?w("150"):void 0;h=m.call(h);null==h?w("151"):void 0;for(var t=m=null,q=f,k=f=0,p=null,v=h.next();null!==q&&!v.done;k++,v=h.next()){q.index>k?(p=q,q=null):p=q.sibling;var V=H(a,q,v.value,r);if(null===V){q||(q=p);break}b&&
	q&&null===V.alternate&&c(a,q);f=g(V,f,k);null===t?m=V:t.sibling=V;t=V;q=p}if(v.done)return d(a,q),m;if(null===q){for(;!v.done;k++,v=h.next())v=B(a,v.value,r),null!==v&&(f=g(v,f,k),null===t?m=v:t.sibling=v,t=v);return m}for(q=e(a,q);!v.done;k++,v=h.next())if(v=C(q,a,k,v.value,r),null!==v){if(b&&null!==v.alternate)q["delete"](null===v.key?k:v.key);f=g(v,f,k);null===t?m=v:t.sibling=v;t=v}b&&q.forEach(function(b){return c(a,b)});return m}return function(a,b,e,g){var m="object"===typeof e&&null!==e;if(m)switch(e.$$typeof){case Ke:a:{var C=
	e.key;for(m=b;null!==m;){if(m.key===C)if(m.type===e.type){d(a,m.sibling);b=f(m,g);b.ref=Me(m,e);b.pendingProps=e.props;b["return"]=a;a=b;break a}else{d(a,m);break}else c(a,m);m=m.sibling}g=se(e,a.internalContextTag,g);g.ref=Me(b,e);g["return"]=a;a=g}return h(a);case oe:a:{for(m=e.key;null!==b;){if(b.key===m)if(b.tag===De){d(a,b.sibling);b=f(b,g);b.pendingProps=e;b["return"]=a;a=b;break a}else{d(a,b);break}else c(a,b);b=b.sibling}e=ve(e,a.internalContextTag,g);e["return"]=a;a=e}return h(a);case pe:a:{if(null!==
	b)if(b.tag===Ee){d(a,b.sibling);b=f(b,g);b.type=e.value;b["return"]=a;a=b;break a}else d(a,b);b=we(e,a.internalContextTag,g);b.type=e.value;b["return"]=a;a=b}return h(a);case qe:a:{for(m=e.key;null!==b;){if(b.key===m)if(b.tag===Ce&&b.stateNode.containerInfo===e.containerInfo&&b.stateNode.implementation===e.implementation){d(a,b.sibling);b=f(b,g);b.pendingProps=e.children||[];b["return"]=a;a=b;break a}else{d(a,b);break}else c(a,b);b=b.sibling}e=xe(e,a.internalContextTag,g);e["return"]=a;a=e}return h(a)}if("string"===
	typeof e||"number"===typeof e)return e=""+e,null!==b&&b.tag===Be?(d(a,b.sibling),b=f(b,g),b.pendingProps=e,b["return"]=a,a=b):(d(a,b),e=ue(e,a.internalContextTag,g),e["return"]=a,a=e),h(a);if(ye(e))return Ca(a,b,e,g);if(Le(e))return r(a,b,e,g);m&&Ne(a,e);if("undefined"===typeof e)switch(a.tag){case Ae:case ze:e=a.type,w("152",e.displayName||e.name||"Component")}return d(a,b)}}
	var Pe=Oe(!0,!0),Qe=Oe(!1,!0),Re=Oe(!1,!1),Se={reconcileChildFibers:Pe,reconcileChildFibersInPlace:Qe,mountChildFibersInPlace:Re,cloneChildFibers:function(a,b){null!==a&&b.child!==a.child?w("153"):void 0;if(null!==b.child){a=b.child;var c=re(a,a.pendingWorkPriority);c.pendingProps=a.pendingProps;b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=re(a,a.pendingWorkPriority),c.pendingProps=a.pendingProps,c["return"]=b;c.sibling=null}}},Te=J.Update,Ue=Pd.AsyncUpdates,Ve=R.cacheContext,
	We=R.getMaskedContext,Xe=R.getUnmaskedContext,Ye=R.isContextConsumer,Ze=ud.addUpdate,$e=ud.addReplaceUpdate,af=ud.addForceUpdate,bf=ud.beginUpdateQueue,cf=R.hasContextChanged,df=bb.isMounted;
	function ef(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;Pa.set(b,a)}var f={isMounted:df,enqueueSetState:function(c,d,e){c=Pa.get(c);var f=b(c,!1);Ze(c,d,void 0===e?null:e,f);a(c,f)},enqueueReplaceState:function(c,d,e){c=Pa.get(c);var f=b(c,!1);$e(c,d,void 0===e?null:e,f);a(c,f)},enqueueForceUpdate:function(c,d){c=Pa.get(c);var e=b(c,!1);af(c,void 0===d?null:d,e);a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=Xe(a),f=Ye(a),g=f?We(a,d):da;b=new c(b,g);
	e(a,b);f&&Ve(a,d,g);return b},mountClassInstance:function(a,b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:w("158");var h=Xe(a);d.props=g;d.state=e;d.refs=da;d.context=We(a,h);ed.enableAsyncSubtreeAPI&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=Ue);"function"===typeof d.componentWillMount&&(h=d.state,d.componentWillMount(),h!==d.state&&f.enqueueReplaceState(d,d.state,null),h=a.updateQueue,null!==
	h&&(d.state=bf(c,a,h,d,e,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=Te)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?w("159"):void 0);var D=g.context,y=Xe(b);y=We(b,y);"function"!==typeof g.componentWillReceiveProps||h===k&&D===y||(D=g.state,g.componentWillReceiveProps(k,y),g.state!==D&&f.enqueueReplaceState(g,g.state,null));D=b.memoizedState;e=null!==b.updateQueue?bf(a,
	b,b.updateQueue,g,D,k,e):D;if(!(h!==k||D!==e||cf()||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&D===a.memoizedState||(b.effectTag|=Te),!1;var B=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)B=!0;else{var H=b.stateNode,C=b.type;B="function"===typeof H.shouldComponentUpdate?H.shouldComponentUpdate(B,e,y):C.prototype&&C.prototype.isPureReactComponent?!ea(h,B)||!ea(D,e):!0}B?("function"===typeof g.componentWillUpdate&&
	g.componentWillUpdate(k,e,y),"function"===typeof g.componentDidUpdate&&(b.effectTag|=Te)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&D===a.memoizedState||(b.effectTag|=Te),c(b,k),d(b,e));g.props=k;g.state=e;g.context=y;return B}}}
	var ff=Se.mountChildFibersInPlace,gf=Se.reconcileChildFibers,hf=Se.reconcileChildFibersInPlace,jf=Se.cloneChildFibers,kf=ud.beginUpdateQueue,lf=R.getMaskedContext,mf=R.getUnmaskedContext,nf=R.hasContextChanged,of=R.pushContextProvider,pf=R.pushTopLevelContextObject,qf=R.invalidateContextProvider,rf=E.IndeterminateComponent,sf=E.FunctionalComponent,tf=E.ClassComponent,uf=E.HostRoot,wf=E.HostComponent,xf=E.HostText,yf=E.HostPortal,zf=E.CoroutineComponent,Af=E.CoroutineHandlerPhase,Bf=E.YieldComponent,
	Cf=E.Fragment,Df=Q.NoWork,Ef=Q.OffscreenPriority,Ff=J.PerformedWork,Gf=J.Placement,Hf=J.ContentReset,If=J.Err,Jf=J.Ref,Kf=Qa.ReactCurrentOwner;
	function Lf(a,b,c,d,e){function f(a,b,c){g(a,b,c,b.pendingWorkPriority)}function g(a,b,c,d){b.child=null===a?ff(b,b.child,c,d):a.child===b.child?gf(b,b.child,c,d):hf(b,b.child,c,d)}function h(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=Jf)}function k(a,b,c,d){h(a,b);if(!c)return d&&qf(b,!1),x(a,b);c=b.stateNode;Kf.current=b;var e=c.render();b.effectTag|=Ff;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&qf(b,!0);return b.child}function p(a){var b=a.stateNode;b.pendingContext?
	pf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&pf(a,b.context,!1);C(a,b.containerInfo)}function x(a,b){jf(a,b);return b.child}function S(a,b){switch(b.tag){case uf:p(b);break;case tf:of(b);break;case yf:C(b,b.stateNode.containerInfo)}return null}var D=a.shouldSetTextContent,y=a.useSyncScheduling,B=a.shouldDeprioritizeSubtree,H=b.pushHostContext,C=b.pushHostContainer,Ca=c.enterHydrationState,r=c.resetHydrationState,m=c.tryToClaimNextHydratableInstance;a=ef(d,e,function(a,b){a.memoizedProps=
	b},function(a,b){a.memoizedState=b});var t=a.adoptClassInstance,v=a.constructClassInstance,V=a.mountClassInstance,ld=a.updateClassInstance;return{beginWork:function(a,b,c){if(b.pendingWorkPriority===Df||b.pendingWorkPriority>c)return S(a,b);switch(b.tag){case rf:null!==a?w("155"):void 0;var d=b.type,e=b.pendingProps,g=mf(b);g=lf(b,g);d=d(e,g);b.effectTag|=Ff;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=tf,e=of(b),t(b,d),V(b,c),b=k(a,b,!0,e)):(b.tag=sf,f(a,b,d),b.memoizedProps=
	e,b=b.child);return b;case sf:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(nf())null===c&&(c=d);else if(null===c||d===c){b=x(a,b);break a}d=mf(b);d=lf(b,d);e=e(c,d);b.effectTag|=Ff;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case tf:return e=of(b),d=void 0,null===a?b.stateNode?w("153"):(v(b,b.pendingProps),V(b,c),d=!0):d=ld(a,b,c),k(a,b,d,e);case uf:return p(b),d=b.updateQueue,null!==d?(e=b.memoizedState,d=kf(a,b,d,null,e,null,c),e===d?(r(),b=x(a,b)):(e=d.element,null!==a&&null!==a.child||
	!Ca(b)?(r(),f(a,b,e)):(b.effectTag|=Gf,b.child=ff(b,b.child,e,c)),b.memoizedState=d,b=b.child)):(r(),b=x(a,b)),b;case wf:H(b);null===a&&m(b);e=b.type;var q=b.memoizedProps;d=b.pendingProps;null===d&&(d=q,null===d?w("154"):void 0);g=null!==a?a.memoizedProps:null;nf()||null!==d&&q!==d?(q=d.children,D(e,d)?q=null:g&&D(e,g)&&(b.effectTag|=Hf),h(a,b),c!==Ef&&!y&&B(e,d)?(b.pendingWorkPriority=Ef,b=null):(f(a,b,q),b.memoizedProps=d,b=b.child)):b=x(a,b);return b;case xf:return null===a&&m(b),a=b.pendingProps,
	null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case Af:b.tag=zf;case zf:c=b.pendingProps;if(nf())null===c&&(c=a&&a.memoizedProps,null===c?w("154"):void 0);else if(null===c||b.memoizedProps===c)c=b.memoizedProps;e=c.children;d=b.pendingWorkPriority;b.stateNode=null===a?ff(b,b.stateNode,e,d):a.child===b.child?gf(b,b.stateNode,e,d):hf(b,b.stateNode,e,d);b.memoizedProps=c;return b.stateNode;case Bf:return null;case yf:a:{C(b,b.stateNode.containerInfo);c=b.pendingWorkPriority;e=b.pendingProps;if(nf())null===
	e&&(e=a&&a.memoizedProps,null==e?w("154"):void 0);else if(null===e||b.memoizedProps===e){b=x(a,b);break a}null===a?b.child=hf(b,b.child,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case Cf:a:{c=b.pendingProps;if(nf())null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=x(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:w("156")}},beginFailedWork:function(a,b,c){switch(b.tag){case tf:of(b);break;case uf:p(b);break;default:w("157")}b.effectTag|=If;null===a?
	b.child=null:b.child!==a.child&&(b.child=a.child);if(b.pendingWorkPriority===Df||b.pendingWorkPriority>c)return S(a,b);b.firstEffect=null;b.lastEffect=null;g(a,b,null,c);b.tag===tf&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
	var Mf=Se.reconcileChildFibers,Nf=R.popContextProvider,Of=R.popTopLevelContextObject,Pf=E.IndeterminateComponent,Qf=E.FunctionalComponent,Rf=E.ClassComponent,Sf=E.HostRoot,Tf=E.HostComponent,Uf=E.HostText,Vf=E.HostPortal,Wf=E.CoroutineComponent,Xf=E.CoroutineHandlerPhase,Yf=E.YieldComponent,Zf=E.Fragment,ag=J.Placement,bg=J.Ref,cg=J.Update,dg=Q.OffscreenPriority;
	function eg(a,b,c){var d=a.createInstance,e=a.createTextInstance,f=a.appendInitialChild,g=a.finalizeInitialChildren,h=a.prepareUpdate,k=b.getRootHostContainer,p=b.popHostContext,x=b.getHostContext,S=b.popHostContainer,D=c.prepareToHydrateHostInstance,y=c.prepareToHydrateHostTextInstance,B=c.popHydrationState;return{completeWork:function(a,b,c){var r=b.pendingProps;if(null===r)r=b.memoizedProps;else if(b.pendingWorkPriority!==dg||c===dg)b.pendingProps=null;switch(b.tag){case Qf:return null;case Rf:return Nf(b),
	null;case Sf:S(b);Of(b);r=b.stateNode;r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null);if(null===a||null===a.child)B(b),b.effectTag&=~ag;return null;case Tf:p(b);c=k();var m=b.type;if(null!==a&&null!=b.stateNode){var t=a.memoizedProps,C=b.stateNode,V=x();r=h(C,m,t,r,c,V);if(b.updateQueue=r)b.effectTag|=cg;a.ref!==b.ref&&(b.effectTag|=bg)}else{if(!r)return null===b.stateNode?w("166"):void 0,null;a=x();if(B(b))D(b,c,a)&&(b.effectTag|=cg);else{a=d(m,r,c,a,b);a:for(t=b.child;null!==
	t;){if(t.tag===Tf||t.tag===Uf)f(a,t.stateNode);else if(t.tag!==Vf&&null!==t.child){t=t.child;continue}if(t===b)break a;for(;null===t.sibling;){if(null===t["return"]||t["return"]===b)break a;t=t["return"]}t=t.sibling}g(a,m,r,c)&&(b.effectTag|=cg);b.stateNode=a}null!==b.ref&&(b.effectTag|=bg)}return null;case Uf:if(a&&null!=b.stateNode)a.memoizedProps!==r&&(b.effectTag|=cg);else{if("string"!==typeof r)return null===b.stateNode?w("166"):void 0,null;a=k();c=x();B(b)?y(b)&&(b.effectTag|=cg):b.stateNode=
	e(r,a,c,b)}return null;case Wf:(r=b.memoizedProps)?void 0:w("165");b.tag=Xf;c=[];a:for((m=b.stateNode)&&(m["return"]=b);null!==m;){if(m.tag===Tf||m.tag===Uf||m.tag===Vf)w("164");else if(m.tag===Yf)c.push(m.type);else if(null!==m.child){m.child["return"]=m;m=m.child;continue}for(;null===m.sibling;){if(null===m["return"]||m["return"]===b)break a;m=m["return"]}m.sibling["return"]=m["return"];m=m.sibling}m=r.handler;r=m(r.props,c);b.child=Mf(b,null!==a?a.child:null,r,b.pendingWorkPriority);return b.child;
	case Xf:return b.tag=Wf,null;case Yf:return null;case Zf:return null;case Vf:return b.effectTag|=cg,S(b),null;case Pf:w("167");default:w("156")}}}}var fg=null,gg=null;function hg(a){return function(b){try{return a(b)}catch(c){}}}
	var ig={injectInternals:function(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!b.supportsFiber)return!0;try{var c=b.inject(a);fg=hg(function(a){return b.onCommitFiberRoot(c,a)});gg=hg(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0},onCommitRoot:function(a){"function"===typeof fg&&fg(a)},onCommitUnmount:function(a){"function"===typeof gg&&gg(a)}},jg=E.ClassComponent,kg=E.HostRoot,lg=E.HostComponent,mg=E.HostText,ng=
	E.HostPortal,og=E.CoroutineComponent,pg=ud.commitCallbacks,qg=ig.onCommitUnmount,rg=J.Placement,sg=J.Update,tg=J.Callback,ug=J.ContentReset;
	function vg(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(t){b(a,t)}}function d(a){return a.tag===lg||a.tag===kg||a.tag===ng}function e(a){for(var b=a;;)if(g(b),null!==b.child&&b.tag!==ng)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}function f(a){for(var b=a,c=!1,d=void 0,f=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?w("160"):void 0;switch(c.tag){case lg:d=
	c.stateNode;f=!1;break a;case kg:d=c.stateNode.containerInfo;f=!0;break a;case ng:d=c.stateNode.containerInfo;f=!0;break a}c=c["return"]}c=!0}if(b.tag===lg||b.tag===mg)e(b),f?C(d,b.stateNode):H(d,b.stateNode);else if(b.tag===ng?d=b.stateNode.containerInfo:g(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];b.tag===ng&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}function g(a){"function"===
	typeof qg&&qg(a);switch(a.tag){case jg:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(t){b(a,t)}break;case lg:c(a);break;case og:e(a.stateNode);break;case ng:f(a)}}var h=a.commitMount,k=a.commitUpdate,p=a.resetTextContent,x=a.commitTextUpdate,S=a.appendChild,D=a.appendChildToContainer,y=a.insertBefore,B=a.insertInContainerBefore,H=a.removeChild,C=a.removeChildFromContainer,Ca=a.getPublicInstance;
	return{commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(d(b)){var c=b;break a}b=b["return"]}w("160");c=void 0}var e=b=void 0;switch(c.tag){case lg:b=c.stateNode;e=!1;break;case kg:b=c.stateNode.containerInfo;e=!0;break;case ng:b=c.stateNode.containerInfo;e=!0;break;default:w("161")}c.effectTag&ug&&(p(b),c.effectTag&=~ug);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||d(c["return"])){c=null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;c.tag!==
	lg&&c.tag!==mg;){if(c.effectTag&rg)continue b;if(null===c.child||c.tag===ng)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&rg)){c=c.stateNode;break a}}for(var f=a;;){if(f.tag===lg||f.tag===mg)c?e?B(b,f.stateNode,c):y(b,f.stateNode,c):e?D(b,f.stateNode):S(b,f.stateNode);else if(f.tag!==ng&&null!==f.child){f.child["return"]=f;f=f.child;continue}if(f===a)break;for(;null===f.sibling;){if(null===f["return"]||f["return"]===a)return;f=f["return"]}f.sibling["return"]=f["return"];f=f.sibling}},
	commitDeletion:function(a){f(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case jg:break;case lg:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&k(c,f,e,a,d,b)}break;case mg:null===b.stateNode?w("162"):void 0;c=b.memoizedProps;x(b.stateNode,null!==a?a.memoizedProps:c,c);break;case kg:break;case ng:break;default:w("163")}},
	commitLifeCycles:function(a,b){switch(b.tag){case jg:var c=b.stateNode;if(b.effectTag&sg)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b.effectTag&tg&&null!==b.updateQueue&&pg(b,b.updateQueue,c);break;case kg:a=b.updateQueue;null!==a&&pg(b,a,b.child&&b.child.stateNode);break;case lg:c=b.stateNode;null===a&&b.effectTag&sg&&h(c,b.type,b.memoizedProps,
	b);break;case mg:break;case ng:break;default:w("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case lg:b(Ca(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var wg=xd.createCursor,xg=xd.pop,yg=xd.push,zg={};
	function Ag(a){function b(a){a===zg?w("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e=wg(zg),f=wg(zg),g=wg(zg);return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){xg(e,a);xg(f,a);xg(g,a)},popHostContext:function(a){f.current===a&&(xg(e,a),xg(f,a))},pushHostContainer:function(a,b){yg(g,b,a);b=d(b);yg(f,a,a);yg(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);d=c(h,a.type,
	d);h!==d&&(yg(f,a,a),yg(e,d,a))},resetHostContainer:function(){e.current=zg;g.current=zg}}}var Bg=E.HostComponent,Cg=E.HostText,Dg=E.HostRoot,Eg=J.Deletion,Fg=J.Placement,Gg=de.createFiberFromHostInstanceForDeletion;
	function Hg(a){function b(a,b){var c=Gg();c.stateNode=b;c["return"]=a;c.effectTag=Eg;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case Bg:return f(b,a.type,a.pendingProps);case Cg:return g(b,a.pendingProps);default:return!1}}function d(a){for(a=a["return"];null!==a&&a.tag!==Bg&&a.tag!==Dg;)a=a["return"];y=a}var e=a.shouldSetTextContent,f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,
	p=a.hydrateInstance,x=a.hydrateTextInstance,S=a.didNotHydrateInstance,D=a.didNotFindHydratableInstance;a=a.didNotFindHydratableTextInstance;if(!(f&&g&&h&&k&&p&&x&&S&&D&&a))return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){w("175")},prepareToHydrateHostTextInstance:function(){w("176")},popHydrationState:function(){return!1}};var y=null,B=null,H=!1;return{enterHydrationState:function(a){B=
	k(a.stateNode.containerInfo);y=a;return H=!0},resetHydrationState:function(){B=y=null;H=!1},tryToClaimNextHydratableInstance:function(a){if(H){var d=B;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=Fg;H=!1;y=a;return}b(y,B)}a.stateNode=d;y=a;B=k(d)}else a.effectTag|=Fg,H=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=p(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return x(a.stateNode,a.memoizedProps,a)},
	popHydrationState:function(a){if(a!==y)return!1;if(!H)return d(a),H=!0,!1;var c=a.type;if(a.tag!==Bg||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=B;c;)b(a,c),c=h(c);d(a);B=y?h(a.stateNode):null;return!0}}}
	var Ig=R.popContextProvider,Jg=xd.reset,Kg=Qa.ReactCurrentOwner,Lg=de.createWorkInProgress,Mg=de.largerPriority,Ng=ig.onCommitRoot,T=Q.NoWork,Og=Q.SynchronousPriority,U=Q.TaskPriority,Pg=Q.HighPriority,Qg=Q.LowPriority,Rg=Q.OffscreenPriority,Sg=Pd.AsyncUpdates,Tg=J.PerformedWork,Ug=J.Placement,Vg=J.Update,Wg=J.PlacementAndUpdate,Xg=J.Deletion,Yg=J.ContentReset,Zg=J.Callback,$g=J.Err,ah=J.Ref,bh=E.HostRoot,ch=E.HostComponent,dh=E.HostPortal,eh=E.ClassComponent,fh=ud.getUpdatePriority,gh=R.resetContext;
	function hh(a){function b(){for(;null!==ma&&ma.current.pendingWorkPriority===T;){ma.isScheduled=!1;var a=ma.nextScheduledRoot;ma.nextScheduledRoot=null;if(ma===zb)return zb=ma=null,z=T,null;ma=a}a=ma;for(var b=null,c=T;null!==a;)a.current.pendingWorkPriority!==T&&(c===T||c>a.current.pendingWorkPriority)&&(c=a.current.pendingWorkPriority,b=a),a=a.nextScheduledRoot;null!==b?(z=c,Jg(),gh(),t(),I=Lg(b.current,c),b!==nc&&(oc=0,nc=b)):(z=T,nc=I=null)}function c(c){Hd=!0;na=null;var d=c.stateNode;d.current===
	c?w("177"):void 0;z!==Og&&z!==U||oc++;Kg.current=null;if(c.effectTag>Tg)if(null!==c.lastEffect){c.lastEffect.nextEffect=c;var e=c.firstEffect}else e=c;else e=c.firstEffect;Ui();for(u=e;null!==u;){var f=!1,g=void 0;try{for(;null!==u;){var h=u.effectTag;h&Yg&&a.resetTextContent(u.stateNode);if(h&ah){var k=u.alternate;null!==k&&Ph(k)}switch(h&~(Zg|$g|Yg|ah|Tg)){case Ug:q(u);u.effectTag&=~Ug;break;case Wg:q(u);u.effectTag&=~Ug;vf(u.alternate,u);break;case Vg:vf(u.alternate,u);break;case Xg:Id=!0,Mh(u),
	Id=!1}u=u.nextEffect}}catch(Jd){f=!0,g=Jd}f&&(null===u?w("178"):void 0,x(u,g),null!==u&&(u=u.nextEffect))}Vi();d.current=c;for(u=e;null!==u;){d=!1;e=void 0;try{for(;null!==u;){var Gd=u.effectTag;Gd&(Vg|Zg)&&Nh(u.alternate,u);Gd&ah&&Oh(u);if(Gd&$g)switch(f=u,g=void 0,null!==P&&(g=P.get(f),P["delete"](f),null==g&&null!==f.alternate&&(f=f.alternate,g=P.get(f),P["delete"](f))),null==g?w("184"):void 0,f.tag){case eh:f.stateNode.componentDidCatch(g.error,{componentStack:g.componentStack});break;case bh:null===
	Ja&&(Ja=g.error);break;default:w("157")}var m=u.nextEffect;u.nextEffect=null;u=m}}catch(Jd){d=!0,e=Jd}d&&(null===u?w("178"):void 0,x(u,e),null!==u&&(u=u.nextEffect))}Hd=!1;"function"===typeof Ng&&Ng(c.stateNode);va&&(va.forEach(H),va=null);b()}function d(a){for(;;){var b=Lh(a.alternate,a,z),c=a["return"],d=a.sibling;var e=a;if(!(e.pendingWorkPriority!==T&&e.pendingWorkPriority>z)){for(var f=fh(e),g=e.child;null!==g;)f=Mg(f,g.pendingWorkPriority),g=g.sibling;e.pendingWorkPriority=f}if(null!==b)return b;
	null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),a.effectTag>Tg&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;if(null!==c)a=c;else{na=a;break}}return null}function e(a){var b=V(a.alternate,a,z);null===b&&(b=d(a));Kg.current=null;return b}function f(a){var b=ld(a.alternate,a,z);null===b&&(b=d(a));Kg.current=null;return b}
	function g(a){p(Rg,a)}function h(){if(null!==P&&0<P.size&&z===U)for(;null!==I;){var a=I;I=null!==P&&(P.has(a)||null!==a.alternate&&P.has(a.alternate))?f(I):e(I);if(null===I&&(null===na?w("179"):void 0,O=U,c(na),O=z,null===P||0===P.size||z!==U))break}}function k(a,d){null!==na?(O=U,c(na),h()):null===I&&b();if(!(z===T||z>a)){O=z;a:do{if(z<=U)for(;null!==I&&!(I=e(I),null===I&&(null===na?w("179"):void 0,O=U,c(na),O=z,h(),z===T||z>a||z>U)););else if(null!==d)for(;null!==I&&!Ab;)if(1<d.timeRemaining()){if(I=
	e(I),null===I)if(null===na?w("179"):void 0,1<d.timeRemaining()){if(O=U,c(na),O=z,h(),z===T||z>a||z<Pg)break}else Ab=!0}else Ab=!0;switch(z){case Og:case U:if(z<=a)continue a;break a;case Pg:case Qg:case Rg:if(null===d)break a;if(!Ab&&z<=a)continue a;break a;case T:break a;default:w("181")}}while(1)}}function p(a,b){Da?w("182"):void 0;Da=!0;var c=O,d=!1,e=null;try{k(a,b)}catch(Kd){d=!0,e=Kd}for(;d;){if(Ya){Ja=e;break}var h=I;if(null===h)Ya=!0;else{var p=x(h,e);null===p?w("183"):void 0;if(!Ya){try{d=
	p;e=a;p=b;for(var q=d;null!==h;){switch(h.tag){case eh:Ig(h);break;case ch:m(h);break;case bh:r(h);break;case dh:r(h)}if(h===q||h.alternate===q)break;h=h["return"]}I=f(d);k(e,p)}catch(Kd){d=!0;e=Kd;continue}break}}}O=c;null!==b&&(Bb=!1);z>U&&!Bb&&($f(g),Bb=!0);a=Ja;Ya=Ab=Da=!1;nc=Ka=P=Ja=null;oc=0;if(null!==a)throw a;}function x(a,b){var c=Kg.current=null,d=!1,e=!1,f=null;if(a.tag===bh)c=a,S(a)&&(Ya=!0);else for(var g=a["return"];null!==g&&null===c;){g.tag===eh?"function"===typeof g.stateNode.componentDidCatch&&
	(d=!0,f=Ra(g),c=g,e=!0):g.tag===bh&&(c=g);if(S(g)){if(Id||null!==va&&(va.has(g)||null!==g.alternate&&va.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===Ka&&(Ka=new Set);Ka.add(c);var h="";g=a;do{a:switch(g.tag){case fe:case ge:case he:case ie:var k=g._debugOwner,m=g._debugSource;var p=Ra(g);var q=null;k&&(q=Ra(k));k=m;p="\n    in "+(p||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":q?" (created by "+q+")":"");break a;default:p=""}h+=p;g=g["return"]}while(g);
	g=h;a=Ra(a);null===P&&(P=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};P.set(c,b);try{console.error(b.error)}catch(Wi){console.error(Wi)}Hd?(null===va&&(va=new Set),va.add(c)):H(c);return c}null===Ja&&(Ja=b);return null}function S(a){return null!==Ka&&(Ka.has(a)||null!==a.alternate&&Ka.has(a.alternate))}function D(a,b){return y(a,b,!1)}function y(a,b){oc>Xi&&(Ya=!0,w("185"));!Da&&b<=z&&(I=null);for(var c=
	!0;null!==a&&c;){c=!1;if(a.pendingWorkPriority===T||a.pendingWorkPriority>b)c=!0,a.pendingWorkPriority=b;null!==a.alternate&&(a.alternate.pendingWorkPriority===T||a.alternate.pendingWorkPriority>b)&&(c=!0,a.alternate.pendingWorkPriority=b);if(null===a["return"])if(a.tag===bh){var d=a.stateNode;b===T||d.isScheduled||(d.isScheduled=!0,zb?zb.nextScheduledRoot=d:ma=d,zb=d);if(!Da)switch(b){case Og:pc?p(Og,null):p(U,null);break;case U:W?void 0:w("186");break;default:Bb||($f(g),Bb=!0)}}else break;a=a["return"]}}
	function B(a,b){var c=O;c===T&&(c=!Yi||a.internalContextTag&Sg||b?Qg:Og);return c===Og&&(Da||W)?U:c}function H(a){y(a,U,!0)}var C=Ag(a),Ca=Hg(a),r=C.popHostContainer,m=C.popHostContext,t=C.resetHostContainer,v=Lf(a,C,Ca,D,B),V=v.beginWork,ld=v.beginFailedWork,Lh=eg(a,C,Ca).completeWork;C=vg(a,x);var q=C.commitPlacement,Mh=C.commitDeletion,vf=C.commitWork,Nh=C.commitLifeCycles,Oh=C.commitAttachRef,Ph=C.commitDetachRef,$f=a.scheduleDeferredCallback,Yi=a.useSyncScheduling,Ui=a.prepareForCommit,Vi=a.resetAfterCommit,
	O=T,Da=!1,Ab=!1,W=!1,pc=!1,I=null,z=T,u=null,na=null,ma=null,zb=null,Bb=!1,P=null,Ka=null,va=null,Ja=null,Ya=!1,Hd=!1,Id=!1,Xi=1E3,oc=0,nc=null;return{scheduleUpdate:D,getPriorityContext:B,batchedUpdates:function(a,b){var c=W;W=!0;try{return a(b)}finally{W=c,Da||W||p(U,null)}},unbatchedUpdates:function(a){var b=pc,c=W;pc=W;W=!1;try{return a()}finally{W=c,pc=b}},flushSync:function(a){var b=W,c=O;W=!0;O=Og;try{return a()}finally{W=b,O=c,Da?w("187"):void 0,p(U,null)}},deferredUpdates:function(a){var b=
	O;O=Qg;try{return a()}finally{O=b}}}}function ih(){w("196")}function jh(a){if(!a)return da;a=Pa.get(a);return"number"===typeof a.tag?ih(a):a._processChildContext(a._context)}jh._injectFiber=function(a){ih=a};var kh=ud.addTopLevelUpdate,lh=R.findCurrentUnmaskedContext,mh=R.isContextProvider,nh=R.processChildContext,oh=E.HostComponent,ph=bb.findCurrentHostFiber,qh=bb.findCurrentHostFiberWithNoPortals;jh._injectFiber(function(a){var b=lh(a);return mh(a)?nh(a,b,!1):b});var rh=F.TEXT_NODE;
	function sh(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function th(a,b){var c=sh(a);a=0;for(var d;c;){if(c.nodeType===rh){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=sh(c)}}var uh=null;function vh(){!uh&&l.canUseDOM&&(uh="textContent"in document.documentElement?"textContent":"innerText");return uh}
	var wh={getOffsets:function(a){var b=window.getSelection&&window.getSelection();if(!b||0===b.rangeCount)return null;var c=b.anchorNode,d=b.anchorOffset,e=b.focusNode,f=b.focusOffset,g=b.getRangeAt(0);try{g.startContainer.nodeType,g.endContainer.nodeType}catch(k){return null}b=b.anchorNode===b.focusNode&&b.anchorOffset===b.focusOffset?0:g.toString().length;var h=g.cloneRange();h.selectNodeContents(a);h.setEnd(g.startContainer,g.startOffset);a=h.startContainer===h.endContainer&&h.startOffset===h.endOffset?
	0:h.toString().length;g=a+b;b=document.createRange();b.setStart(c,d);b.setEnd(e,f);c=b.collapsed;return{start:c?g:a,end:c?a:g}},setOffsets:function(a,b){if(window.getSelection){var c=window.getSelection(),d=a[vh()].length,e=Math.min(b.start,d);b=void 0===b.end?e:Math.min(b.end,d);!c.extend&&e>b&&(d=b,b=e,e=d);d=th(a,e);a=th(a,b);if(d&&a){var f=document.createRange();f.setStart(d.node,d.offset);c.removeAllRanges();e>b?(c.addRange(f),c.extend(a.node,a.offset)):(f.setEnd(a.node,a.offset),c.addRange(f))}}}},
	xh=F.ELEMENT_NODE,yh={hasSelectionCapabilities:function(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)},getSelectionInformation:function(){var a=ia();return{focusedElem:a,selectionRange:yh.hasSelectionCapabilities(a)?yh.getSelection(a):null}},restoreSelection:function(a){var b=ia(),c=a.focusedElem;a=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){yh.hasSelectionCapabilities(c)&&yh.setSelection(c,a);b=
	[];for(a=c;a=a.parentNode;)a.nodeType===xh&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ha(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}},getSelection:function(a){return("selectionStart"in a?{start:a.selectionStart,end:a.selectionEnd}:wh.getOffsets(a))||{start:0,end:0}},setSelection:function(a,b){var c=b.start,d=b.end;void 0===d&&(d=c);"selectionStart"in a?(a.selectionStart=c,a.selectionEnd=Math.min(d,a.value.length)):wh.setOffsets(a,b)}},zh=yh,
	Ah=F.ELEMENT_NODE;function Bh(){w("211")}function Ch(){w("212")}function Dh(a){if(null==a)return null;if(a.nodeType===Ah)return a;var b=Pa.get(a);if(b)return"number"===typeof b.tag?Bh(b):Ch(b);"function"===typeof a.render?w("188"):w("213",Object.keys(a))}Dh._injectFiber=function(a){Bh=a};Dh._injectStack=function(a){Ch=a};var Eh=E.HostComponent;function Fh(a){if(void 0!==a._hostParent)return a._hostParent;if("number"===typeof a.tag){do a=a["return"];while(a&&a.tag!==Eh);if(a)return a}return null}
	function Gh(a,b){for(var c=0,d=a;d;d=Fh(d))c++;d=0;for(var e=b;e;e=Fh(e))d++;for(;0<c-d;)a=Fh(a),c--;for(;0<d-c;)b=Fh(b),d--;for(;c--;){if(a===b||a===b.alternate)return a;a=Fh(a);b=Fh(b)}return null}
	var Hh={isAncestor:function(a,b){for(;b;){if(a===b||a===b.alternate)return!0;b=Fh(b)}return!1},getLowestCommonAncestor:Gh,getParentInstance:function(a){return Fh(a)},traverseTwoPhase:function(a,b,c){for(var d=[];a;)d.push(a),a=Fh(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)},traverseEnterLeave:function(a,b,c,d,e){for(var f=a&&b?Gh(a,b):null,g=[];a&&a!==f;)g.push(a),a=Fh(a);for(a=[];b&&b!==f;)a.push(b),b=Fh(b);for(b=0;b<g.length;b++)c(g[b],"bubbled",d);for(b=
	a.length;0<b--;)c(a[b],"captured",e)}},Ih=Jb.getListener;function Jh(a,b,c){if(b=Ih(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=Cb(c._dispatchListeners,b),c._dispatchInstances=Cb(c._dispatchInstances,a)}function Kh(a){a&&a.dispatchConfig.phasedRegistrationNames&&Hh.traverseTwoPhase(a._targetInst,Jh,a)}function Qh(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?Hh.getParentInstance(b):null;Hh.traverseTwoPhase(b,Jh,a)}}
	function Rh(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Ih(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=Cb(c._dispatchListeners,b),c._dispatchInstances=Cb(c._dispatchInstances,a))}function Sh(a){a&&a.dispatchConfig.registrationName&&Rh(a._targetInst,null,a)}
	var Th={accumulateTwoPhaseDispatches:function(a){Db(a,Kh)},accumulateTwoPhaseDispatchesSkipTarget:function(a){Db(a,Qh)},accumulateDirectDispatches:function(a){Db(a,Sh)},accumulateEnterLeaveDispatches:function(a,b,c,d){Hh.traverseEnterLeave(c,d,Rh,a,b)}},X={_root:null,_startText:null,_fallbackText:null},Uh={initialize:function(a){X._root=a;X._startText=Uh.getText();return!0},reset:function(){X._root=null;X._startText=null;X._fallbackText=null},getData:function(){if(X._fallbackText)return X._fallbackText;
	var a,b=X._startText,c=b.length,d,e=Uh.getText(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);X._fallbackText=e.slice(a,1<d?1-d:void 0);return X._fallbackText},getText:function(){return"value"in X._root?X._root.value:X._root[vh()]}},Vh=Uh,Wh="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Xh={type:null,target:null,currentTarget:ca.thatReturnsNull,eventPhase:null,bubbles:null,
	cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
	function Y(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?ca.thatReturnsTrue:ca.thatReturnsFalse;this.isPropagationStopped=ca.thatReturnsFalse;return this}
	n(Y.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=ca.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=ca.thatReturnsTrue)},persist:function(){this.isPersistent=ca.thatReturnsTrue},isPersistent:ca.thatReturnsFalse,
	destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Wh.length;a++)this[Wh[a]]=null}});Y.Interface=Xh;Y.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;n(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=n({},this.Interface,b);a.augmentClass=this.augmentClass;Yh(a)};Yh(Y);function Zh(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
	function $h(a){a instanceof this?void 0:w("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Yh(a){a.eventPool=[];a.getPooled=Zh;a.release=$h}function ai(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(ai,{data:null});function bi(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(bi,{data:null});var ci=[9,13,27,32],di=l.canUseDOM&&"CompositionEvent"in window,ei=null;l.canUseDOM&&"documentMode"in document&&(ei=document.documentMode);var fi;
	if(fi=l.canUseDOM&&"TextEvent"in window&&!ei){var gi=window.opera;fi=!("object"===typeof gi&&"function"===typeof gi.version&&12>=parseInt(gi.version(),10))}
	var hi=fi,ii=l.canUseDOM&&(!di||ei&&8<ei&&11>=ei),ji=String.fromCharCode(32),ki={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
	captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},li=!1;
	function mi(a,b){switch(a){case "topKeyUp":return-1!==ci.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ni(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var oi=!1;function pi(a,b){switch(a){case "topCompositionEnd":return ni(b);case "topKeyPress":if(32!==b.which)return null;li=!0;return ji;case "topTextInput":return a=b.data,a===ji&&li?null:a;default:return null}}
	function qi(a,b){if(oi)return"topCompositionEnd"===a||!di&&mi(a,b)?(a=Vh.getData(),Vh.reset(),oi=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return ii?null:b.data;default:return null}}
	var ri={eventTypes:ki,extractEvents:function(a,b,c,d){var e;if(di)b:{switch(a){case "topCompositionStart":var f=ki.compositionStart;break b;case "topCompositionEnd":f=ki.compositionEnd;break b;case "topCompositionUpdate":f=ki.compositionUpdate;break b}f=void 0}else oi?mi(a,c)&&(f=ki.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=ki.compositionStart);f?(ii&&(oi||f!==ki.compositionStart?f===ki.compositionEnd&&oi&&(e=Vh.getData()):oi=Vh.initialize(d)),f=ai.getPooled(f,b,c,d),e?f.data=e:(e=ni(c),
	null!==e&&(f.data=e)),Th.accumulateTwoPhaseDispatches(f),e=f):e=null;(a=hi?pi(a,c):qi(a,c))?(b=bi.getPooled(ki.beforeInput,b,c,d),b.data=a,Th.accumulateTwoPhaseDispatches(b)):b=null;return[e,b]}},si={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function ti(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!si[a.type]:"textarea"===b?!0:!1}
	var ui={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};function vi(a,b,c){a=Y.getPooled(ui.change,a,b,c);a.type="change";nb.enqueueStateRestore(c);Th.accumulateTwoPhaseDispatches(a);return a}var wi=null,xi=null;function yi(a){Jb.enqueueEvents(a);Jb.processEventQueue(!1)}
	function zi(a){var b=G.getNodeFromInstance(a);if(Bc.updateValueIfChanged(b))return a}function Ai(a,b){if("topChange"===a)return b}var Bi=!1;l.canUseDOM&&(Bi=Lb("input")&&(!document.documentMode||9<document.documentMode));function Ci(){wi&&(wi.detachEvent("onpropertychange",Di),xi=wi=null)}function Di(a){"value"===a.propertyName&&zi(xi)&&(a=vi(xi,a,ub(a)),sb.batchedUpdates(yi,a))}function Ei(a,b,c){"topFocus"===a?(Ci(),wi=b,xi=c,wi.attachEvent("onpropertychange",Di)):"topBlur"===a&&Ci()}
	function Fi(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return zi(xi)}function Gi(a,b){if("topClick"===a)return zi(b)}function Hi(a,b){if("topInput"===a||"topChange"===a)return zi(b)}
	var Ii={eventTypes:ui,_isInputEventSupported:Bi,extractEvents:function(a,b,c,d){var e=b?G.getNodeFromInstance(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ai;else if(ti(e))if(Bi)g=Hi;else{g=Fi;var h=Ei}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Gi);if(g&&(g=g(a,b)))return vi(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,
	e.getAttribute("value")!==a&&e.setAttribute("value",a))}};function Ji(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(Ji,{view:function(a){if(a.view)return a.view;a=ub(a);return a.window===a?a:(a=a.ownerDocument)?a.defaultView||a.parentWindow:window},detail:function(a){return a.detail||0}});var Ki={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Li(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Ki[a])?!!b[a]:!1}function Mi(){return Li}
	function Ni(a,b,c,d){return Y.call(this,a,b,c,d)}Ji.augmentClass(Ni,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Mi,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
	var Oi={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},Pi={eventTypes:Oi,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?G.getClosestInstanceFromNode(b):
	null):a=null;if(a===b)return null;var f=null==a?e:G.getNodeFromInstance(a);e=null==b?e:G.getNodeFromInstance(b);var g=Ni.getPooled(Oi.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=Ni.getPooled(Oi.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Th.accumulateEnterLeaveDispatches(g,c,a,b);return[g,c]}},Qi=F.DOCUMENT_NODE,Ri=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Si={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
	dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Ti=null,Zi=null,$i=null,aj=!1,bj=M.isListeningToAllDependencies;
	function cj(a,b){if(aj||null==Ti||Ti!==ia())return null;var c=Ti;"selectionStart"in c&&zh.hasSelectionCapabilities(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return $i&&ea($i,c)?null:($i=c,a=Y.getPooled(Si.select,Zi,a,b),a.type="select",a.target=Ti,Th.accumulateTwoPhaseDispatches(a),a)}
	var dj={eventTypes:Si,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:d.nodeType===Qi?d:d.ownerDocument;if(!e||!bj("onSelect",e))return null;e=b?G.getNodeFromInstance(b):window;switch(a){case "topFocus":if(ti(e)||"true"===e.contentEditable)Ti=e,Zi=b,$i=null;break;case "topBlur":$i=Zi=Ti=null;break;case "topMouseDown":aj=!0;break;case "topContextMenu":case "topMouseUp":return aj=!1,cj(c,d);case "topSelectionChange":if(Ri)break;case "topKeyDown":case "topKeyUp":return cj(c,d)}return null}};
	function ej(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(ej,{animationName:null,elapsedTime:null,pseudoElement:null});function fj(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(fj,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function gj(a,b,c,d){return Y.call(this,a,b,c,d)}Ji.augmentClass(gj,{relatedTarget:null});function hj(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
	var ij={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},jj={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
	116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function kj(a,b,c,d){return Y.call(this,a,b,c,d)}
	Ji.augmentClass(kj,{key:function(a){if(a.key){var b=ij[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=hj(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?jj[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Mi,charCode:function(a){return"keypress"===a.type?hj(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
	a.type?hj(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function lj(a,b,c,d){return Y.call(this,a,b,c,d)}Ni.augmentClass(lj,{dataTransfer:null});function mj(a,b,c,d){return Y.call(this,a,b,c,d)}Ji.augmentClass(mj,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Mi});function nj(a,b,c,d){return Y.call(this,a,b,c,d)}Y.augmentClass(nj,{propertyName:null,elapsedTime:null,pseudoElement:null});
	function oj(a,b,c,d){return Y.call(this,a,b,c,d)}Ni.augmentClass(oj,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var pj={},qj={};
	"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
	a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};pj[a]=c;qj[b]=c});
	var rj={eventTypes:pj,extractEvents:function(a,b,c,d){var e=qj[a];if(!e)return null;switch(a){case "topAbort":case "topCancel":case "topCanPlay":case "topCanPlayThrough":case "topClose":case "topDurationChange":case "topEmptied":case "topEncrypted":case "topEnded":case "topError":case "topInput":case "topInvalid":case "topLoad":case "topLoadedData":case "topLoadedMetadata":case "topLoadStart":case "topPause":case "topPlay":case "topPlaying":case "topProgress":case "topRateChange":case "topReset":case "topSeeked":case "topSeeking":case "topStalled":case "topSubmit":case "topSuspend":case "topTimeUpdate":case "topToggle":case "topVolumeChange":case "topWaiting":var f=Y;
	break;case "topKeyPress":if(0===hj(c))return null;case "topKeyDown":case "topKeyUp":f=kj;break;case "topBlur":case "topFocus":f=gj;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":f=Ni;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":f=lj;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":f=
	mj;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":f=ej;break;case "topTransitionEnd":f=nj;break;case "topScroll":f=Ji;break;case "topWheel":f=oj;break;case "topCopy":case "topCut":case "topPaste":f=fj}f?void 0:w("86",a);a=f.getPooled(e,b,c,d);Th.accumulateTwoPhaseDispatches(a);return a}};L.setHandleTopLevel(M.handleTopLevel);Jb.injection.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
	ib.injection.injectComponentTree(G);Jb.injection.injectEventPluginsByName({SimpleEventPlugin:rj,EnterLeaveEventPlugin:Pi,ChangeEventPlugin:Ii,SelectEventPlugin:dj,BeforeInputEventPlugin:ri});
	var sj=A.injection.MUST_USE_PROPERTY,Z=A.injection.HAS_BOOLEAN_VALUE,tj=A.injection.HAS_NUMERIC_VALUE,uj=A.injection.HAS_POSITIVE_NUMERIC_VALUE,vj=A.injection.HAS_STRING_BOOLEAN_VALUE,wj={Properties:{allowFullScreen:Z,allowTransparency:vj,async:Z,autoPlay:Z,capture:Z,checked:sj|Z,cols:uj,contentEditable:vj,controls:Z,"default":Z,defer:Z,disabled:Z,download:A.injection.HAS_OVERLOADED_BOOLEAN_VALUE,draggable:vj,formNoValidate:Z,hidden:Z,loop:Z,multiple:sj|Z,muted:sj|Z,noValidate:Z,open:Z,playsInline:Z,
	readOnly:Z,required:Z,reversed:Z,rows:uj,rowSpan:tj,scoped:Z,seamless:Z,selected:sj|Z,size:uj,start:tj,span:uj,spellCheck:vj,style:0,itemScope:Z,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:vj},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&
	a.ownerDocument.activeElement!==a&&a.setAttribute("value",""+b)}}},xj=A.injection.HAS_STRING_BOOLEAN_VALUE,yj={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},zj={Properties:{autoReverse:xj,externalResourcesRequired:xj,preserveAlpha:xj},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:yj.xlink,xlinkArcrole:yj.xlink,xlinkHref:yj.xlink,xlinkRole:yj.xlink,
	xlinkShow:yj.xlink,xlinkTitle:yj.xlink,xlinkType:yj.xlink,xmlBase:yj.xml,xmlLang:yj.xml,xmlSpace:yj.xml}},Aj=/[\-\:]([a-z])/g;function Bj(a){return a[1].toUpperCase()}
	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Aj,
	Bj);zj.Properties[b]=0;zj.DOMAttributeNames[b]=a});A.injection.injectDOMPropertyConfig(wj);A.injection.injectDOMPropertyConfig(zj);
	var Cj=ig.injectInternals,Dj=F.ELEMENT_NODE,Ej=F.TEXT_NODE,Fj=F.COMMENT_NODE,Gj=F.DOCUMENT_NODE,Hj=F.DOCUMENT_FRAGMENT_NODE,Ij=A.ROOT_ATTRIBUTE_NAME,Jj=ka.getChildNamespace,Kj=N.createElement,Lj=N.createTextNode,Mj=N.setInitialProperties,Nj=N.diffProperties,Oj=N.updateProperties,Pj=N.diffHydratedProperties,Qj=N.diffHydratedText,Rj=N.warnForDeletedHydratableElement,Sj=N.warnForDeletedHydratableText,Tj=N.warnForInsertedHydratedElement,Uj=N.warnForInsertedHydratedText,Vj=G.precacheFiberNode,Wj=G.updateFiberProps;
	nb.injection.injectFiberControlledHostComponent(N);Dh._injectFiber(function(a){return Xj.findHostInstance(a)});var Yj=null,Zj=null;function ak(a){return!(!a||a.nodeType!==Dj&&a.nodeType!==Gj&&a.nodeType!==Hj&&(a.nodeType!==Fj||" react-mount-point-unstable "!==a.nodeValue))}function bk(a){a=a?a.nodeType===Gj?a.documentElement:a.firstChild:null;return!(!a||a.nodeType!==Dj||!a.hasAttribute(Ij))}
	var Xj=function(a){var b=a.getPublicInstance;a=hh(a);var c=a.scheduleUpdate,d=a.getPriorityContext;return{createContainer:function(a){var b=ee();a={current:b,containerInfo:a,isScheduled:!1,nextScheduledRoot:null,context:null,pendingContext:null};return b.stateNode=a},updateContainer:function(a,b,g,h){var e=b.current;g=jh(g);null===b.context?b.context=g:b.pendingContext=g;b=h;h=d(e,ed.enableAsyncSubtreeAPI&&null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent);
	a={element:a};kh(e,a,void 0===b?null:b,h);c(e,h)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case oh:return b(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:function(a){a=ph(a);return null===a?null:a.stateNode},findHostInstanceWithNoPortals:function(a){a=qh(a);return null===a?null:a.stateNode}}}({getRootHostContext:function(a){if(a.nodeType===
	Gj)a=(a=a.documentElement)?a.namespaceURI:Jj(null,"");else{var b=a.nodeType===Fj?a.parentNode:a;a=b.namespaceURI||null;b=b.tagName;a=Jj(a,b)}return a},getChildHostContext:function(a,b){return Jj(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){Yj=M.isEnabled();Zj=zh.getSelectionInformation();M.setEnabled(!1)},resetAfterCommit:function(){zh.restoreSelection(Zj);Zj=null;M.setEnabled(Yj);Yj=null},createInstance:function(a,b,c,d,e){a=Kj(a,b,c,d);Vj(e,a);Wj(a,b);return a},appendInitialChild:function(a,
	b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){Mj(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return Nj(a,b,c,d,e)},commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){Wj(a,e);Oj(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&
	"string"===typeof b.dangerouslySetInnerHTML.__html},resetTextContent:function(a){a.textContent=""},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=Lj(a,b);Vj(d,a);return a},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,b){a.nodeType===Fj?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,
	b,c){a.nodeType===Fj?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){a.nodeType===Fj?a.parentNode.removeChild(b):a.removeChild(b)},canHydrateInstance:function(a,b){return a.nodeType===Dj&&b===a.nodeName.toLowerCase()},canHydrateTextInstance:function(a,b){return""===b?!1:a.nodeType===Ej},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&a.nodeType!==Dj&&a.nodeType!==Ej;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=
	a.firstChild;a&&a.nodeType!==Dj&&a.nodeType!==Ej;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){Vj(f,a);Wj(a,c);return Pj(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){Vj(c,a);return Qj(a,b)},didNotHydrateInstance:function(a,b){1===b.nodeType?Rj(a,b):Sj(a,b)},didNotFindHydratableInstance:function(a,b,c){Tj(a,b,c)},didNotFindHydratableTextInstance:function(a,b){Uj(a,b)},scheduleDeferredCallback:dd.rIC,useSyncScheduling:!0});sb.injection.injectFiberBatchedUpdates(Xj.batchedUpdates);
	function ck(a,b,c,d,e){ak(c)?void 0:w("200");var f=c._reactRootContainer;if(f)Xj.updateContainer(b,f,a,e);else{if(!d&&!bk(c))for(d=void 0;d=c.lastChild;)c.removeChild(d);var g=Xj.createContainer(c);f=c._reactRootContainer=g;Xj.unbatchedUpdates(function(){Xj.updateContainer(b,g,a,e)})}return Xj.getPublicRootInstance(f)}function dk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;ak(b)?void 0:w("200");return ne.createPortal(a,b,null,c)}
	var ek={createPortal:dk,hydrate:function(a,b,c){return ck(null,a,b,!0,c)},render:function(a,b,c){return ck(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null!=a&&Pa.has(a)?void 0:w("38");return ck(a,b,c,!1,d)},unmountComponentAtNode:function(a){ak(a)?void 0:w("40");return a._reactRootContainer?(Xj.unbatchedUpdates(function(){ck(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},findDOMNode:Dh,unstable_createPortal:dk,unstable_batchedUpdates:sb.batchedUpdates,
	unstable_deferredUpdates:Xj.deferredUpdates,flushSync:Xj.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:Jb,EventPluginRegistry:sa,EventPropagators:Th,ReactControlledComponent:nb,ReactDOMComponentTree:G,ReactDOMEventListener:L}};Cj({findFiberByHostInstance:G.getClosestInstanceFromNode,findHostInstanceByFiber:Xj.findHostInstance,bundleType:0,version:"16.0.0",rendererPackageName:"react-dom"});module.exports=ek;


/***/ },
/* 112 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  position: 'absolute',
	  width: '1px',
	  height: '1px',
	  padding: '0px',
	  margin: '-1px',
	  overflow: 'hidden',
	  clip: 'rect(0px, 0px, 0px, 0px)',
	  border: '0px'
	};
	module.exports = exports['default'];

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// @remove-on-eject-begin
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	// @remove-on-eject-end
	'use strict';
	
	if (typeof Promise === 'undefined') {
	  // Rejection tracking prevents a common issue where React gets into an
	  // inconsistent state due to an error, but it gets swallowed by a Promise,
	  // and the user has no idea what causes React's erratic future behavior.
	  __webpack_require__(107).enable();
	  window.Promise = __webpack_require__(106);
	}
	
	// fetch() polyfill for making API calls.
	__webpack_require__(114);
	
	// Object.assign() is commonly used with React.
	// It will use the native implementation if it's present and isn't buggy.
	Object.assign = __webpack_require__(14);


/***/ },
/* 114 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 React v16.0.0
	 react.production.min.js
	
	 Copyright (c) 2013-present, Facebook, Inc.
	
	 This source code is licensed under the MIT license found in the
	 LICENSE file in the root directory of this source tree.
	*/
	'use strict';var f=__webpack_require__(14),p=__webpack_require__(18);__webpack_require__(12);var r=__webpack_require__(10);
	function t(a){for(var b=arguments.length-1,d="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,e=0;e<b;e++)d+="\x26args[]\x3d"+encodeURIComponent(arguments[e+1]);b=Error(d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
	var u={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function v(a,b,d){this.props=a;this.context=b;this.refs=p;this.updater=d||u}v.prototype.isReactComponent={};v.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?t("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};v.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
	function w(a,b,d){this.props=a;this.context=b;this.refs=p;this.updater=d||u}function x(){}x.prototype=v.prototype;var y=w.prototype=new x;y.constructor=w;f(y,v.prototype);y.isPureReactComponent=!0;function z(a,b,d){this.props=a;this.context=b;this.refs=p;this.updater=d||u}var A=z.prototype=new x;A.constructor=z;f(A,v.prototype);A.unstable_isAsyncReactComponent=!0;A.render=function(){return this.props.children};
	var B={Component:v,PureComponent:w,AsyncComponent:z},C={current:null},D=Object.prototype.hasOwnProperty,E="function"===typeof Symbol&&Symbol["for"]&&Symbol["for"]("react.element")||60103,F={key:!0,ref:!0,__self:!0,__source:!0};function G(a,b,d,e,c,g,k){return{$$typeof:E,type:a,key:b,ref:d,props:k,_owner:g}}
	G.createElement=function(a,b,d){var e,c={},g=null,k=null,m=null,q=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),m=void 0===b.__self?null:b.__self,q=void 0===b.__source?null:b.__source,b)D.call(b,e)&&!F.hasOwnProperty(e)&&(c[e]=b[e]);var l=arguments.length-2;if(1===l)c.children=d;else if(1<l){for(var h=Array(l),n=0;n<l;n++)h[n]=arguments[n+2];c.children=h}if(a&&a.defaultProps)for(e in l=a.defaultProps,l)void 0===c[e]&&(c[e]=l[e]);return G(a,g,k,m,q,C.current,c)};
	G.createFactory=function(a){var b=G.createElement.bind(null,a);b.type=a;return b};G.cloneAndReplaceKey=function(a,b){return G(a.type,b,a.ref,a._self,a._source,a._owner,a.props)};
	G.cloneElement=function(a,b,d){var e=f({},a.props),c=a.key,g=a.ref,k=a._self,m=a._source,q=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,q=C.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var l=a.type.defaultProps;for(h in b)D.call(b,h)&&!F.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==l?l[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=d;else if(1<h){l=Array(h);for(var n=0;n<h;n++)l[n]=arguments[n+2];e.children=l}return G(a.type,c,g,k,m,q,e)};
	G.isValidElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===E};var H="function"===typeof Symbol&&Symbol.iterator,I="function"===typeof Symbol&&Symbol["for"]&&Symbol["for"]("react.element")||60103;function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var J=/\/+/g,K=[];
	function L(a,b,d,e){if(K.length){var c=K.pop();c.result=a;c.keyPrefix=b;c.func=d;c.context=e;c.count=0;return c}return{result:a,keyPrefix:b,func:d,context:e,count:0}}function M(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>K.length&&K.push(a)}
	function N(a,b,d,e){var c=typeof a;if("undefined"===c||"boolean"===c)a=null;if(null===a||"string"===c||"number"===c||"object"===c&&a.$$typeof===I)return d(e,a,""===b?"."+O(a,0):b),1;var g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){c=a[k];var m=b+O(c,k);g+=N(c,m,d,e)}else if(m=H&&a[H]||a["@@iterator"],"function"===typeof m)for(a=m.call(a),k=0;!(c=a.next()).done;)c=c.value,m=b+O(c,k++),g+=N(c,m,d,e);else"object"===c&&(d=""+a,t("31","[object Object]"===d?"object with keys {"+
	Object.keys(a).join(", ")+"}":d,""));return g}function O(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function P(a,b){a.func.call(a.context,b,a.count++)}function Q(a,b,d){var e=a.result,c=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,e,d,r.thatReturnsArgument):null!=a&&(G.isValidElement(a)&&(a=G.cloneAndReplaceKey(a,c+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(J,"$\x26/")+"/")+d)),e.push(a))}
	function R(a,b,d,e,c){var g="";null!=d&&(g=(""+d).replace(J,"$\x26/")+"/");b=L(b,g,e,c);null==a||N(a,"",Q,b);M(b)}var S={forEach:function(a,b,d){if(null==a)return a;b=L(null,null,b,d);null==a||N(a,"",P,b);M(b)},map:function(a,b,d){if(null==a)return a;var e=[];R(a,e,null,b,d);return e},count:function(a){return null==a?0:N(a,"",r.thatReturnsNull,null)},toArray:function(a){var b=[];R(a,b,null,r.thatReturnsArgument);return b}};
	module.exports={Children:{map:S.map,forEach:S.forEach,count:S.count,toArray:S.toArray,only:function(a){G.isValidElement(a)?void 0:t("143");return a}},Component:B.Component,PureComponent:B.PureComponent,unstable_AsyncComponent:B.AsyncComponent,createElement:G.createElement,cloneElement:G.cloneElement,isValidElement:G.isValidElement,createFactory:G.createFactory,version:"16.0.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:C,assign:f}};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = applyMiddleware;
	
	var _compose = __webpack_require__(25);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 117 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineReducers;
	
	var _createStore = __webpack_require__(26);
	
	var _isPlainObject = __webpack_require__(21);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(28);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	
	    if (false) {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }
	
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var unexpectedKeyCache = void 0;
	  if (false) {
	    unexpectedKeyCache = {};
	  }
	
	  var shapeAssertionError = void 0;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	
	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }
	
	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(120);


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ponyfill = __webpack_require__(121);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var root; /* global window */
	
	
	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (true) {
	  root = module;
	} else {
	  root = Function('return this')();
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(126)(module)))

/***/ },
/* 121 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3MEYwOEQ4MDMwMzJFNDExOUZGN0MyRjAwQkZFNDkwMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NkNFODE2MzMyM0QxMUU0OTc2NkEyNzVGRDRDQUREMiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NkNFODE2MjMyM0QxMUU0OTc2NkEyNzVGRDRDQUREMiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM3Q0UwRDg3MzgzMkU0MTE5RkY3QzJGMDBCRkU0OTAxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwRjA4RDgwMzAzMkU0MTE5RkY3QzJGMDBCRkU0OTAxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+nXk3UAAAAjtJREFUeNrU1ktIVFEcx/FRhExEei0kULQkiijMKduo0RNCEHuQRohgggsVJbRSNy2qRSK4qIjohRARk5YgGvmoVSEWRe9EzHJVkFZEoInT9w+/gXGasjngwgMf7uDcOeee/+Nco/x+v2cuR7RnjkdM4MPh+jOBj+moxVYsxnvcQhO+Bf/48umjEe+gAHcxgM1YgkNIxGOsjHQHUYEcsIP1XHqQg7dIk36Mo8JugxfTf5swdFfBO6jDSU1+CvdRrRDdwFn8wB7XJG9XrFejCOvQhgnkoxE+3ee0gMX7E1bgmfLRgG0qBrvuwiKnKmJ8xCol0ybLxBaUoBcH8QqjrjvwKZGf8QAJeI0NWsRC9Ut/b3SpIgvRUyX6Es4rD7sxhevqgyOqtj71yz+rKThEY9iJOziAVtX9S31vE5ZhEjvwSCU9gi8K4+3QEg5ttEFYP1zBRnzVwtYHVZp8IZoRiyTE4Y2+f4KU2c6iKdV9qXaSgYfoVPwvahEr57VYjmTtxh6sW/fNzEGYM2lGrnAOWYjHGizFBZWuR6EtxFV8IAcnIjlN7SnKdbXfLECL+sXK+Ttytah1/D6X49omH1a8LVzZCmUHjqt/NuEdUl3fB2MKxXMtaP1ioWhXTuwBlqk4nBawA3CvwnVPlWRHygtcUxXuV8n+0Qf/M27qfCpGnp7WynlIrMRr9LIKX0XhRkhlpakUu1RZg3oh2ZMfQ6UdO4FOdnknDwU1ocX+p15KXh2SvrBn0bz9r+K3AAMAvVSdlmlN6ucAAAAASUVORK5CYII="

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAB3RJTUUH1AgfBgU3vDbVaQAAAAlwSFlzAAAPPAAADzwBFzqfWQAAAwBQTFRFAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Bz0LCAAAAAJ0Uk5T/wDltzBKAAAARUlEQVR42mNgxAIYsPEYkMUZoGwGJNVwNoLAUIWmngHVNFQ2iitQnQQTZACqRkfYVaJrg1qFUE20IMnehGtFNZhIQSAAABhlAUeIwcHOAAAAAElFTkSuQmCC"

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAACWUExURezp2L3CsAAAAH91jbamy9Sx1NXVxL2u0MvA2yEeEZy460hBJUU/JAC+ACQhE4qi2Zaw5JCp3se72Ap3Hsi82cq+2qK/8XeKtWNfTb+x0nSEsG19pH6QtWFfU8S31nt1Wpax5Xp0WoeeynBrVMm92WhkVsGz02JfU21oU5m06Mq/2se62MS21bmqzsW517ipzbyu0P///wUDcXkAAAAydFJOU/////////////////////////////////////////////////////////////////8ADVCY7wAAAO1JREFUeNpiMMQCAAKIAZsgQABhFQQIIAZDeW5uZTgXwgEIIAZFKX5+aQk2iBiUAxBADDwCClyCfIwQQSgHIICAglxigny8wmAI4TACBBCDhoymkrg6KwMIsEI4jAABxGCoyskpy8gEFmSCcNgAAojBkI2RkZENqhLIMWRkMwQIIKg7YSohACCAoIIwlRAAEEBYVQIEEFaVAAHEwIwJDAECiIGZg4NJSAiE5OSYJCWZWFiYGAECCCgowi6qwi6iza6jxs6uywISBAggoKCoFoeoioiemoE+CxgwMQIEEAMzEwZgBAggBkNGTAAQYABIRSX4H75PxQAAAABJRU5ErkJggg=="

/***/ },
/* 125 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAABOUExURezp2AAAAH91jb3CsE9PT83C3CQhE7amy9Sx1ImFdL2u0AC+AMq+2si82Qp3Hsm92cvA28Gz07ipzcq/2se62LmqzsS21cW517yu0P///44+OfEAAAAadFJOU/////////////////////////////////8AFCIA2gAAAMxJREFUeNpikMQCAAKIAZsgQABhFQQIIAYWFklJTjYoD8oBCCAGIAMuJgnlAAQQUDsLG5JOMAcggBiAykGaoADCAQggBqByDhYWbj4w5GTjAJkLEEAg2xkZEIARpB4ggECCHEiCHCBBgADCqhIggLCqBAggrCoBAgirSoAAYmDCBJIAAcTAxMrKiIy4uBiZAQIIKMjLxcPPxSvCJSbIxSXKzs7OyAwQQAxMAjzCAjz8vOKCEkLsYMDIDBBADEyMGIAZIIAYJJkxAUCAAQCiZRN3sUCgAwAAAABJRU5ErkJggg=="

/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }
/******/ ])));
//# sourceMappingURL=main.7108eaf4.js.map